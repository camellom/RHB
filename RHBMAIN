
local is_synapse_function = isexecutorclosure

getgenv().syn = {}
getgenv().comm_channels = {}
syn.create_comm_channel = function() -- credit to MirayXS or whoever made SynapseToScriptWare.lua
	local id = game:GetService("HttpService"):GenerateGUID(false)
	local bindable = Instance.new("BindableEvent")
	local object = newproxy(true)
	getmetatable(object).__index = function(_, i)
		if i == "bro" then
			return bindable
		end
	end
	local event = setmetatable({
		__OBJECT = object
	}, {
		__type = "SynSignal",
		__index = function(self, i)
			if i == "Connect" then
				return function(_, callback)
					print(callback)
					return self.__OBJECT.bro.Event:Connect(callback)
				end
			elseif i == "Fire" then
				return function(_, ...)
					return self.__OBJECT.bro:Fire(...)
				end
			end
		end,
		__newindex = function()
			erroruiconsole("SynSignal table is readonly.")
		end
	})
	comm_channels[id] = event
	return id, event
end

syn.get_comm_channel = function(id)
	local channel = comm_channels[id]
	if not channel then
		erroruiconsole("bad argument #1 to 'get_comm_channel' (invalid communication channel)")
	end
	return channel
end




isSynapseV3 = true

local setRP;
local getRPProperty;
local destroyRP;

local statusEvent = getgenv().ah_statusEvent;

local function setStatus(...)
	if (not statusEvent) then return end;
	statusEvent:Fire(...);
end;


getgenv().RoniroHubV3Ran = true;
getgenv().RoniroHubV3RanReal = true;

local originalFunctions = {};
local HttpService = game:GetService('HttpService');


if (not game:IsLoaded()) then
	setStatus('Waiting for game to load');
	game.Loaded:Wait();
end;

--setreadonly(syn, false);

local oldRequest = clonefunction(request);
local gameId = game.GameId;

local LocalPlayer = game:GetService('Players').LocalPlayer;
originalFunctions.getRankInGroup = clonefunction(LocalPlayer.GetRankInGroup);

local websiteKey, scriptKey = getgenv().websiteKey, getgenv().scriptKey;
local jobId, placeId = game.JobId, game.PlaceId;

local userId = LocalPlayer.UserId;
local isUserTrolled = false;
local accountData;
local scriptVersion='3.0.0'
local title;
local debugMode = false;

jsonEncode = HttpService.JSONEncode
jsonDecode = HttpService.JSONDecode
findFirstChild = game.FindFirstChild

local sharedRequires = {};



setStatus('All done', true);
sharedRequires['Signal'] = (function()

	--- Lua-side duplication of the API of events on Roblox objects.
	-- Signals are needed for to ensure that for local events objects are passed by
	-- reference rather than by value where possible, as the BindableEvent objects
	-- always pass signal arguments by value, meaning tables will be deep copied.
	-- Roblox's deep copy method parses to a non-lua table compatable format.
	-- @classmod Signal

	local Signal = {}
	Signal.__index = Signal
	Signal.ClassName = "Signal"

	--- Constructs a new signal.
	-- @constructor Signal.new()
	-- @treturn Signal
	function Signal.new()
		local self = setmetatable({}, Signal)

		self._bindableEvent = Instance.new("BindableEvent")
		self._argData = nil
		self._argCount = nil -- Prevent edge case of :Fire("A", nil) --> "A" instead of "A", nil

		return self
	end

	function Signal.isSignal(object)
		return typeof(object) == 'table' and getmetatable(object) == Signal;
	end;

	--- Fire the event with the given arguments. All handlers will be invoked. Handlers follow
	-- Roblox signal conventions.
	-- @param ... Variable arguments to pass to handler
	-- @treturn nil
	function Signal:Fire(...)
		self._argData = {...}
		self._argCount = select("#", ...)
		self._bindableEvent:Fire()
		self._argData = nil
		self._argCount = nil
	end

	--- Connect a new handler to the event. Returns a connection object that can be disconnected.
	-- @tparam function handler Function handler called with arguments passed when `:Fire(...)` is called
	-- @treturn Connection Connection object that can be disconnected
	function Signal:Connect(handler)
		if not self._bindableEvent then return error("Signal has been destroyed"); end --Fixes an error while respawning with the UI injected

		if not (type(handler) == "function") then
			error(("connect(%s)"):format(typeof(handler)), 2)
		end

		return self._bindableEvent.Event:Connect(function()
			handler(unpack(self._argData, 1, self._argCount))
		end)
	end

	--- Wait for fire to be called, and return the arguments it was given.
	-- @treturn ... Variable arguments from connection
	function Signal:Wait()
		self._bindableEvent.Event:Wait()
		assert(self._argData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
		return unpack(self._argData, 1, self._argCount)
	end

	--- Disconnects all connected events to the signal. Voids the signal as unusable.
	-- @treturn nil
	function Signal:Destroy()
		if self._bindableEvent then
			self._bindableEvent:Destroy()
			self._bindableEvent = nil
		end

		self._argData = nil
		self._argCount = nil
	end

	return Signal
end)();

sharedRequires['Maid'] = (function()

	---	Manages the cleaning of events and other things.
	-- Useful for encapsulating state and make deconstructors easy
	-- @classmod Maid
	-- @see Signal

	local Signal = sharedRequires['Signal'];
	local tableStr = "table";
	local classNameStr = "Maid";
	local funcStr = "function";
	local threadStr = "thread";

	local Maid = {}
	Maid.ClassName = "Maid"

	--- Returns a new Maid object
	-- @constructor Maid.new()
	-- @treturn Maid
	function Maid.new()
		return setmetatable({
			_tasks = {}
		}, Maid)
	end

	function Maid.isMaid(value)
		return type(value) == tableStr and value.ClassName == classNameStr
	end

	--- Returns Maid[key] if not part of Maid metatable
	-- @return Maid[key] value
	function Maid.__index(self, index)
		if Maid[index] then
			return Maid[index]
		else
			return self._tasks[index]
		end
	end

	--- Add a task to clean up. Tasks given to a maid will be cleaned when
	--  maid[index] is set to a different value.
	-- @usage
	-- Maid[key] = (function)         Adds a task to perform
	-- Maid[key] = (event connection) Manages an event connection
	-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
	-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
	-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
	--                                it is destroyed.
	function Maid:__newindex(index, newTask)
		if Maid[index] ~= nil then
			error(("'%s' is reserved"):format(tostring(index)), 2)
		end

		local tasks = self._tasks
		local oldTask = tasks[index]

		if oldTask == newTask then
			return
		end

		tasks[index] = newTask

		if oldTask then
			if type(oldTask) == "function" then
				oldTask()
			elseif typeof(oldTask) == "RBXScriptConnection" then
				oldTask:Disconnect();
			elseif typeof(oldTask) == 'table' then
				oldTask:Remove();
			elseif (Signal.isSignal(oldTask)) then
				oldTask:Destroy();
			elseif (typeof(oldTask) == 'thread') then
				task.cancel(oldTask);
			elseif oldTask.Destroy then
				oldTask:Destroy();
			end
		end
	end

	--- Same as indexing, but uses an incremented number as a key.
	-- @param task An item to clean
	-- @treturn number taskId
	function Maid:GiveTask(task)
		if not task then
			error("Task cannot be false or nil", 2)
		end

		local taskId = #self._tasks+1
		self[taskId] = task

		return taskId
	end

	--- Cleans up all tasks.
	-- @alias Destroy
	function Maid:DoCleaning()
		local tasks = self._tasks

		-- Disconnect all events first as we know this is safe
		for index, task in pairs(tasks) do
			if typeof(task) == "RBXScriptConnection" then
				tasks[index] = nil
				task:Disconnect()
			end
		end

		-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
		local index, taskData = next(tasks)
		while taskData ~= nil do
			tasks[index] = nil
			if type(taskData) == funcStr then
				taskData()
			elseif typeof(taskData) == "RBXScriptConnection" then
				taskData:Disconnect()
			elseif (Signal.isSignal(taskData)) then
				taskData:Destroy();
			elseif typeof(taskData) == tableStr then
				taskData:Remove();
			elseif (typeof(taskData) == threadStr) then
				task.cancel(taskData);
			elseif taskData.Destroy then
				taskData:Destroy()
			end
			index, taskData = next(tasks)
		end
	end

	--- Alias for DoCleaning()
	-- @function Destroy
	Maid.Destroy = Maid.DoCleaning

	return Maid;
end)();

sharedRequires['Services'] = (function()

	local Services = {};
	local vim = getvirtualinputmanager and getvirtualinputmanager();

	function Services:Get(...)
		local allServices = {};

		for _, service in next, {...} do
			table.insert(allServices, self[service]);
		end

		return unpack(allServices);
	end;

	setmetatable(Services, {
		__index = function(self, p)
			if (p == 'VirtualInputManager' and vim) then
				return vim;
			end;

			local service = game:GetService(p);
			if (p == 'VirtualInputManager') then
				service.Name = "VirtualInputManager ";
			end;

			rawset(self, p, service);
			return rawget(self, p);
		end,
	});

	return Services;
end)();

sharedRequires['KeyBindVisualizer'] = (function()
	local Services = sharedRequires['Services'];
	local UserInputService = Services:Get('UserInputService');
	local Maid = sharedRequires['Maid'];

	local keybindVisualizer = {};
	keybindVisualizer.__index = keybindVisualizer;

	local viewportSize = workspace.CurrentCamera.ViewportSize;
	local library;

	function keybindVisualizer.new()
		local self = setmetatable({}, keybindVisualizer);

		self._textSizes = {};
		self._maid = Maid.new();

		self:_init();

		local dragObject;
		local dragging;
		local dragStart;
		local startPos;

		self._maid:GiveTask(UserInputService.InputBegan:Connect(function(input)
			if (input.UserInputType == Enum.UserInputType.MouseButton1 and self:MouseInFrame()) then
				dragObject = self._textBox
				dragging = true
				dragStart = input.Position
				startPos = dragObject.Position
			end;
		end));

		self._maid:GiveTask(UserInputService.InputChanged:connect(function(input)
			if dragging and input.UserInputType.Name == 'MouseMovement' and not self._destroyed then
				if dragging then
					local delta = input.Position - dragStart;
					local yPos = (startPos.Y + delta.Y) < -36 and -36 or startPos.Y + delta.Y;

					self._textBox.Position = Vector2.new(startPos.X + delta.X,  yPos);
					library.configVars.keybindVisualizerPos = tostring(self._textBox.Position);
				end;
			end;
		end));

		self._maid:GiveTask(UserInputService.InputEnded:connect(function(input)
			if input.UserInputType.Name == 'MouseButton1' then
				dragging = false
			end
		end));

		library.OnLoad:Connect(function()
			if (not library.configVars.keybindVisualizerPos) then return end;
			self._textBox.Position = Vector2.new(unpack(library.configVars.keybindVisualizerPos:split(',')));
		end);

		return self;
	end;

	function keybindVisualizer:_getTextBounds(text, fontSize)
		local t = Drawing.new('Text');
		t.Text = text;
		t.Size = fontSize;

		local res = t.TextBounds;
		t:Remove();
		return res.X;
	end;

	function keybindVisualizer:_createDrawingInstance(instanceType, properties)
		local instance = Drawing.new(instanceType);

		if (properties.Visible == nil) then
			properties.Visible = true;
		end;

		for i,  v in next,  properties do
			instance[i] = v;
		end;

		return instance;
	end;

	function keybindVisualizer:_init()
		self._textBox = self:_createDrawingInstance('Text', {
			Size = 30,
			Position = viewportSize-Vector2.new(180, viewportSize.Y/2),
			Color = Color3.new(255, 255, 255)
		});
	end

	function keybindVisualizer:GetLargest()
		table.sort(self._textSizes, function(a, b) return a.magnitude>b.magnitude; end)
		return self._textSizes[1] or Vector2.new(0, 30);
	end

	function keybindVisualizer:AddText(txt)
		if (self._destroyed) then return end;
		self._largest = self:GetLargest();

		local tab = string.split(self._textBox.Text, '\n');
		if (table.find(tab, txt)) then return end;

		local textSize = Vector2.new(self:_getTextBounds(txt, 30), 30);
		table.insert(self._textSizes, textSize);

		table.insert(tab, txt);
		table.sort(tab, function(a, b) return #a < #b; end)

		self._textBox.Text = table.concat(tab, '\n');
		self._textBox.Position -= Vector2.new(0, 30);
	end

	function keybindVisualizer:MouseInFrame()
		local mousePos = UserInputService:GetMouseLocation();
		local framePos = self._textBox.Position;
		local bottomRight = framePos + self._textBox.TextBounds

		return (mousePos.X >= framePos.X and mousePos.X <= bottomRight.X) and (mousePos.Y >= framePos.Y and mousePos.Y <= bottomRight.Y)
	end;

	function keybindVisualizer:RemoveText(txt)
		if (self._destroyed) then return end;
		local textSize = Vector2.new(self:_getTextBounds(txt, 30), 30);
		table.remove(self._textSizes, table.find(self._textSizes,  textSize));

		self._largest = self:GetLargest();

		local tab = string.split(self._textBox.Text, '\n');
		table.remove(tab, table.find(tab, txt));

		self._textBox.Text = table.concat(tab, '\n');
		self._textBox.Position += Vector2.new(0, 30);
	end

	function keybindVisualizer:UpdateColor(color)
		if (self._destroyed) then return end;
		self._textBox.Color = color;
	end;

	function keybindVisualizer:SetEnabled(state)
		if (self._destroyed) then return end;
		self._textBox.Visible = state;
	end;

	function keybindVisualizer:Remove()
		self._destroyed = true;
		self._maid:Destroy();
		self._textBox:Remove();
	end;

	function keybindVisualizer.init(newLibrary)
		library = newLibrary;
	end;

	return keybindVisualizer;
end)();

sharedRequires['toCamelCase'] = (function()

	local stringPattern = "%s(.)";
	return function (text)
		return string.lower(text):gsub(stringPattern, string.upper);
	end;
end)();

sharedRequires['ToastNotif'] = (function()
	local Services = sharedRequires['Services'];
	local Maid = sharedRequires['Maid'];
	local Signal = sharedRequires['Signal'];

	local TweenService, UserInputService = Services:Get('TweenService', 'UserInputService');

	local Notifications = {};

	local Notification = {};
	Notification.__index = Notification;
	Notification.NotifGap = 40;

	local viewportSize = workspace.CurrentCamera.ViewportSize;

	local TWEEN_INFO = TweenInfo.new(0.2, Enum.EasingStyle.Quad);
	local VALUE_NAMES = {
		number = 'NumberValue',
		Color3 = 'Color3Value',
		Vector2 = 'Vector3Value',
	};

	local movingUpFinished = true;
	local movingDownFinished = true;

	local vector2Str = "Vector2";
	local positionStr = "Position";

	function Notification.new(options)
		local self = setmetatable({
			_options = options
		}, Notification);

		self._options = options;
		self._maid = Maid.new();

		self.Destroying = Signal.new();

		self._tweens = {};
		task.spawn(self._init, self);

		return self;
	end;

	function Notification:_createDrawingInstance(instanceType, properties)
		local instance = Drawing.new(instanceType);

		if (properties.Visible == nil) then
			properties.Visible = true;
		end;

		for i, v in next, properties do
			instance[i] = v;
		end;

		return instance;
	end;

	function Notification:_getTextBounds(text, fontSize)
		local t = Drawing.new('Text');
		t.Text = text;
		t.Size = fontSize;

		local res = t.TextBounds;
		t:Remove();
		return res.X;
		-- This is completetly inaccurate but there is no function to get the textbounds on v2; It prob also matter abt screen size but lets ignore that
		-- return #text * (fontSize / 3.15);
	end;

	function Notification:_tweenProperty(instance, property, value, tweenInfo, dontCancel)
		local currentValue = instance[property]
		local valueType = typeof(currentValue);
		local valueObject = Instance.new(VALUE_NAMES[valueType]);

		self._maid:GiveTask(valueObject);
		if (valueType == vector2Str) then
			value = Vector3.new(value.X, value.Y, 0);
			currentValue = Vector3.new(currentValue.X, currentValue.Y, 0);
		end;

		valueObject.Value = currentValue;
		local tween = TweenService:Create(valueObject, tweenInfo, {Value = value});

		self._tweens[tween] = dontCancel or false;

		self._maid:GiveTask(valueObject:GetPropertyChangedSignal('Value'):Connect(function()
			local newValue = valueObject.Value;

			if (valueType == vector2Str) then
				newValue = Vector2.new(newValue.X, newValue.Y);
			end;

			if self._destroyed then return; end

			instance[property] = newValue;
		end));

		self._maid:GiveTask(tween.Completed:Connect(function()
			valueObject:Destroy();
			self._tweens[tween] = nil;
		end));

		tween:Play();

		if (instance == self._progressBar and property == 'Size') then
			self._maid:GiveTask(tween.Completed:Connect(function(playbackState)
				if (playbackState ~= Enum.PlaybackState.Completed) then return end;
				self:Destroy();
			end));
		end;

		return tween;
	end;

	function Notification:_init()
		self:MoveUp();

		local textSize = Vector2.new(self:_getTextBounds(self._options.text, 19), 30);
		textSize += Vector2.new(10, 0); -- // Padding

		self._textSize = textSize

		self._frame = self:_createDrawingInstance('Square', {
			Size = textSize,
			Position = viewportSize - Vector2.new(-10, textSize.Y+10),
			Color = Color3.fromRGB(12, 12, 12),
			Filled = true
		});

		self._originalPosition = self._frame.Position;

		self._text = self:_createDrawingInstance('Text', {
			Text = self._options.text,
			Center = true,
			Color = Color3.fromRGB(255, 255, 255),
			Position = self._frame.Position + Vector2.new(textSize.X/2, 5), -- 5 Cuz of the padding
			Size = 19
		});

		self._progressBar = self:_createDrawingInstance('Square', {
			Size = Vector2.new(textSize.X, 3),
			Color = Color3.fromRGB(86, 180, 211),
			Filled = true,
			Position = self._frame.Position+Vector2.new(0, self._frame.Size.Y-3)
		});

		table.insert(Notifications,self); --Insert it into the table we are using to move up

		self._startTime = tick();
		local framePos = viewportSize - textSize - Vector2.new(10, 10);

		self:_tweenProperty(self._frame, positionStr, framePos, TWEEN_INFO,true);
		self:_tweenProperty(self._text, positionStr, framePos + Vector2.new(textSize.X/2, 5), TWEEN_INFO,true);
		local t = self:_tweenProperty(self._progressBar, positionStr, framePos + Vector2.new(0, self._frame.Size.Y-3), TWEEN_INFO, true); --We dont really want this to be cancelable

		self._maid._progressConnection = t.Completed:Connect(function() --This should prob use maids lol
			if (self._options.duration) then
				self:_tweenProperty(self._progressBar, 'Size', Vector2.new(0, 3), TweenInfo.new(self._options.duration, Enum.EasingStyle.Linear));
				self:_tweenProperty(self._progressBar, positionStr, framePos - Vector2.new(-self._frame.Size.X, -(self._frame.Size.Y-3)), TweenInfo.new(self._options.duration, Enum.EasingStyle.Linear)); --You should technically remove this after its complete but doesn't matter
			end;
		end)
	end;


	function Notification:MouseInFrame()
		local mousePos = UserInputService:GetMouseLocation();
		local framePos = self._frame.Position;
		local bottomRight = framePos + self._frame.Size

		return (mousePos.X >= framePos.X and mousePos.X <= bottomRight.X) and (mousePos.Y >= framePos.Y and mousePos.Y <= bottomRight.Y)
	end

	function Notification:GetHovered()
		for _,notif in next, Notifications do
			if notif:MouseInFrame() then return notif; end
		end

		return;
	end

	function Notification:MoveUp() --Going to use this to move all the drawing instances up one

		if (self._destroyed) then return; end

		repeat task.wait() until movingUpFinished;

		movingUpFinished = false;

		local distanceUp = Vector2.new(0, -self.NotifGap); --This can be made dynamic but I'm not sure if youd rather use screen size or an argument up to you

		for i,v in next, Notifications do
			--I mean you can obviously use le tween to make it cleaner
			v:CancelTweens(); --Cancel all current tweens that arent the default

			local newFramePos = v._frame.Position+distanceUp;

			v._frame.Position = newFramePos;
			v._text.Position = v._text.Position+distanceUp;
			v._progressBar.Position = v._progressBar.Position+distanceUp;

			if (not v._options.duration) then continue end;

			local newDuration = v._options.duration-(tick()-v._startTime);

			v:_tweenProperty(v._progressBar, 'Size', Vector2.new(0, 3), TweenInfo.new(newDuration, Enum.EasingStyle.Linear));
			v:_tweenProperty(v._progressBar, positionStr, newFramePos - Vector2.new(-v._frame.Size.X, -(v._frame.Size.Y-3)), TweenInfo.new(newDuration, Enum.EasingStyle.Linear));
		end
		movingUpFinished = true;
	end


	function Notification:MoveDown() --Going to use this to move all the drawing instances up one

		if (self._destroyed) then return; end

		repeat task.wait() until movingDownFinished;

		movingDownFinished = false;

		local distanceDown = Vector2.new(0, self.NotifGap); --This can be made dynamic but I'm not sure if youd rather use screen size or an argument up to you

		local index = table.find(Notifications,self) or 1;

		for i = index, 1,-1 do
			local v = Notifications[i];

			v:CancelTweens(); --Cancel all current tweens that arent the default

			local newFramePos = v._frame.Position+distanceDown;

			v._frame.Position = newFramePos;
			v._text.Position = v._text.Position+distanceDown;
			v._progressBar.Position = v._progressBar.Position+distanceDown;

			if (not v._options.duration) then continue end;

			v._startTime = v._startTime or tick();
			local newDuration = v._options.duration-(tick()-v._startTime);

			v:_tweenProperty(v._progressBar, 'Size', Vector2.new(0, 3), TweenInfo.new(newDuration, Enum.EasingStyle.Linear));
			v:_tweenProperty(v._progressBar, positionStr, newFramePos - Vector2.new(-v._frame.Size.X, -(v._frame.Size.Y-3)), TweenInfo.new(newDuration, Enum.EasingStyle.Linear));
		end
		movingDownFinished = true;
	end

	function Notification:CancelTweens()
		for tween,cancelInfo in next, self._tweens do
			if cancelInfo then
				self._maid._progressConnection = nil;
				tween.Completed:Wait();
				continue;
			end
			tween:Cancel();
		end
	end

	function Notification:ClearAllAbove()
		local index = table.find(Notifications,self);

		for i = 1, index do
			task.spawn(function()
				Notifications[i]:Destroy();
			end)
		end
	end

	function Notification:Remove()
		table.remove(Notifications,table.find(Notifications,self)); --We kind of want to use this and kind of don't its causing ALOT of issues with a large amount of things, but it also fixes the order issue gl
	end

	function Notification:Destroy()
		-- // TODO: Use a maid in the future
		if (self._destroyFixed) then return; end;
		self._destroyFixed = true;

		self.Destroying:Fire();

		local framePos = self._originalPosition;
		local textSize = self._textSize;

		self:CancelTweens();

		self:_tweenProperty(self._frame, positionStr, framePos, TWEEN_INFO,true);
		self:_tweenProperty(self._text, positionStr, framePos + Vector2.new(textSize.X/2, 5), TWEEN_INFO,true);
		self:_tweenProperty(self._progressBar, positionStr, framePos + Vector2.new(0, self._frame.Size.Y-3), TWEEN_INFO,true).Completed:Wait();

		self:MoveDown();

		self:Remove();

		self._destroyed = true;

		self._frame:Remove();
		self._text:Remove();
		self._progressBar:Remove();
	end;

	local function onInputBegan(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then  --Clear just that one
			local notif = Notification:GetHovered();
			if notif then
				notif:Destroy();
			end
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then --Clear all above it
			local notif = Notification:GetHovered();
			if notif then
				notif:ClearAllAbove();
			end
		end
	end

	UserInputService.InputBegan:Connect(onInputBegan)

	return Notification;
end)();

sharedRequires['Library'] = (function()


	-- // Services

	local libraryLoadAt = tick();

	local Signal = sharedRequires['Signal'];
	local Services = sharedRequires['Services'];
	local KeyBindVisualizer = sharedRequires['KeyBindVisualizer'];

	local CoreGui, Players, RunService, TextService, UserInputService, ContentProvider, HttpService, TweenService, GuiService, TeleportService = Services:Get('CoreGui', 'Players', 'RunService', 'TextService', 'UserInputService', 'ContentProvider', 'HttpService', 'TweenService', 'GuiService', 'TeleportService');

	local toCamelCase = sharedRequires['toCamelCase'];
	local Maid = sharedRequires['Maid'];
	local ToastNotif = sharedRequires['ToastNotif'];

	local LocalPlayer = Players.LocalPlayer;
	local visualizer;

	if getgenv().library then
		getgenv().library:Unload();
	end;


	if (not isfile('Roniro Hub V3')) then
		makefolder('Roniro Hub V3');
	end;

	if (not isfile('Roniro Hub V3/configs')) then
		makefolder('Roniro Hub V3/configs');
	end;

	if (not isfile('Roniro Hub V3/configs/globalConf.bin')) then
		-- By default global config is turned on
		writefile('Roniro Hub V3/configs/globalConf.bin', 'true');
	end;

	if (debugMode) then
		title = string.format('Roniro Hub | v%s', "DEBUG")
	else
		title = string.format('Roniro Hub | v%s', scriptVersion)
	end

	local globalConfFilePath = 'Roniro Hub V3/configs/globalConf.bin';
	local isGlobalConfigOn = readfile(globalConfFilePath) == 'true';

	local library = {
		unloadMaid = Maid.new(),
		tabs = {},
		draggable = true,
		flags = {},
		title = title,
		open = false,
		popup = nil,
		instances = {},
		connections = {},
		options = {},
		notifications = {},
		configVars = {},
		tabSize = 0,
		theme = {},
		foldername =  isGlobalConfigOn and 'Roniro Hub V3/configs/global' or string.format('Roniro Hub V3/configs/%s', tostring(LocalPlayer.UserId)),
		fileext = ".json",
		chromaColor = Color3.new()
	}

	library.originalTitle = library.title;

	do -- // Load
		library.unloadMaid:GiveTask(task.spawn(function()
			while true do
				for i = 1, 360 do
					library.chromaColor = Color3.fromHSV(i / 360, 1, 1);
					task.wait(0.1);
				end;
			end;
		end));

		-- if(debugMode) then
		getgenv().library = library
		-- end;

		library.OnLoad = Signal.new();
		library.OnKeyPress = Signal.new();
		library.OnKeyRelease = Signal.new();

		library.OnFlagChanged = Signal.new();

		KeyBindVisualizer.init(library);

		library.unloadMaid:GiveTask(library.OnLoad);
		library.unloadMaid:GiveTask(library.OnKeyPress);
		library.unloadMaid:GiveTask(library.OnKeyRelease);
		library.unloadMaid:GiveTask(library.OnFlagChanged);

		visualizer = KeyBindVisualizer.new();
		local mouseMovement = Enum.UserInputType.MouseMovement;

		--Locals
		local dragging, dragInput, dragStart, startPos, dragObject

		local blacklistedKeys = { --add or remove keys if you find the need to
			Enum.KeyCode.Unknown,Enum.KeyCode.W,Enum.KeyCode.A,Enum.KeyCode.S,Enum.KeyCode.D,Enum.KeyCode.Slash,Enum.KeyCode.Tab,Enum.KeyCode.Escape
		}
		local whitelistedMouseinputs = { --add or remove mouse inputs if you find the need to
			Enum.UserInputType.MouseButton1,Enum.UserInputType.MouseButton2,Enum.UserInputType.MouseButton3
		}

		local function onInputBegan(input, gpe)
			local inputType = input.UserInputType;
			if (inputType == mouseMovement) then return end;

			if (UserInputService:GetFocusedTextBox()) then return end;
			local inputKeyCode = input.KeyCode;

			local fastInputObject = {
				KeyCode = {
					Name = inputKeyCode.Name,
					Value = inputKeyCode.Value
				},

				UserInputType = {
					Name = inputType.Name,
					Value = inputType.Value
				},

				UserInputState = input.UserInputState,
				realKeyCode = inputKeyCode,
				realInputType = inputType
			};

			library.OnKeyPress:Fire(fastInputObject, gpe);
		end;

		local function onInputEnded(input)
			local inputType = input.UserInputType;
			if (inputType == mouseMovement) then return end;

			local inputKeyCode = input.KeyCode;

			local fastInputObject = {
				KeyCode = {
					Name = inputKeyCode.Name,
					Value = inputKeyCode.Value
				},

				UserInputType = {
					Name = inputType.Name,
					Value = inputType.Value
				},

				UserInputState = input.UserInputState,
				realKeyCode = inputKeyCode,
				realInputType = inputType
			};

			library.OnKeyRelease:Fire(fastInputObject);
		end;

		library.unloadMaid:GiveTask(UserInputService.InputBegan:Connect(onInputBegan));
		library.unloadMaid:GiveTask(UserInputService.InputEnded:Connect(onInputEnded));

		local function makeTooltip(interest, option)
			library.unloadMaid:GiveTask(interest.InputChanged:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if option.tip then
						library.tooltip.Text = option.tip;
						library.tooltip.Position = UDim2.new(0, input.Position.X + 26, 0, input.Position.Y + 36);
					end;
				end;
			end));

			library.unloadMaid:GiveTask(interest.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if option.tip then
						library.tooltip.Position = UDim2.fromScale(10, 10);
					end;
				end;
			end));
		end;

		--Functions
		library.round = function(num, bracket)
			bracket = bracket or 1
			if typeof(num) == "Vector2" then
				return Vector2.new(library.round(num.X), library.round(num.Y))
			elseif typeof(num) == "Color3" then
				return library.round(num.r * 255), library.round(num.g * 255), library.round(num.b * 255)
			else
				return num - num % bracket;
			end
		end

		function library:Create(class, properties)
			properties = properties or {}
			if not class then return end
			local a = class == 'Square' or class == 'Line' or class == 'Text' or class == 'Quad' or class == 'Circle' or class == 'Triangle'
			local t = a and Drawing or Instance
			local inst = t.new(class)
			for property, value in next, properties do
				inst[property] = value
			end
			table.insert(self.instances, {object = inst, method = a})
			return inst
		end

		function library:AddConnection(connection, name, callback)
			callback = type(name) == 'function' and name or callback
			connection = connection:Connect(callback)
			self.unloadMaid:GiveTask(connection);
			if name ~= callback then
				self.connections[name] = connection
			else
				table.insert(self.connections, connection)
			end
			return connection
		end

		function library:Unload()
			task.wait();
			visualizer:Remove();

			for _, o in next, self.options do
				if o.type == 'toggle' and not string.find(string.lower(o.flag), 'panic') and o.flag ~= 'saveconfigauto' then
					pcall(o.SetState, o, false);
				end;
			end;

			library.unloadMaid:Destroy();
		end

		local function readFileAndDecodeIt(filePath)
			if (not isfile(filePath)) then return; end;

			local suc, fileContent = pcall(readfile, filePath);
			if (not suc) then return; end;

			local suc2, configData = pcall(HttpService.JSONDecode, HttpService, fileContent);
			if (not suc2) then return; end;

			return configData;
		end;

		local function getConfigForGame(configData)
			local configValueName = library.gameName or 'Universal';

			if (not configData[configValueName]) then
				configData[configValueName] = {};
			end;

			return configData[configValueName];
		end;

		function library:LoadConfig(configName)
			if (not table.find(self:GetConfigs(), configName)) then
				return;
			end;

			local filePath = string.format('%s/%s.%s%s', self.foldername, configName, 'config', self.fileext);
			local configData = readFileAndDecodeIt(filePath);
			if (not configData) then print('no config', configName); return; end;
			configData = getConfigForGame(configData);

			-- Set the loaded config to the new config so we save it only when its actually loaded
			library.loadedConfig = configName;
			library.options.configList:SetValue(configName);

			for _, option in next, self.options do
				if (not option.hasInit or option.type == 'button' or not option.flag or option.skipflag) then
					continue;
				end;

				local configDataVal = configData[option.flag];

				if (typeof(configDataVal) == 'nil') then
					continue;
				end;

				if (option.type == 'toggle') then
					task.spawn(option.SetState, option, configDataVal == 1);
				elseif (option.type == 'color') then
					task.spawn(option.SetColor, option, Color3.fromHex(configDataVal));

					if option.trans then
						task.spawn(option.SetTrans, option, configData[option.flag .. 'Transparency']);
					end;
				elseif (option.type == 'bind') then
					task.spawn(option.SetKeys, option, configDataVal);
				else
					task.spawn(option.SetValue, option, configDataVal);
				end;
			end;

			return true;
		end;

		function library:SaveConfig(configName)
			local filePath = string.format('%s/%s.%s%s', self.foldername, configName, 'config', self.fileext);
			local allConfigData = readFileAndDecodeIt(filePath) or {};

			if (allConfigData.configVersion ~= '1') then
				allConfigData = {};
				allConfigData.configVersion = '1';
			end;

			local configData = getConfigForGame(allConfigData);

			--debug.profilebegin('Set config value');
			for _, option in next, self.options do
				if (option.type == 'button' or not option.flag) then continue end;
				if (option.skipflag or option.noSave) then continue end;

				local flag = option.flag;

				if (option.type == 'toggle') then
					configData[flag] = option.state and 1 or 0;
				elseif (option.type == 'color') then
					configData[flag] = option.color:ToHex();
					if (not option.trans) then continue end;
					configData[flag .. 'Transparency'] = option.trans;
				elseif (option.type == 'bind' and option.key ~= 'none') then
					local toSave = {};
					for _, v in next, option.keys do
						table.insert(toSave, v.Name);
					end;

					configData[flag] = toSave;
				elseif (option.type == 'list') then
					configData[flag] = option.value;
				elseif (option.type == 'box' and option.value ~= 'nil' and option.value ~= '') then
					configData[flag] = option.value;
				else
					configData[flag] = option.value;
				end;
			end;
			--debug.profileend();

			local configVars = library.configVars;
			configVars.config = configName;

			-- debug.profilebegin('writefile');
			writefile(self.foldername .. '/' .. self.fileext, HttpService:JSONEncode(configVars));
			-- debug.profileend();

			-- debug.profilebegin('writefile');
			writefile(filePath, HttpService:JSONEncode(allConfigData));
			-- debug.profileend();
		end

		function library:GetConfigs()
			if not isfolder(self.foldername) then
				makefolder(self.foldername)
			end

			local configFiles = {};

			for i, v in next, listfiles(self.foldername) do
				local fileName = v:match('\\(.+)');
				local fileSubExtension = v:match('%.(.+)%.json');

				if (fileSubExtension == 'config') then
					table.insert(configFiles, fileName:match('(.-)%.config'));
				end;
			end;

			if (not table.find(configFiles, 'default')) then
				table.insert(configFiles, 'default');
			end;

			return configFiles;
		end

		function library:UpdateConfig()
			if (not library.hasInit) then return end;
			--debug.profilebegin('Config Save');

			library:SaveConfig(library.loadedConfig or 'default');

			-- debug.profileend();
		end;

		local function createLabel(option, parent)
			option.main = library:Create('TextLabel', {
				LayoutOrder = option.position,
				Position = UDim2.new(0, 6, 0, 0),
				Size = UDim2.new(1, -12, 0, 24),
				BackgroundTransparency = 1,
				TextSize = 15,
				Font = Enum.Font.Code,
				TextColor3 = Color3.new(1, 1, 1),
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextWrapped = true,
				RichText = true,
				Parent = parent
			})

			setmetatable(option, {__newindex = function(t, i, v)
				if i == 'Text' then
					option.main.Text = tostring(v)

					local textSize = TextService:GetTextSize(option.main.ContentText, 15, Enum.Font.Code, Vector2.new(option.main.AbsoluteSize.X, 9e9));
					option.main.Size = UDim2.new(1, -12, 0, textSize.Y);
				end
			end})

			option.Text = option.text
		end

		local function createDivider(option, parent)
			option.main = library:Create('Frame', {
				LayoutOrder = option.position,
				Size = UDim2.new(1, 0, 0, 18),
				BackgroundTransparency = 1,
				Parent = parent
			})

			library:Create('Frame', {
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.new(0.5, 0, 0.5, 0),
				Size = UDim2.new(1, -24, 0, 1),
				BackgroundColor3 = Color3.fromRGB(60, 60, 60),
				BorderColor3 = Color3.new(),
				Parent = option.main
			})

			option.title = library:Create('TextLabel', {
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.new(0.5, 0, 0.5, 0),
				BackgroundColor3 = Color3.fromRGB(30, 30, 30),
				BorderSizePixel = 0,
				TextColor3 =  Color3.new(1, 1, 1),
				TextSize = 15,
				Font = Enum.Font.Code,
				TextXAlignment = Enum.TextXAlignment.Center,
				Parent = option.main
			})

			local interest = option.main;
			makeTooltip(interest, option);

			setmetatable(option, {__newindex = function(t, i, v)
				if i == 'Text' then
					if v then
						option.title.Text = tostring(v)
						option.title.Size = UDim2.new(0, TextService:GetTextSize(option.title.Text, 15, Enum.Font.Code, Vector2.new(9e9, 9e9)).X + 12, 0, 20)
						option.main.Size = UDim2.new(1, 0, 0, 18)
					else
						option.title.Text = ''
						option.title.Size = UDim2.new()
						option.main.Size = UDim2.new(1, 0, 0, 6)
					end
				end
			end})
			option.Text = option.text
		end

		local function createToggle(option, parent)
			option.hasInit = true
			option.onStateChanged = Signal.new();

			option.main = library:Create('Frame', {
				LayoutOrder = option.position,
				Size = UDim2.new(1, 0, 0, 0),
				BackgroundTransparency = 1,
				AutomaticSize = Enum.AutomaticSize.Y,
				Parent = parent
			})

			local tickbox
			local tickboxOverlay
			if option.style then
				tickbox = library:Create('ImageLabel', {
					Position = UDim2.new(0, 6, 0, 4),
					Size = UDim2.new(0, 12, 0, 12),
					BackgroundTransparency = 1,
					Image = 'rbxassetid://3570695787',
					ImageColor3 = Color3.new(),
					Parent = option.main
				})

				library:Create('ImageLabel', {
					AnchorPoint = Vector2.new(0.5, 0.5),
					Position = UDim2.new(0.5, 0, 0.5, 0),
					Size = UDim2.new(1, -2, 1, -2),
					BackgroundTransparency = 1,
					Image = 'rbxassetid://3570695787',
					ImageColor3 = Color3.fromRGB(60, 60, 60),
					Parent = tickbox
				})

				library:Create('ImageLabel', {
					AnchorPoint = Vector2.new(0.5, 0.5),
					Position = UDim2.new(0.5, 0, 0.5, 0),
					Size = UDim2.new(1, -6, 1, -6),
					BackgroundTransparency = 1,
					Image = 'rbxassetid://3570695787',
					ImageColor3 = Color3.fromRGB(40, 40, 40),
					Parent = tickbox
				})

				tickboxOverlay = library:Create('ImageLabel', {
					AnchorPoint = Vector2.new(0.5, 0.5),
					Position = UDim2.new(0.5, 0, 0.5, 0),
					Size = UDim2.new(1, -6, 1, -6),
					BackgroundTransparency = 1,
					Image = 'rbxassetid://3570695787',
					ImageColor3 = library.flags.menuAccentColor,
					Visible = option.state,
					Parent = tickbox
				})

				library:Create('ImageLabel', {
					AnchorPoint = Vector2.new(0.5, 0.5),
					Position = UDim2.new(0.5, 0, 0.5, 0),
					Size = UDim2.new(1, 0, 1, 0),
					BackgroundTransparency = 1,
					Image = 'rbxassetid://5941353943',
					ImageTransparency = 0.6,
					Parent = tickbox
				})

				table.insert(library.theme, tickboxOverlay)
			else
				tickbox = library:Create('Frame', {
					Position = UDim2.new(0, 6, 0, 4),
					Size = UDim2.new(0, 12, 0, 12),
					BackgroundColor3 = library.flags.menuAccentColor,
					BorderColor3 = Color3.new(),
					Parent = option.main
				})

				tickboxOverlay = library:Create('ImageLabel', {
					Size = UDim2.new(1, 0, 1, 0),
					BackgroundTransparency = option.state and 1 or 0,
					BackgroundColor3 = Color3.fromRGB(50, 50, 50),
					BorderColor3 = Color3.new(),
					Image = 'rbxassetid://4155801252',
					ImageTransparency = 0.6,
					ImageColor3 = Color3.new(),
					Parent = tickbox
				})

				library:Create('ImageLabel', {
					Size = UDim2.new(1, 0, 1, 0),
					BackgroundTransparency = 1,
					Image = 'rbxassetid://2592362371',
					ImageColor3 = Color3.fromRGB(60, 60, 60),
					ScaleType = Enum.ScaleType.Slice,
					SliceCenter = Rect.new(2, 2, 62, 62),
					Parent = tickbox
				})

				library:Create('ImageLabel', {
					Size = UDim2.new(1, -2, 1, -2),
					Position = UDim2.new(0, 1, 0, 1),
					BackgroundTransparency = 1,
					Image = 'rbxassetid://2592362371',
					ImageColor3 = Color3.new(),
					ScaleType = Enum.ScaleType.Slice,
					SliceCenter = Rect.new(2, 2, 62, 62),
					Parent = tickbox
				})

				table.insert(library.theme, tickbox)
			end

			option.interest = library:Create('Frame', {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 0, 20),
				BackgroundTransparency = 1,
				Parent = option.main
			})

			option.title = library:Create('TextLabel', {
				Position = UDim2.new(0, 24, 0, 0),
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Text = option.text,
				TextColor3 =  option.state and Color3.fromRGB(210, 210, 210) or Color3.fromRGB(180, 180, 180),
				TextSize = 15,
				Font = Enum.Font.Code,
				TextXAlignment = Enum.TextXAlignment.Left,
				Parent = option.interest
			})

			library.unloadMaid:GiveTask(option.interest.InputBegan:connect(function(input)
				if input.UserInputType.Name == 'MouseButton1' then
					option:SetState(not option.state)
				end
				if input.UserInputType.Name == 'MouseMovement' then
					if not library.warning and not library.slider then
						if option.style then
							tickbox.ImageColor3 = library.flags.menuAccentColor
						else
							tickbox.BorderColor3 = library.flags.menuAccentColor
							tickboxOverlay.BorderColor3 = library.flags.menuAccentColor
						end
					end
					if option.tip then
						library.tooltip.Text = option.tip;
					end
				end
			end))

			makeTooltip(option.interest, option);

			library.unloadMaid:GiveTask(option.interest.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if option.style then
						tickbox.ImageColor3 = Color3.new()
					else
						tickbox.BorderColor3 = Color3.new()
						tickboxOverlay.BorderColor3 = Color3.new()
					end
				end
			end));

			function option:SetState(state, nocallback)
				state = typeof(state) == 'boolean' and state
				state = state or false
				library.flags[self.flag] = state
				self.state = state
				option.title.TextColor3 = state and Color3.fromRGB(210, 210, 210) or Color3.fromRGB(160, 160, 160)
				if option.style then
					tickboxOverlay.Visible = state
				else
					tickboxOverlay.BackgroundTransparency = state and 1 or 0
				end

				if not nocallback then
					task.spawn(self.callback, state);
				end

				option.onStateChanged:Fire(state);
				library.OnFlagChanged:Fire(self);
			end

			task.defer(function()
				option:SetState(option.state);
			end);

			setmetatable(option, {__newindex = function(t, i, v)
				if i == 'Text' then
					option.title.Text = tostring(v)
				else
					rawset(t, i, v);
				end
			end})
		end

		local function createButton(option, parent)
			option.hasInit = true

			option.main = option.sub and option:getMain() or library:Create('Frame', {
				LayoutOrder = option.position,
				Size = UDim2.new(1, 0, 0, 26),
				BackgroundTransparency = 1,
				Parent = parent
			})

			option.title = library:Create('TextLabel', {
				AnchorPoint = Vector2.new(0.5, 1),
				Position = UDim2.new(0.5, 0, 1, -5),
				Size = UDim2.new(1, -12, 0, 18),
				BackgroundColor3 = Color3.fromRGB(50, 50, 50),
				BorderColor3 = Color3.new(),
				Text = option.text,
				TextColor3 = Color3.new(1, 1, 1),
				TextSize = 15,
				Font = Enum.Font.Code,
				Parent = option.main
			})

			if (option.sub) then
				if (not option.parent.subInit) then
					option.parent.subInit = true;

					-- If we are a sub option then set some properties of parent

					option.parent.title.Size = UDim2.fromOffset(0, 18);

					option.parent.listLayout = library:Create('UIGridLayout', {
						Parent = option.parent.main,
						HorizontalAlignment = Enum.HorizontalAlignment.Center,
						FillDirection = Enum.FillDirection.Vertical,
						VerticalAlignment = Enum.VerticalAlignment.Center,
						CellSize = UDim2.new(1 / (#option.main:GetChildren()-1), -8, 0, 18)
					});
				end;

				option.parent.listLayout.CellSize = UDim2.new(1 / (#option.parent.main:GetChildren()-1), -8, 0, 18);
			end;

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.title
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.title
			})

			library:Create('UIGradient', {
				Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Color3.fromRGB(180, 180, 180)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(253, 253, 253)),
				}),
				Rotation = -90,
				Parent = option.title
			})

			library.unloadMaid:GiveTask(option.title.InputBegan:connect(function(input)
				if input.UserInputType.Name == 'MouseButton1' then
					option.callback()
					if library then
						library.flags[option.flag] = true
					end
					if option.tip then
						library.tooltip.Text = option.tip;
					end
				end
				if input.UserInputType.Name == 'MouseMovement' then
					if not library.warning and not library.slider then
						option.title.BorderColor3 = library.flags.menuAccentColor;
					end
					if option.tip then
						library.tooltip.Text = option.tip;
					end
				end
			end));

			makeTooltip(option.title, option);

			library.unloadMaid:GiveTask(option.title.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					option.title.BorderColor3 = Color3.new();
				end
			end));
		end

		local function createBind(option, parent)
			option.hasInit = true

			local Loop
			local maid = Maid.new()

			library.unloadMaid:GiveTask(function()
				maid:Destroy();
			end);

			if option.sub then
				option.main = option:getMain()
			else
				option.main = option.main or library:Create('Frame', {
					LayoutOrder = option.position,
					Size = UDim2.new(1, 0, 0, 20),
					BackgroundTransparency = 1,
					Parent = parent
				})

				option.title = library:Create('TextLabel', {
					Position = UDim2.new(0, 6, 0, 0),
					Size = UDim2.new(1, -12, 1, 0),
					BackgroundTransparency = 1,
					Text = option.text,
					TextSize = 15,
					Font = Enum.Font.Code,
					TextColor3 = Color3.fromRGB(210, 210, 210),
					TextXAlignment = Enum.TextXAlignment.Left,
					Parent = option.main
				})
			end

			local bindinput = library:Create(option.sub and 'TextButton' or 'TextLabel', {
				Position = UDim2.new(1, -6 - (option.subpos or 0), 0, option.sub and 2 or 3),
				SizeConstraint = Enum.SizeConstraint.RelativeYY,
				BackgroundColor3 = Color3.fromRGB(30, 30, 30),
				BorderSizePixel = 0,
				TextSize = 15,
				Font = Enum.Font.Code,
				TextColor3 = Color3.fromRGB(160, 160, 160),
				TextXAlignment = Enum.TextXAlignment.Right,
				Parent = option.main
			})

			if option.sub then
				bindinput.AutoButtonColor = false
			end

			local interest = option.sub and bindinput or option.main;
			local maid = Maid.new();

			local function formatKey(key)
				if (key:match('Mouse')) then
					key = key:gsub('Button', ''):gsub('Mouse', 'M');
				elseif (key:match('Shift') or key:match('Alt') or key:match('Control')) then
					key = key:gsub('Left', 'L'):gsub('Right', 'R');
				end;

				return key:gsub('Control', 'CTRL'):upper();
			end;

			local function formatKeys(keys)
				if (not keys) then return {}; end;
				local ret = {};

				for _, key in next, keys do
					table.insert(ret, formatKey(typeof(key) == 'string' and key or key.Name));
				end;

				return ret;
			end;

			local busy = false;

			makeTooltip(interest, option);

			library.unloadMaid:GiveTask(interest.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseButton1' and not busy then
					busy = true;
					library.disableKeyBind = true;

					bindinput.Text = '[...]'
					bindinput.Size = UDim2.new(0, -TextService:GetTextSize(bindinput.Text, 16, Enum.Font.Code, Vector2.new(9e9, 9e9)).X, 0, 16)
					bindinput.TextColor3 = library.flags.menuAccentColor

					local displayKeys = {};
					local keys = {};

					maid.keybindLoop = RunService.Heartbeat:Connect(function()
						for _, key in next, UserInputService:GetKeysPressed() do
							local value = formatKey(key.KeyCode.Name);

							if (value == 'BACKSPACE') then
								maid.keybindLoop = nil;
								option:SetKeys('none');
								return;
							end;

							if (table.find(displayKeys, value)) then continue; end;
							table.insert(displayKeys, value);
							table.insert(keys, key.KeyCode);
						end;

						for _, mouseBtn in next, UserInputService:GetMouseButtonsPressed() do
							local value = formatKey(mouseBtn.UserInputType.Name);

							if (option.nomouse) then continue end;
							if (not table.find(whitelistedMouseinputs, mouseBtn.UserInputType)) then continue end;

							if (table.find(displayKeys, value)) then continue; end;

							table.insert(displayKeys, value);
							table.insert(keys, mouseBtn.UserInputType);
						end;

						bindinput.Text = '[' .. table.concat(displayKeys, '+') .. ']';

						if (#displayKeys == 3) then
							maid.keybindLoop = nil;
						end;
					end);

					task.wait(0.05);
					maid.onInputEnded = UserInputService.InputEnded:Connect(function(input)
						if(input.UserInputType ~= Enum.UserInputType.Keyboard and not input.UserInputType.Name:find('MouseButton')) then return; end;

						maid.keybindLoop = nil;
						maid.onInputEnded = nil;

						option:SetKeys(keys);
						library.disableKeyBind = false;
						task.wait(0.2);
						busy = false;
					end);
				end
			end));

			local function isKeybindPressed()
				local foundCount = 0;

				for _, key in next, UserInputService:GetKeysPressed() do
					if (table.find(option.keys, key.KeyCode)) then
						foundCount += 1;
					end;
				end;

				for _, key in next, UserInputService:GetMouseButtonsPressed() do
					if (table.find(option.keys, key.UserInputType)) then
						foundCount += 1;
					end;
				end;

				return foundCount == #option.keys;
			end;

			local debounce = false;

			function option:SetKeys(keys)
				if (typeof(keys) == 'string') then
					keys = {keys};
				end;

				keys = keys or {option.key ~= 'none' and option.key or nil};

				for i, key in next, keys do
					if (typeof(key) == 'string' and key ~= 'none') then
						local isMouse = key:find('MouseButton');

						if (isMouse) then
							keys[i] = Enum.UserInputType[key];
						else
							keys[i] = Enum.KeyCode[key];
						end;
					end;
				end;

				bindinput.TextColor3 = Color3.fromRGB(160, 160, 160)

				if Loop then
					Loop:Disconnect()
					Loop = nil;
					library.flags[option.flag] = false
					option.callback(true, 0)
				end

				self.keys = keys;

				if self.keys[1] == 'Backspace' or #self.keys == 0 then
					self.key = 'none'
					bindinput.Text = '[NONE]'

					if (#self.keys ~= 0) then
						visualizer:RemoveText(self.text);
					end;
				else
					if (self.parentFlag and self.key ~= 'none') then
						if (library.flags[self.parentFlag]) then
							visualizer:AddText(self.text);
						end;
					end;

					local formattedKey = formatKeys(self.keys);
					bindinput.Text = '[' .. table.concat(formattedKey, '+') .. ']';
					self.key = table.concat(formattedKey, '+');
				end

				bindinput.Size = UDim2.new(0, -TextService:GetTextSize(bindinput.Text, 16, Enum.Font.Code, Vector2.new(9e9, 9e9)).X, 0, 16)

				if (self.key == 'none') then
					maid.onKeyPress = nil;
					maid.onKeyRelease = nil;
				else
					maid.onKeyPress = library.OnKeyPress:Connect(function()
						if (library.disableKeyBind or #option.keys == 0 or debounce) then return end;
						if (not isKeybindPressed()) then return; end;

						debounce = true;

						if option.mode == 'toggle' then
							library.flags[option.flag] = not library.flags[option.flag]
							option.callback(library.flags[option.flag], 0)
						else
							library.flags[option.flag] = true

							if Loop then
								Loop:Disconnect();
								Loop = nil;
								option.callback(true, 0);
							end;

							Loop = library:AddConnection(RunService.Heartbeat, function(step)
								if not UserInputService:GetFocusedTextBox() then
									option.callback(nil, step)
								end
							end)
						end
					end);

					maid.onKeyRelease = library.OnKeyRelease:Connect(function()
						if (debounce and not isKeybindPressed()) then debounce = false; end;
						if (option.mode ~= 'hold') then return; end;

						local bindKey = option.key;
						if (bindKey == 'none') then return end;

						if not isKeybindPressed() then
							if Loop then
								Loop:Disconnect()
								Loop = nil;

								library.flags[option.flag] = false
								option.callback(true, 0)
							end
						end
					end);
				end;
			end;

			option:SetKeys();
		end

		local function createSlider(option, parent)
			option.hasInit = true

			if option.sub then
				option.main = option:getMain()
			else
				option.main = library:Create('Frame', {
					LayoutOrder = option.position,
					Size = UDim2.new(1, 0, 0, option.textpos and 24 or 40),
					BackgroundTransparency = 1,
					Parent = parent
				})
			end

			option.slider = library:Create('Frame', {
				Position = UDim2.new(0, 6, 0, (option.sub and 22 or option.textpos and 4 or 20)),
				Size = UDim2.new(1, -12, 0, 16),
				BackgroundColor3 = Color3.fromRGB(50, 50, 50),
				BorderColor3 = Color3.new(),
				Parent = option.main
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2454009026',
				ImageColor3 = Color3.new(),
				ImageTransparency = 0.8,
				Parent = option.slider
			})

			option.fill = library:Create('Frame', {
				BackgroundColor3 = library.flags.menuAccentColor,
				BorderSizePixel = 0,
				Parent = option.slider
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.slider
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.slider
			})

			option.title = library:Create('TextBox', {
				Position = UDim2.new((option.sub or option.textpos) and 0.5 or 0, (option.sub or option.textpos) and 0 or 6, 0, 0),
				Size = UDim2.new(0, 0, 0, (option.sub or option.textpos) and 14 or 18),
				BackgroundTransparency = 1,
				Text = (option.text == 'nil' and '' or option.text .. ': ') .. option.value .. option.suffix,
				TextSize = (option.sub or option.textpos) and 14 or 15,
				Font = Enum.Font.Code,
				TextColor3 = Color3.fromRGB(210, 210, 210),
				TextXAlignment = Enum.TextXAlignment[(option.sub or option.textpos) and 'Center' or 'Left'],
				Parent = (option.sub or option.textpos) and option.slider or option.main
			})
			table.insert(library.theme, option.fill)

			library:Create('UIGradient', {
				Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Color3.fromRGB(115, 115, 115)),
					ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1)),
				}),
				Rotation = -90,
				Parent = option.fill
			})

			if option.min >= 0 then
				option.fill.Size = UDim2.new((option.value - option.min) / (option.max - option.min), 0, 1, 0)
			else
				option.fill.Position = UDim2.new((0 - option.min) / (option.max - option.min), 0, 0, 0)
				option.fill.Size = UDim2.new(option.value / (option.max - option.min), 0, 1, 0)
			end

			local manualInput
			library.unloadMaid:GiveTask(option.title.Focused:connect(function()
				if not manualInput then
					option.title:ReleaseFocus()
					option.title.Text = (option.text == 'nil' and '' or option.text .. ': ') .. option.value .. option.suffix
				end
			end));

			library.unloadMaid:GiveTask(option.title.FocusLost:connect(function()
				option.slider.BorderColor3 = Color3.new()
				if manualInput then
					if tonumber(option.title.Text) then
						option:SetValue(tonumber(option.title.Text))
					else
						option.title.Text = (option.text == 'nil' and '' or option.text .. ': ') .. option.value .. option.suffix
					end
				end
				manualInput = false
			end));

			local interest = (option.sub or option.textpos) and option.slider or option.main
			library.unloadMaid:GiveTask(interest.InputBegan:connect(function(input)
				if input.UserInputType.Name == 'MouseButton1' then
					if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
						manualInput = true
						option.title:CaptureFocus()
					else
						library.slider = option
						option.slider.BorderColor3 = library.flags.menuAccentColor
						option:SetValue(option.min + ((input.Position.X - option.slider.AbsolutePosition.X) / option.slider.AbsoluteSize.X) * (option.max - option.min))
					end
				end
				if input.UserInputType.Name == 'MouseMovement' then
					if not library.warning and not library.slider then
						option.slider.BorderColor3 = library.flags.menuAccentColor
					end
					if option.tip then
						library.tooltip.Text = option.tip;
					end
				end
			end));

			makeTooltip(interest, option);

			library.unloadMaid:GiveTask(interest.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if option ~= library.slider then
						option.slider.BorderColor3 = Color3.new();
					end;
				end;
			end));

			if (option.parent) then
				local oldParent = option.slider.Parent;

				option.parent.onStateChanged:Connect(function(state)
					option.slider.Parent = state and oldParent or nil;
				end);
			end;

			local tweenInfo = TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out);

			function option:SetValue(value, nocallback)
				value = value or self.value;

				value = library.round(value, option.float)
				value = math.clamp(value, self.min, self.max)

				if self.min >= 0 then
					TweenService:Create(option.fill, tweenInfo, {Size = UDim2.new((value - self.min) / (self.max - self.min), 0, 1, 0)}):Play();
				else
					TweenService:Create(option.fill, tweenInfo, {
						Size = UDim2.new(value / (self.max - self.min), 0, 1, 0),
						Position = UDim2.new((0 - self.min) / (self.max - self.min), 0, 0, 0)
					}):Play();
				end
				library.flags[self.flag] = value
				self.value = value
				option.title.Text = (option.text == 'nil' and '' or option.text .. ': ') .. string.format(option.float == 1 and '%d' or '%.02f', option.value) .. option.suffix
				if not nocallback then
					task.spawn(self.callback, value)
				end

				library.OnFlagChanged:Fire(self)
			end

			task.defer(function()
				if library then
					option:SetValue(option.value)
				end
			end)
		end

		local function createList(option, parent)
			option.hasInit = true

			if option.sub then
				option.main = option:getMain()
				option.main.Size = UDim2.new(1, 0, 0, 48)
			else
				option.main = library:Create('Frame', {
					LayoutOrder = option.position,
					Size = UDim2.new(1, 0, 0, option.text == 'nil' and 30 or 48),
					BackgroundTransparency = 1,
					Parent = parent
				})

				if option.text ~= 'nil' then
					library:Create('TextLabel', {
						Position = UDim2.new(0, 6, 0, 0),
						Size = UDim2.new(1, -12, 0, 18),
						BackgroundTransparency = 1,
						Text = option.text,
						TextSize = 15,
						Font = Enum.Font.Code,
						TextColor3 = Color3.fromRGB(210, 210, 210),
						TextXAlignment = Enum.TextXAlignment.Left,
						Parent = option.main
					})
				end
			end

			if(option.playerOnly) then
				library.OnLoad:Connect(function()
					option.values = {};

					for i,v in next, Players:GetPlayers() do
						if (v == LocalPlayer) then continue end;
						option:AddValue(v.Name);
					end;

					library.unloadMaid:GiveTask(Players.PlayerAdded:Connect(function(plr)
						option:AddValue(plr.Name);
					end));

					library.unloadMaid:GiveTask(Players.PlayerRemoving:Connect(function(plr)
						option:RemoveValue(plr.Name);
					end));
				end);
			end;

			local function getMultiText()
				local t = {};

				if (option.playerOnly and option.multiselect) then
					for i, v in next, option.values do
						if (option.value[i]) then
							table.insert(t, tostring(i));
						end;
					end;
				else
					for i, v in next, option.values do
						if (option.value[v]) then
							table.insert(t, tostring(v));
						end;
					end;
				end;

				return table.concat(t, ', ');
			end

			option.listvalue = library:Create('TextBox', {
				Position = UDim2.new(0, 6, 0, (option.text == 'nil' and not option.sub) and 4 or 22),
				Size = UDim2.new(1, -12, 0, 22),
				BackgroundColor3 = Color3.fromRGB(50, 50, 50),
				BorderColor3 = Color3.new(),
				Active = false,
				ClearTextOnFocus = false,
				Text = ' ' .. (typeof(option.value) == 'string' and option.value or getMultiText()),
				TextSize = 15,
				Font = Enum.Font.Code,
				TextColor3 = Color3.new(1, 1, 1),
				TextXAlignment = Enum.TextXAlignment.Left,
				TextTruncate = Enum.TextTruncate.AtEnd,
				Parent = option.main
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2454009026',
				ImageColor3 = Color3.new(),
				ImageTransparency = 0.8,
				Parent = option.listvalue
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.listvalue
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.listvalue
			})

			option.arrow = library:Create('ImageLabel', {
				Position = UDim2.new(1, -16, 0, 7),
				Size = UDim2.new(0, 8, 0, 8),
				Rotation = 90,
				BackgroundTransparency = 1,
				Image = 'rbxassetid://4918373417',
				ImageColor3 = Color3.new(1, 1, 1),
				ScaleType = Enum.ScaleType.Fit,
				ImageTransparency = 0.4,
				Parent = option.listvalue
			})

			option.holder = library:Create('TextButton', {
				ZIndex = 4,
				BackgroundColor3 = Color3.fromRGB(40, 40, 40),
				BorderColor3 = Color3.new(),
				Text = '',
				TextColor3 = Color3.fromRGB(255,255, 255),
				AutoButtonColor = false,
				Visible = false,
				Parent = library.base
			})

			option.content = library:Create('ScrollingFrame', {
				ZIndex = 4,
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100),
				ScrollBarThickness = 6,
				ScrollingDirection = Enum.ScrollingDirection.Y,
				VerticalScrollBarInset = Enum.ScrollBarInset.Always,
				TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
				BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
				Parent = option.holder
			})

			library:Create('ImageLabel', {
				ZIndex = 4,
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.holder
			})

			library:Create('ImageLabel', {
				ZIndex = 4,
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.holder
			})

			local layout = library:Create('UIListLayout', {
				Padding = UDim.new(0, 2),
				Parent = option.content
			})

			library:Create('UIPadding', {
				PaddingTop = UDim.new(0, 4),
				PaddingLeft = UDim.new(0, 4),
				Parent = option.content
			})

			local valueCount = 0;

			local function updateHolder(newValueCount)
				option.holder.Size = UDim2.new(0, option.listvalue.AbsoluteSize.X, 0, 8 + ((newValueCount or valueCount) > option.max and (-2 + (option.max * 22)) or layout.AbsoluteContentSize.Y))
				option.content.CanvasSize = UDim2.new(0, 0, 0, 8 + layout.AbsoluteContentSize.Y)
			end;

			library.unloadMaid:GiveTask(layout.Changed:Connect(function() updateHolder(); end));
			local interest = option.sub and option.listvalue or option.main
			local focused = false;

			library.unloadMaid:GiveTask(option.listvalue.Focused:Connect(function() focused = true; end));
			library.unloadMaid:GiveTask(option.listvalue.FocusLost:Connect(function() focused = false; end));

			library.unloadMaid:GiveTask(option.listvalue:GetPropertyChangedSignal('Text'):Connect(function()
				if (not focused) then return end;
				local newText = option.listvalue.Text;

				if (newText:sub(1, 1) ~= ' ') then
					newText = ' ' .. newText;
					option.listvalue.Text = newText;
					option.listvalue.CursorPosition = 2;
				end;

				local search = string.lower(newText:sub(2));
				local matchedResults = 0;

				for name, label in next, option.labels do
					if (string.find(string.lower(name), search)) then
						matchedResults += 1;
						label.Visible = true;
					else
						label.Visible = false;
					end;
				end;

				updateHolder(matchedResults);
			end));

			library.unloadMaid:GiveTask(option.listvalue.InputBegan:connect(function(input)
				if input.UserInputType.Name == 'MouseButton1' then
					if library.popup == option then library.popup:Close() return end
					if library.popup then
						library.popup:Close()
					end
					option.arrow.Rotation = -90
					option.open = true
					option.holder.Visible = true
					local pos = option.main.AbsolutePosition
					option.holder.Position = UDim2.new(0, pos.X + 6, 0, pos.Y + ((option.text == 'nil' and not option.sub) and 66 or 84))
					library.popup = option
					option.listvalue.BorderColor3 = library.flags.menuAccentColor
					option.listvalue:CaptureFocus();
					option.listvalue.CursorPosition = string.len(typeof(option.value) == 'string' and option.value or getMultiText() or option.value) + 2;

					if (option.multiselect) then
						option.listvalue.Text = ' ';
					end;
				end
				if input.UserInputType.Name == 'MouseMovement' then
					if not library.warning and not library.slider then
						option.listvalue.BorderColor3 = library.flags.menuAccentColor
					end
				end
			end));

			library.unloadMaid:GiveTask(option.listvalue.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if not option.open then
						option.listvalue.BorderColor3 = Color3.new()
					end
				end
			end));

			library.unloadMaid:GiveTask(interest.InputBegan:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if option.tip then
						library.tooltip.Text = option.tip;
					end
				end
			end));

			makeTooltip(interest, option);

			function option:AddValue(value, state)
				if self.labels[value] then return end
				state = state or (option.playerOnly and false)

				valueCount = valueCount + 1

				if self.multiselect then
					self.values[value] = state
				else
					if not table.find(self.values, value) then
						table.insert(self.values, value)
					end
				end

				local label = library:Create('TextLabel', {
					ZIndex = 4,
					Size = UDim2.new(1, 0, 0, 20),
					BackgroundTransparency = 1,
					Text = value,
					TextSize = 15,
					Font = Enum.Font.Code,
					TextTransparency = self.multiselect and (self.value[value] and 1 or 0) or self.value == value and 1 or 0,
					TextColor3 = Color3.fromRGB(210, 210, 210),
					TextXAlignment = Enum.TextXAlignment.Left,
					Parent = option.content
				})

				self.labels[value] = label

				local labelOverlay = library:Create('TextLabel', {
					ZIndex = 4,
					Size = UDim2.new(1, 0, 1, 0),
					BackgroundTransparency = 0.8,
					Text = ' ' ..value,
					TextSize = 15,
					Font = Enum.Font.Code,
					TextColor3 = library.flags.menuAccentColor,
					TextXAlignment = Enum.TextXAlignment.Left,
					Visible = self.multiselect and self.value[value] or self.value == value,
					Parent = label
				});

				table.insert(library.theme, labelOverlay)

				library.unloadMaid:GiveTask(label.InputBegan:connect(function(input)
					if input.UserInputType.Name == 'MouseButton1' then
						if self.multiselect then
							self.value[value] = not self.value[value]
							self:SetValue(self.value);
							self.listvalue.Text = ' ';
							self.listvalue.CursorPosition = 2;
							self.listvalue:CaptureFocus();
						else
							self:SetValue(value)
							self:Close()
						end
					end
				end));
			end

			for i, value in next, option.values do
				option:AddValue(tostring(typeof(i) == 'number' and value or i))
			end

			function option:RemoveValue(value)
				local label = self.labels[value]
				if label then
					label:Destroy()
					self.labels[value] = nil
					valueCount = valueCount - 1
					if self.multiselect then
						self.values[value] = nil
						self:SetValue(self.value)
					else
						table.remove(self.values, table.find(self.values, value))
						if self.value == value then
							self:SetValue(self.values[1] or '')

							if (not self.values[1]) then
								option.listvalue.Text = '';
							end;
						end
					end
				end
			end

			function option:SetValue(value, nocallback)
				if self.multiselect and typeof(value) ~= 'table' then
					value = {}
					for i,v in next, self.values do
						value[v] = false
					end
				end

				if (not value) then return end;

				self.value = self.multiselect and value or self.values[table.find(self.values, value) or 1];
				if (self.playerOnly and not self.multiselect) then
					self.value = Players:FindFirstChild(value);
				end;

				if (not self.value) then return end;

				library.flags[self.flag] = self.value;
				option.listvalue.Text = ' ' .. (self.multiselect and getMultiText() or tostring(self.value));

				for name, label in next, self.labels do
					local visible = self.multiselect and self.value[name] or self.value == name;
					label.TextTransparency = visible and 1 or 0;
					if label:FindFirstChild'TextLabel' then
						label.TextLabel.Visible = visible;
					end;
				end;

				if not nocallback then
					self.callback(self.value)
				end
			end

			task.defer(function()
				if library and not option.noload then
					option:SetValue(option.value)
				end
			end)

			function option:Close()
				library.popup = nil
				option.arrow.Rotation = 90
				self.open = false
				option.holder.Visible = false
				option.listvalue.BorderColor3 = Color3.new()
				option.listvalue:ReleaseFocus();
				option.listvalue.Text = ' ' .. (self.multiselect and getMultiText() or tostring(self.value));

				for _, label in next, option.labels do
					label.Visible = true;
				end;
			end

			return option
		end

		local function createBox(option, parent)
			option.hasInit = true

			option.main = library:Create('Frame', {
				LayoutOrder = option.position,
				Size = UDim2.new(1, 0, 0, option.text == 'nil' and 28 or 44),
				BackgroundTransparency = 1,
				Parent = parent
			})

			if option.text ~= 'nil' then
				option.title = library:Create('TextLabel', {
					Position = UDim2.new(0, 6, 0, 0),
					Size = UDim2.new(1, -12, 0, 18),
					BackgroundTransparency = 1,
					Text = option.text,
					TextSize = 15,
					Font = Enum.Font.Code,
					TextColor3 = Color3.fromRGB(210, 210, 210),
					TextXAlignment = Enum.TextXAlignment.Left,
					Parent = option.main
				})
			end

			option.holder = library:Create('Frame', {
				Position = UDim2.new(0, 6, 0, option.text == 'nil' and 4 or 20),
				Size = UDim2.new(1, -12, 0, 20),
				BackgroundColor3 = Color3.fromRGB(50, 50, 50),
				BorderColor3 = Color3.new(),
				Parent = option.main
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2454009026',
				ImageColor3 = Color3.new(),
				ImageTransparency = 0.8,
				Parent = option.holder
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.holder
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.holder
			})

			local inputvalue = library:Create('TextBox', {
				Position = UDim2.new(0, 4, 0, 0),
				Size = UDim2.new(1, -4, 1, 0),
				BackgroundTransparency = 1,
				Text = '  ' .. option.value,
				TextSize = 15,
				Font = Enum.Font.Code,
				TextColor3 = Color3.new(1, 1, 1),
				TextXAlignment = Enum.TextXAlignment.Left,
				TextWrapped = true,
				ClearTextOnFocus = false,
				Parent = option.holder
			})

			library.unloadMaid:GiveTask(inputvalue.FocusLost:connect(function(enter)
				option.holder.BorderColor3 = Color3.new()
				option:SetValue(inputvalue.Text, enter)
			end));

			library.unloadMaid:GiveTask(inputvalue.Focused:connect(function()
				option.holder.BorderColor3 = library.flags.menuAccentColor
			end));

			library.unloadMaid:GiveTask(inputvalue.InputBegan:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if not library.warning and not library.slider then
						option.holder.BorderColor3 = library.flags.menuAccentColor
					end
					if option.tip then
						library.tooltip.Text = option.tip;
					end
				end
			end));

			makeTooltip(inputvalue, option);

			library.unloadMaid:GiveTask(inputvalue.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if not inputvalue:IsFocused() then
						option.holder.BorderColor3 = Color3.new();
					end;
				end;
			end));

			function option:SetValue(value, enter)
				if (value:gsub('%s+', '') == '') then
					value = '';
				end;

				library.flags[self.flag] = tostring(value);
				self.value = tostring(value);
				inputvalue.Text = self.value;
				self.callback(value, enter);

				library.OnFlagChanged:Fire(self);
			end
			task.defer(function()
				if library then
					option:SetValue(option.value)
				end
			end)
		end

		local function createColorPickerWindow(option)
			option.mainHolder = library:Create('TextButton', {
				ZIndex = 4,
				--Position = UDim2.new(1, -184, 1, 6),
				Size = UDim2.new(0, option.trans and 200 or 184, 0, 264),
				BackgroundColor3 = Color3.fromRGB(40, 40, 40),
				BorderColor3 = Color3.new(),
				AutoButtonColor = false,
				Visible = false,
				Parent = library.base
			})

			option.rgbBox = library:Create('Frame', {
				Position = UDim2.new(0, 6, 0, 214),
				Size = UDim2.new(0, (option.mainHolder.AbsoluteSize.X - 12), 0, 20),
				BackgroundColor3 = Color3.fromRGB(57, 57, 57),
				BorderColor3 = Color3.new(),
				ZIndex = 5;
				Parent = option.mainHolder
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2454009026',
				ImageColor3 = Color3.new(),
				ImageTransparency = 0.8,
				ZIndex = 6;
				Parent = option.rgbBox
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				ZIndex = 6;
				Parent = option.rgbBox
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				ZIndex = 6;
				Parent = option.rgbBox
			})

			local r, g, b = library.round(option.color);
			local colorText = table.concat({r, g, b}, ',');

			option.rgbInput = library:Create('TextBox', {
				Position = UDim2.new(0, 4, 0, 0),
				Size = UDim2.new(1, -4, 1, 0),
				BackgroundTransparency = 1,
				Text = colorText,
				TextSize = 14,
				Font = Enum.Font.Code,
				TextColor3 = Color3.new(1, 1, 1),
				TextXAlignment = Enum.TextXAlignment.Center,
				TextWrapped = true,
				ClearTextOnFocus = false,
				ZIndex = 6;
				Parent = option.rgbBox
			})

			option.hexBox = option.rgbBox:Clone()
			option.hexBox.Position = UDim2.new(0, 6, 0, 238)
			-- option.hexBox.Size = UDim2.new(0, (option.mainHolder.AbsoluteSize.X/2 - 10), 0, 20)
			option.hexBox.Parent = option.mainHolder
			option.hexInput = option.hexBox.TextBox;

			library:Create('ImageLabel', {
				ZIndex = 4,
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.mainHolder
			})

			library:Create('ImageLabel', {
				ZIndex = 4,
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.mainHolder
			})

			local hue, sat, val = Color3.toHSV(option.color)
			hue, sat, val = hue == 0 and 1 or hue, sat + 0.005, val - 0.005
			local editinghue
			local editingsatval
			local editingtrans

			local transMain
			if option.trans then
				transMain = library:Create('ImageLabel', {
					ZIndex = 5,
					Size = UDim2.new(1, 0, 1, 0),
					BackgroundTransparency = 1,
					Image = 'rbxassetid://2454009026',
					ImageColor3 = Color3.fromHSV(hue, 1, 1),
					Rotation = 180,
					Parent = library:Create('ImageLabel', {
						ZIndex = 4,
						AnchorPoint = Vector2.new(1, 0),
						Position = UDim2.new(1, -6, 0, 6),
						Size = UDim2.new(0, 10, 1, -60),
						BorderColor3 = Color3.new(),
						Image = 'rbxassetid://4632082392',
						ScaleType = Enum.ScaleType.Tile,
						TileSize = UDim2.new(0, 5, 0, 5),
						Parent = option.mainHolder
					})
				})

				option.transSlider = library:Create('Frame', {
					ZIndex = 5,
					Position = UDim2.new(0, 0, option.trans, 0),
					Size = UDim2.new(1, 0, 0, 2),
					BackgroundColor3 = Color3.fromRGB(38, 41, 65),
					BorderColor3 = Color3.fromRGB(255, 255, 255),
					Parent = transMain
				})

				library.unloadMaid:GiveTask(transMain.InputBegan:connect(function(Input)
					if Input.UserInputType.Name == 'MouseButton1' then
						editingtrans = true
						option:SetTrans(1 - ((Input.Position.Y - transMain.AbsolutePosition.Y) / transMain.AbsoluteSize.Y))
					end
				end));

				library.unloadMaid:GiveTask(transMain.InputEnded:connect(function(Input)
					if Input.UserInputType.Name == 'MouseButton1' then
						editingtrans = false
					end
				end));
			end

			local hueMain = library:Create('Frame', {
				ZIndex = 4,
				AnchorPoint = Vector2.new(0, 1),
				Position = UDim2.new(0, 6, 1, -54),
				Size = UDim2.new(1, option.trans and -28 or -12, 0, 10),
				BackgroundColor3 = Color3.new(1, 1, 1),
				BorderColor3 = Color3.new(),
				Parent = option.mainHolder
			})

			library:Create('UIGradient', {
				Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
					ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 0, 255)),
					ColorSequenceKeypoint.new(0.33, Color3.fromRGB(0, 0, 255)),
					ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)),
					ColorSequenceKeypoint.new(0.67, Color3.fromRGB(0, 255, 0)),
					ColorSequenceKeypoint.new(0.83, Color3.fromRGB(255, 255, 0)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0)),
				}),
				Parent = hueMain
			})

			local hueSlider = library:Create('Frame', {
				ZIndex = 4,
				Position = UDim2.new(1 - hue, 0, 0, 0),
				Size = UDim2.new(0, 2, 1, 0),
				BackgroundColor3 = Color3.fromRGB(38, 41, 65),
				BorderColor3 = Color3.fromRGB(255, 255, 255),
				Parent = hueMain
			})

			library.unloadMaid:GiveTask(hueMain.InputBegan:connect(function(Input)
				if Input.UserInputType.Name == 'MouseButton1' then
					editinghue = true
					local X = (hueMain.AbsolutePosition.X + hueMain.AbsoluteSize.X) - hueMain.AbsolutePosition.X
					X = math.clamp((Input.Position.X - hueMain.AbsolutePosition.X) / X, 0, 0.995)
					option:SetColor(Color3.fromHSV(1 - X, sat, val))
				end
			end));

			library.unloadMaid:GiveTask(hueMain.InputEnded:connect(function(Input)
				if Input.UserInputType.Name == 'MouseButton1' then
					editinghue = false
				end
			end));

			local satval = library:Create('ImageLabel', {
				ZIndex = 4,
				Position = UDim2.new(0, 6, 0, 6),
				Size = UDim2.new(1, option.trans and -28 or -12, 1, -74),
				BackgroundColor3 = Color3.fromHSV(hue, 1, 1),
				BorderColor3 = Color3.new(),
				Image = 'rbxassetid://4155801252',
				ClipsDescendants = true,
				Parent = option.mainHolder
			})

			local satvalSlider = library:Create('Frame', {
				ZIndex = 4,
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.new(sat, 0, 1 - val, 0),
				Size = UDim2.new(0, 4, 0, 4),
				Rotation = 45,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				Parent = satval
			})

			library.unloadMaid:GiveTask(satval.InputBegan:connect(function(Input)
				if Input.UserInputType.Name == 'MouseButton1' then
					editingsatval = true
					local X = (satval.AbsolutePosition.X + satval.AbsoluteSize.X) - satval.AbsolutePosition.X
					local Y = (satval.AbsolutePosition.Y + satval.AbsoluteSize.Y) - satval.AbsolutePosition.Y
					X = math.clamp((Input.Position.X - satval.AbsolutePosition.X) / X, 0.005, 1)
					Y = math.clamp((Input.Position.Y - satval.AbsolutePosition.Y) / Y, 0, 0.995)
					option:SetColor(Color3.fromHSV(hue, X, 1 - Y))
				end
			end));

			library:AddConnection(UserInputService.InputChanged, function(Input)
				if (not editingsatval and not editinghue and not editingtrans) then return end;

				if Input.UserInputType.Name == 'MouseMovement' then
					if editingsatval then
						local X = (satval.AbsolutePosition.X + satval.AbsoluteSize.X) - satval.AbsolutePosition.X
						local Y = (satval.AbsolutePosition.Y + satval.AbsoluteSize.Y) - satval.AbsolutePosition.Y
						X = math.clamp((Input.Position.X - satval.AbsolutePosition.X) / X, 0.005, 1)
						Y = math.clamp((Input.Position.Y - satval.AbsolutePosition.Y) / Y, 0, 0.995)
						option:SetColor(Color3.fromHSV(hue, X, 1 - Y))
					elseif editinghue then
						local X = (hueMain.AbsolutePosition.X + hueMain.AbsoluteSize.X) - hueMain.AbsolutePosition.X
						X = math.clamp((Input.Position.X - hueMain.AbsolutePosition.X) / X, 0, 0.995)
						option:SetColor(Color3.fromHSV(1 - X, sat, val))
					elseif editingtrans then
						option:SetTrans(1 - ((Input.Position.Y - transMain.AbsolutePosition.Y) / transMain.AbsoluteSize.Y))
					end
				end
			end)

			library.unloadMaid:GiveTask(satval.InputEnded:connect(function(Input)
				if Input.UserInputType.Name == 'MouseButton1' then
					editingsatval = false
				end
			end));

			option.hexInput.Text = option.color:ToHex();

			library.unloadMaid:GiveTask(option.rgbInput.FocusLost:connect(function()
				local color = Color3.fromRGB(unpack(option.rgbInput.Text:split(',')));
				return option:SetColor(color)
			end));

			library.unloadMaid:GiveTask(option.hexInput.FocusLost:connect(function()
				local color = Color3.fromHex(option.hexInput.Text);
				return option:SetColor(color);
			end));

			function option:updateVisuals(Color)
				hue, sat, val = Color:ToHSV();
				hue, sat, val = math.clamp(hue, 0, 1), math.clamp(sat, 0, 1), math.clamp(val, 0, 1);

				hue = hue == 0 and 1 or hue
				satval.BackgroundColor3 = Color3.fromHSV(hue, 1, 1)
				if option.trans then
					transMain.ImageColor3 = Color3.fromHSV(hue, 1, 1)
				end
				hueSlider.Position = UDim2.new(1 - hue, 0, 0, 0)
				satvalSlider.Position = UDim2.new(sat, 0, 1 - val, 0)

				local color = Color3.fromHSV(hue, sat, val);
				local r, g, b = library.round(color);

				option.hexInput.Text = color:ToHex();
				option.rgbInput.Text = table.concat({r, g, b}, ',');
			end

			return option
		end

		local function createColor(option, parent)
			option.hasInit = true

			if option.sub then
				option.main = option:getMain()
			else
				option.main = library:Create('Frame', {
					LayoutOrder = option.position,
					Size = UDim2.new(1, 0, 0, 20),
					BackgroundTransparency = 1,
					Parent = parent
				})

				option.title = library:Create('TextLabel', {
					Position = UDim2.new(0, 6, 0, 0),
					Size = UDim2.new(1, -12, 1, 0),
					BackgroundTransparency = 1,
					Text = option.text,
					TextSize = 15,
					Font = Enum.Font.Code,
					TextColor3 = Color3.fromRGB(210, 210, 210),
					TextXAlignment = Enum.TextXAlignment.Left,
					Parent = option.main
				})
			end

			option.visualize = library:Create(option.sub and 'TextButton' or 'Frame', {
				Position = UDim2.new(1, -(option.subpos or 0) - 24, 0, 4),
				Size = UDim2.new(0, 18, 0, 12),
				SizeConstraint = Enum.SizeConstraint.RelativeYY,
				BackgroundColor3 = option.color,
				BorderColor3 = Color3.new(),
				Parent = option.main
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2454009026',
				ImageColor3 = Color3.new(),
				ImageTransparency = 0.6,
				Parent = option.visualize
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.visualize
			})

			library:Create('ImageLabel', {
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = option.visualize
			})

			local interest = option.sub and option.visualize or option.main

			if option.sub then
				option.visualize.Text = ''
				option.visualize.AutoButtonColor = false
			end

			library.unloadMaid:GiveTask(interest.InputBegan:connect(function(input)
				if input.UserInputType.Name == 'MouseButton1' then
					if not option.mainHolder then
						createColorPickerWindow(option)
					end
					if library.popup == option then library.popup:Close() return end
					if library.popup then library.popup:Close() end
					option.open = true
					local pos = option.main.AbsolutePosition
					option.mainHolder.Position = UDim2.new(0, pos.X + 36 + (option.trans and -16 or 0), 0, pos.Y + 56)
					option.mainHolder.Visible = true
					library.popup = option
					option.visualize.BorderColor3 = library.flags.menuAccentColor
				end
				if input.UserInputType.Name == 'MouseMovement' then
					if not library.warning and not library.slider then
						option.visualize.BorderColor3 = library.flags.menuAccentColor
					end
					if option.tip then
						library.tooltip.Text = option.tip;
					end
				end
			end));

			makeTooltip(interest, option);

			library.unloadMaid:GiveTask(interest.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseMovement' then
					if not option.open then
						option.visualize.BorderColor3 = Color3.new();
					end;
				end;
			end));

			function option:SetColor(newColor, nocallback, noFire)
				newColor = newColor or Color3.new(1, 1, 1)
				if self.mainHolder then
					self:updateVisuals(newColor)
				end
				option.visualize.BackgroundColor3 = newColor
				library.flags[self.flag] = newColor
				self.color = newColor

				if not nocallback then
					task.spawn(self.callback, newColor)
				end

				if (not noFire) then
					library.OnFlagChanged:Fire(self);
				end;
			end

			if option.trans then
				function option:SetTrans(value, manual)
					value = math.clamp(tonumber(value) or 0, 0, 1)
					if self.transSlider then
						self.transSlider.Position = UDim2.new(0, 0, value, 0)
					end
					self.trans = value
					library.flags[self.flag .. 'Transparency'] = 1 - value
					task.spawn(self.calltrans, value)
				end
				option:SetTrans(option.trans)
			end

			task.defer(function()
				if library then
					option:SetColor(option.color)
				end
			end)

			function option:Close()
				library.popup = nil
				self.open = false
				self.mainHolder.Visible = false
				option.visualize.BorderColor3 = Color3.new()
			end
		end

		function library:AddTab(title, pos)
			local tab = {canInit = true, columns = {}, title = tostring(title)}
			table.insert(self.tabs, pos or #self.tabs + 1, tab)

			function tab:AddColumn()
				local column = {sections = {}, position = #self.columns, canInit = true, tab = self}
				table.insert(self.columns, column)

				function column:AddSection(title)
					local section = {title = tostring(title), options = {}, canInit = true, column = self}
					table.insert(self.sections, section)

					function section:AddLabel(text)
						local option = {text = text}
						option.section = self
						option.type = 'label'
						option.position = #self.options
						table.insert(self.options, option)

						if library.hasInit and self.hasInit then
							createLabel(option, self.content)
						else
							option.Init = createLabel
						end

						return option
					end

					function section:AddDivider(text, tip)
						local option = {text = text, tip = tip}
						option.section = self
						option.type = 'divider'
						option.position = #self.options
						table.insert(self.options, option)

						if library.hasInit and self.hasInit then
							createDivider(option, self.content)
						else
							option.Init = createDivider
						end

						return option
					end

					function section:AddToggle(option)
						option = typeof(option) == 'table' and option or {}
						option.section = self
						option.text = tostring(option.text)
						option.state = typeof(option.state) == 'boolean' and option.state or false
						option.default = option.state;
						option.callback = typeof(option.callback) == 'function' and option.callback or function() end
						option.type = 'toggle'
						option.position = #self.options
						option.flag = (library.flagprefix or '') .. toCamelCase(option.flag or option.text)
						option.subcount = 0
						option.tip = option.tip and tostring(option.tip)
						option.style = option.style == 2
						library.flags[option.flag] = option.state
						table.insert(self.options, option)
						library.options[option.flag] = option

						function option:AddColor(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							return section:AddColor(subOption)
						end

						function option:AddBind(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							return section:AddBind(subOption)
						end

						function option:AddList(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							return section:AddList(subOption)
						end

						function option:AddSlider(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1

							subOption.parent = option;
							return section:AddSlider(subOption)
						end

						if library.hasInit and self.hasInit then
							createToggle(option, self.content)
						else
							option.Init = createToggle
						end

						return option
					end

					function section:AddButton(option)
						option = typeof(option) == 'table' and option or {}
						option.section = self
						option.text = tostring(option.text)
						option.callback = typeof(option.callback) == 'function' and option.callback or function() end
						option.type = 'button'
						option.position = #self.options
						option.flag = (library.flagprefix or '') .. toCamelCase(option.flag or option.text)
						option.subcount = 0
						option.tip = option.tip and tostring(option.tip)
						table.insert(self.options, option)
						library.options[option.flag] = option

						function option:AddBind(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() option.main.Size = UDim2.new(1, 0, 0, 40) return option.main end
							self.subcount = self.subcount + 1
							return section:AddBind(subOption)
						end

						function option:AddColor(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() option.main.Size = UDim2.new(1, 0, 0, 40) return option.main end
							self.subcount = self.subcount + 1
							return section:AddColor(subOption)
						end

						function option:AddButton(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							subOption.parent = option;
							section:AddButton(subOption)

							return option;
						end;

						function option:SetText(text)
							option.title.Text = text;
						end;

						if library.hasInit and self.hasInit then
							createButton(option, self.content)
						else
							option.Init = createButton
						end

						return option
					end

					function section:AddBind(option)
						option = typeof(option) == 'table' and option or {}
						option.section = self
						option.text = tostring(option.text)
						option.key = (option.key and option.key.Name) or option.key or 'none'
						option.nomouse = typeof(option.nomouse) == 'boolean' and option.nomouse or false
						option.mode = typeof(option.mode) == 'string' and ((option.mode == 'toggle' or option.mode == 'hold') and option.mode) or 'toggle'
						option.callback = typeof(option.callback) == 'function' and option.callback or function() end
						option.type = 'bind'
						option.position = #self.options
						option.flag = (library.flagprefix or '') .. toCamelCase(option.flag or option.text)
						option.tip = option.tip and tostring(option.tip)
						table.insert(self.options, option)
						library.options[option.flag] = option

						if library.hasInit and self.hasInit then
							createBind(option, self.content)
						else
							option.Init = createBind
						end

						return option
					end

					function section:AddSlider(option)
						option = typeof(option) == 'table' and option or {}
						option.section = self
						option.text = tostring(option.text)
						option.min = typeof(option.min) == 'number' and option.min or 0
						option.max = typeof(option.max) == 'number' and option.max or 0
						option.value = option.min < 0 and 0 or math.clamp(typeof(option.value) == 'number' and option.value or option.min, option.min, option.max)
						option.default = option.value;
						option.callback = typeof(option.callback) == 'function' and option.callback or function() end
						option.float = typeof(option.value) == 'number' and option.float or 1
						option.suffix = option.suffix and tostring(option.suffix) or ''
						option.textpos = option.textpos == 2
						option.type = 'slider'
						option.position = #self.options
						option.flag = (library.flagprefix or '') .. toCamelCase(option.flag or option.text)
						option.subcount = 0
						option.tip = option.tip and tostring(option.tip)
						library.flags[option.flag] = option.value
						table.insert(self.options, option)
						library.options[option.flag] = option

						function option:AddColor(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							return section:AddColor(subOption)
						end

						function option:AddBind(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							return section:AddBind(subOption)
						end

						if library.hasInit and self.hasInit then
							createSlider(option, self.content)
						else
							option.Init = createSlider
						end

						return option
					end

					function section:AddList(option)
						option = typeof(option) == 'table' and option or {}
						option.section = self
						option.text = tostring(option.text)
						option.values = typeof(option.values) == 'table' and option.values or {}
						option.callback = typeof(option.callback) == 'function' and option.callback or function() end
						option.multiselect = typeof(option.multiselect) == 'boolean' and option.multiselect or false
						--option.groupbox = (not option.multiselect) and (typeof(option.groupbox) == 'boolean' and option.groupbox or false)
						option.value = option.multiselect and (typeof(option.value) == 'table' and option.value or {}) or tostring(option.value or option.values[1] or '')
						if option.multiselect then
							for i,v in next, option.values do
								option.value[v] = false
							end
						end
						option.max = option.max or 8
						option.open = false
						option.type = 'list'
						option.position = #self.options
						option.labels = {}
						option.flag = (library.flagprefix or '') .. toCamelCase(option.flag or option.text)
						option.subcount = 0
						option.tip = option.tip and tostring(option.tip)
						library.flags[option.flag] = option.value
						table.insert(self.options, option)
						library.options[option.flag] = option

						function option:AddValue(value, state)
							if self.multiselect then
								self.values[value] = state
							else
								table.insert(self.values, value)
							end
						end

						function option:AddColor(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							return section:AddColor(subOption)
						end

						function option:AddBind(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							return section:AddBind(subOption)
						end

						if library.hasInit and self.hasInit then
							createList(option, self.content)
						else
							option.Init = createList
						end

						return option
					end

					function section:AddBox(option)
						option = typeof(option) == 'table' and option or {}
						option.section = self
						option.text = tostring(option.text)
						option.value = tostring(option.value or '')
						option.callback = typeof(option.callback) == 'function' and option.callback or function() end
						option.type = 'box'
						option.position = #self.options
						option.flag = (library.flagprefix or '') .. toCamelCase(option.flag or option.text)
						option.tip = option.tip and tostring(option.tip)
						library.flags[option.flag] = option.value
						table.insert(self.options, option)
						library.options[option.flag] = option

						if library.hasInit and self.hasInit then
							createBox(option, self.content)
						else
							option.Init = createBox
						end

						return option
					end

					function section:AddColor(option)
						option = typeof(option) == 'table' and option or {}
						option.section = self
						option.text = tostring(option.text)
						option.color = typeof(option.color) == 'table' and Color3.new(option.color[1], option.color[2], option.color[3]) or option.color or Color3.new(1, 1, 1)
						option.callback = typeof(option.callback) == 'function' and option.callback or function() end
						option.calltrans = typeof(option.calltrans) == 'function' and option.calltrans or (option.calltrans == 1 and option.callback) or function() end
						option.open = false
						option.default = option.color;
						option.trans = tonumber(option.trans)
						option.subcount = 1
						option.type = 'color'
						option.position = #self.options
						option.flag = (library.flagprefix or '') .. toCamelCase(option.flag or option.text)
						option.tip = option.tip and tostring(option.tip)
						library.flags[option.flag] = option.color
						table.insert(self.options, option)
						library.options[option.flag] = option

						function option:AddColor(subOption)
							subOption = typeof(subOption) == 'table' and subOption or {}
							subOption.sub = true
							subOption.subpos = self.subcount * 24
							function subOption:getMain() return option.main end
							self.subcount = self.subcount + 1
							return section:AddColor(subOption)
						end

						if option.trans then
							library.flags[option.flag .. 'Transparency'] = option.trans
						end

						if library.hasInit and self.hasInit then
							createColor(option, self.content)
						else
							option.Init = createColor
						end

						return option
					end

					function section:SetTitle(newTitle)
						self.title = tostring(newTitle)
						if self.titleText then
							self.titleText.Text = tostring(newTitle)
						end
					end

					function section:Init()
						if self.hasInit then return end
						self.hasInit = true

						self.main = library:Create('Frame', {
							BackgroundColor3 = Color3.fromRGB(30, 30, 30),
							BorderColor3 = Color3.new(),
							Parent = column.main
						})

						self.content = library:Create('Frame', {
							Size = UDim2.new(1, 0, 1, 0),
							BackgroundColor3 = Color3.fromRGB(30, 30, 30),
							BorderColor3 = Color3.fromRGB(60, 60, 60),
							BorderMode = Enum.BorderMode.Inset,
							Parent = self.main
						})

						library:Create('ImageLabel', {
							Size = UDim2.new(1, -2, 1, -2),
							Position = UDim2.new(0, 1, 0, 1),
							BackgroundTransparency = 1,
							Image = 'rbxassetid://2592362371',
							ImageColor3 = Color3.new(),
							ScaleType = Enum.ScaleType.Slice,
							SliceCenter = Rect.new(2, 2, 62, 62),
							Parent = self.main
						})

						table.insert(library.theme, library:Create('Frame', {
							Size = UDim2.new(1, 0, 0, 1),
							BackgroundColor3 = library.flags.menuAccentColor,
							BorderSizePixel = 0,
							BorderMode = Enum.BorderMode.Inset,
							Parent = self.main
						}))

						local layout = library:Create('UIListLayout', {
							HorizontalAlignment = Enum.HorizontalAlignment.Center,
							SortOrder = Enum.SortOrder.LayoutOrder,
							Padding = UDim.new(0, 2),
							Parent = self.content
						})

						library:Create('UIPadding', {
							PaddingTop = UDim.new(0, 12),
							Parent = self.content
						})

						self.titleText = library:Create('TextLabel', {
							AnchorPoint = Vector2.new(0, 0.5),
							Position = UDim2.new(0, 12, 0, 0),
							Size = UDim2.new(0, TextService:GetTextSize(self.title, 15, Enum.Font.Code, Vector2.new(9e9, 9e9)).X + 10, 0, 3),
							BackgroundColor3 = Color3.fromRGB(30, 30, 30),
							BorderSizePixel = 0,
							Text = self.title,
							TextSize = 15,
							Font = Enum.Font.Code,
							TextColor3 = Color3.new(1, 1, 1),
							Parent = self.main
						})

						library.unloadMaid:GiveTask(layout.Changed:connect(function()
							self.main.Size = UDim2.new(1, 0, 0, layout.AbsoluteContentSize.Y + 16)
						end));

						for _, option in next, self.options do
							option.Init(option, self.content)
						end
					end

					if library.hasInit and self.hasInit then
						section:Init()
					end

					return section
				end

				function column:Init()
					if self.hasInit then return end
					self.hasInit = true

					self.main = library:Create('ScrollingFrame', {
						ZIndex = 2,
						Position = UDim2.new(0, 6 + (self.position * 239), 0, 2),
						Size = UDim2.new(0, 233, 1, -4),
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						ScrollBarImageColor3 = Color3.fromRGB(),
						ScrollBarThickness = 4,
						VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
						ScrollingDirection = Enum.ScrollingDirection.Y,
						Visible = true
					})

					local layout = library:Create('UIListLayout', {
						HorizontalAlignment = Enum.HorizontalAlignment.Center,
						SortOrder = Enum.SortOrder.LayoutOrder,
						Padding = UDim.new(0, 12),
						Parent = self.main
					})

					library:Create('UIPadding', {
						PaddingTop = UDim.new(0, 8),
						PaddingLeft = UDim.new(0, 2),
						PaddingRight = UDim.new(0, 2),
						Parent = self.main
					})

					library.unloadMaid:GiveTask(layout.Changed:connect(function()
						self.main.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 14)
					end));

					for _, section in next, self.sections do
						if section.canInit and #section.options > 0 then
							section:Init()
						end
					end
				end

				if library.hasInit and self.hasInit then
					column:Init()
				end

				return column
			end

			function tab:Init()
				if self.hasInit then return end
				self.hasInit = true

				local size = TextService:GetTextSize(self.title, 18, Enum.Font.Code, Vector2.new(9e9, 9e9)).X + 10

				self.button = library:Create('TextLabel', {
					Position = UDim2.new(0, library.tabSize, 0, 22),
					Size = UDim2.new(0, size, 0, 30),
					BackgroundTransparency = 1,
					Text = self.title,
					TextColor3 = Color3.new(1, 1, 1),
					TextSize = 15,
					Font = Enum.Font.Code,
					TextWrapped = true,
					ClipsDescendants = true,
					Parent = library.main
				});

				library.tabSize = library.tabSize + size

				library.unloadMaid:GiveTask(self.button.InputBegan:connect(function(input)
					if input.UserInputType.Name == 'MouseButton1' then
						library:selectTab(self);
					end;
				end));

				for _, column in next, self.columns do
					if column.canInit then
						column:Init();
					end;
				end;
			end;

			if self.hasInit then
				tab:Init()
			end

			return tab
		end

		function library:AddWarning(warning)
			warning = typeof(warning) == 'table' and warning or {}
			warning.text = tostring(warning.text)
			warning.type = warning.type == 'confirm' and 'confirm' or ''

			local answer
			function warning:Show()
				library.warning = warning
				if warning.main and warning.type == '' then
					warning.main:Destroy();
					warning.main = nil;
				end
				if library.popup then library.popup:Close() end
				if not warning.main then
					warning.main = library:Create('TextButton', {
						ZIndex = 2,
						Size = UDim2.new(1, 0, 1, 0),
						BackgroundTransparency = 0.3,
						BackgroundColor3 = Color3.new(),
						BorderSizePixel = 0,
						Text = '',
						AutoButtonColor = false,
						Parent = library.main
					})

					warning.message = library:Create('TextLabel', {
						ZIndex = 2,
						Position = UDim2.new(0, 20, 0.5, -60),
						Size = UDim2.new(1, -40, 0, 40),
						BackgroundTransparency = 1,
						TextSize = 16,
						Font = Enum.Font.Code,
						TextColor3 = Color3.new(1, 1, 1),
						TextWrapped = true,
						RichText = true,
						Parent = warning.main
					})

					if warning.type == 'confirm' then
						local button = library:Create('TextLabel', {
							ZIndex = 2,
							Position = UDim2.new(0.5, -105, 0.5, -10),
							Size = UDim2.new(0, 100, 0, 20),
							BackgroundColor3 = Color3.fromRGB(40, 40, 40),
							BorderColor3 = Color3.new(),
							Text = 'Yes',
							TextSize = 16,
							Font = Enum.Font.Code,
							TextColor3 = Color3.new(1, 1, 1),
							Parent = warning.main
						})

						library:Create('ImageLabel', {
							ZIndex = 2,
							Size = UDim2.new(1, 0, 1, 0),
							BackgroundTransparency = 1,
							Image = 'rbxassetid://2454009026',
							ImageColor3 = Color3.new(),
							ImageTransparency = 0.8,
							Parent = button
						})

						library:Create('ImageLabel', {
							ZIndex = 2,
							Size = UDim2.new(1, 0, 1, 0),
							BackgroundTransparency = 1,
							Image = 'rbxassetid://2592362371',
							ImageColor3 = Color3.fromRGB(60, 60, 60),
							ScaleType = Enum.ScaleType.Slice,
							SliceCenter = Rect.new(2, 2, 62, 62),
							Parent = button
						})

						local button1 = library:Create('TextLabel', {
							ZIndex = 2,
							Position = UDim2.new(0.5, 5, 0.5, -10),
							Size = UDim2.new(0, 100, 0, 20),
							BackgroundColor3 = Color3.fromRGB(40, 40, 40),
							BorderColor3 = Color3.new(),
							Text = 'No',
							TextSize = 16,
							Font = Enum.Font.Code,
							TextColor3 = Color3.new(1, 1, 1),
							Parent = warning.main
						})

						library:Create('ImageLabel', {
							ZIndex = 2,
							Size = UDim2.new(1, 0, 1, 0),
							BackgroundTransparency = 1,
							Image = 'rbxassetid://2454009026',
							ImageColor3 = Color3.new(),
							ImageTransparency = 0.8,
							Parent = button1
						})

						library:Create('ImageLabel', {
							ZIndex = 2,
							Size = UDim2.new(1, 0, 1, 0),
							BackgroundTransparency = 1,
							Image = 'rbxassetid://2592362371',
							ImageColor3 = Color3.fromRGB(60, 60, 60),
							ScaleType = Enum.ScaleType.Slice,
							SliceCenter = Rect.new(2, 2, 62, 62),
							Parent = button1
						})

						library.unloadMaid:GiveTask(button.InputBegan:connect(function(input)
							if input.UserInputType.Name == 'MouseButton1' then
								answer = true
							end
						end));

						library.unloadMaid:GiveTask(button1.InputBegan:connect(function(input)
							if input.UserInputType.Name == 'MouseButton1' then
								answer = false
							end
						end));
					else
						local button = library:Create('TextLabel', {
							ZIndex = 2,
							Position = UDim2.new(0.5, -50, 0.5, -10),
							Size = UDim2.new(0, 100, 0, 20),
							BackgroundColor3 = Color3.fromRGB(30, 30, 30),
							BorderColor3 = Color3.new(),
							Text = 'OK',
							TextSize = 16,
							Font = Enum.Font.Code,
							TextColor3 = Color3.new(1, 1, 1),
							Parent = warning.main
						})

						library.unloadMaid:GiveTask(button.InputEnded:connect(function(input)
							if input.UserInputType.Name == 'MouseButton1' then
								answer = true
							end
						end));
					end
				end
				warning.main.Visible = true
				warning.message.Text = warning.text

				repeat task.wait() until answer ~= nil;
				library.warning = nil;

				local answerCopy = answer;
				warning:Close();

				return answerCopy;
			end

			function warning:Close()
				answer = nil
				if not warning.main then return end
				warning.main.Visible = false
			end

			return warning
		end

		function library:Close()
			self.open = not self.open

			if self.main then
				if self.popup then
					self.popup:Close()
				end

				self.base.Enabled = self.open
			end

			library.tooltip.Position = UDim2.fromScale(10, 10);
		end

		function library:Init(silent)
			if self.hasInit then return end

			self.hasInit = true
			self.base = library:Create('ScreenGui', {IgnoreGuiInset = true, AutoLocalize = false, Enabled = not silent})
			self.dummyBox = library:Create('TextBox', {Visible = false, Parent = self.base});
			self.dummyModal = library:Create('TextButton', {Visible = false, Modal = true, Parent = self.base});

			self.unloadMaid:GiveTask(self.base);

			if (game.PlaceId == 185655149) then
				self.base.Parent = LocalPlayer.PlayerGui
				self.base.ResetOnSpawn = false
			elseif (game.PlaceId == 920587237) then
				self.base.Parent = LocalPlayer.PlayerGui
				self.base.ResetOnSpawn = false
			else
				self.base.Parent = CoreGui
			end

			self.main = self:Create('ImageButton', {
				AutoButtonColor = false,
				Position = UDim2.new(0, 100, 0, 46),
				Size = UDim2.new(0, 500, 0, 600),
				BackgroundColor3 = Color3.fromRGB(20, 20, 20),
				BorderColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Tile,
				Visible = true,
				Parent = self.base
			})

			local top = self:Create('Frame', {
				Size = UDim2.new(1, 0, 0, 50),
				BackgroundColor3 = Color3.fromRGB(30, 30, 30),
				BorderColor3 = Color3.new(),
				Parent = self.main
			})

			self.titleLabel = self:Create('TextLabel', {
				Position = UDim2.new(0, 6, 0, -1),
				Size = UDim2.new(0, 0, 0, 20),
				BackgroundTransparency = 1,
				Text = tostring(self.title),
				Font = Enum.Font.Code,
				TextSize = 18,
				TextColor3 = Color3.new(1, 1, 1),
				TextXAlignment = Enum.TextXAlignment.Left,
				Parent = self.main
			})

			table.insert(library.theme, self:Create('Frame', {
				Size = UDim2.new(1, 0, 0, 1),
				Position = UDim2.new(0, 0, 0, 24),
				BackgroundColor3 = library.flags.menuAccentColor,
				BorderSizePixel = 0,
				Parent = self.main
			}))

			library:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2454009026',
				ImageColor3 = Color3.new(),
				ImageTransparency = 0.4,
				Parent = top
			})

			self.tabHighlight = self:Create('Frame', {
				BackgroundColor3 = library.flags.menuAccentColor,
				BorderSizePixel = 0,
				Parent = self.main
			})
			table.insert(library.theme, self.tabHighlight)

			self.columnHolder = self:Create('Frame', {
				Position = UDim2.new(0, 5, 0, 55),
				Size = UDim2.new(1, -10, 1, -60),
				BackgroundTransparency = 1,
				Parent = self.main
			})

			self.tooltip = self:Create('TextLabel', {
				ZIndex = 2,
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				TextSize = 15,
				Size = UDim2.fromOffset(0, 0),
				Position = UDim2.fromScale(10, 10),
				Font = Enum.Font.Code,
				TextColor3 = Color3.new(1, 1, 1),
				Visible = true,
				Active = false,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				Parent = self.base,
				AutomaticSize = Enum.AutomaticSize.XY
			})

			self:Create('UISizeConstraint', {
				Parent = self.tooltip,
				MaxSize = Vector2.new(400, 1000),
				MinSize = Vector2.new(0, 0),
			});

			self:Create('Frame', {
				AnchorPoint = Vector2.new(0.5, 0),
				Position = UDim2.new(0.5, 0, 0, 0),
				Size = UDim2.new(1, 10, 1, 0),
				Active = false,
				Style = Enum.FrameStyle.RobloxRound,
				Parent = self.tooltip
			})

			self:Create('ImageLabel', {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.fromRGB(60, 60, 60),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = self.main
			})

			self:Create('ImageLabel', {
				Size = UDim2.new(1, -2, 1, -2),
				Position = UDim2.new(0, 1, 0, 1),
				BackgroundTransparency = 1,
				Image = 'rbxassetid://2592362371',
				ImageColor3 = Color3.new(),
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(2, 2, 62, 62),
				Parent = self.main
			})

			library.unloadMaid:GiveTask(top.InputBegan:connect(function(input)
				if input.UserInputType.Name == 'MouseButton1' then
					dragObject = self.main
					dragging = true
					dragStart = input.Position
					startPos = dragObject.Position
					if library.popup then library.popup:Close() end
				end
			end));

			library.unloadMaid:GiveTask(top.InputChanged:connect(function(input)
				if dragging and input.UserInputType.Name == 'MouseMovement' then
					dragInput = input
				end
			end));

			library.unloadMaid:GiveTask(top.InputEnded:connect(function(input)
				if input.UserInputType.Name == 'MouseButton1' then
					dragging = false
				end
			end));

			local titleTextSize = TextService:GetTextSize(self.titleLabel.Text, 18, Enum.Font.Code, Vector2.new(1000, 0));

			local searchLabel = library:Create('ImageLabel', {
				Position = UDim2.new(0, titleTextSize.X + 10, 0.5, -8),
				Size = UDim2.new(0, 16, 0, 16),
				BackgroundTransparency = 1,
				Image = 'rbxasset://textures/ui/Settings/ShareGame/icons.png',
				ImageRectSize = Vector2.new(16, 16),
				ImageRectOffset = Vector2.new(6, 106),
				ClipsDescendants = true,
				Parent = self.titleLabel
			});

			local searchBox = library:Create('TextBox', {
				BackgroundTransparency = 1,
				Position = UDim2.fromOffset(searchLabel.AbsolutePosition.X-80, 5),
				Size = UDim2.fromOffset(50, 15),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextXAlignment = Enum.TextXAlignment.Left,
				Parent = self.titleLabel,
				Text = '',
				PlaceholderText = 'Type something to search...',
				Visible = false
			});

			local searchContainer = library:Create('ScrollingFrame', {
				BackgroundTransparency = 1,
				Visible = false,
				Size = UDim2.fromScale(1, 1),
				AutomaticCanvasSize = Enum.AutomaticSize.Y,
				Parent = library.columnHolder,
				BorderSizePixel = 0,
				ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100),
				ScrollBarThickness = 6,
				CanvasSize = UDim2.new(),
				ScrollingDirection = Enum.ScrollingDirection.Y,
				VerticalScrollBarInset = Enum.ScrollBarInset.Always,
				TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
				BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
			});

			library:Create('UIListLayout', {
				Parent = searchContainer
			})

			local allFoundResults = {};
			local modifiedNames = {};

			local function clearFoundResult()
				for _, option in next, allFoundResults do
					option.main.Parent = option.originalParent;
				end;

				for _, option in next, modifiedNames do
					option.title.Text = option.text;
					option.main.Parent = option.originalParent;
				end;

				table.clear(allFoundResults);
				table.clear(modifiedNames);
			end;

			local sFind, sLower = string.find, string.lower;

			library.unloadMaid:GiveTask(searchBox:GetPropertyChangedSignal('Text'):Connect(function()
				local text = string.lower(searchBox.Text):gsub('%s', '');

				for _, v in next, library.options do
					if (not v.originalParent) then
						v.originalParent = v.main.Parent;
					end;
				end;

				clearFoundResult();

				for _, v in next, library.currentTab.columns do
					v.main.Visible = text == '' and true or false;
				end;

				if (text == '') then return; end;
				local matchedResults = false;

				for _, v in next, library.options do
					local main = v.main;

					if (v.text == 'Enable' or v.parentFlag) then
						if (v.type == 'toggle' or v.type == 'bind') then
							local parentName = v.parentFlag and 'Bind' or v.section.title;
							v.title.Text = string.format('%s [%s]', v.text, parentName);

							table.insert(modifiedNames, v);
						end;
					end;

					if (sFind(sLower(v.text), text) or sFind(sLower(v.flag), text)) then
						matchedResults = true;
						main.Parent = searchContainer;
						table.insert(allFoundResults, v);
					else
						main.Parent = v.originalParent;
					end;
				end;

				searchContainer.Visible = matchedResults;
			end));

			library.unloadMaid:GiveTask(searchLabel.InputBegan:Connect(function(inputObject)
				if(inputObject.UserInputType ~= Enum.UserInputType.MouseButton1) then return end;
				searchBox.Visible = true;
				searchBox:CaptureFocus();
			end));

			library.unloadMaid:GiveTask(searchBox.FocusLost:Connect(function()
				if (searchBox.Text:gsub('%s', '') ~= '') then return end;
				searchBox.Visible = false;
			end));


			local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out);

			function self:selectTab(tab)
				if self.currentTab == tab then return end
				if library.popup then library.popup:Close() end
				clearFoundResult();
				searchBox.Visible = false;
				searchBox.Text = '';

				if self.currentTab then
					self.currentTab.button.TextColor3 = Color3.fromRGB(255, 255, 255)
					for _, column in next, self.currentTab.columns do
						column.main.Parent = nil;
						column.main.Visible = true;
					end
				end
				self.main.Size = UDim2.new(0, 16 + ((#tab.columns < 2 and 2 or #tab.columns) * 239), 0, 600)
				self.currentTab = tab
				tab.button.TextColor3 = library.flags.menuAccentColor;

				TweenService:Create(self.tabHighlight, tweenInfo, {
					Position = UDim2.new(0, tab.button.Position.X.Offset, 0, 50),
					Size = UDim2.new(0, tab.button.AbsoluteSize.X, 0, -1)
				}):Play();

				for _, column in next, tab.columns do
					column.main.Parent = self.columnHolder
				end
			end

			task.spawn(function()
				while library do
					local Configs = self:GetConfigs()
					for _, config in next, Configs do
						if config ~= 'nil' and not table.find(self.options.configList.values, config) then
							self.options.configList:AddValue(config)
						end
					end
					for _, config in next, self.options.configList.values do
						if config ~= 'nil' and not table.find(Configs, config) then
							self.options.configList:RemoveValue(config)
						end
					end
					task.wait(1);
				end
			end)

			for _, tab in next, self.tabs do
				if tab.canInit then
					tab:Init();
				end;
			end;

			self:AddConnection(UserInputService.InputEnded, function(input)
				if (input.UserInputType.Name == 'MouseButton1') and self.slider then
					self.slider.slider.BorderColor3 = Color3.new();
					self.slider = nil;
				end;
			end);

			self:AddConnection(UserInputService.InputChanged, function(input)
				if self.open then
					if input == dragInput and dragging and library.draggable then
						local delta = input.Position - dragStart;
						local yPos = (startPos.Y.Offset + delta.Y) < -36 and -36 or startPos.Y.Offset + delta.Y;

						dragObject:TweenPosition(UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, yPos), 'Out', 'Quint', 0.1, true);
					end;

					if self.slider and input.UserInputType.Name == 'MouseMovement' then
						self.slider:SetValue(self.slider.min + ((input.Position.X - self.slider.slider.AbsolutePosition.X) / self.slider.slider.AbsoluteSize.X) * (self.slider.max - self.slider.min));
					end;
				end;
			end);

			local configData = readFileAndDecodeIt(library.foldername .. '/' .. library.fileext);

			if (configData) then
				library.configVars = configData;
				library:LoadConfig(configData.config);

				library.OnLoad:Connect(function()
					library.options.configList:SetValue(library.loadedConfig or 'default');
				end);
			else
				print('[Script] [Config Loader] An error has occured', configData);
			end;

			self:selectTab(self.tabs[1]);

			if (not silent) then
				self:Close();
			else
				self.open = false;
			end;

			library.OnLoad:Fire();
			library.OnLoad:Destroy();
			library.OnLoad = nil;
		end;

		function library:SetTitle(text)
			if (not self.titleLabel) then
				return;
			end;

			self.titleLabel.Text = text;
		end;

		do -- // Load Basics
			local configWarning = library:AddWarning({type = 'confirm'})
			local messageWarning = library:AddWarning();

			function library:ShowConfirm(text)
				configWarning.text = text;
				return configWarning:Show();
			end;

			function library:ShowMessage(text)
				messageWarning.text = text;
				return messageWarning:Show();
			end

			local function showBasePrompt(text)
				local r, g, b = library.round(library.flags.menuAccentColor);

				local configName = text == 'create' and library.flags.configName or library.flags.configList;
				local trimedValue = configName:gsub('%s', '');

				if(trimedValue == '') then
					library:ShowMessage(string.format('Can not %s a config with no name !', text));
					return false;
				end;

				return library:ShowConfirm(string.format(
					'Are you sure you want to %s config <font color=\'rgb(%s, %s, %s)\'>%s</font>',
					text,
					r,
					g,
					b,
					configName
					));
			end;

			local joinDiscord;

			do -- // Utils
				function joinDiscord(code)
					for i = 6463, 6472 do -- // Just cause there is a 10 range port
						if(pcall(function()
								request({
									Url = ('http://127.0.0.1:%s/rpc?v=1'):format(i),
									Method = 'POST',
									Headers = {
										['Content-Type'] = 'application/json',
										Origin = 'https://discord.com' -- // memery moment
									},
									Body = ('{"cmd":"INVITE_BROWSER","args":{"code":"%s"},"nonce":"%s"}'):format(code, string.lower(HttpService:GenerateGUID(false)))
								});
							end)) then
							print('found port', i);
							break;
						end;
					end;
				end;
			end;

			local maid = Maid.new();
			library.unloadMaid:GiveTask(function()
				maid:Destroy();
			end);

			local settingsTab       = library:AddTab('Settings', 100);
			local settingsColumn    = settingsTab:AddColumn();
			local settingsColumn1   = settingsTab:AddColumn();
			local settingsMain      = settingsColumn:AddSection('Main');
			local settingsMenu      = settingsColumn:AddSection('Menu');
			local configSection     = settingsColumn1:AddSection('Configs');
			local discordSection    = settingsColumn:AddSection('Discord');
			local BackgroundArray   = {};

			local Backgrounds = {
				Floral  = 5553946656,
				Flowers = 6071575925,
				Circles = 6071579801,
				Hearts  = 6073763717,
			};

			task.spawn(function()
				for i, v in next, Backgrounds do
					table.insert(BackgroundArray, 'rbxassetid://' .. v);
				end;

				ContentProvider:PreloadAsync(BackgroundArray);
			end);

			local lastShownNotifAt = 0;

			local function setCustomBackground()
				local imageURL = library.flags.customBackground;
				imageURL = imageURL:gsub('%s', '');

				if (imageURL == '') then return end;

				if (not isfolder('Roniro Hub V3/CustomBackgrounds')) then
					makefolder('Roniro Hub V3/CustomBackgrounds');
				end;

				local path = string.format('Roniro Hub V3/CustomBackgrounds/%s.bin', crypt.hash(imageURL));

				if (not isfile(path)) then
					local suc, httpRequest = pcall(request, {
						Url = imageURL,
					});

					if (not suc) then return library:ShowMessage('The url you have specified for the custom background is invalid.'); end;

					if (not httpRequest.Success) then return library:ShowMessage(string.format('Request failed %d', httpRequest.StatusCode)); end;
					local imgType = httpRequest.Headers['Content-Type']:lower();
					if (imgType ~= 'image/png' and imgType ~= 'image/jpeg') then return library:ShowMessage('Only PNG and JPEG are supported'); end;

					writefile(path, httpRequest.Body);
				end;

				library.main.Image = getcustomasset(path);

				local acColor = library.flags.menuBackgroundColor;
				local r, g, b = acColor.R * 255, acColor.G * 255, acColor.B * 255;

				if (r <= 100 and g <= 100 and b <= 100 and tick() - lastShownNotifAt > 1) then
					lastShownNotifAt = tick();
					ToastNotif.new({text = 'Your menu accent color is dark custom background may not show.', duration = 20});
				end;
			end;

			settingsMain:AddBox({
				text = 'Custom Background',
				tip = 'Put a valid image link here',
				callback = setCustomBackground
			});

			library.OnLoad:Connect(function()
				local customBackground = library.flags.customBackground;
				if (customBackground:gsub('%s', '') == '') then return end;

				task.defer(setCustomBackground);
			end);

			do
				local scaleTypes = {};

				for _, scaleType in next, Enum.ScaleType:GetEnumItems() do
					table.insert(scaleTypes, scaleType.Name);
				end;

				settingsMain:AddList({
					text = 'Background Scale Type',
					values = scaleTypes,
					callback = function()
						library.main.ScaleType = Enum.ScaleType[library.flags.backgroundScaleType];
					end
				});
			end;

			settingsMain:AddButton({
				text = 'Unload Menu',
				nomouse = true,
				callback = function()
					library:Unload()
				end
			});

			settingsMain:AddBind({
				text = 'Unload Key',
				nomouse = true,
				callback = library.options.unloadMenu.callback
			});

			-- settingsMain:AddToggle({
			--     text = 'Remote Control'
			-- });

			settingsMenu:AddBind({
				text = 'Open / Close',
				flag = 'UI Toggle',
				nomouse = true,
				key = 'LeftAlt',
				callback = function() library:Close() end
			})

			settingsMenu:AddColor({
				text = 'Accent Color',
				flag = 'Menu Accent Color',
				color = Color3.fromRGB(18, 127, 253),
				callback = function(Color)
					if library.currentTab then
						library.currentTab.button.TextColor3 = Color
					end

					for _, obj in next, library.theme do
						obj[(obj.ClassName == 'TextLabel' and 'TextColor3') or (obj.ClassName == 'ImageLabel' and 'ImageColor3') or 'BackgroundColor3'] = Color
					end
				end
			})

			settingsMenu:AddToggle({
				text = 'Keybind Visualizer',
				state = true,
				callback = function(state)
					return visualizer:SetEnabled(state);
				end
			}):AddColor({
				text = 'Keybind Visualizer Color',
				callback = function(color)
					return visualizer:UpdateColor(color);
				end
			});

			settingsMenu:AddToggle({
				text = 'Rainbow Keybind Visualizer',
				callback = function(t)
					if (not t) then
						return maid.rainbowKeybindVisualizer;
					end;

					maid.rainbowKeybindVisualizer = task.spawn(function()
						while task.wait() do
							visualizer:UpdateColor(library.chromaColor);
						end;
					end);
				end
			})

			settingsMenu:AddList({
				text = 'Background',
				flag = 'UI Background',
				values = {'Floral', 'Flowers', 'Circles', 'Hearts'},
				callback = function(Value)
					if Backgrounds[Value] then
						library.main.Image = 'rbxassetid://' .. Backgrounds[Value]
					end
				end
			}):AddColor({
				flag = 'Menu Background Color',
				color = Color3.new(),
				trans = 1,
				callback = function(Color)
					library.main.ImageColor3 = Color
				end,
				calltrans = function(Value)
					library.main.ImageTransparency = 1 - Value
				end
			});

			settingsMenu:AddSlider({
				text = 'Tile Size',
				value = 90,
				min = 50,
				max = 500,
				callback = function(Value)
					library.main.TileSize = UDim2.new(0, Value, 0, Value)
				end
			})

			configSection:AddBox({
				text = 'Config Name',
				skipflag = true,
			})

			local function getAllConfigs()
				local files = {};

				for _, v in next, listfiles('Roniro Hub V3/configs') do
					if (not isfolder(v)) then continue; end;

					for _, v2 in next, listfiles(v) do
						local configName = v2:match('(%w+).config.json');
						if (not configName) then continue; end;

						local folderName = v:match('configs\\(%w+)');
						local fullConfigName = string.format('%s - %s', folderName, configName);

						table.insert(files, fullConfigName);
					end;
				end;

				return files;
			end;

			local function updateAllConfigs()
				for _, v in next, library.options.loadFromList.values do
					library.options.loadFromList:RemoveValue(v);
				end;

				for _, configName in next, getAllConfigs() do
					library.options.loadFromList:AddValue(configName);
				end;
			end

			configSection:AddList({
				text = 'Configs',
				skipflag = true,
				value = '',
				flag = 'Config List',
				values = library:GetConfigs(),
			})

			configSection:AddButton({
				text = 'Create',
				callback = function()
					if (showBasePrompt('create')) then
						library.options.configList:AddValue(library.flags.configName);
						library.options.configList:SetValue(library.flags.configName);
						library:SaveConfig(library.flags.configName);
						library:LoadConfig(library.flags.configName);

						updateAllConfigs();
					end;
				end
			})

			local btn;
			btn = configSection:AddButton({
				text = isGlobalConfigOn and 'Switch To Local Config' or 'Switch to Global Config';

				callback = function()
					isGlobalConfigOn = not isGlobalConfigOn;
					writefile(globalConfFilePath, tostring(isGlobalConfigOn));

					btn:SetText(isGlobalConfigOn and 'Switch To Local Config' or 'Switch to Global Config');
					library:ShowMessage('Note: Switching from Local to Global requires script relaunch.');
				end
			});

			configSection:AddButton({
				text = 'Save',
				callback = function()
					if (showBasePrompt('save')) then
						library:SaveConfig(library.flags.configList);
					end;
				end
			}):AddButton({
				text = 'Load',
				callback = function()
					if (showBasePrompt('load')) then
						library:UpdateConfig(); -- Save config before switching to new one
						library:LoadConfig(library.flags.configList);
					end
				end
			}):AddButton({
				text = 'Delete',
				callback = function()
					if (showBasePrompt('delete')) then
						local Config = library.flags.configList
						local configFilePath = library.foldername .. '/' .. Config .. '.config' .. library.fileext;

						if table.find(library:GetConfigs(), Config) and isfile(configFilePath) then
							library.options.configList:RemoveValue(Config)
							delfile(configFilePath);
						end
					end;
				end
			})

			configSection:AddList({
				text = 'Load From',
				flag = 'Load From List',
				values = getAllConfigs()
			});

			configSection:AddButton({
				text = 'Load From',
				callback = function()
					if (not showBasePrompt('load from')) then return; end;
					if (isGlobalConfigOn) then return library:ShowMessage('You can not load a config from another user if you are in global config mode.'); end;

					local folderName, configName = library.flags.loadFromList:match('(%w+) %p (.+)');
					local fullConfigName = string.format('%s.config.json', configName);

					if (isfile(library.foldername .. '/' .. fullConfigName)) then
						-- If there is already an existing config with this name then

						if (not library:ShowConfirm('There is already a config with this name in your config folder. Would you like to delete it? Pressing no will cancel the operation')) then
							return;
						end;
					end;

					local configData = readfile(string.format('Roniro Hub V3/configs/%s/%s', folderName, fullConfigName));
					writefile(string.format('%s/%s', library.foldername, fullConfigName), configData);

					library:LoadConfig(configName);
				end
			})

			configSection:AddToggle({
				text = 'Automatically Save Config',
				state = true,
				flag = 'saveConfigAuto',
				callback = function(toggle)
					-- This is required incase the game crash but we can move the interval to 60 seconds

					if(not toggle) then
						maid.saveConfigAuto = nil;
						library:UpdateConfig(); -- Make sure that we update config to save that user turned off automatically save config
						return;
					end;

					maid.saveConfigAuto = task.spawn(function()
						while true do
							task.wait(60);
							library:UpdateConfig();
						end;
					end);
				end,
			})

			local function saveConfigBeforeGameLeave()
				if (not library.flags.saveconfigauto) then return; end;
				library:UpdateConfig();
			end;

			library.unloadMaid:GiveTask(GuiService.NativeClose:Connect(saveConfigBeforeGameLeave));

			-- NativeClose does not fire on the Lua App
			library.unloadMaid:GiveTask(GuiService.MenuOpened:Connect(saveConfigBeforeGameLeave));

			library.unloadMaid:GiveTask(LocalPlayer.OnTeleport:Connect(function(state)
				if (state ~= Enum.TeleportState.Started and state ~= Enum.TeleportState.RequestedFromServer) then return end;
				saveConfigBeforeGameLeave();
			end));

			discordSection:AddButton({
				text = 'Join Discord',
				callback = function() return joinDiscord('HWj5e7gpNN') end
			});

			discordSection:AddButton({
				text = 'Copy Discord Invite',
				callback = function() return setclipboard('discord.gg/HWj5e7gpNN') end
			});
		end;
	end;

	warn(string.format('[Script] [Library] Loaded in %.02f seconds', tick() - libraryLoadAt));

	library.OnFlagChanged:Connect(function(data)
		local keybindExists = library.options[string.lower(data.flag) .. 'Bind'];
		if (not keybindExists or not keybindExists.key or keybindExists.key == 'none') then return end;

		local toggled = library.flags[data.flag];

		if (toggled) then
			visualizer:AddText(data.text);
		else
			visualizer:RemoveText(data.text);
		end
	end);

	return library;
end)();

sharedRequires['Utility'] = (function()


	local Services = sharedRequires['Services'];
	local library = sharedRequires['Library'];
	local Signal = sharedRequires['Signal'];

	local Players, UserInputService, HttpService, CollectionService = Services:Get('Players', 'UserInputService', 'HttpService', 'CollectionService');
	local LocalPlayer = Players.LocalPlayer;

	local Utility = {};

	Utility.onPlayerAdded = Signal.new();
	Utility.onCharacterAdded = Signal.new();
	Utility.onLocalCharacterAdded = Signal.new();

	local mathFloor = clonefunction(math.floor)
	local isDescendantOf = clonefunction(game.IsDescendantOf);
	local findChildIsA = clonefunction(game.FindFirstChildWhichIsA);
	local findFirstChild = clonefunction(game.FindFirstChild);

	local IsA = clonefunction(game.IsA);

	local getMouseLocation = clonefunction(UserInputService.GetMouseLocation);
	local getPlayers = clonefunction(Players.GetPlayers);

	local worldToViewportPoint = clonefunction(Instance.new("Camera").WorldToViewportPoint);

	function Utility:countTable(t)
		local found = 0;

		for i, v in next, t do
			found = found + 1;
		end;

		return found;
	end;

	function Utility:roundVector(vector)
		return Vector3.new(vector.X, 0, vector.Z);
	end;

	function Utility:getCharacter(player)
		local playerData = self:getPlayerData(player);
		if (not playerData.alive) then return end;

		local maxHealth, health = playerData.maxHealth, playerData.health;
		return playerData.character, maxHealth, (health / maxHealth) * 100, mathFloor(health), playerData.rootPart;
	end;

	function Utility:isTeamMate(player)
		local playerData, myPlayerData = self:getPlayerData(player), self:getPlayerData();
		local playerTeam, myTeam = playerData.team, myPlayerData.team;

		if(playerTeam == nil or myTeam == nil) then
			return false;
		end;

		return playerTeam == myTeam;
	end;

	function Utility:getRootPart(player)
		local playerData = self:getPlayerData(player);
		return playerData and playerData.rootPart;
	end;

	function Utility:renderOverload(data) end;

	local function castPlayer(origin, direction, rayParams, playerToFind)
		local distanceTravalled = 0;

		while true do
			distanceTravalled = distanceTravalled + direction.Magnitude;

			local target = workspace:Raycast(origin, direction, rayParams);

			if(target) then
				if(isDescendantOf(target.Instance, playerToFind)) then
					return false;
				elseif(target and target.Instance.CanCollide) then
					return true;
				end;
			elseif(distanceTravalled > 2000) then
				return false;
			end;

			origin = origin + direction;
		end;
	end;

	function Utility:getClosestCharacter(rayParams)
		rayParams = rayParams or RaycastParams.new();
		rayParams.FilterDescendantsInstances = {}

		local myCharacter = Utility:getCharacter(LocalPlayer);
		local myHead = myCharacter and findFirstChild(myCharacter, 'Head');
		if(not myHead) then return end;

		if(rayParams.FilterType == Enum.RaycastFilterType.Blacklist) then
			table.insert(rayParams.FilterDescendantsInstances, myHead.Parent);
		end;

		local camera = workspace.CurrentCamera;
		if(not camera) then return end;

		local mousePos = library.flags.useFOV and getMouseLocation(UserInputService);
		local lastDistance, lastPlayer = math.huge, {};

		local maxFov = library.flags.useFOV and library.flags.aimbotFOV or math.huge;
		local whitelistedPlayers = library.options.aimbotWhitelistedPlayers.values;

		for _, player in next, getPlayers(Players) do
			if(player == LocalPlayer or table.find(whitelistedPlayers, player.Name)) then continue end;

			local character, health = Utility:getCharacter(player);

			if(not character or health <= 0 or findChildIsA(character, 'ForceField')) then continue; end;
			if(library.flags.checkTeam and Utility:isTeamMate(player)) then continue end;

			local head = character and findFirstChild(character, 'Head');
			if(not head) then continue end;

			local newDistance = (myHead.Position - head.Position).Magnitude;
			if(newDistance > lastDistance) then continue end;

			if (mousePos) then
				local screenPosition, visibleOnScreen = worldToViewportPoint(camera, head.Position);
				screenPosition = Vector2.new(screenPosition.X, screenPosition.Y);

				if((screenPosition - mousePos).Magnitude > maxFov or not visibleOnScreen) then continue end;
			end;

			local isBehindWall = library.flags.visibilityCheck and castPlayer(myHead.Position, (head.Position - myHead.Position).Unit * 100, rayParams, head.Parent);
			if (isBehindWall) then continue end;

			lastPlayer = {Player = player, Character = character, Health = health};
			lastDistance = newDistance;
		end;

		return lastPlayer, lastDistance;
	end;

	function Utility:getClosestCharacterWithEntityList(entityList, rayParams, options)
		rayParams = rayParams or RaycastParams.new();
		rayParams.FilterDescendantsInstances = {}

		options = options or {};
		options.maxDistance = options.maxDistance or math.huge;

		local myCharacter = Utility:getCharacter(LocalPlayer);
		local myHead = myCharacter and findFirstChild(myCharacter, 'Head');
		if(not myHead) then return end;

		if(rayParams.FilterType == Enum.RaycastFilterType.Blacklist) then
			table.insert(rayParams.FilterDescendantsInstances, myHead.Parent);
		end;

		local camera = workspace.CurrentCamera;
		if(not camera) then return end;

		local mousePos = library.flags.useFOV and getMouseLocation(UserInputService);
		local lastDistance, lastPlayer = math.huge, {};
		local whitelistedPlayers = library.options.aimbotWhitelistedPlayers.values;

		local maxFov = library.flags.useFOV and library.flags.aimbotFOV or math.huge;

		for _, player in next, entityList do
			if(player == myCharacter or table.find(whitelistedPlayers, player.Name)) then continue end;

			local humanoid = findChildIsA(player, 'Humanoid');
			if (not humanoid or humanoid.Health <= 0) then continue end;

			local character = player;

			if(not character or findChildIsA(character, 'ForceField')) then continue; end;

			local head = character and findFirstChild(character, 'Head');
			if(not head) then continue end;

			local newDistance = (myHead.Position - head.Position).Magnitude;
			if(newDistance > lastDistance or newDistance > options.maxDistance) then continue end;

			if (mousePos) then
				local screenPosition, visibleOnScreen = worldToViewportPoint(camera, head.Position);
				screenPosition = Vector2.new(screenPosition.X, screenPosition.Y);

				if((screenPosition - mousePos).Magnitude > maxFov or not visibleOnScreen) then continue end;
			end;

			local isBehindWall = library.flags.visibilityCheck and castPlayer(myHead.Position, (head.Position - myHead.Position).Unit * 100, rayParams, head.Parent);
			if (isBehindWall) then continue end;

			lastPlayer = {Player = player, Character = character, Health = humanoid.Health};
			lastDistance = newDistance;
		end;

		return lastPlayer, lastDistance;
	end;

	function panic()
		library:Unload();
	end;

	local playersData = {};

	local function onCharacterAdded(player)
		local playerData = playersData[player];
		if (not playerData) then return end;

		local character = player.Character;
		if (not character) then return end;

		local localAlive = true;

		table.clear(playerData.parts);

		Utility.listenToChildAdded(character, function(obj)
			if (obj.Name == 'Humanoid') then
				playerData.humanoid = obj;
			elseif (obj.Name == 'HumanoidRootPart') then
				playerData.rootPart = obj;
			elseif (obj.Name == 'Head') then
				playerData.head = obj;
			end;
		end);

		if (player == LocalPlayer) then
			Utility.listenToDescendantAdded(character, function(obj)
				if (IsA(obj, 'BasePart')) then
					table.insert(playerData.parts, obj);

					local con;
					con = obj:GetPropertyChangedSignal('Parent'):Connect(function()
						if (obj.Parent) then return end;
						con:Disconnect();
						table.remove(playerData.parts, table.find(playerData.parts, obj));
					end);
				end;
			end);
		end;

		local function onPrimaryPartChanged()
			playerData.primaryPart = character.PrimaryPart;
			playerData.alive = not not playerData.primaryPart;
		end

		local hum = character:WaitForChild('Humanoid', 30);
		playerData.humanoid = hum;
		if (not playerData.humanoid) then return warn('[Utility] [onCharacterAdded] Player is missing humanoid ' .. player:GetFullName()) end;
		if (not player.Parent or not character.Parent) then return end;

		character:GetPropertyChangedSignal('PrimaryPart'):Connect(onPrimaryPartChanged);

		if (character.PrimaryPart) then
			onPrimaryPartChanged();
		end;

		playerData.character = character;
		playerData.alive = true;
		playerData.health = playerData.humanoid.Health;
		playerData.maxHealth = playerData.humanoid.MaxHealth;

		hum.Destroying:Connect(function()
			playerData.alive = false;
			localAlive = false;
		end);

		hum.Died:Connect(function()
			playerData.alive = false;
			localAlive = false;
		end);

		playerData.humanoid:GetPropertyChangedSignal('Health'):Connect(function()
			playerData.health = hum.Health;
		end);

		playerData.humanoid:GetPropertyChangedSignal('MaxHealth'):Connect(function()
			playerData.maxHealth = hum.MaxHealth;
		end);

		local function fire()
			if (not localAlive) then return end;
			Utility.onCharacterAdded:Fire(playerData);

			if (player == LocalPlayer) then
				Utility.onLocalCharacterAdded:Fire(playerData);
			end;
		end;

		if (library.OnLoad) then
			library.OnLoad:Connect(fire);
		else
			fire();
		end;
	end;

	local function onPlayerAdded(player)
		local playerData = {};

		playerData.player = player;
		playerData.team = player.Team;
		playerData.parts = {};

		playersData[player] = playerData;

		local function fire()
			Utility.onPlayerAdded:Fire(player);
		end;

		task.spawn(onCharacterAdded, player);

		player.CharacterAdded:Connect(function()
			onCharacterAdded(player);
		end);

		player:GetPropertyChangedSignal('Team'):Connect(function()
			playerData.team = player.Team;
		end);

		if (library.OnLoad) then
			library.OnLoad:Connect(fire);
		else
			fire();
		end;
	end;

	function Utility:getPlayerData(player)
		return playersData[player or LocalPlayer] or {};
	end;

	function Utility.listenToChildAdded(folder, listener, options)
		options = options or {listenToDestroying = false};

		local createListener = typeof(listener) == 'table' and listener.new or listener;

		assert(typeof(folder) == 'Instance', 'listenToChildAdded folder #1 listener has to be an instance');
		assert(typeof(createListener) == 'function', 'listenToChildAdded #2 listener has to be a function');

		local function onChildAdded(child)
			local listenerObject = createListener(child);

			if (options.listenToDestroying) then
				child.Destroying:Connect(function()
					local removeListener = typeof(listener) == 'table' and (function() local a = (listener.Destroy or listener.Remove); a(listenerObject) end) or listenerObject;

					if (typeof(removeListener) ~= 'function') then
						warn('[Utility] removeListener is not definded possible memory leak for', folder);
					else
						removeListener(child);
					end;
				end);
			end;
		end

		--debug.profilebegin(string.format('Utility.listenToChildAdded(%s)', folder:GetFullName()));

		for _, child in next, folder:GetChildren() do
			task.spawn(onChildAdded, child);
		end;

		--debug.profileend();

		return folder.ChildAdded:Connect(createListener);
	end;

	function Utility.listenToChildRemoving(folder, listener)
		local createListener = typeof(listener) == 'table' and listener.new or listener;

		assert(typeof(folder) == 'Instance', 'listenToChildRemoving folder #1 listener has to be an instance');
		assert(typeof(createListener) == 'function', 'listenToChildRemoving #2 listener has to be a function');

		return folder.ChildRemoved:Connect(createListener);
	end;

	function Utility.listenToDescendantAdded(folder, listener, options)
		options = options or {listenToDestroying = false};

		local createListener = typeof(listener) == 'table' and listener.new or listener;

		assert(typeof(folder) == 'Instance', 'listenToDescendantAdded folder #1 listener has to be an instance');
		assert(typeof(createListener) == 'function', 'listenToDescendantAdded #2 listener has to be a function');

		local function onDescendantAdded(child)
			local listenerObject = createListener(child);

			if (options.listenToDestroying) then
				child.Destroying:Connect(function()
					local removeListener = typeof(listener) == 'table' and (listener.Destroy or listener.Remove) or listenerObject;

					if (typeof(removeListener) ~= 'function') then
						warn('[Utility] removeListener is not definded possible memory leak for', folder);
					else
						removeListener(child);
					end;
				end);
			end;
		end

		--debug.profilebegin(string.format('Utility.listenToDescendantAdded(%s)', folder:GetFullName()));

		for _, child in next, folder:GetDescendants() do
			task.spawn(onDescendantAdded, child);
		end;

		--debug.profileend();

		return folder.DescendantAdded:Connect(onDescendantAdded);
	end;

	function Utility.listenToDescendantRemoving(folder, listener)
		local createListener = typeof(listener) == 'table' and listener.new or listener;

		assert(typeof(folder) == 'Instance', 'listenToDescendantRemoving folder #1 listener has to be an instance');
		assert(typeof(createListener) == 'function', 'listenToDescendantRemoving #2 listener has to be a function');

		return folder.DescendantRemoving:Connect(createListener);
	end;

	function Utility.listenToTagAdded(tagName, listener)
		for _, v in next, CollectionService:GetTagged(tagName) do
			task.spawn(listener, v);
		end;

		return CollectionService:GetInstanceAddedSignal(tagName):Connect(listener);
	end;

	function Utility.getFunctionHash(f)
		if (typeof(f) ~= 'function') then return error('getFunctionHash(f) #1 has to be a function') end;

		local constants = getconstants(f);
		local protos = getprotos(f);

		local total = HttpService:JSONEncode({constants, protos});

		return crypt.hash(total);
	end;

	local function onPlayerRemoving(player)
		playersData[player] = nil;
	end;

	for _, player in next, Players:GetPlayers() do
		task.spawn(onPlayerAdded, player);
	end;

	Players.PlayerAdded:Connect(onPlayerAdded);
	Players.PlayerRemoving:Connect(onPlayerRemoving);

	function Utility.find(t, c)
		for i, v in next, t do
			if (c(v, i)) then
				return v, i;
			end;
		end;

		return nil;
	end;

	function Utility.map(t, c)
		local ret = {};

		for i, v in next, t do
			local val = c(v, i);
			if (val) then
				table.insert(ret, val);
			end;
		end;

		return ret;
	end;

	return Utility;
end)();

sharedRequires['EntityESP'] = (function()
	local library = sharedRequires['Library'];
	local Utility = sharedRequires['Utility'];
	local Services = sharedRequires['Services'];

	local RunService, UserInputService, HttpService = Services:Get('RunService', 'UserInputService', 'HttpService');

	local EntityESP = {};

	local worldToViewportPoint = clonefunction(Instance.new('Camera').WorldToViewportPoint);
	local vectorToWorldSpace = CFrame.new().VectorToWorldSpace;
	local getMouseLocation = clonefunction(UserInputService.GetMouseLocation);

	local id = HttpService:GenerateGUID(false);
	local userId = "1234"

	local lerp = Color3.new().lerp;
	local flags = library.flags;

	local vector3New = Vector3.new;
	local Vector2New = Vector2.new;

	local mathFloor = math.floor;

	local mathRad = math.rad;
	local mathCos = math.cos;
	local mathSin = math.sin;
	local mathAtan2 = math.atan2;

	local showTeam;
	local allyColor;
	local enemyColor;
	local maxEspDistance;
	local toggleBoxes;
	local toggleTracers;
	local unlockTracers;
	local showHealthBar;
	local proximityArrows;
	local maxProximityArrowDistance;

	local scalarPointAX, scalarPointAY;
	local scalarPointBX, scalarPointBY;

	local labelOffset, tracerOffset;
	local boxOffsetTopRight, boxOffsetBottomLeft;

	local healthBarOffsetTopRight, healthBarOffsetBottomLeft;
	local healthBarValueOffsetTopRight, healthBarValueOffsetBottomLeft;

	local realGetRPProperty;

	local setRP;
	local getRPProperty;
	local destroyRP;

	local scalarSize = 20;

	local ESP_RED_COLOR, ESP_GREEN_COLOR = Color3.fromRGB(192, 57, 43), Color3.fromRGB(39, 174, 96)
	local TRIANGLE_ANGLE = mathRad(45);

	do --// Entity ESP
		EntityESP = {};
		EntityESP.__index = EntityESP;
		EntityESP.__ClassName = 'entityESP';

		EntityESP.id = 0;

		local emptyTable = {};

		function EntityESP.new(player)
			EntityESP.id += 1;

			local self = setmetatable({}, EntityESP);

			self._id = EntityESP.id;
			self._player = player;
			self._playerName = player.Name;
			self._playerId = player.UserId;

			self._triangle = Drawing.new('Triangle');
			self._triangle.Visible = true;
			self._triangle.Thickness = 0;
			self._triangle.Color = Color3.fromRGB(255, 255, 255);
			self._triangle.Filled = true;

			self._label = Drawing.new('Text');
			self._label.Visible = false;
			self._label.Center = true;
			self._label.Outline = true;
			self._label.Text = '';
			self._label.Font = Drawing.Fonts[library.flags.espFont];
			self._label.Size = library.flags.textSize;
			self._label.Color = Color3.fromRGB(255, 255, 255);

			self._box = Drawing.new('Quad');
			self._box.Visible = false;
			self._box.Thickness = 1;
			self._box.Filled = false;
			self._box.Color = Color3.fromRGB(255, 255, 255);

			self._healthBar = Drawing.new('Quad');
			self._healthBar.Visible = false;
			self._healthBar.Thickness = 1;
			self._healthBar.Filled = false;
			self._healthBar.Color = Color3.fromRGB(255, 255, 255);

			self._healthBarValue = Drawing.new('Quad');
			self._healthBarValue.Visible = false;
			self._healthBarValue.Thickness = 1;
			self._healthBarValue.Filled = true;
			self._healthBarValue.Color = Color3.fromRGB(0, 255, 0);

			self._line = Drawing.new('Line');
			self._line.Visible = false;
			self._line.Color = Color3.fromRGB(255, 255, 255);

			-- for i, v in next, self do
			--if (typeof(v) == 'table' and rawget(v, '__OBJECT')) then
			--rawset(v, '_cache', {});
			-- end;
			--end;

			self._labelObject = self._label;

			return self;
		end;

		function EntityESP:Plugin()
			return emptyTable;
		end;

		function EntityESP:ConvertVector(...)
			-- if(flags.twoDimensionsESP) then
			-- return vector3New(...));
			-- else
			return vectorToWorldSpace(self._cameraCFrame, vector3New(...));
			-- end;
		end;

		function EntityESP:GetOffsetTrianglePosition(closestPoint, radiusOfDegree)
			local cosOfRadius, sinOfRadius = mathCos(radiusOfDegree), mathSin(radiusOfDegree);
			local closestPointX, closestPointY = closestPoint.X, closestPoint.Y;

			local sameBCCos = (closestPointX + scalarPointBX * cosOfRadius);
			local sameBCSin = (closestPointY + scalarPointBX * sinOfRadius);

			local sameACSin = (scalarPointAY * sinOfRadius);
			local sameACCos = (scalarPointAY * cosOfRadius)

			local pointX1 = (closestPointX + scalarPointAX * cosOfRadius) - sameACSin;
			local pointY1 = closestPointY + (scalarPointAX * sinOfRadius) + sameACCos;

			local pointX2 = sameBCCos - (scalarPointBY * sinOfRadius);
			local pointY2 = sameBCSin + (scalarPointBY * cosOfRadius);

			local pointX3 = sameBCCos - sameACSin;
			local pointY3 = sameBCSin + sameACCos;

			return Vector2New(mathFloor(pointX1), mathFloor(pointY1)), Vector2New(mathFloor(pointX2), mathFloor(pointY2)), Vector2New(mathFloor(pointX3), mathFloor(pointY3));
		end;

		function EntityESP:Update(t)
			local camera = self._camera;
			if(not camera) then return self:Hide() end;

			local character, maxHealth, floatHealth, health, rootPart = Utility:getCharacter(self._player);
			if(not character) then return self:Hide() end;

			rootPart = rootPart or Utility:getRootPart(self._player);
			if(not rootPart) then return self:Hide() end;

			local rootPartPosition = rootPart.Position;

			local labelPos, visibleOnScreen = worldToViewportPoint(camera, rootPartPosition + labelOffset);
			local triangle = self._triangle;

			local isTeamMate = Utility:isTeamMate(self._player);
			if(isTeamMate and not showTeam) then return self:Hide() end;

			local distance = (rootPartPosition - self._cameraPosition).Magnitude;
			if(distance > maxEspDistance) then return self:Hide() end;

			local espColor = isTeamMate and allyColor or enemyColor;
			local canView = false;

			if (proximityArrows and not visibleOnScreen and distance < maxProximityArrowDistance) then
				local vectorUnit;

				if (labelPos.Z < 0) then
					vectorUnit = -(Vector2.new(labelPos.X, labelPos.Y) - self._viewportSizeCenter).Unit; --PlayerPos-Center.Unit
				else
					vectorUnit = (Vector2.new(labelPos.X, labelPos.Y) - self._viewportSizeCenter).Unit; --PlayerPos-Center.Unit
				end;

				local degreeOfCorner = -mathAtan2(vectorUnit.X, vectorUnit.Y) - TRIANGLE_ANGLE;
				local closestPointToPlayer = self._viewportSizeCenter + vectorUnit * scalarSize --screenCenter+unit*scalar (Vector 2)

				local pointA, pointB, pointC = self:GetOffsetTrianglePosition(closestPointToPlayer, degreeOfCorner);

				--setRP(triangle, 'PointA', pointA);
				--setRP(triangle, 'PointB', pointB);
				--setRP(triangle, 'PointC', pointC);
				triangle.PointA = pointA
				triangle.PointB = pointB
				triangle.PointC = pointC

				--setRP(triangle, 'Color', espColor);
				triangle.Color = espColor
				canView = true;
			end;

			--setRP(triangle, 'Visible', canView);
			triangle.Visible = canView
			if (not visibleOnScreen) then return self:Hide(true) end;

			self._visible = visibleOnScreen;

			local label, box, line, healthBar, healthBarValue = self._label, self._box, self._line, self._healthBar, self._healthBarValue;
			local pluginData = self:Plugin();

			local text = '[' .. (pluginData.playerName or self._playerName) .. '] [' .. mathFloor(distance) .. ']\n[' .. mathFloor(health) .. '/' .. mathFloor(maxHealth) .. '] [' .. mathFloor(floatHealth) .. ' %]' .. (pluginData.text or '') .. ' [' .. self._playerId .. ']';

			--setRP(label, 'Visible', visibleOnScreen);
			--setRP(label, 'Position', Vector2New(labelPos.X, labelPos.Y - realGetRPProperty(self._labelObject, 'TextBounds').Y));
			--setRP(label, 'Text', text);
			--setRP(label, 'Color', espColor);
			label.Visible = visibleOnScreen
			label.Position = Vector2New(labelPos.X, labelPos.Y - label.TextBounds.Y)
			label.Text = text
			label.Color = espColor

			if(toggleBoxes) then
				local boxTopRight = worldToViewportPoint(camera, rootPartPosition + boxOffsetTopRight);
				local boxBottomLeft = worldToViewportPoint(camera, rootPartPosition + boxOffsetBottomLeft);

				local topRightX, topRightY = boxTopRight.X, boxTopRight.Y;
				local bottomLeftX, bottomLeftY = boxBottomLeft.X, boxBottomLeft.Y;

				--setRP(box, 'Visible', visibleOnScreen);

				--setRP(box, 'PointA', Vector2New(topRightX, topRightY));
				--setRP(box, 'PointB', Vector2New(bottomLeftX, topRightY));
				--setRP(box, 'PointC', Vector2New(bottomLeftX, bottomLeftY));
				--setRP(box, 'PointD', Vector2New(topRightX, bottomLeftY));
				--setRP(box, 'Color', espColor);

				box.Visible = visibleOnScreen

				box.PointA = Vector2New(topRightX, topRightY)
				box.PointB = Vector2New(bottomLeftX, topRightY)
				box.PointC = Vector2New(bottomLeftX, bottomLeftY)
				box.PointD = Vector2New(topRightX, bottomLeftY)
				box.Color = espColor
			else
				box.Visible = false
			end;

			if(toggleTracers) then
				local linePosition = worldToViewportPoint(camera, rootPartPosition + tracerOffset);

				--setRP(line, 'Visible', visibleOnScreen);


				--setRP(line, 'From', unlockTracers and getMouseLocation(UserInputService) or self._viewportSize);
				--setRP(line, 'To', Vector2New(linePosition.X, linePosition.Y));
				--setRP(line, 'Color', espColor);

				line.Visible = visibleOnScreen

				line.From = unlockTracers and getMouseLocation(UserInputService) or self._viewportSize
				line.To = Vector2New(linePosition.X, linePosition.Y)
				line.Color = espColor
			else
				--setRP(line, 'Visible', false);
				line.Visible = false
			end;

			if(showHealthBar) then
				local healthBarValueHealth = (1 - (floatHealth / 100)) * 7.4;

				local healthBarTopRight = worldToViewportPoint(camera, rootPartPosition + healthBarOffsetTopRight);
				local healthBarBottomLeft = worldToViewportPoint(camera, rootPartPosition + healthBarOffsetBottomLeft);

				local healthBarTopRightX, healthBarTopRightY = healthBarTopRight.X, healthBarTopRight.Y;
				local healthBarBottomLeftX, healthBarBottomLeftY = healthBarBottomLeft.X, healthBarBottomLeft.Y;

				local healthBarValueTopRight = worldToViewportPoint(camera, rootPartPosition + healthBarValueOffsetTopRight - self:ConvertVector(0, healthBarValueHealth, 0));
				local healthBarValueBottomLeft = worldToViewportPoint(camera, rootPartPosition - healthBarValueOffsetBottomLeft);

				local healthBarValueTopRightX, healthBarValueTopRightY = healthBarValueTopRight.X, healthBarValueTopRight.Y;
				local healthBarValueBottomLeftX, healthBarValueBottomLeftY = healthBarValueBottomLeft.X, healthBarValueBottomLeft.Y;
		--[[
		setRP(healthBar, 'Visible', visibleOnScreen);
		setRP(healthBar, 'Color', espColor);


		setRP(healthBar, 'PointA', Vector2New(healthBarTopRightX, healthBarTopRightY));
		setRP(healthBar, 'PointB', Vector2New(healthBarBottomLeftX, healthBarTopRightY));
		setRP(healthBar, 'PointC', Vector2New(healthBarBottomLeftX, healthBarBottomLeftY));
		setRP(healthBar, 'PointD', Vector2New(healthBarTopRightX, healthBarBottomLeftY));

		setRP(healthBarValue, 'Visible', visibleOnScreen);
		setRP(healthBarValue, 'Color', lerp(ESP_RED_COLOR, ESP_GREEN_COLOR, floatHealth / 100));

		setRP(healthBarValue, 'PointA', Vector2New(healthBarValueTopRightX, healthBarValueTopRightY));
		setRP(healthBarValue, 'PointB', Vector2New(healthBarValueBottomLeftX, healthBarValueTopRightY));
		setRP(healthBarValue, 'PointC', Vector2New(healthBarValueBottomLeftX, healthBarValueBottomLeftY));
		setRP(healthBarValue, 'PointD', Vector2New(healthBarValueTopRightX, healthBarValueBottomLeftY));
		]]


				healthBar.Visible = visibleOnScreen
				healthBar.Color = espColor

				healthBar.PointA = Vector2New(healthBarTopRightX, healthBarTopRightY)
				healthBar.PointB = Vector2New(healthBarBottomLeftX, healthBarTopRightY)
				healthBar.PointC = Vector2New(healthBarBottomLeftX, healthBarBottomLeftY)
				healthBar.PointD = Vector2New(healthBarTopRightX, healthBarBottomLeftY)

				healthBarValue.Visible = visibleOnScreen
				healthBarValue.Color = lerp(ESP_RED_COLOR, ESP_GREEN_COLOR, floatHealth / 100)

				healthBarValue.PointA = Vector2New(healthBarValueTopRightX, healthBarValueTopRightY)
				healthBarValue.PointB = Vector2New(healthBarValueBottomLeftX, healthBarValueTopRightY)
				healthBarValue.PointC = Vector2New(healthBarValueBottomLeftX, healthBarValueBottomLeftY)
				healthBarValue.PointD = Vector2New(healthBarValueTopRightX, healthBarValueBottomLeftY)


			else
				--setRP(healthBar, 'Visible', false);
				--setRP(healthBarValue, 'Visible', false);

				healthBar.Visible = false
				healthBarValue.Visible = false

			end;
		end;

		function EntityESP:Destroy()
			if (not self._label) then return end;

			--destroyRP(self._label);
			--self._label = nil;
			self._label:Destroy()
			--destroyRP(self._box);
			--self._box = nil;
			self._box:Destroy()
			--destroyRP(self._line);
			-- self._line = nil;
			self._line:Destroy()
			-- destroyRP(self._healthBar);
			--self._healthBar = nil;
			self._healthBar:Destroy()
			--destroyRP(self._healthBarValue);
			--self._healthBarValue = nil;
			self._healthBarValue:Destroy()
			-- destroyRP(self._triangle);
			-- self._triangle = nil;
			self._triangle:Destroy()
		end;


		function EntityESP:Hide(bypassTriangle)
			if (not bypassTriangle) then
				--setRP(self._triangle, 'Visible', false);
				self._triangle.Visible = false
			end;

			if (not self._visible) then return end;
			self._visible = false;

			-- setRP(self._label, 'Visible', false);
			--setRP(self._box, 'Visible', false);
			--setRP(self._line, 'Visible', false);

			--setRP(self._healthBar, 'Visible', false);
			--setRP(self._healthBarValue, 'Visible', false);


			self._label.Visible = false
			self._box.Visible = false
			self._line.Visible = false

			self._healthBar.Visible = false
			self._healthBarValue.Visible = false

		end;

		function EntityESP:SetFont(font)
			self._label.Font = font
		end;

		function EntityESP:SetTextSize(textSize)
			--setRP(self._label, 'Size', textSize);
			self._label.Size = textSize
		end;

		local function updateESP()
			local camera = workspace.CurrentCamera;
			EntityESP._camera = camera;
			if (not camera) then return end;

			EntityESP._cameraCFrame = EntityESP._camera.CFrame;
			EntityESP._cameraPosition = EntityESP._cameraCFrame.Position;

			local viewportSize = camera.ViewportSize;

			EntityESP._viewportSize = Vector2New(viewportSize.X / 2, viewportSize.Y - 10);
			EntityESP._viewportSizeCenter = viewportSize / 2;

			showTeam = flags.showTeam;
			allyColor = flags.allyColor;
			enemyColor = flags.enemyColor;
			maxEspDistance = flags.maxEspDistance;
			toggleBoxes = flags.toggleBoxes;
			toggleTracers = flags.toggleTracers;
			unlockTracers = flags.unlockTracers;
			showHealthBar = flags.showHealthBar;
			maxProximityArrowDistance = flags.maxProximityArrowDistance;
			proximityArrows = flags.proximityArrows;

			scalarSize = library.flags.proximityArrowsSize or 20;

			scalarPointAX, scalarPointAY = scalarSize, scalarSize;
			scalarPointBX, scalarPointBY = -scalarSize, -scalarSize;

			labelOffset = EntityESP:ConvertVector(0, 3.25, 0);
			tracerOffset = EntityESP:ConvertVector(0, -4.5, 0);

			boxOffsetTopRight = EntityESP:ConvertVector(2.5, 3, 0);
			boxOffsetBottomLeft = EntityESP:ConvertVector(-2.5, -4.5, 0);

			healthBarOffsetTopRight = EntityESP:ConvertVector(-3, 3, 0);
			healthBarOffsetBottomLeft = EntityESP:ConvertVector(-3.5, -4.5, 0);

			healthBarValueOffsetTopRight = EntityESP:ConvertVector(-3.05, 2.95, 0);
			healthBarValueOffsetBottomLeft = EntityESP:ConvertVector(3.45, 4.45, 0);
		end;

		updateESP();
		RunService:BindToRenderStep(id, Enum.RenderPriority.Camera.Value, updateESP);
	end;

	return EntityESP;
end)();

sharedRequires['AudioPlayer'] = (function()
	local Maid = sharedRequires['Maid'];
	local Services = sharedRequires['Services'];
	local library = sharedRequires['Library'];

	local RunService = Services:Get('RunService');

	local oldVolume = UserSettings().GameSettings.MasterVolume;
	local playingAudios = 0;

	UserSettings().GameSettings:GetPropertyChangedSignal('MasterVolume'):Connect(function()
		local newVolume = UserSettings().GameSettings.MasterVolume;

		if (playingAudios <= 0) then
			oldVolume = newVolume;
		end;
	end);

	local AudioPlayer = {};
	AudioPlayer.__index = AudioPlayer;

	local audioFolder = Instance.new('Folder');

	if (not gethui) then
		--syn.protect_gui(audioFolder);
	end;

	audioFolder.Parent = gethui and gethui() or Services:Get('CoreGui');
	if (not isfolder('Roniro Hub V3/sounds')) then
		makefolder('Roniro Hub V3/sounds');
	end;

	function AudioPlayer.new(options)
		local self = setmetatable({}, AudioPlayer);

		options = options or {};
		options.forcedAudio = options.forcedAudio;

		self._options = options;

		self._sound = Instance.new('Sound');
		self._sound.Volume = options.volume or 1;
		self._sound.Looped = options.looped or false;

		self._sound.Parent = audioFolder;

		self._maid = Maid.new();

		if (options.soundId) then
			self._sound.SoundId = options.soundId;
		elseif (options.url) then
			local fileName = crypt.hash(options.url, "md5") .. '.bin';
			local filePath = string.format('Roniro Hub V3/sounds/%s', fileName);

			if (not isfile(filePath)) then 
				local success, data = pcall(request, {Url = options.url});
				if (success) then
					--writefile(filePath, data.Body);
				end;
			end;

			--self._sound.SoundId = getcustomasset(filePath);
		end;

		if (options.autoPlay) then
			self:Play();
		end;

		self._maid:GiveTask(self._sound.Ended:Connect(function()
			playingAudios -= 1;
			self._maid.loop = nil;
			if (not self._options.forcedAudio) then return end;
			UserSettings().GameSettings.MasterVolume = oldVolume;
		end));

		return self;
	end;

	function AudioPlayer:GetSound()
		return self._sound;
	end;

	function AudioPlayer:Play()
		playingAudios += 1;

		if (self._options.forcedAudio) then
			self._maid.loop = RunService.Heartbeat:Connect(function()
				UserSettings().GameSettings.MasterVolume = 10;
			end);
		end;

		self._sound:Play();
	end;

	function AudioPlayer:Stop()
		playingAudios -= 1;

		self._maid.loop = nil;
		UserSettings().GameSettings.MasterVolume = oldVolume;

		self._sound:Stop();
	end;

	return AudioPlayer;
end)();

sharedRequires['supportedGamesList'] = (function()
	return [[{"88070565":"Bloxburg","111958650":"Arsenal","113491250":"Phantom Forces","170247232":"Parkour","212154879":"Sword Burst 2","245662005":"Jailbreak","254394801":"KAT","299659045":"Phantom Forces","301252049":"RoBeats","358276974":"Apocalypse Rising 2","380704901":"Ro Ghoul","383310974":"Adopt Me","648454481":"Grand Piece Online","807930589":"Wild West","913400159":"Ace Of Spadez","1087859240":"Rogue Lineage","1168263273":"Bad Business","1180269832":"Arcane Odyssey","1359573625":"DeepWoken","1390601379":"Combat Warriors","1625049715":"AdventureTales","1643537246":"RoBeats CS","1663370770":"Mighty Omega","1946714362":"Bloodlines","2142948266":"Shitty Slayer","3291589472":"Voxl Blade","3525075510":"Project Mugetsu","5019154432":"Balthazar"}]]
end)();

sharedRequires['055b759436afbb00dff7f3d6892eda9b8ef9b685f5abb07e1ecf6fca60f206b9'] = (function()
	return [[
local Players = game:GetService('Players');
local RunService = game:GetService('RunService');
local LocalPlayer = Players.LocalPlayer;

local camera, rootPart, rootPartPosition;

local originalCommEvent = ...;
local commEvent;

if (typeof(originalCommEvent) == 'table') then
	commEvent = {
		_event = originalCommEvent._event,

		Connect = function(self, f)
			return self._event.Event:Connect(f)
		end,

		Fire = function(self, ...)
			self._event:Fire(...);
		end
	};
else
	commEvent = getgenv().syn.get_comm_channel(originalCommEvent);
end;

local flags = {};

local updateTypes = {};

local BaseESPParallel = {};
BaseESPParallel.__index = BaseESPParallel;

local container = {};
local DEFAULT_ESP_COLOR = Color3.fromRGB(255, 255, 255);

local mFloor = math.floor;
local isSynapseV3 = not not gethui;

local worldToViewportPoint = Instance.new('Camera').WorldToViewportPoint;
local vector2New = Vector2.new;

local realSetRP;
local realDestroyRP;
local realGetRPProperty;



local updateDrawingQueue = {};
local destroyDrawingQueue = {};

local activeContainer = {};
local customInstanceCache = {};

local gameName;
local enableESPSearch = false;

local sLower = string.lower;
local sFind = string.find;

local findFirstChild = clonefunction(game.FindFirstChild);
local getAttribute = clonefunction(game.GetAttribute);

function BaseESPParallel.new(data, showESPFlag, customInstance)
	local self = setmetatable(data, BaseESPParallel);

	if (customInstance) then
		if (not customInstanceCache[data._code]) then
			local func = loadstring(data._code);
			getfenv(func).library = setmetatable({}, {__index = function(self, p) return flags end});

			customInstanceCache[data._code] = func;
		end;
		self._instance = customInstanceCache[data._code](unpack(data._vars));
	end;

	local instance, tag, color, isLazy = self._instance, self._tag, self._color, self._isLazy;
	self._showFlag2 = showESPFlag;


	if (isSynapseV3 and typeof(instance) == 'Instance' and false) then
		-- if (typeof(instance) == 'table') then
		-- 	task.spawn(error, instance);
		-- end;

		self._label = TextDynamic.new(PointInstance.new(instance));
		self._label.Color = DEFAULT_ESP_COLOR;
		self._label.XAlignment = XAlignment.Center;
		self._label.YAlignment = YAlignment.Center;
		self._label.Outlined = true;
		self._label.Text = string.format('[%s]', tag);
	else
		self._label = Drawing.new('Text');
		self._label.Transparency = 1;
		self._label.Color = color;
		self._label.Text = '[' .. tag .. ']';
		self._label.Center = true;
		self._label.Outline = true;
	end;

	local flagValue = flags[self._showFlag];
	-- self._object = isSynapseV3 and self._label or self._label.__OBJECT;

	for i, v in next, self do
		if (typeof(v) == 'table' and rawget(v, '__OBJECT')) then
			rawset(v, '_cache', {});
		end;
	end;

	container[self._id] = self;

	if (isLazy) then
		self._instancePosition = instance.Position;
	end;

	self:UpdateContainer();
	return self;
end;

function BaseESPParallel:Destroy()
	container[self._id] = nil;
	if (table.find(activeContainer, self)) then
		table.remove(activeContainer, table.find(activeContainer, self));
	end;
	table.insert(destroyDrawingQueue, self._label);
end;

function BaseESPParallel:Unload()
	table.insert(updateDrawingQueue, {
		label = self._label,
		visible = false
	});
end;

function BaseESPParallel:BaseUpdate(espSearch)
	local instancePosition = self._instancePosition or self._instance.Position;
	if (not instancePosition) then return self:Unload() end;

	local distance = (rootPartPosition - instancePosition).Magnitude;
	local maxDist = flags[self._maxDistanceFlag] or 10000;
	if(distance >= maxDist and maxDist ~= 10000) then return self:Unload(); end;

	local visibleState = flags[self._showFlag];
	local label, text = self._label, self._text;

	if(visibleState == nil) then
		visibleState = true;
	elseif (not visibleState) then
		return self:Unload();
	end;

	-- if (isSynapseV3) then return end;

	local position, visible = worldToViewportPoint(camera, instancePosition);
	if(not visible) then return self:Unload(); end;

	local newPos = vector2New(position.X, position.Y);

	local labelText = '';

	if (flags[self._showHealthFlag]) then
		-- Custom instance do not touch they have custom funcs
		local humanoid = self._instance:FindFirstChildWhichIsA('Humanoid') or self._instance.Parent and self._instance.Parent:FindFirstChild('Humanoid');

		if (not humanoid) then
			if (gameName == 'Arcane Odyssey') then
				local attributes = findFirstChild(self._instance.Parent, 'Attributes');
				if (attributes) then
					humanoid = {
						Health = attributes.Health.Value,
						MaxHealth = attributes.MaxHealth.Value,
					}
				end
			elseif (gameName == 'Voxl Blade') then
				humanoid = {
					Health = getAttribute(self._instance, 'HP'),
					MaxHealth = getAttribute(self._instance, 'MAXHP'),
				}
			end;
		end;

		if (humanoid) then
			local health = mFloor(humanoid.Health);
			local maxHealth = mFloor(humanoid.MaxHealth);

			labelText = labelText .. '[' .. health .. '/' .. maxHealth ..']';
		end;
	end;

	labelText = labelText .. '[' .. text .. ']';

	local visible = true;

	if (enableESPSearch and espSearch and not sFind(sLower(labelText), espSearch)) then
		visible = false;
	end;

	local newColor = flags[self._colorFlag] or flags[self._colorFlag2] or DEFAULT_ESP_COLOR;

	if (flags[self._showDistanceFlag]) then
		labelText = labelText .. ' [' .. mFloor(distance) .. ']';
	end;

	table.insert(updateDrawingQueue, {
		position = newPos,
		color = newColor,
		text = labelText,
		label = label,
		visible = visible
	});
end;

function BaseESPParallel:UpdateContainer()
	local showFlag, showFlag2 = self._showFlag, self._showFlag2;

	if (flags[showFlag] == false or not flags[showFlag2]) then
		local exists = table.find(activeContainer, self);
		if (exists) then table.remove(activeContainer, exists); end;
		self:Unload();
	elseif (not table.find(activeContainer, self)) then
		table.insert(activeContainer, self);
	end;
end;

function updateTypes.new(data)
	local showESPFlag = data.showFlag;
	local isCustomInstance = data.isCustomInstance;
	data = data.data;

	BaseESPParallel.new(data, showESPFlag, isCustomInstance);
end;

function updateTypes.destroy(data)
	--task.desynchronize();
	local id = data.id;

	for _, v in next, container do
		if (v._id == id) then
			v:Destroy();
		end;
	end;
end;

local event;
local flagChanged;

local containerUpdated = false;

function updateTypes.giveEvent(data)
	event = data.event;
	gameName = data.gameName;

	enableESPSearch = gameName == 'Voxl Blade' or gameName == 'DeepWoken' or gameName == 'Rogue Lineage';

	event.Event:Connect(function(data)
		if (data.type == 'color') then
			flags[data.flag] = data.color;
		elseif (data.type == 'slider') then
			flags[data.flag] = data.value;
		elseif (data.type == 'toggle') then
			flags[data.flag] = data.state;
		elseif (data.type == 'box') then
			flags[data.flag] = data.value;
		end;

		if (data.type ~= 'toggle' or containerUpdated) then return end;
		containerUpdated = true;

		task.defer(function()
			--debug.profilebegin('containerUpdates');
			for _, v in next, container do
				v:UpdateContainer();
			end;
			--debug.profileend();

			containerUpdated = false;
		end);
	end);
end;

commEvent:Connect(function(data)
	local f = updateTypes[data.updateType];
	if (not f) then return end;
	f(data);
end);

commEvent:Fire({updateType = 'ready'});

RunService.Heartbeat:Connect(function(deltaTime)
	--task.desynchronize();

	camera = workspace.CurrentCamera;
	rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
	rootPartPosition = rootPart and rootPart.Position;

	if(not camera or not rootPart) then return; end;

	local espSearch = enableESPSearch and flags.espSearch;

	if (espSearch and espSearch ~= '') then
		espSearch = sLower(espSearch);
	end;

	for i = 1, #activeContainer do
		activeContainer[i]:BaseUpdate(espSearch);
	end;

	local goSerial = #updateDrawingQueue ~= 0 or #destroyDrawingQueue ~= 0;
	
	--debug.profilebegin('updateDrawingQueue');

	for i = 1, #updateDrawingQueue do
		local v = updateDrawingQueue[i];
		local label, position, visible, color, text = v.label, v.position, v.visible, v.color, v.text;

		if (isSynapseV3) then
			if (position) then
				label.Position = position;
			end;

			if (visible ~= nil) then
				label.Visible = visible;
			end;

			if (color) then
				label.Color = color;
			end;

			if (text) then
				label.Text = text;
			end;
		else                
			if (position) then
				--setRP(label, 'Position', position);
				label.Position = position
			end;

			if (visible ~= nil) then
				--setRP(label, 'Visible', visible);
				label.Visible = visible
			end;

			if (color) then
				--setRP(label, 'Color', color);
				label.Color = color
			end;

			if (text) then
				--setRP(label, 'Text', text);
				label.Text = text
			end;
		end;
	end;

	--debug.profileend();
	--debug.profilebegin('destroyDrawingQueue');

	for i = 1, #destroyDrawingQueue do
		destroyDrawingQueue[i]:Remove();
	end;

	--debug.profileend();
	--debug.profilebegin('table clear');

	updateDrawingQueue = {};
	destroyDrawingQueue = {};

	--debug.profileend();
end);
]];
end)();

sharedRequires['createBaseESP'] = (function()
	--------SX_VM_CNONE();
	local Maid = sharedRequires['Maid'];
	local Services = sharedRequires['Services'];

	local toCamelCase = sharedRequires['toCamelCase'];
	local library = sharedRequires['Library'];

	local Players, CorePackages, HttpService = Services:Get('Players', 'CorePackages', 'HttpService');
	local LocalPlayer = Players.LocalPlayer;

	local NUM_ACTORS = 8;

--[[
We'll add an example cuz I have no brain

local chestsESP = createBaseESP('chests'); -- This is the base ESP it returns a class with .new, .Destroy, :UpdateAll, :UnloadAll, and some other stuff

-- Listen to chests childAdded through Utility.listenToChildAdded and then create an espObject for that chest
-- chestsESP.new only accepts BasePart or CFrame
-- It has a lazy parameter allowing it to not update the get the position everyframe only get the screen position
-- Also a color parameter

Utility.listenToChildAdded(workspace.Chests, function(obj)
	local espObject = chestsESP.new(obj, 'Normal Chest', color, isLazy);

	obj.Destroying:Connect(function()
		espObject:Destroy();
	end);
end);

local function updateChestESP(toggle)
	if (not toggle) then
		maid.chestESP = nil;
		chestsESP:UnloadAll();
		return;
	end;

	maid.chestESP = RunService.Stepped:Connect(function()
		chestsESP:UpdateAll();
	end);
end;

-- UI Lib functions
:AddToggle({text = 'Enable', flag = 'chests', callback = updateChestESP});
:AddToggle({text = 'Show Distance', textpos = 2, flag = 'Chests Show Distance'});
:AddToggle({text = 'Show Normal Chest'}):AddColor({text = 'Normal Chest Color'}); -- Filer for if you want to see that chest and select the color of it
]]

	local playerScripts = LocalPlayer:WaitForChild('PlayerScripts')

	--local playerScriptsLoader = playerScripts:FindFirstChild('PlayerScriptsLoader');
	local actors = {};

	local readyCount = 0;
	local broadcastEvent = Instance.new('BindableEvent');

	local supportedGamesList = HttpService:JSONDecode(sharedRequires['supportedGamesList']);
	local gameName = supportedGamesList[tostring(game.GameId)];

	if (playerScriptsLoader) then
		for _ = 1, NUM_ACTORS do
			local commId, commEvent;

			if (isSynapseV3) then
				commEvent = {
					_event = Instance.new('BindableEvent'),

					Connect = function(self, f)
						return self._event.Event:Connect(f)
					end,

					Fire = function(self, ...)
						self._event:Fire(...);
					end
				};
			else
				commId, commEvent = getgenv().syn.create_comm_channel();
			end;

			local clone = playerScriptsLoader:Clone();
			local actor = Instance.new('Actor');
			clone.Parent = actor;

			local playerModule = CorePackages.InGameServices.MouseIconOverrideService:Clone();
			playerModule.Name = 'PlayerModule';
			playerModule.Parent = actor;

			if (not isSynapseV3) then
				--syn.protect_gui(actor);
			end;

			actor.Parent = LocalPlayer.PlayerScripts;

			local connection;

			connection = commEvent:Connect(function(data)
				if (data.updateType == 'ready') then
					commEvent:Fire({updateType = 'giveEvent', event = broadcastEvent, gameName = gameName});
					actor:Destroy();

					readyCount += 1;

					connection:Disconnect();
					connection = nil;
				end;
			end);

			originalFunctions.runOnActor(actor, sharedRequires['055b759436afbb00dff7f3d6892eda9b8ef9b685f5abb07e1ecf6fca60f206b9'], commId or commEvent);
			table.insert(actors, {
				actor = actor,
				commEvent = commEvent
			});
		end;

		print('Waiting for actors');
		repeat task.wait(); until readyCount >= NUM_ACTORS;
		print('All actors have been loaded');
	else
		local commId, commEvent = getgenv().syn.create_comm_channel();

		local connection;
		connection = commEvent:Connect(function(data)
			if (data.updateType == 'ready') then
				connection:Disconnect();
				connection = nil;

				commEvent:Fire({updateType = 'giveEvent', event = broadcastEvent});
			end;
		end);

		loadstring(sharedRequires['055b759436afbb00dff7f3d6892eda9b8ef9b685f5abb07e1ecf6fca60f206b9'])(commId);

		table.insert(actors, {commEvent = commEvent});
		readyCount = 1;
	end;

	local count = 1;

	local function createBaseEsp(flag, container)
		container = container or {};
		local BaseEsp = {};

		BaseEsp.ClassName = 'BaseEsp';
		BaseEsp.Flag = flag;
		BaseEsp.Container = container;
		BaseEsp.__index = BaseEsp;

		local whiteColor = Color3.new(1, 1, 1);

		local maxDistanceFlag = BaseEsp.Flag .. 'MaxDistance';
		local showHealthFlag = BaseEsp.Flag .. 'ShowHealth';
		local showESPFlag = BaseEsp.Flag;

		function BaseEsp.new(instance, tag, color, isLazy)
			assert(instance, '#1 instance expected');
			assert(tag, '#2 tag expected');

			local isCustomInstance = false;

			if (typeof(instance) == 'table' and rawget(instance, 'code')) then
				isCustomInstance = true;
			end;

			color = color or whiteColor;

			local self = setmetatable({}, BaseEsp);
			self._tag = tag;

			local displayName = tag;

			if (typeof(tag) == 'table') then
				displayName = tag.displayName;
				self._tag = tag.tag;
			end;

			self._instance = instance;
			self._text = displayName;
			self._color = color;
			self._showFlag = toCamelCase('Show ' .. self._tag);
			self._colorFlag = toCamelCase(self._tag .. ' Color');
			self._colorFlag2 = BaseEsp.Flag .. 'Color';
			self._showDistanceFlag = BaseEsp.Flag .. 'ShowDistance';
			self._isLazy = isLazy;
			self._actor = actors[(count % readyCount) + 1];
			self._id = count;
			self._maid = Maid.new();

			count += 1;

			if (isLazy and not isCustomInstance) then
				self._instancePosition = instance.Position;
			end;

			self._maxDistanceFlag = maxDistanceFlag;
			self._showHealthFlag = showHealthFlag;

			if (isCustomInstance) then
				self._isCustomInstance = true;
				self._code = instance.code;
				self._vars = instance.vars;
			end;

			local smallData = table.clone(self);
			smallData._actor = nil;
			self._actor.commEvent:Fire({
				updateType = 'new',
				data = smallData,
				isCustomInstance = isCustomInstance,
				showFlag = showESPFlag
			});


			return self;
		end;

		function BaseEsp:Unload() end;
		function BaseEsp:BaseUpdate() end;
		function BaseEsp:UpdateAll() end;
		function BaseEsp:Update() end;
		function BaseEsp:UnloadAll() end;
		function BaseEsp:Disable() end;

		function BaseEsp:Destroy()
			self._maid:Destroy();
			self._actor.commEvent:Fire({
				updateType = 'destroy',
				id = self._id
			});
		end;

		return BaseEsp;
	end;

	library.OnFlagChanged:Connect(function(data)
		broadcastEvent:Fire({
			type = data.type,
			flag = data.flag,
			color = data.color,
			state = data.state,
			value = data.value
		});
	end);

	return createBaseEsp;
end)();
--debu123
sharedRequires['makeESP'] = (function()
	local Utility = sharedRequires['Utility'];
	local createBaseESP = sharedRequires['createBaseESP'];
	local library = sharedRequires['Library'];
	local toCamelCase = sharedRequires['toCamelCase'];

	local sectionIndex = 1;
	local addedESPSearch = false;
	local function makeEsp(options)
		options = options or {};

		local tag = toCamelCase(options.sectionName);

		assert(options.sectionName, 'options.sectionName is required');
		assert(options.callback, 'options.callback is required');
		assert(options.args, 'options.args is required');
		assert(options.type, 'options.type is required');

		sectionIndex = (sectionIndex % 2) + 1;

		local espSections = Utility:getESPSection();
		local espSection = espSections['column' .. sectionIndex]:AddSection(options.sectionName);

		if (not addedESPSearch) then
			addedESPSearch = true;
			espSections.espSettings:AddBox({
				text = 'ESP Search',
				skipflag = true,
				noload = true
			});
		end;

		local enableToggle = espSection:AddToggle({
			text = 'Enable',
			flag = options.sectionName
		});

		if (not options.noColorPicker) then
			enableToggle:AddColor({
				flag = string.format('%s Color', options.sectionName)
			});
		end;

		local showDistance = espSection:AddToggle({
			text = 'Show Distance',
			flag = options.sectionName .. ' Show Distance'
		})

		showDistance:AddSlider({
			text = 'Max Distance',
			flag = options.sectionName .. ' Max Distance',
			min = 100,
			value = 100000,
			max = 100000,
			float = 100,
			textpos = 2
		});

		local espConstructor = createBaseESP(tag);

		-- If arg is not a table turn arg into a table
		options.args = typeof(options.args) == 'table' and options.args or {options.args};

		local descOrChild = options.type == 'childAdded' or options.type == 'descendantAdded';
		local watcherFunc;

		if (descOrChild) then
			watcherFunc = Utility[options.type == 'childAdded' and 'listenToChildAdded' or 'listenToDescendantAdded'];
		elseif (options.type == 'tagAdded') then
			watcherFunc = Utility.listenToTagAdded;
		end;

		if (not watcherFunc) then
			return error(options.tag .. ' is not being watched!');
		end;

		for _, parent in next, options.args do
			library.unloadMaid:GiveTask(watcherFunc(parent, function(obj)
				options.callback(obj, espConstructor);
			end));
		end;

		local loadedData = options.onLoaded and options.onLoaded(espSection);

		library.OnLoad:Connect(function()
			local onStateChanged = enableToggle.onStateChanged;

			onStateChanged:Connect(function(state)
				showDistance.main.Visible = state;
			end);

			if (not loadedData) then return; end;

			onStateChanged:Connect(function(state)
				for _, listItem in next, loadedData.list do
					listItem.main.Visible = state;
				end;
			end);
		end);
	end;

--[[
Example usage:

local section = makeEsp({
	sectionName = 'Mobs',

	type = 'childAdded',
	args = {workspace},

	callback = function(obj, esp)
		esp.new(obj, obj:GetAttribute('MobName') or mob.Name, nil, true); -- Simple args from createBaseESP
	end,

	onLoaded = function(section)
		section:AddToggle({
			text = 'Show Health'
		});

		-- You can also return a list for esp that require toggle for each obj
		return {
			list = arrayOfToggles
		};
	end
});
]]

	-- This is required cause we want the script to finish loading before we setup esp
	return function (options)
		task.spawn(makeEsp, options);
	end;

end)();

sharedRequires['AnalyticsAPI'] = (function()
	local HttpService = game:GetService('HttpService');

	local Analytics = {}
	Analytics.__index = Analytics;

	do
		function Analytics.new(id)
			local self = setmetatable({}, Analytics);

			self._id = id;

			return self;
		end;

		function Analytics:Report(Category, Action, Value)
			local Label = string.format('AH:%s', "lol");
	--[[
	task.spawn(request, {
		Url = 'http://www.google-analytics.com/collect',
		Method = 'POST',
		Body = string.format('v=1&t=event&sc=start&tid=%s&cid=%s&ec=%s&ea=%s&el=%s&ev=%s', self._id, accountData.uuid, HttpService:UrlEncode(Category), HttpService:UrlEncode(Action), HttpService:UrlEncode(Label), HttpService:UrlEncode(Value)),
		Headers = {
			['Content-Type'] = 'application/x-www-form-urlencoded'
		}
	})]]
		end;
	end;

	return Analytics;
end)();

sharedRequires['ControlModule'] = (function()
	local Services = sharedRequires['Services'];
	local ContextActionService, HttpService = Services:Get('ContextActionService', 'HttpService');

	local ControlModule = {};

	do
		ControlModule.__index = ControlModule

		function ControlModule.new()
			local self = {
				forwardValue = 0,
				backwardValue = 0,
				leftValue = 0,
				rightValue = 0
			}

			setmetatable(self, ControlModule)
			self:init()
			return self
		end

		function ControlModule:init()
			local handleMoveForward = function(actionName, inputState, inputObject)
				self.forwardValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
				return Enum.ContextActionResult.Pass
			end

			local handleMoveBackward = function(actionName, inputState, inputObject)
				self.backwardValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
				return Enum.ContextActionResult.Pass
			end

			local handleMoveLeft = function(actionName, inputState, inputObject)
				self.leftValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
				return Enum.ContextActionResult.Pass
			end

			local handleMoveRight = function(actionName, inputState, inputObject)
				self.rightValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
				return Enum.ContextActionResult.Pass
			end

			ContextActionService:BindAction(HttpService:GenerateGUID(false), handleMoveForward, false, Enum.KeyCode.W);
			ContextActionService:BindAction(HttpService:GenerateGUID(false), handleMoveBackward, false, Enum.KeyCode.S);
			ContextActionService:BindAction(HttpService:GenerateGUID(false), handleMoveLeft, false, Enum.KeyCode.A);
			ContextActionService:BindAction(HttpService:GenerateGUID(false), handleMoveRight, false, Enum.KeyCode.D);
		end

		function ControlModule:GetMoveVector()
			return Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end

	return ControlModule.new();
end)();

sharedRequires['AltManagerAPI'] = (function()
	-- DOCUMENTATION: https://ic3w0lf22.gitbook.io/roblox-account-manager/

	local Account = {} Account.__index = Account

	local WebserverSettings = {
		Port = '7963',
		Password = ''
	}

	function WebserverSettings:SetPort(Port) self.Port = Port end
	function WebserverSettings:SetPassword(Password) self.Password = Password end

	local HttpService = game:GetService'HttpService'
	local Request = request;

	local function GET(Method, Account, ...)
		local Arguments = {...}
		local Url = 'http://localhost:' .. WebserverSettings.Port .. '/' .. Method .. '?Account=' .. Account

		for Index, Parameter in pairs(Arguments) do
			Url = Url .. '&' .. Parameter
		end

		if WebserverSettings.Password and #WebserverSettings.Password >= 6 then
			Url = Url .. '&Password=' .. WebserverSettings.Password
		end

		local Response = Request {
			Method = 'GET',
			Url = Url
		}

		if Response.StatusCode ~= 200 then return false end

		return Response.Body
	end

	local function POST(Method, Account, Body, ...)
		local Arguments = {...}
		local Url = 'http://localhost:' .. WebserverSettings.Port .. '/' .. Method .. '?Account=' .. Account

		for Index, Parameter in pairs(Arguments) do
			Url = '&' .. Url .. Parameter
		end

		if WebserverSettings.Password and #WebserverSettings.Password >= 6 then
			Url = Url .. '&Password=' .. WebserverSettings.Password
		end

		local Response = Request {
			Method = 'POST',
			Url = Url,
			Body = Body
		}

		if Response.StatusCode ~= 200 then return false end

		return Response.Body
	end

	function Account.new(Username, SkipValidation)
		local self = {} setmetatable(self, Account)

		local IsValid = SkipValidation or GET('GetCSRFToken', Username)

		if not IsValid or IsValid == 'Invalid Account' then return false end

		self.Username = Username

		return self
	end

	function Account:GetCSRFToken() return GET('GetCSRFToken', self.Username) end

	function Account:BlockUser(Argument)
		if typeof(Argument) == 'string' then
			return GET('BlockUser', self.Username, 'UserId=' .. Argument)
		elseif typeof(Argument) == 'Instance' and Argument:IsA'Player' then
			return self:BlockUser(tostring(Argument.UserId))
		elseif typeof(Argument) == 'number' then
			return self:BlockUser(tostring(Argument))
		end
	end
	function Account:UnblockUser(Argument)
		if typeof(Argument) == 'string' then
			return GET('UnblockUser', self.Username, 'UserId=' .. Argument)
		elseif typeof(Argument) == 'Instance' and Argument:IsA'Player' then
			return self:BlockUser(tostring(Argument.UserId))
		elseif typeof(Argument) == 'number' then
			return self:BlockUser(tostring(Argument))
		end
	end
	function Account:GetBlockedList() return GET('GetBlockedList', self.Username) end
	function Account:UnblockEveryone() return GET('UnblockEveryone', self.Username) end

	function Account:GetAlias() return GET('GetAlias', self.Username) end
	function Account:GetDescription() return GET('GetDescription', self.Username) end
	function Account:SetAlias(Alias) return POST('SetAlias', self.Username, Alias) end
	function Account:SetDescription(Description) return POST('SetDescription', self.Username, Description) end
	function Account:AppendDescription(Description) return POST('AppendDescription', self.Username, Description) end

	function Account:GetField(Field) return GET('GetField', self.Username, 'Field=' .. HttpService:UrlEncode(Field)) end
	function Account:SetField(Field, Value) return GET('SetField', self.Username, 'Field=' .. HttpService:UrlEncode(Field), 'Value=' .. HttpService:UrlEncode(tostring(Value))) end
	function Account:RemoveField(Field) return GET('RemoveField', self.Username, 'Field=' .. HttpService:UrlEncode(Field)) end

	function Account:SetServer(PlaceId, JobId) return GET('SetServer', self.Username, 'PlaceId=' .. PlaceId, 'JobId=' .. JobId) end
	function Account:SetRecommendedServer(PlaceId) return GET('SetServer', self.Username, 'PlaceId=' .. PlaceId) end

	function Account:ImportCookie(Token) return GET('ImportCookie', 'Cookie=' .. Token) end
	function Account:GetCookie() return GET('GetCookie', self.Username) end
	function Account:LaunchAccount(PlaceId, JobId, FollowUser, JoinVip) -- if you want to follow someone, PlaceId must be their user id
		return GET('LaunchAccount', self.Username, 'PlaceId=' .. PlaceId, JobId and ('JobId=' .. JobId), FollowUser and 'FollowUser=true', JoinVip and 'JoinVIP=true')
	end

	return Account, WebserverSettings
end)();
print("ok2")
sharedRequires['BlockUtils'] = (function()
	local Services = sharedRequires['Services'];
	local library = sharedRequires['Library'];
	local AltManagerAPI = sharedRequires['AltManagerAPI'];
	local Players, GuiService, HttpService, StarterGui, VirtualInputManager, CoreGui = Services:Get('Players', 'GuiService', 'HttpService', 'StarterGui', 'VirtualInputManager', 'CoreGui');
	local LocalPlayer = Players.LocalPlayer;

	local BlockUtils = {};
	local IsFriendWith = LocalPlayer.IsFriendsWith;

	local apiAccount;

	task.spawn(function()
		--apiAccount = AltManagerAPI.new(LocalPlayer.Name);
	end);

	local function isFriendWith(userId)
		local suc, data = pcall(IsFriendWith, LocalPlayer, userId);

		if (suc) then
			return data;
		end;

		return true;
	end;

	function BlockUtils:BlockUser(userId)
		if(library.flags.useAltManagerToBlock and apiAccount) then
			apiAccount:BlockUser(userId);

			local blockedListRetrieved, blockList = pcall(HttpService.JSONDecode, HttpService, apiAccount:GetBlockedList());
			if(blockedListRetrieved and typeof(blockList) == 'table' and blockList.success and blockList.total >= 20) then
				apiAccount:UnblockEveryone();
			end;
		else
			library.base.Enabled = false;

			local blockedUserIds = StarterGui:GetCore('GetBlockedUserIds');
			local playerToBlock = Instance.new('Player');
			playerToBlock.UserId = tonumber(userId);

			local lastList = #blockedUserIds;
			GuiService:ClearError();

			repeat
				StarterGui:SetCore('PromptBlockPlayer', playerToBlock);

				local confirmButton = CoreGui.RobloxGui.PromptDialog.ContainerFrame:FindFirstChild('ConfirmButton');
				if (not confirmButton) then break end;

				local btnPosition = confirmButton.AbsolutePosition + Vector2.new(40, 40);

				VirtualInputManager:SendMouseButtonEvent(btnPosition.X, btnPosition.Y, 0, false, game, 1);
				task.wait();
				VirtualInputManager:SendMouseButtonEvent(btnPosition.X, btnPosition.Y, 0, true, game, 1);
				task.wait();
			until #StarterGui:GetCore('GetBlockedUserIds') ~= lastList;

			task.wait(0.2);

			library.base.Enabled = true;
		end;
	end;

	function BlockUtils:UnblockUser()

	end;

	function BlockUtils:BlockRandomUser()
		for _, v in next, Players:GetPlayers() do
			if (v ~= LocalPlayer and not isFriendWith(v.UserId)) then
				self:BlockUser(v.UserId);
				break;
			end;
		end;
	end;

	return BlockUtils;
end)();

sharedRequires['Webhook'] = (function()
	local Services = sharedRequires['Services'];
	local HttpService = Services:Get('HttpService');

	local Webhook = {};
	Webhook.__index = Webhook;

	function Webhook.new(url)
		local self = setmetatable({}, Webhook);

		self._url = url;

		return self;
	end;

	function Webhook:Send(data, yields)
		if (typeof(data) == 'string') then
			data = {content = data};
		end;

		local function send()
			request({
				Url = self._url,
				Method = 'POST',
				Headers = {['Content-Type'] = 'application/json'},
				Body = originalFunctions.jsonEncode(HttpService, data)
			});
		end;

		if (yields) then
			pcall(send);
		else
			task.spawn(send);
		end;
	end;

	return Webhook;
end)();

sharedRequires['Security'] = (function()
	local Webhook = sharedRequires['Webhook'];
	local WEBHOOK_URL = '';

	local Security = {};

	-- TODO: Use our own backend logic rather than discord for logging the users infraction
	function Security:LogInfraction(infraction)

		-- Webhook.new(WEBHOOK_URL):Send({
		--   content = string.format('%s - %s', accountData.uuid, infraction)
		-- }, true);

		--return SX_CRASH();
	end

	return Security;
end)();

sharedRequires['TextLogger'] = (function()
	local library = sharedRequires['Library'];

	local Services = sharedRequires['Services'];
	local Signal = sharedRequires['Signal'];
	local ToastNotif = sharedRequires['ToastNotif'];
	local Security = sharedRequires['Security'];

	local UserInputService, TweenService, TextService, ReplicatedStorage, Players, HttpService = Services:Get('UserInputService', 'TweenService', 'TextService', 'ReplicatedStorage', 'Players', 'HttpService');
	local LocalPlayer = Players.LocalPlayer;

	local TextLogger = {};
	TextLogger.__index = TextLogger;

	TextLogger.Colors = {};
	TextLogger.Colors.Background = Color3.fromRGB(30, 30, 30);
	TextLogger.Colors.Border = Color3.fromRGB(155, 155, 155);
	TextLogger.Colors.TitleColor = Color3.fromRGB(255, 255, 255);

	local Text = {};

	-- // Text
	do
		Text.__index = Text;

		function Text.new(options)
			local self = setmetatable(options, Text);
			self._originalText = options.originalText or options.text;

			self.label = library:Create('TextLabel', {
				BackgroundTransparency = 1,
				Parent = self._parent._logs,
				Size = UDim2.new(1, 0, 0, 25),
				Font = Enum.Font.Roboto,
				TextColor3 = options.color or Color3.fromRGB(255, 255, 255),
				TextSize = 20,
				RichText = true,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				Text = self.text;
			});

			self:SetText(options.text);

			self.OnMouseEnter = Signal.new();
			self.OnMouseLeave = Signal.new();

			local index = #self._parent.logs + 1;
			local mouseButton2 = Enum.UserInputType.MouseButton2;
			local mouseHover = Enum.UserInputType.MouseMovement;

			self.label.InputBegan:Connect(function(inputObject, gpe)
				if (inputObject.UserInputType == mouseButton2 and not gpe) then
					local toolTip = self._parent._toolTip;

					self._parent._currentToolTip = self;
					self._parent._currentToolTipIndex = index;

					toolTip.Visible = true;
					toolTip:TweenSize(UDim2.fromOffset(150, #self._parent.params.buttons * 30), 'Out', 'Quad', 0.1, true);

					local mouse = UserInputService:GetMouseLocation();
					toolTip.Position = UDim2.fromOffset(mouse.X, mouse.Y);
				elseif (inputObject.UserInputType == mouseHover) then
					self.OnMouseEnter:Fire();
				end;
			end);

			self.label.InputEnded:Connect(function(inputObject)
				if (inputObject.UserInputType == mouseHover) then
					self.OnMouseLeave:Fire();
				end;
			end);

			table.insert(self._parent.logs, self);
			table.insert(self._parent.allLogs, {
				_originalText = self._originalText
			});

			local contentSize = self._parent._layout.AbsoluteContentSize;
			self._parent._logs.CanvasSize = UDim2.fromOffset(0, contentSize.Y);

			if (library.flags.chatLoggerAutoScroll) then
				self._parent._logs.CanvasPosition = Vector2.new(0, contentSize.Y);
			end;

			return self;
		end;

		function Text:Destroy()
			local logs = self._parent.logs;
			table.remove(logs, table.find(logs, self));
			self.label:Destroy();
		end;

		function Text:SetText(text)
			self.label.Text = text;
			local textSize = TextService:GetTextSize(self.label.ContentText, 20, Enum.Font.Roboto, Vector2.new(self._parent._logs.AbsoluteSize.X, math.huge));

			self.label.Size = UDim2.new(1, 0, 0, textSize.Y);
			self._parent:UpdateCanvas();
		end;
	end;

	local function setCameraSubject(subject)
		workspace.CurrentCamera.CameraSubject = subject;
	end;

	local function initChatLoggerPreset(chatLogger)
		library.unloadMaid:GiveTask(ReplicatedStorage.DefaultChatSystemChatEvents.OnMessageDoneFiltering.OnClientEvent:Connect(function(messageData)
			for i = 2, 10 do
				local l, s, n, f, a = debug.info(i, 'lsnfa');

				if (l or s or n or f or a) then
					task.spawn(function() Security:LogInfraction('omdf'); end);
					return;
				end;
			end;

			--local player, message = originalFunctions.findFirstChild(Players, messageData.FromSpeaker), messageData.Message;
			if (not player or not message) then return end;

			chatLogger.OnPlayerChatted:Fire(player, message);
		end));

		local reported = {};

		chatLogger.OnClick:Connect(function(btnType, textData, textIndex)
			if (btnType == 'Copy Text') then
				setclipboard(textData.text);
			elseif (btnType == 'Copy Username') then
				setclipboard(textData.player.Name);
			elseif (btnType == 'Copy User Id') then
				setclipboard(tostring(textData.player.UserId));
			elseif (btnType == 'Spectate') then
				setCameraSubject(textData.player.Character);
				textData.tooltip.Text = 'Unspectate';
			elseif (btnType == 'Unspectate') then
				setCameraSubject(LocalPlayer.Character);
				textData.tooltip.Text = 'Spectate';
			elseif (btnType == 'Report User') then

			end;
		end);

		chatLogger.OnUpdate:Connect(function(updateType, vector)
			library.configVars['chatLogger' .. updateType] = tostring(vector);
		end);

		library.OnLoad:Connect(function()
			local chatLoggerSize = library.configVars.chatLoggerSize;
			chatLoggerSize = chatLoggerSize and Vector2.new(unpack(chatLoggerSize:split(',')));

			local chatLoggerPosition = library.configVars.chatLoggerPosition;
			chatLoggerPosition = chatLoggerPosition and Vector2.new(unpack(chatLoggerPosition:split(',')));

			if (chatLoggerSize) then
				chatLogger:SetSize(UDim2.fromOffset(chatLoggerSize.X, chatLoggerSize.Y));
			end;

			if (chatLoggerPosition) then
				chatLogger:SetPosition(UDim2.fromOffset(chatLoggerPosition.X, chatLoggerPosition.Y));
			end;

			chatLogger:UpdateCanvas();
		end);
	end;

	function TextLogger.new(params)
		params = params or {};
		params.buttons = params.buttons or {};
		params.title = params.title or 'No Title';

		local self = setmetatable({}, TextLogger);
		local screenGui = library:Create('ScreenGui', {IgnoreGuiInset = true, Enabled = false, AutoLocalize = false});

		self.params = params;
		self._gui = screenGui;
		self.logs = {};
		self.allLogs = {};

		self.OnPlayerChatted = Signal.new();
		self.OnClick = Signal.new();
		self.OnUpdate = Signal.new();

		local main = library:Create('Frame', {
			Name = 'Main',
			Active = true,
			Visible = true,
			Size = UDim2.new(0, 500, 0, 300),
			Position = UDim2.new(0.5, -250, 0.5, -150),
			BackgroundTransparency = 0.3,
			BackgroundColor3 = TextLogger.Colors.Background,
			Parent = screenGui
		});

		self._main = main;

		local dragger = library:Create('Frame', {
			Parent = main,
			Active = true,
			BackgroundTransparency = 1,
			Size = UDim2.new(0, 50, 0, 50),
			Position = UDim2.new(1, 10, 1, 10),
			AnchorPoint = Vector2.new(1, 1)
		});

		library:Create('UICorner', {
			Parent = main,
			CornerRadius = UDim.new(0, 4),
		});

		library:Create('UIStroke', {
			Parent = main,
			Color = TextLogger.Colors.Border
		});

		local title = library:Create('TextButton', {
			Parent = main,
			Size = UDim2.new(1, 0, 0, 30),
			BackgroundTransparency = 1,
			TextColor3 = TextLogger.Colors.TitleColor,
			Font = Enum.Font.Roboto,
			Text = params.title,
			TextSize = 20
		});

		local dragStart;
		local startPos;
		local dragging;

		dragger.InputBegan:Connect(function(inputObject, gpe)
			if (inputObject.UserInputType == Enum.UserInputType.MouseButton1) then
				local dragStart = inputObject.Position;
				dragStart = Vector2.new(dragStart.X, dragStart.Y);

				local startPos = main.Size;

				repeat
					local mousePosition = UserInputService:GetMouseLocation();
					local delta = mousePosition - dragStart;

					main.Size = UDim2.new(0, startPos.X.Offset + delta.X, 0, (startPos.Y.Offset + delta.Y) - 36);

					task.wait();
				until (inputObject.UserInputState == Enum.UserInputState.End);

				self:UpdateCanvas();
				self.OnUpdate:Fire('Size', main.AbsoluteSize);
			end;
		end);

		title.InputBegan:Connect(function(inputObject, gpe)
			if (inputObject.UserInputType ~= Enum.UserInputType.MouseButton1) then return end;

			dragging = true;

			dragStart = inputObject.Position;
			startPos = main.Position;

			repeat
				task.wait();
			until inputObject.UserInputState == Enum.UserInputState.End;

			self.OnUpdate:Fire('Position', main.AbsolutePosition);
			dragging = false;

			self:UpdateCanvas();
		end);

		UserInputService.InputChanged:Connect(function(input, gpe)
			if (not dragging or input.UserInputType ~= Enum.UserInputType.MouseMovement) then return end;

			local delta = input.Position - dragStart;
			local yPos = startPos.Y.Offset + delta.Y;
			main:TweenPosition(UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, yPos), 'Out', 'Quint', 0.1, true);
		end);

		local titleBorder = library:Create('Frame', {
			Parent = title,
			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 1,
		});

		library:Create('UICorner', {
			Parent = titleBorder,
			CornerRadius = UDim.new(0, 4),
		});

		library:Create('UIStroke', {
			Parent = titleBorder,
			Color = TextLogger.Colors.Border
		});

		local logsContainer = library:Create('Frame', {
			Parent = main,
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, -35),
			Position = UDim2.fromOffset(0, 35)
		});

		library:Create('UIPadding', {
			Parent = logsContainer,
			PaddingBottom = UDim.new(0, 10),
			PaddingLeft = UDim.new(0, 10),
			PaddingRight = UDim.new(0, 10),
			PaddingTop = UDim.new(0, 10),
		});

		local logs = library:Create('ScrollingFrame', {
			Parent = logsContainer,
			ClipsDescendants = true,
			BorderSizePixel = 0,
			Size = UDim2.fromScale(1, 1),
			BackgroundTransparency = 1,
			BottomImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
			MidImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
			TopImage = 'rbxasset://textures/ui/Scroll/scroll-middle.png',
			ScrollBarThickness = 5,
			CanvasSize = UDim2.new(0, 0, 0, 0),
			ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
		});

		self._layout = library:Create('UIListLayout', {
			Parent = logs,
			Padding = UDim.new(0, 5),
			FillDirection = Enum.FillDirection.Vertical,
			HorizontalAlignment = Enum.HorizontalAlignment.Left,
			SortOrder = Enum.SortOrder.LayoutOrder,
			VerticalAlignment = Enum.VerticalAlignment.Top,
		});

		local toolTip = library:Create('Frame', {
			Parent = screenGui,
			BackgroundColor3 = TextLogger.Colors.Background,
			Size = UDim2.new(0, 150, 0, 0),
			ZIndex = 100,
			ClipsDescendants = true,
			Visible = false,
		});

		library:Create('UICorner', {
			Parent = toolTip,
			CornerRadius = UDim.new(0, 8),
		});

		library:Create('UIStroke', {
			Parent = toolTip,
			Color = TextLogger.Colors.Border,
		});

		library:Create('UIListLayout', {
			Parent = toolTip,
			Padding = UDim.new(0, 0),
			FillDirection = Enum.FillDirection.Vertical,
			HorizontalAlignment = Enum.HorizontalAlignment.Left,
			SortOrder = Enum.SortOrder.LayoutOrder,
			VerticalAlignment = Enum.VerticalAlignment.Top,
		});

		self._toolTip = toolTip;

		local function makeButton(btnName)
			local button = library:Create('TextButton', {
				Parent = toolTip,
				Size = UDim2.new(1, 0, 0, 30),
				BackgroundTransparency = 1,
				Font = Enum.Font.Roboto,
				Text = btnName,
				TextSize = 15,
				TextColor3 = TextLogger.Colors.TitleColor,
				ZIndex = 100
			});

			local textTweenIn = TweenService:Create(button, TweenInfo.new(0.1), {
				TextColor3 = Color3.fromRGB(200, 200, 200)
			});

			local textTweenOut = TweenService:Create(button, TweenInfo.new(0.1), {
				TextColor3 = Color3.fromRGB(255, 255, 255)
			});

			button.MouseEnter:Connect(function()
				textTweenIn:Play();
			end);

			button.MouseLeave:Connect(function()
				textTweenOut:Play();
			end);

			button.InputBegan:Connect(function(inputObject, gpe)
				if (gpe or inputObject.UserInputType ~= Enum.UserInputType.MouseButton1) then return end;

				self._currentToolTip.tooltip = button;
				self.OnClick:Fire(button.Text, self._currentToolTip, self._currentToolTipIndex);
			end);
		end;

		self._logs = logs;

		--syn.protect_gui(screenGui);
		screenGui.Parent = game.CoreGui;

		UserInputService.InputBegan:Connect(function(input)
			local userInputType = input.UserInputType;

			if (userInputType == Enum.UserInputType.MouseButton1) then
				self._toolTip:TweenSize(UDim2.new(0, 150, 0, 0), 'Out', 'Quad', 0.1, true, function()
					self._toolTip.Visible = false;
				end);

				self._currentToolTip = nil;
				self._currentToolTipIndex = nil;
			end;
		end);

		for _, v in next, params.buttons do
			makeButton(v);
		end;

		if (params.preset == 'chatLogger') then
			initChatLoggerPreset(self);
		end;

		return self;
	end;

	function TextLogger:AddText(textData)
		textData._parent = self;
		local textObject = Text.new(textData);

		return textObject;
	end;

	function TextLogger:SetVisible(state)
		self._gui.Enabled = state;
	end;

	function TextLogger:UpdateCanvas()
		for _, v in next, self.logs do
			local textSize = TextService:GetTextSize(v.label.ContentText, 20, Enum.Font.Roboto, Vector2.new(self._logs.AbsoluteSize.X, math.huge));
			v.label.Size = UDim2.new(1, 0, 0, textSize.Y);
		end;

		local contentSize = self._layout.AbsoluteContentSize;

		self._logs.CanvasSize = UDim2.fromOffset(0, contentSize.Y);

		if (library.flags.chatLoggerAutoScroll) then
			self._logs.CanvasPosition = Vector2.new(0, contentSize.Y);
		end;
	end;

	function TextLogger:SetSize(size)
		self._main.Size = size;
		self:UpdateCanvas();
	end;

	function TextLogger:SetPosition(position)
		self._main.Position = position;
		self:UpdateCanvas();
	end;

	return TextLogger;
end)();

sharedRequires['fromHex'] = (function()
	local function fromHex(str)
		return (string.gsub(str, '..', function (cc)
			return string.char(tonumber(cc, 16));
		end));
	end;

	return fromHex;
end)();
print("ok4")
sharedRequires['c83ce6a4e7b2a57431226bcf42132062a87d15e0887c9580ba22afdca872839f'] = (function()
	return [[{"2637545558":"Silver Ring","5069102444":"Stick","7808606344":"Green Adventurer Coat","6448694082":"Herbalist's Hat","7808436873":"Guard's Kabuto","7808435817":"Red Royal Guard","7032469171":"Spark Gland","5842121293":"Ranger's Boots","8700290376":"Smoke Ministry Cloak","4673673233":"Messer","8765495788":"Flamekeeper Cestus","8700292068":"Purple Royal Duelist","7808426095":"Black Adventurer Coat","6448695746":"Crescent Cleaver","10944864312":"Kyrscleave","8700297246":"Red Justicar Defender","7837367316":"Dawn Scarf","5405133671":"Gremorian Longspear","7819487839":"Aristocrat Glasses","11493419845":"Rifle Spear","5799297150":"Ten-gallon Hat","9337204134":"Bounder Claw","6429369728":"Seafood Boil","5855133355":"Vigil Hood","7036471589":"Reversal Spark","7836919224":"Forest Scarf","7013706647":"Silver Ring","5799298101":"Novice Brace","9969347036":"Ironsinger Heavy Plate","7837621224":"Black Shrouded Cape","5907307871":"Brilliant Cape","5842120234":"Hunter's Brace","7808436633":"Captain's Kabuto","5405135270":"Falchion","8270698605":"Iron Cestus","7013402708":"Isshin's Ring","6448728441":"Star Duster","5705963126":"Blacksteel Pauldrons","8700281529":"Sage Pathfinder Elite","11491707869":"Kyrstreza","8280107937":"The Path's Defender","6448742964":"Razor Cutlass","10431523243":"Gran Sudaruska","5405136068":"Vigil Longsword","8700640454":"Umber First Ranger Duster","5405134593":"Gilded Knife","5842122844":"Imperial Boots","7032715026":"Gale Stone","9960339048":"Phalanx Helm","5054802060":"Broken Gatling Gun","7837370563":"White Scarf","7808431912":"Shattered Katana","5842122594":"Autumn Boots","6132543079":"Bloodfeather Cowl","5842969006":"Worshipper's Shield","5842121371":"Redsteel Boots","11123380641":"Browncap","4653682385":"Mace","6419942986":"Calamari","7808435621":"Hivelord Mask","5405134478":"Whaling Knife","6448697951":"Azure Royal Guard","5894739497":"Apprentice Rapier","4665676177":"Plumfruit","6436226661":"Crystal Pendant Earrings","5405134330":"Adretian Axe","5799300555":"Black Fur Pauldrons","8700291659":"Green Royal Duelist","5799299766":"Imperial Pauldrons","7819487052":"Red Aristocrat Glasses","6249271537":"Flintlock","9960340205":"Mercenary's Garb","7808435989":"Blue Royal Guard","11508432095":"Enforcer's Axe","6012236150":"Kite Shield","6436226327":"Ruby Drop Earrings","6424915152":"Scallop","6448694267":"Herbalist's Hat","6424915468":"Urchin","5405138402":"Hero Blade Of Shadow","7650051743":"Sword","5799297636":"Feathertop Helm","5799300308":"Bluesteel Pauldrons","5799295812":"Black Deepwoken Cloak","13002269112":"Flareblood Kamas","8121417213":"Tanto","6489268160":"Rosen's Peacemaker","6448694802":"Vagabond's Bicorn","5714510638":"Blacksteel Helm","6448702481":"Grand Boots","6419750949":"Sea Bass","5799297250":"Black Blindfold","7666186674":"White Gumshoe Longcoat","7837370225":"Black Scarf","6669315144":"Authority Helm","8764565495":"Canor Fang","5799295080":"Investigator's Hat","8138184965":"Champion's Sword","8699695290":"First Light","9960336716":"Sandrunner Scarf","6429530863":"Demon Mask","5405134819":"Silver Dagger","6448698418":"Azure Royal Guards","7673608398":"Beige Aristocrat Coat","8700289279":"Red Ministry Cloak","7808427062":"Brown Adventurer Coat","8700287249":"Green Megalodaunt Coat","6022452972":"Khan Shield","5705963429":"Canticlysm Pendant","5049245745":"Wheat","5799302611":"Nomad Pendant","5628707607":"Strange Claw","7837621530":"Midnight Shrouded Cape","8700357191":"Magenta Elite Pathfinder","8700640450":"Azure First Ranger Duster","5817301154":"Vanguard Brace","5805397315":"Smith's Gloves","5850589846":"Legate Helm","9960339470":"Phalanx Heavy Boots","5051248589":"Calabash","9048865551":"Railblade","5705976072":"Moonlit Earrings","5542033067":"Leather Boots","8700290825":"Peach Ministry Cloak","7837620789":"Red Shrouded Cape","8700640449":"Lavender First Ranger Duster","8700292776":"Rose Royal Duelist","5405133451":"Ritual Spear","9752895127":"Inquisitor's Thorn","5405135891":"Officer Saber","6448694628":"Alchemist Hat","5842122067":"Black Fur Boots","5799303918":"Emerald Tusk Earrings","7808431156":"Pale Assassin's Cloak","7837360302":"Tundra Scarf","9960341323":"Celtorian Sabatons","11468956988":"Petra's Anchor","7666184050":"Grey Gumshoe Longcoat","6448696178":"Darksteel Greatsword","4673703249":"Iron Spear","9960338123":"Bulwark Helm","7666186063":"Black Gumshoe Longcoat","8699695169":"Night Axe","5799296946":"Brigand's Bicorn","5799303611":"Pendant Earrings","12868100519":"Crypt Blade","5705963723":"Old Blood Earrings","6334456831":"Hivelord Hubris","5706119518":"Gladiator Pauldrons","10374163255":"Hive Scourge Cuirass","7819486539":"Polarized Eyeglasses","8700640465":"Jade First Ranger Duster","5606047864":"Schematic","11122387292":"Dentifilo","6448698795":"Iron Pauldrons","5405138500":"Krulian Knife","9594272549":"Megurger","6132703115":"Bloodfeather Mask","10374055286":"Etrean Siege Sabatons","6448700096":"Enforcer Plate","7666184629":"Gumshoe Hat","6448692964":"Blindfold","5048774760":"Coral","10857130088":"Iron Birch","7771927612":"Worn Cog","6498239550":"Konga's Clutch Ring","4673700644":"Stiletto","5849612301":"Leather Pauldrons","8230193135":"Dark Feather","5842122480":"Bluesteel Boots","5405135657":"Officer Saber","5799301768":"Woodland Pauldrons","6448693907":"Glassdancer Wraps","5799298923":"White Parka","5405134045":"Forge Greathammer","6424914992":"Chum","5799301251":"Redsteel Pauldrons","5610004726":"Master Thief Earrings","6436226803":"Dew Drop Earrings","6424318342":"Fish Omelette","5849601024":"Halberd","12500495992":"Akira's Ring","10374148323":"Winter Corps Parka","8275365134":"Ethiron Curseshield","7038529675":"Aeon Logstone","10653583718":"Light's Final Toll","5799300026":"Autumn Pauldrons","9960335808":"Dark Owl Cloak","6274335402":"Black Hood","8699695073":"Acheron's Warspear","5707321653":"Confessor's Charm","9960341166":"Celtor Commander Plate","9960340839":"Celtor Helm","5799302078":"Flameguard Pauldrons","12900346985":"Curved Blade Of Winds","5714510949":"Gladiator Helmet","6436226542":"Amethyst Pendant Earrings","5877374213":"Black Cape","8700291376":"Red Royal Duelist","5907308073":"Brilliant Pauldrons","6448695545":"Knight's Helm","10649431674":"Iron Blunderbuss","5799299115":"Black Parka","8700296939":"Black Justicar Defender","7013783109":"Silver Ring","5106910210":"Megalodaunt Coral","8229693222":"Thresher Spine","8700281646":"Ash Pathfinder Elite","7032332910":"Frigid Prism","6022452674":"Khan Boots","6349514972":"Targe","5842122238":"White Fur Boots","8700281155":"Black Pathfinder Elite","10374052860":"Etrean Siege Cuirass","5799303085":"Red Eye Pendant","10374149549":"Winter Corps Boots","9960337717":"Grand Authority Plate","8280463944":"Old World Greatshield","5405134185":"Canorian Axe","5805397758":"Smith Bandana","5405135397":"Zweihander","7808435506":"Duelist's Mask","7666184486":"Ochre Gumshoe Longcoat","8700290043":"Yellow Ministry Cloak","8700289897":"Verdant Ministry Cloak","9995290481":"Frozen Membrane","5799301536":"Ranger's Brace","5405133921":"Steel Maul","7837363369":"Crimson Scarf","8699695168":"Relic Axe","7808436350":"Royal Guard's Kabuto","6424318416":"Mushroom Omelette","5043681225":"Mushroom Soup","10374079308":"Ministry Operative Cloak","11237117285":"Enforcer's Blade","5405136314":"Pale Morning","5058929875":"Ongo","5799297023":"Eyeglasses","5799297369":"Strapped Hat","5557731080":"Barrel Helm","5069092985":"Wood","6448699922":"Enforcer Boots","8700282599":"Crimson Pathfinder Elite","8700297896":"Purple Justicar Defender","5805397989":"Smith's Goggles","6424318273":"Fish Meat","10944864020":"Kyrstear","9960336308":"Dark Owl Chapeau","5842120380":"Vanguard Boots","8700289423":"Onyx Ministry Cloak","5799295189":"Polarized Eyeglasses","6022452767":"Khan Pauldrons","5799295349":"Dark Cowl","5058784034":"Spider Egg","6448697007":"Warden Ceremonial Sword","8700287002":"Red Megalodaunt Coat","6448696838":"Iron Mask","8700286805":"Blue Megalodaunt Coat","5714510810":"Guardian Helm","5705962526":"Guardian Pauldrons","8699695269":"Inquisitor's Straight Sword","5922042274":"Cloth","4673718281":"Battleaxe","7837617108":"White Shrouded Cape","7836920551":"Desert Scarf","4673679440":"Katana","8700291113":"Faded Royal Duelist","5045088863":"Bamboo Bundle","9960337519":"Grand Authority Sabatons","5799296265":"Brown Parka","8699695180":"True Seraph's Spear","5842121006":"Woodland Boots","10944863839":"Kyrsblade","5842123154":"Tracker's Boots","8699695052":"Evanspear Handaxe","11398158868":"Enforcer Hammer","4673686878":"Scimitar","6448694456":"Alchemist's Hat","8700287472":"Blue Megalodaunt Coat","5558108814":"Silver Ring","8274858821":"Legion Cestus","6448696405":"Shotel","5799302810":"Varicosa Medallion","5799302952":"Bloodcurse Pendant","5907308163":"Brilliant Boots","6424318562":"Sushi","8700297663":"Faded Justicar Defender","9960338845":"Legion Phalanx Plate","6448701754":"Grand Pauldrons","6436226440":"Practicioner's Earrings","6695910473":"Enforcer Eye","8700288111":"Peach Megalodaunt Coat","6448694964":"Crimson Blindfold","8699695126":"Sacred Hammer","8700292481":"Dark Royal Duelist","8700298677":"Orange Justicar Defender","8700287807":"Brown Megalodaunt Coat","5799295446":"Red Headband","5799297882":"Silver Pauldrons","5850573360":"Simple Pauldrons","8699695031":"Serrated Warspear","9960340613":"Mercenary's Boots","8699695191":"Great Maul","5799304203":"Seafarer Pendant","11491707780":"Kyrsedge","7837361566":"Desert Scarf","6419942901":"Egg","6448695134":"Investigator's Hat","5799300695":"White Fur Pauldrons","8700640458":"Cloud First Ranger Duster","8699695246":"Forgotten Gladius","7808435294":"Assassin's Hood","5842123537":"Silver Sabatons","8215631291":"Thresher Talon","5799297473":"Ten-gallon Bandana","5842123345":"Novice Boots","9960336983":"Sandrunner Wraps","6448728622":"Star Boots","6448698967":"Iron Boots","7023923881":"Dying Embers","5052282912":"Beeswax","6471674350":"Dragoon","6448695350":"Blackleaf Helm","5799296847":"Brigand Cloak","6448695945":"Serpent's Edge","5058929959":"Redd","4665615318":"Pomar","10944864619":"Kyrsglaive","7036671370":"Umbral Obsidian","5557731910":"Steel Pauldrons","5842120635":"Woodland Boots","9752893846":"Crucible Rapier","7808426565":"White Deepwoken Cloak","8700298453":"Pink Justicar Defender","6022467997":"Khan Helmet","6481418019":"Revolver","9960336188":"Dark Owl Cape","5799472140":"Black Parka","6406423250":"Providence Coat","11122306597":"Gobletto","9971524012":"Old World Sun Pendant","5405135049":"Worshipper Longsword","7808425864":"Royal Pathfinder","8764565306":"Nemit's Sickle","8699695303":"Markor's Inheritor","5405133802":"Trident Spear"}]]
end)();

sharedRequires['86ff59a72aa0134033a45a2517ab434d34ec44d886554adb2efc1b5600868d9b'] = (function()
	local LocalPlayer = game:GetService('Players').LocalPlayer;
	local ReplicatedStorage = game:GetService('ReplicatedStorage');

	local Maid = sharedRequires['Maid'];
	local ToastNotif = sharedRequires['ToastNotif'];

	local function createCirclet(parent, weldPart, cframe, color)
		local circlet = game:GetObjects('rbxassetid://12562484379')[1]:Clone();
		circlet.Size = Vector3.new(1.372, 0.198, 1.396);
		circlet.Parent = parent;

		if (color) then
			circlet.Color = color;
		end;

		local weld = Instance.new('Weld', circlet);
		weld.Part0 = weldPart;
		weld.Part1 = circlet;
		weld.C0 = cframe;

		return circlet;
	end;

	return function (misc)
		local functions = {};
		local globalMaid = Maid.new();

		local function makeToggle(name, parts, offset)
			local maid = Maid.new();
			local currentColor;

			misc:AddToggle({
				text = name,
				callback = function(t)
					if (not t) then
						maid:DoCleaning();
						return;
					end;

					local function onCharacterAdded(character)
						if (not character) then return end;

						for i, partName in next, parts do
							task.spawn(function()
								local partObject = character:WaitForChild(partName, 5);
								if (not partObject) then return end;

								maid[name .. i] = createCirclet(character, partObject, offset, currentColor);
							end);
						end;
					end;

					onCharacterAdded(LocalPlayer.Character);
					maid:GiveTask(LocalPlayer.CharacterAdded:Connect(onCharacterAdded));
				end
			}):AddColor({
				text = name,
				callback = function(color)
					for i = 1, #parts do
						if (not maid[name..i]) then continue end;
						maid[name .. i].Color = color;
					end;

					currentColor = color;
				end
			});
		end;

		local turnedOn = false;

		function functions.lightbornSkinColor(t)
			if (not t) then
				globalMaid.lightbornSkinColor = nil;
				if (turnedOn) then
					turnedOn = false;
					ToastNotif.new({text = 'Respawn to get back old skin color'});
				end;
				return;
			end;

			turnedOn = true;

			globalMaid.lightbornSkinColor = task.spawn(function()
				while true do
					task.wait(0.1);
					if (not LocalPlayer.Character) then continue end;
					pcall(function()
						LocalPlayer.Character.Head.FaceMount.DGFace.Texture = "rbxassetid://6466188578"
					end);
					for _, v in next, LocalPlayer.Character:GetChildren() do
						if (v.Name == 'LightbornCirclet') then continue end;
						if (v:FindFirstChild('MarkingMount')) then
							v.MarkingMount.Color = Color3.fromRGB(253, 234, 141);
						elseif (v:IsA('BasePart')) then
							v.Color = Color3.fromRGB(253, 234, 141);
						end;
					end;
				end;
			end);
		end;

		local function contractorToggle(t)
			if (not t) then
				globalMaid.contractorCharAdded = nil;
				globalMaid.contractorParts = nil;
				return;
			end;

			local function onCharacterAdded(character)
				if (not character) then return end;
				local char = LocalPlayer.Character;
				local hrp = char:WaitForChild('HumanoidRootPart', 10);
				if (not hrp) then return end;

				local string = ReplicatedStorage.Assets.Effects.ContractorString;
				local clone1, clone2, clone3, clone4;

				do
					clone1 = string:Clone();
					clone1.Parent = hrp;

					local attachment1 = Instance.new("Attachment",hrp);
					attachment1.Position = Vector3.new(1,5,0);
					attachment1.Name = "StringAttach1";--AboveHrp

					local attachment2 = Instance.new("Attachment",char.RightHand);
					attachment2.Position = Vector3.new(0.5,0,0);
					attachment2.Name = "StringAttach2";--RightHand

					clone1.Attachment1 = attachment1;
					clone1.Attachment0 = attachment2;


					clone2 = string:Clone();
					clone2.Parent = hrp;

					local attachment3 = Instance.new("Attachment",hrp);
					attachment3.Position = Vector3.new(-1,5,0);
					attachment3.Name = "StringAttach3";--AboveHrp

					local attachment4 = Instance.new("Attachment",char.LeftHand);
					attachment4.Position = Vector3.new(-0.5,0,0);
					attachment4.Name = "StringAttach4";--LeftHand

					clone2.Attachment1 = attachment3;
					clone2.Attachment0 = attachment4;
				end

				do
					clone3 = string:Clone();
					clone3.Parent = hrp;

					local attachment3 = Instance.new("Attachment",hrp);
					attachment3.Position = Vector3.new(0.5,5,0);
					attachment3.Name = "StringAttach3";--RightShoulder

					clone3.Attachment1 = attachment3;
					clone3.Attachment0 = char.Torso.RightCollarAttachment;

					clone4 = string:Clone();
					clone4.Parent = hrp;

					local attachment4 = Instance.new("Attachment",hrp);
					attachment4.Position = Vector3.new(-1,5,0);
					attachment4.Name = "StringAttach4"; --LeftShoulder

					clone4.Attachment1 = attachment4;
					clone4.Attachment0 = char.Torso.LeftCollarAttachment;
				end

				globalMaid.contractorParts = function()
					clone1:Destroy();
					clone2:Destroy();
					clone3:Destroy();
					clone4:Destroy();
				end;
			end

			onCharacterAdded(LocalPlayer.Character);
			globalMaid.contractorCharAdded = LocalPlayer.CharacterAdded:Connect(onCharacterAdded);
		end

		misc:AddToggle({text = 'Lightborn Skin Color', callback = functions.lightbornSkinColor})

		makeToggle('Lightborn (Variant 1)', {'Head'}, CFrame.new(-0.001, 0.754, -0.002));
		makeToggle('Lightborn (Variant 2)', {'Head'}, CFrame.new(-0.001, -0.35, -0.002));
		makeToggle('Lightborn (Variant 3)', {'Right Arm', 'Left Arm'}, CFrame.new(-0.001, -0.5, -0.002));

		misc:AddToggle({
			text = 'Contractor',
			callback = contractorToggle
		})
	end;
end)();

sharedRequires['findPlayer'] = (function()
	local Services = sharedRequires['Services']
	local Players = Services:Get('Players');

	return function (playerName)
		for _, v in next, Players:GetPlayers() do
			if(v.Name:lower():sub(1, #playerName) == playerName:lower()) then
				return v;
			end;
		end;
	end;
end)()

sharedRequires['getImageSize'] = (function()
	local Buffer = {};

	Buffer.ClassName = 'Buffer';
	Buffer.__index = Buffer;

	function Buffer.new(data)
		local self = setmetatable({}, Buffer);

		self._data = data;
		self._pos = 0;

		return self;
	end;

	function Buffer:read(num)
		local data = self._data:sub(self._pos + 1, self._pos + num);
		self._pos = self._pos + num;

		return data;
	end;

	local function read(str)
		return str:sub(1,1):byte() * 16777216 + str:sub(2,2):byte() * 65536 + str:sub(3,3):byte() * 256 + str:sub(4,4):byte();
	end;

	local function getImageSize(imageData)
		local buffer = Buffer.new(imageData);

		buffer:read(1);

		if(buffer:read(3) == 'PNG') then
			buffer:read(12);

			local width = read(buffer:read(4));
			local height = read(buffer:read(4));

			return Vector2.new(width, height);
		end;

		buffer:read(-4);

		if (buffer:read(4) == "GIF8") then
			buffer:read(2);

			local width = buffer:read(1):byte()+buffer:read(1):byte()*256;
			local height = buffer:read(1):byte()+buffer:read(1):byte()*256;

			return Vector2.new(width, height);
		end;
	end;

	return getImageSize;
end)()

sharedRequires['basics'] = (function()
	local AudioPlayer = sharedRequires['AudioPlayer'];
	local makeESP = sharedRequires['makeESP'];
	local Utility = sharedRequires['Utility'];
	local Maid = sharedRequires['Maid'];
	local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
	local Services = sharedRequires['Services'];
	local createBaseESP = sharedRequires['createBaseESP'];
	local EntityESP = sharedRequires['EntityESP'];
	local ControlModule = sharedRequires['ControlModule'];
	local ToastNotif = sharedRequires['ToastNotif'];
	local BlockUtils = sharedRequires['BlockUtils'];
	local TextLogger = sharedRequires['TextLogger'];
	local fromHex = sharedRequires['fromHex'];
	local toCamelCase = sharedRequires['toCamelCase'];
	local Webhook = sharedRequires['Webhook'];
	local Signal = sharedRequires['Signal'];
	local prettyPrint = sharedRequires['prettyPrint'];

	local Players, UserInputService, Lighting, RunService = Services:Get('Players', 'UserInputService', 'Lighting', 'RunService');
	local LocalPlayer = Players.LocalPlayer;

	local basicsHelpers = {};

	local chatFocused = false;
	local maid = Maid.new();

	UserInputService.TextBoxFocused:Connect(function()
		chatFocused = true;
	end);

	UserInputService.TextBoxFocusReleased:Connect(function()
		chatFocused = false;
	end);

	function basicsHelpers.infiniteJump(toggle)
		if(not toggle) then return end;

		repeat
			local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
			if(rootPart and UserInputService:IsKeyDown(Enum.KeyCode.Space) and not chatFocused) then
				rootPart.Velocity = Vector3.new(rootPart.Velocity.X, library.flags.infiniteJumpHeight, rootPart.Velocity.Z);
			end;
			task.wait(0.1);
		until not library.flags.infiniteJump;
	end;

	local lastFogDensity = 0;

	function basicsHelpers.noFog(t)
		if not t then Lighting.Atmosphere.Density = lastFogDensity; maid.noFog = nil; return; end

		maid.noFog = Lighting.Atmosphere:GetPropertyChangedSignal('Density'):Connect(function()
			Lighting.Atmosphere.Density = 0;
		end);

		lastFogDensity = Lighting.Atmosphere.Density;
		Lighting.Atmosphere.Density = 0;
	end

	function basicsHelpers.noBlur(t)
		local dof = Lighting.DepthOfField;
		if not t then maid.noBlur = nil; dof.Enabled = true; return; end

		maid.noBlur = Lighting.DepthOfField:GetPropertyChangedSignal('Enabled'):Connect(function()
			if not dof.Enabled then return; end
			dof.Enabled = false;
		end);

		dof.Enabled = false;
	end

	local oldAmbient, oldBritghtness = Lighting.Ambient, Lighting.Brightness;

	function basicsHelpers.fullBright(toggle)
		if(not toggle) then
			maid.fullBright = nil;
			Lighting.Ambient, Lighting.Brightness = oldAmbient, oldBritghtness;
			return
		end;

		oldAmbient, oldBritghtness = Lighting.Ambient, Lighting.Brightness;
		maid.fullBright = Lighting:GetPropertyChangedSignal('Ambient'):Connect(function()
			Lighting.Ambient = Color3.fromRGB(255, 255, 255);
			Lighting.Brightness = 1;
		end);
		Lighting.Ambient = Color3.fromRGB(255, 255, 255);
	end;

	function basicsHelpers.speedHack(toggle)
		if (not toggle) then
			maid.speedHack = nil;

			local humanoid = Utility:getPlayerData().humanoid;
			if (not humanoid) then return; end;
			humanoid.WalkSpeed = 16;

			return;
		end;

		maid.speedHack = RunService.Heartbeat:Connect(function()
			local humanoid = Utility:getPlayerData().humanoid;
			if (not humanoid) then return; end;

			humanoid.WalkSpeed = library.flags.speedHackValue
		end);
	end;

	function basicsHelpers.flyHack(toggle)
		if (not toggle) then
			maid.flyHack = nil;
			maid.flyBv = nil;
			return;
		end;

		maid.flyBv = Instance.new('BodyVelocity');
		maid.flyBv.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

		maid.flyHack = RunService.Heartbeat:Connect(function()
			local playerData = Utility:getPlayerData();
			local rootPart, camera = playerData.rootPart, workspace.CurrentCamera;
			if (not rootPart or not camera) then return end;

			maid.flyBv.Parent = rootPart;
			maid.flyBv.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.flyHackValue);
		end);
	end;

	function basicsHelpers.noclip(toggle)
		if (not toggle) then
			maid.noclip = nil;

			local humanoid = Utility:getPlayerData().humanoid;
			if (not humanoid) then return end;

			humanoid:ChangeState('Physics');
			task.wait();
			humanoid:ChangeState('RunningNoPhysics');
			return;
		end;

		maid.noclip = RunService.Heartbeat:Connect(function()
			local parts = Utility:getPlayerData().parts;
			if (not parts) then return; end;

			for _, part in next, parts do
				part.CanCollide = false;
			end;
		end);
	end;

	return basicsHelpers;
end)()

sharedRequires['mobfarm'] = (function()
	local AudioPlayer = sharedRequires['AudioPlayer'];
	local makeESP = sharedRequires['makeESP'];
	local Utility = sharedRequires['Utility'];
	local Maid = sharedRequires['Maid'];
	local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
	local Services = sharedRequires['Services'];
	local createBaseESP = sharedRequires['createBaseESP'];
	local EntityESP = sharedRequires['EntityESP'];
	local ControlModule = sharedRequires['ControlModule'];
	local ToastNotif = sharedRequires['ToastNotif'];
	local BlockUtils = sharedRequires['BlockUtils'];
	local TextLogger = sharedRequires['TextLogger'];
	local fromHex = sharedRequires['fromHex'];
	local toCamelCase = sharedRequires['toCamelCase'];
	local Webhook = sharedRequires['Webhook'];
	local Signal = sharedRequires['Signal'];
	local prettyPrint = sharedRequires['prettyPrint'];


	local TweenService, RunService = Services:Get('TweenService', 'RunService');
	local mobfarmHelper = {};
	local allTweens = {};

	function mobfarmHelper:getClosest(folder, options)
		assert(typeof(options) == 'table');
		options.maxDistance = options.maxDistance or math.huge;

		local rootPart = options.rootOverride or Utility:getPlayerData().rootPart;
		if (not rootPart) then return nil; end;

		local closestDistance, closestMob = math.huge, nil;

		for _, child in next, typeof(folder) == 'table' and folder or folder:GetChildren() do
			local mobRoot = options.getRoot and options.getRoot(child) or child:FindFirstChild('HumanoidRootPart');
			if (not mobRoot) then continue end;
			if (options.isAlive and not options.isAlive(child)) then continue end;
			if (options.filter and not options.filter(child)) then continue end;

			local distance = (rootPart.Position - mobRoot.Position).Magnitude;
			if (options.prioritize and options.prioritize(child)) then return child, distance; end;

			if (distance < closestDistance and distance <= options.maxDistance) then
				closestDistance = distance;
				closestMob = child;
			end;
		end;

		return closestMob, closestDistance;
	end;

	function mobfarmHelper:tweenTeleport(goalCFrame, options)
		local rootPart = Utility:getPlayerData().rootPart;
		if (not rootPart) then return false; end;

		if (typeof(goalCFrame) == 'Vector3') then
			goalCFrame = CFrame.new(goalCFrame);
		end;

		options = options or {};
		options.tweenSpeed = options.tweenSpeed or library.flags.tweenSpeed or 100;
		options.offset = options.offset or CFrame.identity*goalCFrame.Rotation;

		if (options.instant) then
			options.tweenSpeed = 5000;
		end;

		mobfarmHelper.noPhysics(options);
		local maid = Maid.new();

		local distance = (rootPart.Position - goalCFrame.Position).Magnitude;

		if (options.tweenSpeedIgnoreY) then
			distance = Utility:roundVector(rootPart.Position - goalCFrame.Position).Magnitude;
		end;

		local tweenInfo = TweenInfo.new(distance / options.tweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut);
		local tween = TweenService:Create(rootPart, tweenInfo, {
			CFrame = goalCFrame * options.offset
		});

		allTweens[tween] = tween;
		maid:GiveTask(RunService.Heartbeat:Connect(function()
			mobfarmHelper.noPhysics(options);
		end));

		maid:GiveTask(function()
			allTweens[tween] = nil;
		end);

		maid:GiveTask(tween.Completed:Connect(function()
			maid:Destroy();
		end));

		tween:Play();
		return tween;
	end;

	function mobfarmHelper.noPhysics(options)
		local playerData = Utility:getPlayerData();
		local rootPart = playerData.rootPart;
		for _, part in next, playerData.parts do
			part.CanCollide = false;
		end;

		rootPart.CFrame = CFrame.new(rootPart.CFrame.Position) * options.offset.Rotation;
		if (not rootPart or rootPart:FindFirstChild('NoPhysics')) then return end;

		local bodyVelocity = Instance.new('BodyVelocity');
		bodyVelocity.Name = 'NoPhysics';
		bodyVelocity.MaxForce = Vector3.one * math.huge;
		bodyVelocity.Velocity = Vector3.zero;
		bodyVelocity.Parent = rootPart;
	end;

	function mobfarmHelper.destroyTweens()
		for i, v in next, allTweens do
			v:Cancel();
			allTweens[i] = nil;
		end;
	end;

	function mobfarmHelper.turnOffAutoFarm()
		mobfarmHelper.destroyTweens();
		mobfarmHelper.destroyNoPhysics();
	end;

	function mobfarmHelper.destroyNoPhysics()
		local playerData = Utility:getPlayerData();
		local rootPart = playerData.rootPart;
		if (not rootPart or not rootPart:FindFirstChild('NoPhysics')) then return end;

		rootPart.NoPhysics:Destroy();
	end;

	return mobfarmHelper;
end)()

sharedRequires['mobfarm'] = (function()
	local AudioPlayer = sharedRequires['AudioPlayer'];
	local makeESP = sharedRequires['makeESP'];
	local Utility = sharedRequires['Utility'];
	local Maid = sharedRequires['Maid'];
	local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
	local Services = sharedRequires['Services'];
	local createBaseESP = sharedRequires['createBaseESP'];
	local EntityESP = sharedRequires['EntityESP'];
	local ControlModule = sharedRequires['ControlModule'];
	local ToastNotif = sharedRequires['ToastNotif'];
	local BlockUtils = sharedRequires['BlockUtils'];
	local TextLogger = sharedRequires['TextLogger'];
	local fromHex = sharedRequires['fromHex'];
	local toCamelCase = sharedRequires['toCamelCase'];
	local Webhook = sharedRequires['Webhook'];
	local Signal = sharedRequires['Signal'];
	local prettyPrint = sharedRequires['prettyPrint'];


	local TweenService, RunService = Services:Get('TweenService', 'RunService');
	local mobfarmHelper = {};
	local allTweens = {};

	function mobfarmHelper:getClosest(folder, options)
		assert(typeof(options) == 'table');
		options.maxDistance = options.maxDistance or math.huge;

		local rootPart = options.rootOverride or Utility:getPlayerData().rootPart;
		if (not rootPart) then return nil; end;

		local closestDistance, closestMob = math.huge, nil;

		for _, child in next, typeof(folder) == 'table' and folder or folder:GetChildren() do
			local mobRoot = options.getRoot and options.getRoot(child) or child:FindFirstChild('HumanoidRootPart');
			if (not mobRoot) then continue end;
			if (options.isAlive and not options.isAlive(child)) then continue end;
			if (options.filter and not options.filter(child)) then continue end;

			local distance = (rootPart.Position - mobRoot.Position).Magnitude;
			if (options.prioritize and options.prioritize(child)) then return child, distance; end;

			if (distance < closestDistance and distance <= options.maxDistance) then
				closestDistance = distance;
				closestMob = child;
			end;
		end;

		return closestMob, closestDistance;
	end;

	function mobfarmHelper:tweenTeleport(goalCFrame, options)
		local rootPart = Utility:getPlayerData().rootPart;
		if (not rootPart) then return false; end;

		if (typeof(goalCFrame) == 'Vector3') then
			goalCFrame = CFrame.new(goalCFrame);
		end;

		options = options or {};
		options.tweenSpeed = options.tweenSpeed or library.flags.tweenSpeed or 100;
		options.offset = options.offset or CFrame.identity*goalCFrame.Rotation;

		if (options.instant) then
			options.tweenSpeed = 5000;
		end;

		mobfarmHelper.noPhysics(options);
		local maid = Maid.new();

		local distance = (rootPart.Position - goalCFrame.Position).Magnitude;

		if (options.tweenSpeedIgnoreY) then
			distance = Utility:roundVector(rootPart.Position - goalCFrame.Position).Magnitude;
		end;

		local tweenInfo = TweenInfo.new(distance / options.tweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut);
		local tween = TweenService:Create(rootPart, tweenInfo, {
			CFrame = goalCFrame * options.offset
		});

		allTweens[tween] = tween;
		maid:GiveTask(RunService.Heartbeat:Connect(function()
			mobfarmHelper.noPhysics(options);
		end));

		maid:GiveTask(function()
			allTweens[tween] = nil;
		end);

		maid:GiveTask(tween.Completed:Connect(function()
			maid:Destroy();
		end));

		tween:Play();
		return tween;
	end;

	function mobfarmHelper.noPhysics(options)
		local playerData = Utility:getPlayerData();
		local rootPart = playerData.rootPart;
		for _, part in next, playerData.parts do
			part.CanCollide = false;
		end;

		rootPart.CFrame = CFrame.new(rootPart.CFrame.Position) * options.offset.Rotation;
		if (not rootPart or rootPart:FindFirstChild('NoPhysics')) then return end;

		local bodyVelocity = Instance.new('BodyVelocity');
		bodyVelocity.Name = 'NoPhysics';
		bodyVelocity.MaxForce = Vector3.one * math.huge;
		bodyVelocity.Velocity = Vector3.zero;
		bodyVelocity.Parent = rootPart;
	end;

	function mobfarmHelper.destroyTweens()
		for i, v in next, allTweens do
			v:Cancel();
			allTweens[i] = nil;
		end;
	end;

	function mobfarmHelper.turnOffAutoFarm()
		mobfarmHelper.destroyTweens();
		mobfarmHelper.destroyNoPhysics();
	end;

	function mobfarmHelper.destroyNoPhysics()
		local playerData = Utility:getPlayerData();
		local rootPart = playerData.rootPart;
		if (not rootPart or not rootPart:FindFirstChild('NoPhysics')) then return end;

		rootPart.NoPhysics:Destroy();
	end;

	return mobfarmHelper;
end)()


sharedRequires['basics'] = (function()
	local AudioPlayer = sharedRequires['AudioPlayer'];
	local makeESP = sharedRequires['makeESP'];
	local Utility = sharedRequires['Utility'];
	local Maid = sharedRequires['Maid'];
	local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
	local Services = sharedRequires['Services'];
	local createBaseESP = sharedRequires['createBaseESP'];
	local EntityESP = sharedRequires['EntityESP'];
	local ControlModule = sharedRequires['ControlModule'];
	local ToastNotif = sharedRequires['ToastNotif'];
	local BlockUtils = sharedRequires['BlockUtils'];
	local TextLogger = sharedRequires['TextLogger'];
	local fromHex = sharedRequires['fromHex'];
	local toCamelCase = sharedRequires['toCamelCase'];
	local Webhook = sharedRequires['Webhook'];
	local Signal = sharedRequires['Signal'];
	local prettyPrint = sharedRequires['prettyPrint'];

	local Players, UserInputService, Lighting, RunService = Services:Get('Players', 'UserInputService', 'Lighting', 'RunService');
	local LocalPlayer = Players.LocalPlayer;

	local basicsHelpers = {};

	local chatFocused = false;
	local maid = Maid.new();

	UserInputService.TextBoxFocused:Connect(function()
		chatFocused = true;
	end);

	UserInputService.TextBoxFocusReleased:Connect(function()
		chatFocused = false;
	end);

	function basicsHelpers.infiniteJump(toggle)
		if(not toggle) then return end;

		repeat
			local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
			if(rootPart and UserInputService:IsKeyDown(Enum.KeyCode.Space) and not chatFocused) then
				rootPart.Velocity = Vector3.new(rootPart.Velocity.X, library.flags.infiniteJumpHeight, rootPart.Velocity.Z);
			end;
			task.wait(0.1);
		until not library.flags.infiniteJump;
	end;

	local lastFogDensity = 0;

	function basicsHelpers.noFog(t)
		if not t then Lighting.Atmosphere.Density = lastFogDensity; maid.noFog = nil; return; end

		maid.noFog = Lighting.Atmosphere:GetPropertyChangedSignal('Density'):Connect(function()
			Lighting.Atmosphere.Density = 0;
		end);

		lastFogDensity = Lighting.Atmosphere.Density;
		Lighting.Atmosphere.Density = 0;
	end

	function basicsHelpers.noBlur(t)
		local dof = Lighting.DepthOfField;
		if not t then maid.noBlur = nil; dof.Enabled = true; return; end

		maid.noBlur = Lighting.DepthOfField:GetPropertyChangedSignal('Enabled'):Connect(function()
			if not dof.Enabled then return; end
			dof.Enabled = false;
		end);

		dof.Enabled = false;
	end

	local oldAmbient, oldBritghtness = Lighting.Ambient, Lighting.Brightness;

	function basicsHelpers.fullBright(toggle)
		if(not toggle) then
			maid.fullBright = nil;
			Lighting.Ambient, Lighting.Brightness = oldAmbient, oldBritghtness;
			return
		end;

		oldAmbient, oldBritghtness = Lighting.Ambient, Lighting.Brightness;
		maid.fullBright = Lighting:GetPropertyChangedSignal('Ambient'):Connect(function()
			Lighting.Ambient = Color3.fromRGB(255, 255, 255);
			Lighting.Brightness = 1;
		end);
		Lighting.Ambient = Color3.fromRGB(255, 255, 255);
	end;

	function basicsHelpers.speedHack(toggle)
		if (not toggle) then
			maid.speedHack = nil;

			local humanoid = Utility:getPlayerData().humanoid;
			if (not humanoid) then return; end;
			humanoid.WalkSpeed = 16;

			return;
		end;

		maid.speedHack = RunService.Heartbeat:Connect(function()
			local humanoid = Utility:getPlayerData().humanoid;
			if (not humanoid) then return; end;

			humanoid.WalkSpeed = library.flags.speedHackValue
		end);
	end;

	function basicsHelpers.flyHack(toggle)
		if (not toggle) then
			maid.flyHack = nil;
			maid.flyBv = nil;
			return;
		end;

		maid.flyBv = Instance.new('BodyVelocity');
		maid.flyBv.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

		maid.flyHack = RunService.Heartbeat:Connect(function()
			local playerData = Utility:getPlayerData();
			local rootPart, camera = playerData.rootPart, workspace.CurrentCamera;
			if (not rootPart or not camera) then return end;

			maid.flyBv.Parent = rootPart;
			maid.flyBv.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.flyHackValue);
		end);
	end;

	function basicsHelpers.noclip(toggle)
		if (not toggle) then
			maid.noclip = nil;

			local humanoid = Utility:getPlayerData().humanoid;
			if (not humanoid) then return end;

			humanoid:ChangeState('Physics');
			task.wait();
			humanoid:ChangeState('RunningNoPhysics');
			return;
		end;

		maid.noclip = RunService.Heartbeat:Connect(function()
			local parts = Utility:getPlayerData().parts;
			if (not parts) then return; end;

			for _, part in next, parts do
				part.CanCollide = false;
			end;
		end);
	end;

	return basicsHelpers;
end)()

sharedRequires['PerfectBlock'] = (function()
	local AudioPlayer = sharedRequires['AudioPlayer'];
	local makeESP = sharedRequires['makeESP'];
	local Utility = sharedRequires['Utility'];
	local Maid = sharedRequires['Maid'];
	local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
	local Services = sharedRequires['Services'];
	local createBaseESP = sharedRequires['createBaseESP'];
	local EntityESP = sharedRequires['EntityESP'];
	local ControlModule = sharedRequires['ControlModule'];
	local ToastNotif = sharedRequires['ToastNotif'];
	local BlockUtils = sharedRequires['BlockUtils'];
	local TextLogger = sharedRequires['TextLogger'];
	local fromHex = sharedRequires['fromHex'];
	local toCamelCase = sharedRequires['toCamelCase'];
	local Webhook = sharedRequires['Webhook'];
	local Signal = sharedRequires['Signal'];
	local prettyPrint = sharedRequires['prettyPrint'];

	local animLogger = TextLogger.new({
		title = 'Auto Parry Helper Logger',
		buttons = {'Copy Animation Id', 'Add To Ignore List', 'Test'}
	});


	local Players, MarketplaceService = Services:Get('Players', 'MarketplaceService');
	local LocalPlayer = Players.LocalPlayer;

	local maid = Maid.new();

	local PerfectBlock = {};
	PerfectBlock.__index = PerfectBlock;

	local IsA = game.IsA;

	local parryMaid = Maid.new();
	local animTimes = {};
	local animationNames = {};
	local ignoredAnimations = {'5517298834', '10001707271';  '11093531300', '6043954920', '7075728341', '10001705684', '507765644', '4563261864', '2095054253', '9984793787', '5796457289', '4126956669', '5796460384'};

	local myRootPart;

	task.spawn(function()
		while true do
			myRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
			task.wait();
		end;
	end);

	if (debugMode) then
		animLogger:SetVisible(true);

		animLogger.OnClick:Connect(function(btnName, ctx)
			if (btnName == 'Copy Animation Id') then
				setclipboard(ctx.animationId);
			elseif (btnName == 'Add To Ignore List') then
				if (table.find(ignoredAnimations, ctx.animationId)) then return end;
				table.insert(ignoredAnimations, ctx.animationId);
			elseif (btnName == 'Test') then
				animTimes[ctx.animationId] = _G.perfectBlockTime or 0;
			end;
		end);

		getgenv().animTimes = animTimes;
		getgenv().ignoredAnimations = ignoredAnimations;
		getgenv().copyIgnoreAnimations = function()
			setclipboard(prettyPrint(ignoredAnimations));
		end;

		library.flags.chatLoggerAutoScroll = true;
	end;

	animTimes['5746701412'] = 0; -- Fishman Karate Punch
	animTimes['4760307723'] = 0.3; -- Pistol Aim

	animTimes['11382679819'] = 0; -- Some Katana Slash
	animTimes['4087684389'] = 0; -- Default Punch

	local function parry(t, root, anim, maxRange)
		if (t ~= 0) then
			task.wait(t);
		end;
		keypress(0x46);
		task.wait(0.5);
		keyrelease(0x46);
	end;


	local function calculatePingWait(n)
		-- local playerPing = Stats.PerformanceStats.Ping:GetValue()/1000;
		-- n -= (playerPing*(library.flags.pingAdjustmentPercentage/100));

		return n;
	end;

	local function parryAttack(timings,rootPart,animationTrack,maxRange,useAnimSpeed)
		warn(" CALLED PARRY ATTACK!!!!!")

		_G.canAttack = false;

		local solved = false;

		local function getAllTimings(t, index)
			local total = 0;

			for i = index, 1, -1 do
				total += t[i];
			end;

			return total;
		end;

		local endIndex = #timings;

		for i in next, timings do
			task.spawn(function()
				local convertedWait = calculatePingWait(getAllTimings(timings, i)/(useAnimSpeed and animationTrack.Speed or 1));

				local waited = parry(convertedWait,rootPart,animationTrack,maxRange);
				-- warn("WE WAITED "..waited,"CURRENT TIME|"..convertedWait);

				if (i == endIndex) then
					solved = true;
				end;
			end);
		end;

		repeat
			task.wait();
		until solved;

		_G.canAttack = true;
	end

	function PerfectBlock.new(character)
		if (character == LocalPlayer.Character) then return end;

		local self = setmetatable({
			_character = character,
			_name = character.Name,
			_maid = Maid.new(),
			_isPlayer = Players:FindFirstChild(character.Name)
		}, PerfectBlock);

		self._maid:GiveTask(character:GetPropertyChangedSignal('Parent'):Connect(function()
			local newParent = character.Parent;
			if (newParent == nil) then return self:Destroy() end;
		end));

		self._maid:GiveTask(Utility.listenToChildAdded(character, function(obj)
			if (obj.Name == 'HumanoidRootPart') then
				self._rootPart = obj;
				self:_onHumanoidAdded(); -- We call it here cause we want AnimationPlayed to be listened if there is rootPart
			elseif (IsA(obj, 'Humanoid')) then
				self._humanoid = obj;
				self:_onHumanoidAdded();
			end;
		end));

		self._maid:GiveTask(Utility.listenToChildRemoving(character, function(obj)
			if (obj.Name == 'HumanoidRootPart') then
				self._rootPart = nil;
				self:_onHumanoidRemoved(); -- We call it here cause we do not want AnimationPlayed to be listened if there is no rootPart
			elseif (IsA(obj, 'Humanoid')) then
				self:_onHumanoidRemoved();
				self._humanoid = nil;
			end;
		end));

		parryMaid:GiveTask(function()
			self._maid:Destroy();
		end);

		return self;
	end;

	function PerfectBlock:_onHumanoidAdded()
		if (not self._rootPart or not self._humanoid) then return end;
		local humanoid = self._humanoid;

		self._maid[humanoid] = humanoid.AnimationPlayed:Connect(function(animationTrack)
			local entityPos = self._rootPart and self._rootPart.Position;
			if (not entityPos or not myRootPart) then return end;
			if ((entityPos - myRootPart.Position).Magnitude >= 150) then return end;
			-- if (library.flags.autoParryWhitelist[self._name]) then return end;

			-- local autoParryMode = library.flags.autoParryMode;

			-- if (not autoParryMode.All) then
			--     if (autoParryMode.Mobs and self._isPlayer and not autoParryMode.Players) then
			--         return
			--     end;
			--     if (autoParryMode.Players and not self._isPlayer and not autoParryMode.Mobs) then
			--         return;
			--     end;
			-- end;

			if (library.flags.checkIfFacingTarget) then
				local dotProduct = (entityPos - myRootPart.Position):Dot(myRootPart.CFrame.LookVector);
				if (dotProduct <= 0) then return print('Not parrying player is not facing target') end;
			end;

			if (library.flags.checkIfTargetFaceYou) then
				local dotProduct = (myRootPart.Position - entityPos):Dot(self._rootPart.CFrame.LookVector);
				if (dotProduct <= 0) then return print('Not parrying target is not facing player') end;
			end;

			local animId = animationTrack.Animation.AnimationId:match('%d+');
			local waitTime = animTimes[animId];
			local maxRange = getgenv().defaultRange or 20;

			local animName = animationNames[animId];

			if (debugMode and not table.find(ignoredAnimations, animId)) then
				if (not animName) then
					animationNames[animId] = '?';
					task.spawn(function()
						animationNames[animId] = MarketplaceService:GetProductInfo(tonumber(animId), Enum.InfoType.Asset).Name;
					end);
				end;

				animLogger:AddText({
					animationId = animId,
					text = string.format('Animation played %s | %s from %s %s', animId, animationNames[animId], self._name, waitTime and 'has' or 'dont have')
				});
			end;

			if (typeof(waitTime) == 'table') then
				local waitTimeObject = animTimes[animId];

				maxRange = waitTimeObject.maxRange or 20;
				waitTime = waitTimeObject.waitTime;
			end;

			if (typeof(waitTime) == 'function') then
				warn('[Auto Parry] Using custom function for', animId, animName or 'no animation name');
				waitTime(animationTrack, self._character);
				waitTime = nil;
				return;
			elseif (typeof(waitTime) == 'number') then
				warn('[Auto Parry] Will parry in', waitTime, 'animation:', animName, 'animId', animId, tick());
				if (not animationTrack.IsPlaying) then return print('feeint 2') end;

				print('anim state', animationTrack.IsPlaying);
				--Parry Attack
				parryAttack({waitTime},self._rootPart,animationTrack,maxRange);

				_G.canAttack = true;
				return;
			end;
		end);
	end;

	function PerfectBlock:_onHumanoidRemoved()
		local humanoid = self._humanoid;
		if (not humanoid) then return end;
		self._maid[humanoid] = nil;
	end;

	function PerfectBlock:Destroy()
		self._maid:Destroy();
	end;

	local function init(t)
		if (not t) then
			parryMaid:DoCleaning();
			maid.autoParryOnNewCharacter = nil;
			maid.autoParryOnNewCharacter2 = nil;
			return;
		end;

		maid.autoParryOnNewCharacter = Utility.listenToChildAdded(workspace.NPCs, PerfectBlock);
		maid.autoParryOnNewCharacter2 = Utility.listenToChildAdded(workspace.PlayerCharacters, PerfectBlock);
	end;

	return init;
end)()

sharedRequires['prettyPrint'] = (function()
	-- Thanks corewave
	type = typeof or type
	local str_types = {
		['boolean'] = true,
		['userdata'] = true,
		['table'] = true,
		['function'] = true,
		['number'] = true,
		['nil'] = true
	}

	local function count_table(t)
		local c = 0
		for i, v in next, t do
			c = c + 1
		end

		return c
	end

	local function string_ret(o, typ)
		local ret, mt, old_func
		if not (typ == 'table' or typ == 'userdata') then
			return tostring(o)
		end
		mt = (getrawmetatable or getmetatable)(o)
		if not mt then 
			return tostring(o)
		end

		old_func = rawget(mt, '__tostring')
		rawset(mt, '__tostring', nil)
		ret = tostring(o)
		rawset(mt, '__tostring', old_func)
		return ret
	end

	local function format_value(v)
		local typ = type(v)

		if str_types[typ] then
			return string_ret(v, typ)
		elseif typ == 'string' then
			return '"'..v..'"'
		elseif typ == 'Instance' then
			return v.GetFullName(v)
		else
			return typ..'.new(' .. tostring(v) .. ')'
		end
	end

	local function serialize_table(t, p, c, s)
		local str = ""
		local n = count_table(t)
		local ti = 1
		local e = n > 0

		c = c or {}
		p = p or 1
		s = s or string.rep

		local function localized_format(v, is_table)
			return is_table and (c[v][2] >= p) and serialize_table(v, p + 1, c, s) or format_value(v)
		end

		c[t] = {t, 0}

		for i, v in next, t do
			local typ_i, typ_v = type(i) == 'table', type(v) == 'table'
			c[i], c[v] = (not c[i] and typ_i) and {i, p} or c[i], (not c[v] and typ_v) and {v, p} or c[v]
			str = str .. s('  ', p) .. '[' .. localized_format(i, typ_i) .. '] = '  .. localized_format(v, typ_v) .. (ti < n and ',' or '') .. '\n'
			ti = ti + 1
		end

		return ('{' .. (e and '\n' or '')) .. str .. (e and s('  ', p - 1) or '') .. '}'
	end

	if (debugMode) then
		getgenv().prettyPrint = serialize_table;
	end;

	return serialize_table
end)();
if (not accountData) then
	accountData = {
		uuid = 'test',
		createdAt = 0,
		flags = {},
		roles = {'AnimeAdventuresScript'},
		username = 'test'
	}
end;

_G = debugMode and _G or {};

local scriptLoadAt = tick();
local websiteScriptKey, scriptKey = getgenv().websiteKey, getgenv().scriptKey;
local silentLaunch = not not getgenv().silentLaunch;

local function printf() end;

if (not game:IsLoaded()) then
	game.Loaded:Wait();
end;
print("ok5")
local library = sharedRequires['Library'];

local Services = sharedRequires['Services'];
local toCamelCase = sharedRequires['toCamelCase'];

local ToastNotif = sharedRequires['ToastNotif'];
local AnalayticsAPI = sharedRequires['AnalyticsAPI'];
local errorAnalytics = AnalayticsAPI.new("UA-187309782-1");
local Utility = sharedRequires['Utility'];

local _ = sharedRequires['prettyPrint'];

local Players, TeleportService, ScriptContext, MemStorageService, HttpService, ReplicatedStorage = Services:Get("Players", 'TeleportService', 'ScriptContext', 'MemStorageService', 'HttpService', 'ReplicatedStorage');

local BLOODLINES_MAIN_PLACE = 10266164381;
local BLOODLINES = 1946714362;

-- If script ran for more than 60 sec and game is rogue lineage then go back to teleporter
if(tick() - scriptLoadAt >= 60) then
	if((game.PlaceId == 3541987450 or game.PlaceId == 3016661674 or game.PlaceId == 5208655184)) then
		TeleportService:Teleport(3016661674);
		return;
	elseif (game.GameId == BLOODLINES) then
		TeleportService:Teleport(BLOODLINES_MAIN_PLACE);
	end;
end;

do -- //Hook print debug
	if (debugMode) then
		local oldPrint = print;
		local oldWarn = warn;
		function print(...)
			return oldPrint('[DEBUG]', ...);
		end;

		function warn(...)
			return oldWarn('[DEBUG]', ...);
		end;

		function printf(msg, ...)
			return oldPrint(string.format('[DEBUG] ' .. msg, ...));
		end;
	else
		function print() end;
		function warn() end;
		function printf() end;
	end;
end;

local LocalPlayer = Players.LocalPlayer
local executed = false;


getgenv().debugMode = debugMode;

getgenv().originalFunctions = {
	fireServer = Instance.new('RemoteEvent').FireServer,
	invokeServer = Instance.new('RemoteFunction').InvokeServer,
	getRankInGroup = LocalPlayer.GetRankInGroup,
	index = getrawmetatable(game).__index,
	jsonEncode = HttpService.JSONEncode,
	jsonDecode = HttpService.JSONDecode,
	findFirstChild = game.FindFirstChild,
	--getCommChannel = syn.get_comm_channel
}


LocalPlayer.OnTeleport:Connect(function(state)
	if (executed or state ~= Enum.TeleportState.InProgress) then return end;
	executed = true;

	if(not debugMode) then

	end;
end);

local supportedGamesList = HttpService:JSONDecode(sharedRequires['supportedGamesList']);
local gameName = supportedGamesList[tostring(game.GameId)];

--//Base library

for _, v in next, getconnections(LocalPlayer.Idled) do
	if (v.Function) then continue end;
	v:Disable();
end;

--//Load special game Hub

local window;
local column1;
local column2;

if(debugMode) then
	ToastNotif.new({
		text = 'Hub running in debug mode'
	});
end;

if (gameName) then
	window = library:AddTab(gameName);
	column1 = window:AddColumn();
	column2 = window:AddColumn();

	library.columns = {
		column1,
		column2
	};

	library.gameName = gameName;
	library.window = window;
end;

local myScriptId = debug.info(1, 's');
local seenErrors = {};

local hubVersion = typeof(ah_metadata) == 'table' and rawget(ah_metadata, 'version') or '';
if (typeof(hubVersion) ~= "string") then return SX_CRASH() end;

local function onScriptError(message)
	if (table.find(seenErrors, message)) then
		return;
	end;

	if (message:find(myScriptId)) then
		table.insert(seenErrors, message);
		local reportMessage = 'Ronirohub_v_' .. hubVersion .. message;
		errorAnalytics:Report(gameName, reportMessage, 1);
	end;
end

if (not debugMode) then
	ScriptContext.ErrorDetailed:Connect(onScriptError);
	if (gameName) then
		errorAnalytics:Report('Loaded', gameName, 1);

		if (not MemStorageService:HasItem('AnalyticsGame')) then
			MemStorageService:SetItem('AnalyticsGame', true);
			errorAnalytics:Report('RealLoaded', gameName, 1);
		end;
	end;
end;

--//Loads universal part

local universalLoadAt = tick();

(function()
	local Maid = sharedRequires['Maid'];
	local Services = sharedRequires['Services'];
	local EntityESP = sharedRequires['EntityESP'];
	local library = sharedRequires['Library'];
	local Utility = sharedRequires['Utility'];

	local Players, RunService = Services:Get("Players", "RunService");
	local LocalPlayer = Players.LocalPlayer;

	local maid = Maid.new();
	local entityEspList = {};

	local function onPlayerAdded(player)
		if (player == LocalPlayer) then return end;
		local espEntity = EntityESP.new(player);

		library.unloadMaid[player] = function()
			table.remove(entityEspList, table.find(entityEspList, espEntity));
			espEntity:Destroy();
		end;

		table.insert(entityEspList, espEntity);
	end;

	local function onPlayerRemoving(player)
		library.unloadMaid[player] = nil;
	end;

	library.OnLoad:Connect(function()
		Players.PlayerAdded:Connect(onPlayerAdded);
		Players.PlayerRemoving:Connect(onPlayerRemoving);

		for i, v in next, Players:GetPlayers() do
			task.spawn(onPlayerAdded, v);
		end;
	end);

	local function updateEspState(toggle)
		if (not toggle) then
			maid.updateEsp = nil;
			for _, entity in next, entityEspList do
				entity:Hide();
			end;

			return;
		end;

		local lastUpdateAt = 0;
		local ESP_UPDATE_RATE = 10/1000;

		maid.updateEsp = RunService.RenderStepped:Connect(function()
			if (tick() - lastUpdateAt < ESP_UPDATE_RATE) then return end;
			lastUpdateAt = tick();

			--debug.profilebegin('Full Entity Update');

			for _, entity in next, entityEspList do
				--debug.profilebegin('Single Entity Update ' .. entity._playerName);
				entity:Update();
				--debug.profileend();
			end;

			--debug.profileend();
		end);
	end;

	local function toggleRainbowEsp(flag)
		return function(toggle)
			if(not toggle) then
				maid['rainbow' .. flag] = nil;
				return;
			end;

			maid['rainbow' .. flag] = RunService.RenderStepped:Connect(function()
				library.options[flag]:SetColor(library.chromaColor, false, true);
			end);
		end;
	end;

	local esp = library:AddTab('ESP');
	local column1 = esp:AddColumn();
	local column2 = esp:AddColumn();
	local espSettings = column1:AddSection("Esp Settings");
	local espCustomisation = column2:AddSection("Esp Customisation");
	local proximityArrows = column1:AddSection("a8165694dfdfaa22d8d3a7160261a637");

	espSettings:AddToggle({
		text = 'Toggle Esp',
		callback = updateEspState
	}):AddSlider({
		text = 'Max Esp Distance',
		value = 10000,
		min = 50,
		max = 10000,
		callback = function(value)
			if (value == 10000) then
				value = math.huge;
			end;

			library.flags.maxEspDistance = value;
		end,
	});

	espSettings:AddList({
		text = 'Esp Font',
		flag = 'Esp Font',
		values = {'UI', 'System', 'Plex', 'Monospace'},
		callback = function(font)
			font = Drawing.Fonts[font];
			for i, v in next, entityEspList do
				v:SetFont(font);
			end;
		end,
	});

	espSettings:AddSlider({
		text = 'Text Size',
		textpos = 2,
		max = 100,
		min = 16,
		callback = function(textSize)
			for i, v in next, entityEspList do
				v:SetTextSize(textSize);
			end;
		end;
	});

	espSettings:AddToggle({
		text = 'Toggle Tracers',
	});

	proximityArrows:AddToggle({
		text = 'Proximity Arrows',
	}):AddSlider({text = 'Arrows Size', flag = 'Proximity Arrows Size', min = 10, max = 25, value = 20, textpos = 2});

	proximityArrows:AddSlider({
		text = 'Max Distance',
		flag = 'Max Proximity Arrow Distance',
		min = 0,
		max = 2000,
		value = 1000
	});

	espSettings:AddToggle({
		text = 'Toggle Boxes',
	});

	-- espSettings:AddToggle({
	--     text = '2D Esp',
	--     flag = 'Two Dimensions E S P'
	-- });

	espSettings:AddToggle({
		text = 'Show Health Bar'
	});

	espSettings:AddToggle({
		text = 'Show Team',
	});

	espCustomisation:AddToggle({
		text = 'Rainbow Enemy Color',
		callback = toggleRainbowEsp('enemyColor')
	});

	espCustomisation:AddToggle({
		text = 'Rainbow Ally Color',
		callback = toggleRainbowEsp('allyColor')
	});

	espCustomisation:AddToggle({
		text = 'Unlock Tracers',
	});

	espCustomisation:AddColor({
		text = 'Ally Color',
	})

	espCustomisation:AddColor({
		text = 'Enemy Color',
	});

	function Utility:getESPSection()
		return {
			espCustomisation = espCustomisation,
			espSettings = espSettings,
			column1 = column1,
			column2 = column2
		};
	end;

	Utility.setupRenderOverload = function()
		Utility:renderOverload({
			espCustomisation = espCustomisation,
			espSettings = espSettings,
			column1 = column1,
			column2 = column2
		});
	end;
end)();
(function()
	local Maid = sharedRequires['Maid'];
	local Services = sharedRequires['Services'];
	local library = sharedRequires['Library'];
	local Utility = sharedRequires['Utility'];

	local RunService, UserInputService = Services:Get('RunService', 'UserInputService');
	local UserService = game:GetService('UserService');

	local maid = Maid.new();

	local Circle = Drawing.new('Circle');
	local targetLine = Drawing.new('Line');

	Circle.Transparency = 1;
	Circle.Visible = false;
	Circle.Color = Color3.fromRGB(255, 255, 255);
	Circle.Radius = 100;
	Circle.Thickness = 1;

	targetLine = Drawing.new('Line');
	targetLine.Visible = true;
	targetLine.Transparency = 1;
	targetLine.Thickness = 1;
	targetLine.Color = Color3.fromRGB(255, 255, 255);

	local function Aimbot(ended)
		if (ended) then
			maid.aimbot = nil;
			return;
		end;

		maid.aimbot = RunService.RenderStepped:Connect(function()
			if(not library) then
				maid.aimbot = nil;
				return;
			end;

			local Character = Utility:getClosestCharacter()
			Character = Character and Character.Character;
			if(not Character) then return end;

			local head = Character:FindFirstChild('Head');
			local hitPos = head and head.CFrame.Position;

			local Camera = workspace.CurrentCamera;
			if(not Camera) then return end;

			local aimPart = library.flags.aimPart;
			if(aimPart == 'Torso') then
				hitPos = hitPos - Vector3.new(0, 1.5, 0);
			elseif(aimPart == 'Leg') then
				hitPos = hitPos - Vector3.new(0, 3, 0);
			end;

			local hitPosition2D, visible = Camera:WorldToViewportPoint(hitPos);
			if (not visible) then return end;

			hitPosition2D = Vector2.new(hitPosition2D.X, hitPosition2D.Y);

			local mousePosition = UserInputService:GetMouseLocation();
			local final = (hitPosition2D - mousePosition) / (_G.test or 10);
			mousemoverel(final.X, final.Y);
		end);
	end;

	local function updateCircleProp(property)
		return function(value)
			if (property == "NumSides" and value == 50) then
				value = 500;
			elseif (property == "Filled" and library.flags.circleTransparency == 1) then
				library.flags.circleTransparency = 0.9;
				Circle.Transparency = 0.9;
			end
			Circle[property] = value;
		end;
	end;

	local function toggleRainbowCircle(toggle)
		if(not toggle) then
			maid.toggleRainbowCircle = nil;
			return;
		end;

		local circleColor = library.options.circleColor;

		maid.toggleRainbowCircle = RunService.RenderStepped:Connect(function()
			circleColor:SetColor(library.chromaColor);
		end);
	end;

	local function showCircle(toggle)
		Circle.Visible = toggle;

		if(not toggle) then
			maid.updateCirclePosition = nil;
			return;
		end;

		maid.updateCirclePosition = RunService.Heartbeat:Connect(function()
			-- if(library.flags.unlockCircle) then
			if(Circle) then
				Circle.Position = UserInputService:GetMouseLocation()
			end;
			-- else
			--     local camera = workspace.CurrentCamera;
			--     if(not camera) then return end;

			--     local cameraViewPortSize = camera.ViewportSize;
			--     local x = cameraViewPortSize.X / 2;
			--     local y = cameraViewPortSize.Y / 2;

			--     Circle.Position = Vector2.new(x, y);
			-- end;
		end);
	end;

	local Window = library:AddTab('Aimbot');
	local section1 = Window:AddColumn();
	local section2 = Window:AddColumn();
	local aimbotSettings = section1:AddSection('Aimbot Settings');
	local circleSettings = section2:AddSection('Circle Settings');
	local aimbotWhitelist = section1:AddSection('Aimbot Whitelist');

	do -- Render gui
		do -- // Circle Settings
			circleSettings:AddToggle({
				text = 'Show Circle',
				callback = showCircle
			}):AddColor({
				color = Color3.fromRGB(255, 0, 0),
				trans = 1,
				flag = 'Circle Color',
				calltrans = updateCircleProp('Transparency'),
				callback = updateCircleProp('Color')
			})

			circleSettings:AddToggle({
				text = 'Rainbow Circle',
				callback = toggleRainbowCircle
			})

			circleSettings:AddToggle({
				text = 'Fill Circle',
				callback = updateCircleProp('Filled')
			})

			circleSettings:AddSlider({
				text = 'Circle Shape',
				value = 50,
				min = 4,
				max = 50,
				float = 2,
				callback = updateCircleProp('NumSides')
			})

			circleSettings:AddSlider({
				text = 'Circle Thickness',
				value = 1,
				max = 50,
				callback = updateCircleProp('Thickness')
			});
		end;

		do -- // Aimbot Settings
			aimbotSettings:AddBind({
				text = 'Enable',
				flag = 'Toggle Aimbot',
				mode = 'hold',
				callback = Aimbot
			})

			aimbotSettings:AddSlider({
				text = 'Field Of View',
				flag = 'Aimbot F O V',
				min = 0,
				value = 100,
				max = 800,
				callback = updateCircleProp('Radius')
			})

			aimbotSettings:AddList({
				text = 'Aim Part',
				values = {'Head', 'Torso', 'Leg'}
			})

			aimbotSettings:AddToggle({
				text = 'Use Field Of View',
				flag = 'use F O V'
			})

			aimbotSettings:AddToggle({
				text = 'Visibility Check',
			})

			aimbotSettings:AddToggle({
				text = 'Check Team',
				state = true
			})
		end;

		do -- // Aimbot Whitelist
			local usersInfosByName = {};

			local function addPlayer(userId, isTextBox)
				if (not isTextBox) then
					userId = library.flags.aimbotWhitelistPlayers;
					userId = userId and userId.UserId;
				end;

				if (not userId) then return print('no user id', userId, isTextBox); end;

				local suc, userInfos = pcall(function()
					return UserService:GetUserInfosByUserIdsAsync({userId});
				end);

				if (not suc) then
					return warn(userInfos);
				end;

				local userInfo = userInfos[1];
				if (not userInfo) then return end;
				library.options.aimbotWhitelistedPlayers:AddValue(userInfo.Username);

				local aimbotWhitelistedPlayers = library.configVars.aimbotWhitelistedPlayers;

				if (not aimbotWhitelistedPlayers) then
					aimbotWhitelistedPlayers = {};
					library.configVars.aimbotWhitelistedPlayers = aimbotWhitelistedPlayers;
				end;

				if (not table.find(aimbotWhitelistedPlayers, userInfo.Id)) then
					table.insert(aimbotWhitelistedPlayers, userInfo.Id);
					usersInfosByName[userInfo.Username] = userInfo;
				end;
			end;

			local function removePlayer()
				local userInfo = usersInfosByName[library.flags.aimbotWhitelistedPlayers];
				if (not userInfo) then return end;

				library.options.aimbotWhitelistedPlayers:RemoveValue(userInfo.Username);
				local whitelistedPlayers = library.configVars.aimbotWhitelistedPlayers;

				table.remove(whitelistedPlayers, table.find(whitelistedPlayers, userInfo.Id));
			end;

			library.OnLoad:Connect(function()
				local whitelistedPlayers = library.configVars.aimbotWhitelistedPlayers or {};
				local userInfos = UserService:GetUserInfosByUserIdsAsync(whitelistedPlayers);

				for _, userInfo in next, userInfos do
					library.options.aimbotWhitelistedPlayers:AddValue(userInfo.Username);
					usersInfosByName[userInfo.Username] = userInfo;
				end;
			end);

			aimbotWhitelist:AddDivider('Add Player');
			aimbotWhitelist:AddList({text = 'Players', flag = 'Aimbot Whitelist Players', playerOnly = true, noSave = true});
			aimbotWhitelist:AddButton({text = 'Add Player', callback = addPlayer});

			aimbotWhitelist:AddDivider('Remove Player');
			aimbotWhitelist:AddList({text = 'Whitelisted Players', flag = 'Aimbot Whitelisted Players'});
			aimbotWhitelist:AddButton({text = 'Remove Player', callback = removePlayer});

			aimbotWhitelist:AddDivider('Advanced Whitelist');
			aimbotWhitelist:AddBox({text = 'Player UserId', flag = 'Aimbot Whitelist Player Box'});
			aimbotWhitelist:AddButton({text = 'Add Player By User Id', callback = function() addPlayer(tonumber(library.flags.aimbotWhitelistPlayerBox), true) end});
		end;
	end;
end)();

printf('[Script] [Universal] Took %.02f to load', tick() - universalLoadAt);

local loadingGameStart = tick();

if (gameName == 'Ace Of Spadez') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local Players = Services:Get('Players');
		local column1 = unpack(library.columns);

		local LocalPlayer = Players.LocalPlayer;

		local FindFirstChild = game.FindFirstChild;
		local GetPlayers = Players.GetPlayers;

		local Combat = column1:AddSection('Combat')
		local GunMods = column1:AddSection('Gun Mods')

		local camera = require(LocalPlayer.PlayerScripts.Main.Camera);

		local oldRecoil;
		oldRecoil = hookfunction(camera.Recoil, function(...)
			if (library.flags.noRecoil) then return end;
			warn('flagged recoil bud')
			return oldRecoil(...);
		end);

		function Utility:getCharacter(player)
			local character = player.Character;
			if (not character) then return end;

			local rootPart = FindFirstChild(character, 'HumanoidRootPart');
			if (not rootPart) then return end;

			local health = FindFirstChild(character, 'Health');
			if (not health) then return end;

			local maxHealth = health.Max.Value;
			local healthValue = health.Value;

			return character, maxHealth, (healthValue / maxHealth) * 100, math.floor(healthValue), rootPart;
		end;

				--// Silent Aim

				local function getEnemies()
					local enemies = {};
		
					for i, v in next, GetPlayers(Players) do
						if(v.Character and v.Team and v.Team ~= LocalPlayer.Team and v.Team.Name ~= 'Spectators') then
							table.insert(enemies, v.Character);
						end;
					end;
		
					return enemies;
				end;
		
				local oldIndex;
				local isA = game.IsA;
		
				-- The game do customSpawn(func) inside of the bullet func so we can identify if it's the bullet function by checking if it's customSpawn
				local function isBulletFunc()
					local s = debug.info(5, 's');
		
					if (s and s:find('Spawn')) then
						print('true found bullet')
						return true;
					end;
				end;
		
				local function getSilentAimPos()
					local rayParams = RaycastParams.new();
					rayParams.FilterType = Enum.RaycastFilterType.Whitelist;
					rayParams.FilterDescendantsInstances = {FindFirstChild(workspace.Game, 'Map'), getEnemies()};
					local target = Utility:getClosestCharacter(rayParams);
					target = target and target.Character;
					local hitPart = target and FindFirstChild(target, 'Head');
					print(hitPart.Position)
					if (hitPart) then
					    print('got position')
						return hitPart.Position;
					end;
				end;
		
				oldIndex = hookmetamethod(game, '__index', function(self, p)
					if (p == 'CFrame' and isA(self, 'Camera') and library.flags.silentAim and string.find(debug.traceback(), 'WeaponSystem')) then
						if (isBulletFunc()) then
							local pos = getSilentAimPos()
							print('BRAMMMMM')
							return CFrame.new(oldIndex(self, p).Position, pos or oldIndex(self, p).LookVector);
						end;
					elseif (p == 'Position' and isA(self, 'Part') and library.flags.silentAim and string.find(debug.traceback(), 'WeaponSystem')) then
						if (isBulletFunc()) then
							print('IDK WHAT DOES THISSSS')
							return getSilentAimPos() or oldIndex(self, p);
						end;
					end;
		
					return oldIndex(self, p);
				end);
		
				local oldMathRandom;
				oldMathRandom = hookfunction(math.random, function(n1, n2)
					local traceback = debug.traceback();
					if(string.find(traceback, 'TouchBullet') and library.flags.noSpread) then
						print('BOOMMMM NO SPREAD')
						return 0;
					end;
		
					return oldMathRandom(n1, n2)
				end);

		Combat:AddToggle({
			text = "Silent Aim",
		})

		Combat:AddToggle({
			text = "Melee Silent Aim"
		})

		GunMods:AddToggle({
			text = "No Recoil",
		})

		GunMods:AddToggle({
			text = "No Spread",
		})

		print('loaded?')
	end)()
end


if (gameName == 'Adopt Me') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local ReplicatedStorage, Players, RunService, UserInputService, MemStorageService, TeleportService, NetworkClient, GuiService = Services:Get('ReplicatedStorage', 'Players', 'RunService', 'UserInputService', 'MemStorageService', 'TeleportService', 'NetworkClient', 'GuiService');
		local column1, column2 = unpack(library.columns);

		local fsysModule = ReplicatedStorage.Fsys;

		print('we wait for sys');

		local fsys = require(fsysModule);
		local LocalPlayer = Players.LocalPlayer;

		local function rejoinServer()
			library:UpdateConfig();

			while (true) do
				TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId);
				GuiService:ClearError();
				task.wait(5);
			end;
		end;

		task.spawn(function()
			while task.wait(1) do
				if (not NetworkClient:FindFirstChild('ClientReplicator')) then
					rejoinServer();
					break;
				end;
			end;
		end);

		local routerTable
		for i, v in next, getgc(true) do
			if type(v) == 'table' and type(rawget(v, 'RouterClient')) == 'table' then
				routerTable = v
				print("Table found with 'RouterClient' function:", routerTable)
				break
			end
		end

		local function loader(name)
			if not routerTable then
				print("No table with 'RouterClient' function found.")
				return nil
			end

			print('waiting for', name)

			repeat
				task.wait()
			until typeof(routerTable[name]) == 'table'

			return routerTable[name]
		end

		local routerClient = loader('RouterClient');
		local interiorsM = loader('InteriorsM');
		local clientData = loader('ClientData')
		local obbyList = loader('ObbyDB')
		local petsDB = loader('InventoryDB').pets;
		local door = loader('Door');

		local uiManager = loader('UIManager');
		local inventory = clientData.get('inventory')

		print('waiting for loadedIn');
		repeat
			task.wait();
		until clientData.get('loaded_in');

		local remotes = getupvalue(getfenv(routerClient.get).get_remote_from_cache, 1);

		local doorMT = getupvalue(door.new, 1);
		local oldEnter = doorMT.enter;

		oldEnter = hookfunction(oldEnter, function(...)
			if (library.flags.petFarm) then return end;
			return oldEnter(...);
		end);

		library.OnLoad:Connect(function()
			if (not LocalPlayer.Character) then
				remotes['TeamAPI/ChooseTeam']:InvokeServer(library.flags.switchTeam);
				uiManager.set_app_visibility('MainMenuApp', false);
				uiManager.set_app_visibility('NewsApp', false);
			end;
		end);

		--// Functions

		local funcs = {};

		function funcs.setDataloss()
			remotes['RadioAPI/Add']:InvokeServer('\128', 123);
			ToastNotif.new({text = 'Dataloss set, anything after this point won\'t save'});
		end;

		function funcs.unsetDataloss()
			remotes['RadioAPI/Remove']:invokeServer(123);
			ToastNotif.new({text = 'Dataloss unset!'});
		end;

		local function teleportTo(location, door, data)
			setthreadidentity(2);
			interiorsM.enter(location, door, data);
			setthreadidentity(7);
		end;

		local function getFood(id)
			for _, v in next, inventory.food do
				if not id or v.id == id then
					return v.unique;
				end;
			end;
		end;

		local function getFurniture(Name)
			for _, v in next, workspace.HouseInteriors.furniture:GetChildren() do
				local Model = v:FindFirstChildOfClass('Model');
				local useId = Model and Model:FindFirstChild('UseBlocks') and Model:FindFirstChildWhichIsA('StringValue', true)

				if useId and useId.Name == 'use_id' and useId.Value == Name then
					return v:FindFirstChildWhichIsA('Model'):GetAttribute('furniture_unique');
				end;
			end;
		end;

		local function isInMainMap()
			return interiorsM:get_current_location().destination_id == 'MainMap';
		end;

		local function isInNursery()
			return interiorsM:get_current_location().destination_id == 'Nursery';
		end;

		local Autofarm = column1:AddSection('Autofarm');
		local Misc = column1:AddSection('Misc');
		local Local = column2:AddSection('Local');

		local petsToFarm = {};

		coroutine.wrap(function()
			while true do
				table.clear(petsToFarm);
				inventory = clientData.get('inventory');
				if (not inventory or not inventory.pets) then task.wait(); continue end;

				for _, v in next, inventory.pets do
					table.insert(petsToFarm, v.id .. ' | age: ' .. tostring(v.properties.age));
				end;

				task.wait(1);
			end;
		end)();

		local currentPet;
		local stores = {'CoffeeShop', 'Supermarket', 'PizzaPlace', 'ToyShop', 'Obbies', 'Neighborhood', 'CampingShop', 'AutoShop', 'Nursery', 'Cave', 'IceCream', 'PotionShop', 'SkyCastle', 'Hospital', 'HatShop', 'PetShop', 'School', 'BabyShop', 'HotSpringHouse', 'SafetyHub', 'DebugInterior'};

		local function onAilmentAdded(ailment)
			if ailment:IsA('Frame') then
				remotes['MonitorAPI/AddRate']:InvokeServer(ailment.Name, 100);
			end;
		end;

		Autofarm:AddToggle({text = 'Pet Farm'});

		Autofarm:AddList({
			text = 'Pet to Farm',
			values = petsToFarm,
			callback = function(value)
				for i, v in next, inventory.pets do
					if v.id .. ' | age: ' .. tostring(v.properties.age) == value then
						currentPet = v;
					end;
				end;
			end;
		});

		local wantedPets = {};

		for _, v in next, petsDB do
			if (v.rarity == 'legendary' and not v.is_egg and not v.origin_entry.robux) then
				table.insert(wantedPets, v.name);
			end;
		end;

		table.sort(wantedPets, function(a, b) return a < b end);
		Autofarm:AddList({text = 'Wanted Pets', values = wantedPets, multiselect = true});

		Autofarm:AddToggle({text = 'Farm All Pets'})
		Autofarm:AddToggle({text = 'Farm Until Full Grown'});

		Autofarm:AddToggle({
			text = 'No Rendering',
			callback = function(t) RunService:Set3dRenderingEnabled(not t) end
		})

		Autofarm:AddToggle({
			text = 'Baby Farm',
			callback = function(value)
				if value then
					for _, ailment in next, LocalPlayer.PlayerGui.AilmentsMonitorApp.Ailments:GetChildren() do
						onAilmentAdded(ailment);
					end;
				end;
			end;
		});

		Autofarm:AddBox({text = 'Webhook Url'});
		Autofarm:AddToggle({text = 'Auto Paycheck'});

		Misc:AddButton({
			text = 'Complete All Obbies',
			callback = function()
				for i in next, obbyList do
					remotes['MinigameAPI/FinishObby']:FireServer(i);
				end;
			end
		});

		Local:AddSlider({
			text = 'Walk Speed',
			textpos = 2,
			min = 16,
			max = 200,
			default = 16
		});

		Local:AddSlider({
			text = 'Jump Height',
			textpos = 2,
			min = 50,
			max = 200,
			default = 50
		});

		Local:AddToggle({
			text = 'Noclip'
		});

		Local:AddButton({
			text = 'Teleport to Main Map',
			callback = function()
				teleportTo('MainMap', 'Neighborhood/MainDoor', {});
			end
		});

		Local:AddButton({
			text = 'Teleport to Home',
			callback = function()
				teleportTo('housing', 'MainDoor', {
					['house_owner'] = LocalPlayer
				});
			end
		});

		Local:AddList({
			text = 'Teleport to Store',
			values = stores,
			noload = true,
			skipflag = true,
			callback = function(value)
				if not isInMainMap() then
					teleportTo('MainMap', 'Neighborhood/MainDoor', {});
					repeat task.wait() until isInMainMap();
				end;

				teleportTo(value, 'MainDoor', {});
			end
		});

		Misc:AddButton({
			text = 'Set Dataloss',
			callback = funcs.setDataloss
		});

		Misc:AddButton({
			text = 'Remove Dataloss',
			callback = funcs.unsetDataloss
		});

		Misc:AddButton({
			text = 'Make Pets Flyable',
			callback = function()
				for _, v in next, inventory.pets do
					v.properties.flyable = true;
				end;
			end
		});

		Misc:AddButton({
			text = 'Make Pets Rideable',
			callback = function()
				for _, v in next, inventory.pets do
					v.properties.rideable = true;
				end;
			end
		});

		Misc:AddList({
			text = 'Switch Team',
			values = {'Babies','Parents'},
			noload = true,
			skipflag = true,
			callback = function(team)
				remotes['TeamAPI/ChooseTeam']:InvokeServer(team, true);
			end
		});

		local function getPetId()
			if not library.flags.farmAllPets then
				return currentPet and currentPet.unique;
			end;

			local allPets = {};

			for _, pet in next, inventory.pets do
				if (pet.properties.age == 6) then continue end;
				local isEgg = petsDB[pet.id].is_egg;

				if (isEgg) then
					table.insert(allPets, {
						properties = {age = 0},
						id = pet.id,
						unique = pet.unique
					});

					continue;
				end;

				table.insert(allPets, pet);
			end;

			if (library.flags.farmUntilFullGrown) then
				table.sort(allPets, function(a, b)
					return a.unique < b.unique;
				end);

				print('we return', allPets[1] and allPets[1].unique);
				return allPets[1] and allPets[1].unique;
			end;

			table.sort(allPets, function(a, b)
				return a.properties.age < b.properties.age;
			end);

			local lowestAge = allPets[1] and allPets[1].properties.age;
			if (not lowestAge) then return end;

			local smallestAgePets = {};

			for _,  pet in next, allPets do
				if (pet.properties.age == lowestAge) then
					table.insert(smallestAgePets, pet);
				end;
			end;

			table.sort(smallestAgePets, function(a, b)
				return a.unique < b.unique;
			end);

			return smallestAgePets[1].unique;
		end;

		--// Pet Farm Action Functions

		local Actions = {
			hungry = function(data)
				local food = getFood();

				if not food then
					print('no food buying food');

					repeat
						remotes['ShopAPI/BuyItem']:InvokeServer('food', 'apple', {});
						task.wait(1);
					until getFood();

					print('bought food');
				else
					print('food found');
				end

				food = getFood()
				if not food then
					print('no food :(');
					return
				end

				print('equip food');
				remotes['ToolAPI/Equip']:InvokeServer(food);
				print('consume food');
				remotes['PetAPI/ConsumeFoodItem']:FireServer(food);

				local ranAt = tick();

				repeat
					task.wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			pizza_party = function(data)
				teleportTo('PizzaShop', 'MainDoor', {});

				local ranAt = tick();

				repeat
					task.wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			pool_party = function(data)
				teleportTo('MainMap', 'Neighborhood/MainDoor', {});

				local poolSiteCF = workspace:WaitForChild('StaticMap'):WaitForChild('Pool'):WaitForChild('PoolOrigin');
				local ranAt = tick();

				pcall(function()
					LocalPlayer.Character:SetPrimaryPartCFrame(poolSiteCF.CFrame * CFrame.new(0, 5, 0));
				end);

				repeat
					task.wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			salon = function(data)
				teleportTo('Salon', 'MainDoor', {});

				local ranAt = tick();

				repeat
					task.wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			dirty = function(data, pet)
				teleportTo('housing', 'MainDoor', {
					['house_owner'] = LocalPlayer
				})

				repeat task.wait() until getFurniture('generic_shower')

				task.spawn(function()
					remotes['HousingAPI/ActivateFurniture']:InvokeServer(LocalPlayer, getFurniture('generic_shower'), 'UseBlock', {
						['cframe'] = LocalPlayer.Character.PrimaryPart.CFrame
					}, pet)
				end)

				local ranAt = tick();

				repeat
					task.wait()
				until data.progress == 1 or tick() - ranAt > 60;

				local PetID = getPetId()

				remotes['ToolAPI/Unequip']:InvokeServer(PetID)
				remotes['ToolAPI/Equip']:InvokeServer(PetID)
			end,

			sleepy = function(data, pet)
				print('doing sleepy tp');
				repeat
					teleportTo('housing', 'MainDoor', {
						['house_owner'] = LocalPlayer
					})
					task.wait(1)
				until getFurniture('generic_crib');
				print('teleported!, using furniture and waiting for task to finish');

				task.spawn(function()
					remotes['HousingAPI/ActivateFurniture']:InvokeServer(LocalPlayer, getFurniture('generic_crib'), 'UseBlock', {
						['cframe'] = LocalPlayer.Character.PrimaryPart.CFrame
					}, pet)
				end)

				local ranAt = tick();

				repeat
					task.wait()
				until data.progress == 1 or tick() - ranAt > 60;
				print('task finished or timedout');

				local petId = getPetId();
				remotes['ToolAPI/Unequip']:InvokeServer(petId);
				remotes['ToolAPI/Equip']:InvokeServer(petId);
			end,

			bored = function(data)
				teleportTo('MainMap', 'Neighborhood/MainDoor', {})

				local BoredAilmentTarget = workspace:WaitForChild('StaticMap'):WaitForChild('Park'):WaitForChild('BoredAilmentTarget')
				local ranAt = tick();

				repeat
					pcall(function()
						LocalPlayer.Character:SetPrimaryPartCFrame(BoredAilmentTarget.CFrame * CFrame.new(0, 5, 0));
					end);

					RunService.Heartbeat:Wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			thirsty = function(data, Pet)
				repeat
					teleportTo('Nursery', 'MainDoor', {});
					task.wait(1);
				until isInNursery();

				local rootPart = LocalPlayer.Character and LocalPlayer.Character:WaitForChild('HumanoidRootPart', 10);
				if (not rootPart) then return end;

				task.wait(2);

				local ranAt = tick();

				repeat
					print('we fire it');
					task.spawn(function()
						remotes['HousingAPI/ActivateInteriorFurniture']:InvokeServer('f-8', 'UseBlock', {
							cframe = rootPart.CFrame
						}, Pet);
					end);

					task.wait(10);
				until data.progress == 1 or tick() - ranAt > 60;

				local petId = getPetId();

				remotes['ToolAPI/Unequip']:InvokeServer(petId);
				remotes['ToolAPI/Equip']:InvokeServer(petId);

				task.wait(2);
			end,

			sick = function(data)
				teleportTo('Hospital', 'MainDoor', {});
				local ranAt = tick();

				repeat
					remotes['MonitorAPI/HealWithDoctor']:FireServer();
					task.wait(1);
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			adoption_party = function(data)
				teleportTo('Nursury', 'MainDoor', {});
				local ranAt = tick();

				repeat
					task.wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			school = function(data)
				teleportTo('School', 'MainDoor', {});
				local ranAt = tick();

				repeat
					task.wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			hot_spring = function(data)
				teleportTo('MainMap', 'Neighborhood/MainDoor', {});

				local hotSpringCF = workspace:WaitForChild('StaticMap'):WaitForChild('HotSpring'):WaitForChild('HotSpringOrigin')
				local ranAt = tick();

				pcall(function()
					LocalPlayer.Character:SetPrimaryPartCFrame(hotSpringCF.CFrame * CFrame.new(0, 5, 0));
				end);

				repeat
					task.wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end,

			camping = function(data)
				teleportTo('MainMap', 'Neighborhood/MainDoor', {});

				local campSiteCF = workspace:WaitForChild('StaticMap'):WaitForChild('Campsite'):WaitForChild('CampsiteOrigin');
				local ranAt = tick();

				pcall(function()
					LocalPlayer.Character:SetPrimaryPartCFrame(campSiteCF.CFrame * CFrame.new(0, 5, 0));
				end);

				repeat
					task.wait();
				until data.progress == 1 or tick() - ranAt > 60;
			end
		};

		--// Pet Farm Loop

		local function calculateNeeded(ailments,percentage)
			return math.ceil(ailments/percentage);
		end;

		coroutine.wrap(function()
			while task.wait(1) do
				if (not library.flags.petFarm) then continue end;
				inventory = clientData.get('inventory');

				local petCharWrapper = clientData.get('pet_char_wrapper');
				local equipManager = clientData.get('equip_manager');

				local autoDataLoss = library.flags.autoDataloss;

				if (not equipManager) then
					print('no equip manager!');
					continue;
				end

				local petId = getPetId();
				local currentEquipedPet = equipManager.pets;

				if not currentEquipedPet or currentEquipedPet.unique ~= petId or not petCharWrapper then
					remotes['ToolAPI/Unequip']:InvokeServer(petId);
					remotes['ToolAPI/Equip']:InvokeServer(petId);
				end;

				currentEquipedPet = equipManager.pets;

				if (not currentEquipedPet or not currentEquipedPet.properties) then
					print('no currentEquipedPet');
					continue;
				end;

				local ailmentsCompleted = currentEquipedPet.properties.ailments_completed;
				if (not ailmentsCompleted) then print('no ailment completed'); continue end;

				if (not petCharWrapper or not petCharWrapper.ailments_monitor or not petCharWrapper.ailments_monitor.ailments) then print('no pet char wrapper'); continue end;

				local percentage = petCharWrapper.pet_progression.percentage;
				if (not percentage) then continue end;

				local willHatch = calculateNeeded(ailmentsCompleted, percentage)-1 == ailmentsCompleted;
				local isEgg = petsDB[currentEquipedPet.id].is_egg;
				print(isEgg, ailmentsCompleted, willHatch, percentage, calculateNeeded(ailmentsCompleted, percentage));
				if (isEgg and ailmentsCompleted > 0 and willHatch and not MemStorageService:HasItem(petId) and autoDataLoss) then
					print('we rejoin server');
					MemStorageService:SetItem(petId, 'true');
					rejoinServer();
					continue;
				end;

				local function getAllAilments(noMT)
					-- This function is really bad but we have to do this cause the game keeps replacing the table
					local ailments = {};

					for _, ailmentData in next, uiManager.apps.AilmentsMonitorApp.ailments_data do
						for _, prop in next, ailmentData.props.babies do
							if (not prop.is_pet) then continue end;
							if (noMT) then
								table.insert(ailments, prop);
								continue;
							end;

							prop = table.clone(prop);
							prop.progress = nil;

							setmetatable(prop, {
								__index = function(self, p)
									if (p == 'progress') then
										for _, ailment in next, getAllAilments(true) do
											if (ailment.unique == prop.unique) then
												print('we returned', ailment.progress);
												return ailment.progress;
											end;
										end;

										print('we dont find it!, prob got removed');
										return 1;
									end;

									return rawget(self, p);
								end
							});

							table.insert(ailments, prop);
						end;
					end;

					return ailments;
				end;

				local ailments = getAllAilments();

				local function getAilment()
					for _, v in next, ailments do
						if (v.id == 'sleepy') then
							return v;
						end;
					end;

					return ailments[1];
				end;

				local ailment = getAilment();
				if (not ailment) then print('no ailment') continue end;
				if (not Actions[ailment.id]) then print('UH ???') continue end;

				if (willHatch and autoDataLoss) then
					print('ON Y VA?');
					funcs.setDataloss();

					task.spawn(function()
						print('pet will hatch, waiting for it to hatch');
						local _, pet = remotes['PetAPI/OwnedEggHatched'].OnClientEvent:Wait();

						print('webhook send', library.flags.webhookUrl);

						if (library.flags.wantedPets[pet.name]) then
							Webhook.new(library.flags.webhookUrl):Send(string.format('@everyone You got a %s %s', pet.rarity, pet.name), true);

							-- disdplay webhook notif;
							funcs.unsetDataloss();
						else
							Webhook.new(library.flags.webhookUrl):Send(string.format('You got a unwanted %s %s', pet.rarity, pet.name), true);
						end;

						print('pet hatched!', pet.name, pet.id, pet.rarity);
						task.wait(1);
						rejoinServer();
					end);
				end;

				print('going for' .. ailment.id .. '\n', equipManager.pets, equipManager.pets.id);
				Actions[ailment.id](ailment, petCharWrapper.char);
				task.wait(2.5);

				if (willHatch and autoDataLoss) then
					print('stopped');
					return;
				end;
			end;
		end)();

		--// Baby Farm

		LocalPlayer.PlayerGui.AilmentsMonitorApp.Ailments.ChildAdded:Connect(function(ailment)
			if library.flags.babyFarm then
				onAilmentAdded(ailment);
			end;
		end);

		--// Auto Paycheck

		coroutine.wrap(function()
			while task.wait(1) do
				if library.flags.autoPayCheck then
					remotes['PayAPI/CashOut']:InvokeServer();
				end;
			end;
		end)();

		--// Local Stuff Loop

		UserInputService.JumpRequest:Connect(function()
			if library.flags.infiniteJump and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid') then
				LocalPlayer.Character.Humanoid:ChangeState('Jumping');
			end;
		end);

		RunService.Stepped:Connect(function()
			if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid') and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
				LocalPlayer.Character.Humanoid.WalkSpeed = library.flags.walkSpeed;
				LocalPlayer.Character.Humanoid.JumpPower = library.flags.jumpHeight;

				if (not library.flags.noclip or library.flags.petFarm) then return end;

				for _, v in next, LocalPlayer.Character:GetChildren() do
					if v:IsA('BasePart') then
						v.CanCollide = false;
					end;
				end;
			end;
		end);
	end)()
end

if (gameName == 'Parkour') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];



		local column1, column2 = unpack(library.columns);

		local ReplicatedStorage, Players, RunService = Services:Get('ReplicatedStorage', 'Players', 'RunService');
		local IsA = game.IsA;

		local LocalPlayer = Players.LocalPlayer;
		local Heartbeat = RunService.Heartbeat;

		local pointsAutoFarm;
		local toggleBagEsp;
		local disconnectOnModJoin;
		local alwaysPerfectLandings;
		local infWallJump;
		local rgbChat;
		local annoy;
		local enableRenderDistance;
		local infWallRun;
		local blackBubbleChat;

		local bagEsp = {};

		do -- // Bag Esp
			bagEsp.__index = bagEsp;
			bagEsp.objects = {};

			function bagEsp.new(bag)
				local self = setmetatable({}, bagEsp);
				self.rarity = bag.Rarity.Value;
				self.root = bag.PrimaryPart;

				self.line = Drawing.new('Line');
				self.line.Transparency = 1;
				self.line.Color = Color3.fromRGB(255, 255, 255);

				self.text = Drawing.new('Text');
				self.text.Center = true;
				self.text.Color = Color3.fromRGB(255, 255, 255);
				self.text.Transparency = 1;

				table.insert(bagEsp.objects, self);

				return self;
			end;

			function bagEsp:hide()
				self.text.Visible = false;
				self.line.Visible = false;
			end;

			function bagEsp:update(myRootPart)
				if(not library.flags.toggleBagEsp) then
					return self:hide();
				end;

				local distance = (self.root.Position - myRootPart.Position).Magnitude;
				if(distance > library.flags.maxBagEspDistance) then
					return self:hide();
				end;

				local screenPosition, visible = workspace.CurrentCamera:WorldToViewportPoint(self.root.Position);
				if(not visible) then
					return self:hide();
				end;

				local vectorScreenPosition = Vector2.new(screenPosition.X, screenPosition.Y);
				local viewportSize = workspace.CurrentCamera.ViewportSize;

				self.text.Position = vectorScreenPosition;
				self.text.Text = string.format("[%s] [%.02f]", self.rarity, distance);
				self.text.Visible = true;

				self.line.From = Vector2.new(viewportSize.X / 2, viewportSize.Y);
				self.line.To = vectorScreenPosition;
				self.line.Visible = true;
			end;

			function bagEsp:destroy()
				table.remove(self.objects, table.find(self.objects, self));

				self.line:Remove();
				self.text:Remove();

				self.line = nil;
				self.text = nil;
			end;

			local function onBagAdded(instance)
				if(instance:FindFirstChild('BagTouchScript')) then
					local esp = bagEsp.new(instance);
					instance:GetPropertyChangedSignal('Parent'):Wait();
					esp:destroy();
				end;
			end;

			for i, v in next, workspace:GetChildren() do
				coroutine.wrap(onBagAdded)(v);
			end;

			workspace.ChildAdded:Connect(onBagAdded);
		end;

		do -- // Hooks
			local blacklistedEvents = {'LandWithForceField', 'UpdateCombo', 'HighCombo'};
			local oldNamecall;
			local oldNewIndex;

			local function returnOne()
				return 1;
			end;

			local getCurrentCombo = ReplicatedStorage.GetCurrentCombo
			getCurrentCombo.OnClientInvoke = returnOne;

			oldNamecall = hookmetamethod(game, '__namecall', function(self, ...)
				----SX_VM_CNONE();
				local method = getnamecallmethod();

				if(method == 'FireServer' and table.find(blacklistedEvents, tostring(self))) then
					return;
				end;

				return oldNamecall(self, ...);
			end);

			oldNewIndex = hookmetamethod(game, '__newindex', function(self, p, v)
				----SX_VM_CNONE();
				if(p == 'WalkSpeed' and IsA(self, 'Humanoid') and library.flags.toggleSpeedHack) then
					v = library.flags.speedHack;
					return oldNewIndex(self, p, v);
				elseif(p == 'OnClientInvoke' and self == getCurrentCombo) then
					print('attempt to change onclientinvoke');
					return;
				end;

				return oldNewIndex(self, p, v);
			end);

			local oldMathClamp;
			oldMathClamp = hookfunction(getrenv().math.clamp, function(n, min, max)
				if(min == 0 and max == 0.4 and string.find(debug.traceback(), 'upMovement') and library.flags.perfectMs) then
					print('called', n, min, max, debug.traceback());
					-- table.foreach(getconstants(2), warn);

					return Random.new():NextInteger(library.flags.perfectMsRange, library.flags.perfectMsRange + 10) / 1000;
				end;

				return oldMathClamp(n, min, max);
			end);
		end;

		do -- // Utility
			local mainEnv = getsenv(LocalPlayer:WaitForChild('Backpack'):WaitForChild('Main'));

			local forceField = Instance.new('ForceField');
			forceField.Visible = false;

			local client = {};

			local function onCharacterAdded()
				wait(1);
				mainEnv = getsenv(LocalPlayer:WaitForChild('Backpack'):WaitForChild('Main'));
				repeat wait(); until mainEnv.updateGrapplerPos;
				client = getupvalue(mainEnv.updateGrapplerPos, 2);

				local oldGearIs = mainEnv.gearIs;

				function mainEnv.gearIs(bodyType, gearType)
					if(library and gearType == 'PowerGauntlet' and library.flags.powergripMode) then
						return true
					end;

					return oldGearIs(bodyType, gearType);
				end;

				local oldComboAdd = mainEnv.comboAdd;
				function mainEnv.comboAdd(...)
					if(checkcaller()) then
						return;
					end;

					return oldComboAdd(...);
				end;

				local oldupdatePlayerVisibility = mainEnv.updatePlayerVisibility;
				local lastUpdatedAt = 0;

				function mainEnv.updatePlayerVisibility(...)
					if (tick() - lastUpdatedAt < 2) then return end;
					lastUpdatedAt = tick();

					return oldupdatePlayerVisibility();
				end
			end;

			function pointsAutoFarm()
				while(library.flags.togglePointsAutoFarm) do
					local wallrunDist = math.random(85, 99);

					local mt = setmetatable({wallrunDist = wallrunDist}, {
						__newindex = function(self, p, v)
							if(p == 'combo') then
								v = 5;
							end;

							rawset(self, p, v);
						end;
					});

					mainEnv.getfenv = newcclosure(function()
						return mainEnv;
					end);

					pcall(mainEnv.pointsAdd, wallrunDist * 0.8, 'wallrun', mt);
					task.wait(0.4 + math.random() * 1.5);
				end;
			end;

			function toggleBagEsp()
				repeat
					local myRootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;

					if(myRootPart) then
						for i, v in next, bagEsp.objects do
							v:update(myRootPart);
						end;
					end;

					Heartbeat:Wait();
				until not library.flags.toggleBagEsp;
			end;

			function disconnectOnModJoin()
				while(library.flags.disconnectOnModJoin) do
					for i, v in next, Players:GetPlayers() do
						pcall(function()
							local role = v:GetRoleInGroup(3468086);
							if(role ~= 'Member' and role ~= 'Guest') then
								LocalPlayer:Kick('\nModerator Joined');
							end;
						end);
					end;

					wait();
				end;
			end;

			function alwaysPerfectLandings(t)
				while(library.flags.alwaysPerfectLandings) do
					client.lastPrep = tick();
					client.preparePlaying = true;
					Heartbeat:Wait();
				end;
			end;

			function infWallJump()
				while(library.flags.infWallClimb) do
					client.numWallclimb = math.huge;
					Heartbeat:Wait();
				end;

				client.numWallclimb = 1;
			end;

			function infWallRun(toggle)
				if(not toggle) then return end;

				while(library.flags.infWallRun) do
					client.numWallrun = math.huge;
					Heartbeat:Wait();
				end;

				client.numWallrun = 1;
			end;

			function rgbChat(t)
				ReplicatedStorage.BubbleColours[LocalPlayer.Name].RGB.Value = t and true;
			end;

			function blackBubbleChat(t)
				ReplicatedStorage.BubbleColours[LocalPlayer.Name].Value = t and Color3.fromRGB(30, 30, 30) or Color3.fromRGB(255, 255, 25);
			end;

			function annoy(toggle)
				if(not toggle) then return end;
				repeat
					mainEnv.playCharacterSound("GrapplePull");
					mainEnv.playCharacterSound("Grapple");
					Heartbeat:Wait();
				until not library.flags.annoy;
			end;

			do -- // Render Distance Setup
				local chunkObjectsList = {workspace.Props, workspace.TimeTrials, workspace.Billboards, workspace.BustableDoors, workspace.MapDecoration};
				local chunkObjects;

				local function getPartPosition(object)
					return object:IsA('BasePart') and object.Position or object:IsA('Model') and object.WorldPivot.Position;
				end

				local function updateChunk(disable)
					local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
					if(not rootPart or not chunkObjects) then return end;

					local rootPosition = rootPart.Position;
					local maxRenderDistance = (library.flags.renderDistanceValue or 500);

					for i = 1, #chunkObjects do
						local v = chunkObjects[i];
						if(not disable and (v.position - rootPosition).Magnitude >= maxRenderDistance) then
							v.object.Parent = nil;
						else
							v.object.Parent = chunkObjectsList[v.oldParent];
						end;
					end;
				end;

				function enableRenderDistance(toggle)
					if (not toggle) then
						updateChunk(true);
						return
					end;

					if (not chunkObjects) then
						chunkObjects = {};

						for i, v in next, chunkObjectsList do
							for i2, v2 in next, v:GetChildren() do
								table.insert(chunkObjects, {position = getPartPosition(v2), object = v2, oldParent = i});
							end;
						end;

						print('[Map Chunk] made', #chunkObjects, 'chunk objects');
					end;

					repeat
						updateChunk();
						task.wait(1);
					until not library.flags.enableRenderDistance;

					updateChunk(true);
				end;
			end;

			LocalPlayer.CharacterAdded:Connect(onCharacterAdded);
			onCharacterAdded();
		end;

		local parkourAutoFarm = column1:AddSection('Auto Farm');
		local parkourCharacter = column1:AddSection('Main');
		local parkourBagEsp = column2:AddSection('Bag Esp');
		local parkourMisc = column2:AddSection('Misc');

		parkourAutoFarm:AddToggle({text = 'Toggle Points Auto Farm', callback = pointsAutoFarm})

		parkourCharacter:AddToggle({text = 'Always Perfect Landings', callback = alwaysPerfectLandings});
		parkourCharacter:AddToggle({text = 'Powergrip Mode'});
		parkourCharacter:AddToggle({text = 'Toggle Speed Hack'});
		parkourCharacter:AddToggle({text = 'Perfect Ms'}):AddSlider({flag = 'Perfect Ms Range', min = 10, max = 100});
		parkourCharacter:AddToggle({text = 'Inf Wall Climb', callback = infWallJump});
		parkourCharacter:AddToggle({text = 'Inf Wall Run', callback = infWallRun});
		parkourCharacter:AddSlider({text = 'Speed Hack', value = 100, min = 0, max = 500});

		parkourMisc:AddToggle({text = 'Enable Render Distance', callback = enableRenderDistance}):AddSlider({flag = 'Render Distance Value', min = 250, max = 5000});

		parkourMisc:AddToggle({text = 'Annoy', callback = annoy});
		parkourMisc:AddToggle({text = 'Disconnect On Mod Join', callback = disconnectOnModJoin});
		parkourMisc:AddToggle({text = 'Rgb Chat', callback = rgbChat});
		parkourMisc:AddToggle({text = 'Black Bubble Chat', callback = blackBubbleChat})

		parkourBagEsp:AddToggle({text = 'Toggle Bag Esp', callback = toggleBagEsp});
		parkourBagEsp:AddSlider({text = 'Max Bag Esp Distance', value = 10000, min = 100, max = 10000});
	end)()
end

if (gameName == 'Mighty Omega') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];



		local column1, column2 = unpack(library.columns);


		local ReplicatedStorage, Players, RunService, Lighting, UserInputService, VirtualInputManager, TeleportService, PathfindingService, MarketPlaceService, guiService = Services:Get(
			'ReplicatedStorage',
			'Players',
			'RunService',
			'Lighting',
			'UserInputService',
			'VirtualInputManager',
			'TeleportService',
			'PathfindingService',
			'MarketplaceService',
			'GuiService'
		);

		local chatLogger = Textlogger.new({
			title = 'Chat Logger',
			preset = 'chatLogger',
			buttons = {'Copy Username', 'Copy User Id', 'Copy Text', 'Report User'}
		});

		do -- // Chat Logger
			chatLogger.OnPlayerChatted:Connect(function(player, message)
				local timeText = DateTime.now():FormatLocalTime('H:mm:ss', 'en-us');
				local playerName = player.Name;

				message = ('[%s] [%s] %s'):format(timeText, playerName, message);

				chatLogger:AddText({
					text = message,
					player = player
				});
			end);
		end;

		local plr = Players.LocalPlayer;
		local plrGUI = plr.PlayerGui;
		local char = plr.Character;
		local mouse = plr:GetMouse()
		local camera = workspace.CurrentCamera;
		local LivingThings;
		local tryingToSleep = false;
		local doingAction = false;
		local modNotifier = audioPlayer.new({
			soundId = 'rbxassetid://5608799630',
			volume = 10,
			forcedAudio = 10,
			looped = true
		});


		--function inits
		local isA = game.IsA;
		local ffc = game.FindFirstChild;
		local ffcwia = game.FindFirstChildWhichIsA;
		local kick = game.Players.LocalPlayer.Kick;

		plr.CharacterAdded:Connect(function()
			char = plr.Character;
		end);

		plr.ChildAdded:Connect(function(v)
			if v.Name ~= "PlayerGui" then return; end

			plrGUI = v;
		end)

		local modroles = {
			["MainChar"] = true;
			["Mod"] = true;
			["Trial Mod"] = true;
			["Associates."] = true;
			["Owner"] = true;
		};

		local plrTbl = {};
		local function checkIfMod(v)
			local role;
			pcall(function()
				role = v:GetRoleInGroup(4800422);
			end);

			plrTbl[string.lower(v.Name)] = v;

			if not library.flags.modNotifier or not role or not modroles[role] then return; end
			if library.flags.autoPanic then library:Unload(); end

			if library.flags.autoLeave then
				if char then char:Destroy(); end
				task.delay(10,kick,plr,'Mod joined your server');
			end

			modNotifier:Play();

			local notif = ToastNotif.new({
				text = "There is a mod in your server: "..v.Name;
			});

			notif.Destroying:Connect(function()
				modNotifier:Stop();
			end)
		end

		Players.PlayerAdded:Connect(checkIfMod);

		Players.PlayerRemoving:Connect(function(v)
			plrTbl[string.lower(v.Name)] = nil;
		end);

		--Non exploit functions

		local function parseKey(str)
			return Utility.find({str:byte(1,9999)}, function(v) return v > 128 end);
		end

		local function getKey(script)
			if not script:IsA("LocalScript") then error("Expected a localscript got "..script.ClassName) end
			local key;

			local ran,env = pcall(getsenv,script);
			if not ran then return; end

			for _,v in next, env do
				if typeof(v) ~= 'function' then continue; end

				for _,k in next, getupvalues(v) do
					if typeof(k) ~= 'string' or not parseKey(k) then continue; end

					key = k;
					break;
				end
			end

			if key then return key; end

			for _,v in next, script.Parent:GetDescendants() do
				local con = string.match(v.ClassName,"Button") and getconnections(v.MouseButton1Click)[1] or getconnections(v.Changed)[1];
				if not con or not con.Function then continue; end

				for _,k in next, getupvalues(con.Function) do
					if typeof(k) ~= 'string' or not parseKey(k) then continue; end

					key = k;
					break;
				end

				if key then break; end
			end
			return key;
		end

		getgenv().getKey = getKey;

		local function round(n, decimals)
			decimals = decimals or 0
			return math.floor(n * 10^decimals) / 10^decimals
		end
		local function loaded()
			if not char then
				return false;
			elseif not ffc(char,"HumanoidRootPart") then
				return false;
			elseif not ffc(char,"Humanoid") then
				return false;
			elseif not ffc(char,"DB") then
				return false;
			end
			return true;
		end

		local function safeClick(part) --Part should have a vector3 and contain ClickDetector

			if not library.flags.useMouseClick then fireclickdetector(part.Parent:FindFirstChildWhichIsA("ClickDetector")); return; end
			if (char.HumanoidRootPart.Position-part.Position).Magnitude <= 10 then
				local posOnC = workspace.Camera:WorldToScreenPoint(part.Position);
				local inset = guiService:GetGuiInset();
				local center = {
					x = (posOnC.X+inset.X)+(part.Size.X/2);
					y = (posOnC.Y+inset.Y)+(part.Size.Y/2);
				}
				VirtualInputManager:SendMouseMoveEvent(center.x,center.y,game);
				task.wait(0.1);
				VirtualInputManager:SendMouseButtonEvent(center.x,center.y,0,true,game,0);
				task.wait(0.1);
				VirtualInputManager:SendMouseButtonEvent(center.x,center.y,0,false,game,0);
			end
		end

		local function safeButton(button)
			local size = button.AbsoluteSize;
			local pos = button.AbsolutePosition;
			local inset = guiService:GetGuiInset();
			local center = {
				x = (pos.X+inset.X)+(size.X/2);
				y = (pos.Y+inset.Y)+(size.Y/2);
			}
			VirtualInputManager:SendMouseButtonEvent(center.x,center.y,0,true,game,0);
			task.wait(0.1);
			VirtualInputManager:SendMouseButtonEvent(center.x,center.y,0,false,game,0);
		end
--[[For synv3 update

local execmenu = false;
if ffc(plr,"PlayerGui") and ffc(plrGUI,"LoadMenu") then
    local result = filtergc('function',{IgnoreSyn=true,Constants={0.2,"LoadStats"}},true);
    setconstant(v,43,100);
    execmenu = true;
end
--]]

		--Execute in menu
		local execmenu = false;
		if ffc(plr,"PlayerGui") and ffc(plrGUI,"LoadMenu") then
			local env = plr.PlayerGui.LoadMenu.LocalScript;
			for i,v in next, getgc() do
				if typeof(v) == 'function' and rawget(getfenv(v),"script") == env then
					for t,k in next, getconstants(v) do
						if k == 0.2 then
							setconstant(v,t,100);
						end
					end
				end
			end

			execmenu = true;
		end
		repeat task.wait() until char;
		repeat task.wait() until ffc(plr,"Backpack");
		repeat task.wait() until ffc(plr.Backpack,"LocalS");
		--Inits
		local foodTool,lastFood;
		local hungerBar;
		local calorieBar;
		local staminaBar;
		local fatigueNum;
		local utility;
		local visualFrame;
		local beds = {};

		--Toggle inits
		local eating = false;
		local sprinting = false;

--[[Use this to update hash
    local plr = game.Players.LocalPlayer;
    local closure = (plr.Backpack.LocalS);
    setclipboard(getscripthash(closure));
]]

		repeat task.wait() until ffcwia(plr.Backpack,"Tool");
		if execmenu then
			task.wait(2);
		end

--[[ For synv3 update
local result = filtergc('function',{IgnoreSyn=true,Constants={"F1ySuspicion"}},true);

local banR_Name = getconstant(result,table.find(getconstants(result),"F1ySuspicion")-1);
local key = getupvalue(result,21);
local parent = getupvalue(result,20);
local banRemote = ffc(parent,banR_Name);

if not typeof(key) == 'string' then plr:Kick("Key was incorrect"); end
if not banRemote then plr:Kick("Failed to grab the ban remote"); end


]]

		local banRemote;
		local remoteKey;

		local function initGC()
			for _, v in next, getgc() do
				if (typeof(v) == 'function' and islclosure(v) and not is_synapse_function(v) and table.find(getconstants(v), 'F1ySuspicion')) then
					banRemote = getconstant(v, table.find(getconstants(v), 'F1ySuspicion') - 1);

					for _, uv in next, getupvalues(v) do
						if (typeof(uv) == 'string') then
							remoteKey = uv;
						end;
					end;

					if getupvalue(v,20) and ffc(getupvalue(v,20),banRemote) then
						banRemote = ffc(getupvalue(v,20),banRemote);
						return true;
					else
						return plr:Kick('Failed to grab ban remote');
					end;
				end;
			end;
		end;

		print('waiting for gc scan.');
		repeat task.wait(); until initGC();

		if not banRemote or not remoteKey then
			plr:Kick('Kicked you to protect your account something, in the game has changed.');
			return;
		end

		if (banRemote.Name ~= 'Detector') then
			plr:Kick('Kicked you to protect your account something, in the game has changed.');
			return;
		end

		local oldNamecall;
		oldNamecall = hookmetamethod(game, "__namecall",function(self, ...)
			------SX_VM_CNONE();

			local ncMethod = getnamecallmethod();
			if self == banRemote and ncMethod == "FireServer" or self == banRemote and ncMethod == "fireServer" then
				return;
			end;

			if library.flags.infRhythm then

				if ncMethod == 'Stop' or ncMethod == 'Play' then
					local remote = ffc(plr,"Action",true);
					if (not remote) then return oldNamecall(self, ...); end;

					local connection = getconnections(remote.OnClientEvent)[1];
					if (not connection) then return oldNamecall(self, ...); end;

					local actionCon = getupvalues(connection.Function);

					local toolInfo = actionCon[13];
					if toolInfo and toolInfo.Stance and self == toolInfo.Stance then
						toolInfo.Priority = (ncMethod == 'Stop') and 1000 or 1;
						return;
					end
				end

				local args = {...};
				if args[2] == "RhythmStance" and args[3] == false then return; end
			end

			return oldNamecall(self,...);
		end);

		local oldFireServer;
		oldFireServer = hookfunction(Instance.new("RemoteEvent").FireServer,function(self, ...)
			------SX_VM_CNONE();

			if self == banRemote then
				return;
			end;

			return oldFireServer(self,...);
		end);

		--Setting values probably will use a promise for this later!!

		local function grabUIObjects()
			pcall(function()
				if (plrGUI:FindFirstChild('MainGui') and plrGUI.MainGui:FindFirstChild('Utility')) then
					utility = plrGUI.MainGui.Utility;
					hungerBar = utility.StomachBar.BarF.Bar;
					calorieBar = utility.StomachBar.Calories.Bar;
					staminaBar = utility.StamBar.BarF.Bar;
					fatigueNum = utility.BodyFatigue;
					visualFrame = utility.VisualFrame;
				end
			end);
		end;

		grabUIObjects();

		local Stats = setmetatable({},{ --Creates a metatable that returns values in %
			__index = function(t,k)
				if not hungerBar or hungerBar.Parent == nil then
					grabUIObjects();
				end;

				if k == "Hunger" then
					if hungerBar then
						return hungerBar.Size.X.Scale*100;
					end
				elseif k == "Calories" then
					if calorieBar then
						return calorieBar.Size.X.Scale*100;
					end
				elseif k == "Stamina" then
					if staminaBar then
						return staminaBar.Size.X.Scale*100;
					end
				elseif k == "Fatigue" then
					if fatigueNum then
						return tonumber(string.match(fatigueNum.Text,"[%d%.]+"));
					end
				elseif k == "isEating" then
					if ffc(char,"DB") then
						return char.DB.Value;
					end
				elseif k == "Rhythm" then
					if ffc(char,"Rhythm") then
						return char.Rhythm.Value;
					end
				elseif k == "isKnocked" then
					if ffc(char,"Ragdolled") then
						return char.Ragdolled.Value;
					end
				elseif k == "Sleeping" then
					if not loaded() then return false; end

					for i,v in next, char.HumanoidRootPart:GetConnectedParts() do
						if v.Name == "Matress" then
							return true;
						end
					end
					return false;
				elseif k == "isRunning" then
					if not loaded() then return false; end

					local foundAnim = false;
					for i,v in next, char.Humanoid.Animator:GetPlayingAnimationTracks() do
						local curId = v.Animation.AnimationId;
						if curId == "rbxassetid://5087736730" or curId == "rbxassetid://4889489948" then
							foundAnim = true;
						end
					end
					return foundAnim;
				elseif k == "isSquatting" then
					if not loaded() then return false; end

					local foundAnim = false;
					for i,v in next, char.Humanoid.Animator:GetPlayingAnimationTracks() do
						local curId = v.Animation.AnimationId;
						if curId == "rbxassetid://4934239228" then
							foundAnim = true;
						end
					end
					return foundAnim;
				elseif k == "isPushuping" then
					if not loaded() then return false; end

					local foundAnim = false;
					for i,v in next, char.Humanoid.Animator:GetPlayingAnimationTracks() do
						local curId = v.Animation.AnimationId;
						if curId == "rbxassetid://4931281501" then
							foundAnim = true;
						end
					end
					return foundAnim;
				elseif k == "ProteinShake" then
					if visualFrame then
						return ffc(visualFrame,"Protein Shake");
					end
				elseif k == "BCAA" then
					if visualFrame then
						return ffc(visualFrame,"BCAA");
					end
				elseif k == "FatBurner" then
					if visualFrame then
						return ffc(visualFrame,"Fat Burner");
					end
				elseif k == "Scalar" then
					if visualFrame then
						return ffc(visualFrame,"Scalar");
					end
				end
			end
		});
		getfenv().Stats = Stats; --Sets to script env

		local env = getsenv(plr.Backpack.LocalS)

		--Gets all the beds on the map
		for i,v in next, workspace:GetDescendants() do
			if isA(v,"ClickDetector") and v.Parent.Name == "Bed" and ffc(v.Parent,"Blanket") then
				table.insert(beds,v.Parent);
			end
		end
		--Get closest bed returns bed model that is closest to you.
		local function closestBed()
			if not loaded() then return; end
			local last = 15; --Must be within 15 studs to click a bed aka ontop of it
			local closest;
			for i = 1,#beds do
				if ffc(beds[i],"Matress") and (beds[i].Matress.Position - char.HumanoidRootPart.Position).magnitude < last then
					closest = beds[i];
					last = (closest.Matress.Position - char.HumanoidRootPart.Position).magnitude;
				end
			end
			return closest;
		end

		--Get food tool
		local function getFood(foodName)
			if not foodName then foodName = ""; end
			if not loaded() then return; end

			local food;
			if foodName ~= "" then
				food = ffc(plr.Backpack,foodName) or ffc(char,foodName);
			else
				food = ffc(plr.Backpack,"FoodScript",true) or ffc(char,"FoodScript",true);
			end

			if not food then return; end
			if isA(food,"Tool") then
				return {food, food.Name};
			else
				return {food.Parent, food.Parent.Name};
			end
		end

		local function isBusy()
			if library.flags.autoEat and Stats.Hunger <= library.flags["autoEatAt%"] then
				repeat task.wait(); until Stats.Hunger >= library.flags["eatTo%"] or (not library.flags.legitAutoMachine and not library.flags.riskyAutoMachine and not library.flags.autoDura)
			end
			if library.flags.autoProtein and getFood('Protein Shake') then
				repeat task.wait(); until Stats.ProteinShake or (not library.flags.legitAutoMachine and not library.flags.riskyAutoMachine and not library.flags.autoDura)
			end

			if library.flags.autoBcaa and getFood('BCAA') then
				repeat task.wait(); until Stats.BCAA or (not library.flags.legitAutoMachine and not library.flags.riskyAutoMachine and not library.flags.autoDura)
			end

			if library.flags.autoFatBurner and getFood('Fat Burner') then
				repeat task.wait(); until Stats.FatBurner or (not library.flags.legitAutoMachine and not library.flags.riskyAutoMachine and not library.flags.autoDura)
			end

			if library.flags.autoScalar and getFood('Scalar') then
				repeat task.wait(); until Stats.Scalar or (not library.flags.legitAutoMachine and not library.flags.riskyAutoMachine and not library.flags.autoDura)
			end
			return;
		end

		--Get tool by Name
		local function getToolByName(toolName)
			if not loaded() then return; end

			return ffc(plr.Backpack,toolName) or ffc(char,toolName);
		end

		--Get fight tool
		local function getStyle()
			if not loaded() then return; end
			if not ffc(plr,"Backpack") then return; end
			if ffc(plr.Backpack,"Style",true) then
				return ffc(plr.Backpack,"Style",true).Parent;
			elseif ffc(char,"Style",true) then
				return ffc(char,"Style",true).Parent;
			end
			return nil
		end

		--toggleSleep function that sleeps on bed and unsleep if in bed.
		local function toggleSleep()
			if not loaded() then return; end

			local bed = closestBed();
			if not bed then return; end

			if not Stats.Sleeping then
				tryingToSleep = true;
				repeat
					task.wait(0.2);
					char.Humanoid:UnequipTools();
					safeClick(bed.Matress);
				until Stats.Sleeping or not library.flags.autoSleep;
				tryingToSleep = false;

			elseif Stats.Sleeping and bed then
				char.Humanoid:UnequipTools();
				safeClick(bed.Matress);
				task.wait(0.5);
				for i,v in next, char:GetChildren() do
					if v.Name == "Safe" then
						v:Destroy();
					end
				end

			end
		end
		local trainButtons = {
			["Strike"] = {};
			["Dura"] = {};
			["Road"] = {};
		};
		local BadModels = {};
		--Puts all the buttons in appropriate tables
		for i,v in next, workspace:GetDescendants() do
			if v.Name == "Weight2" and v.Parent.Name == "Model" and not BadModels[v.Parent] then
				BadModels[v.Parent] = true;
			end
			if v.Name == "Roadwork: $40" then
				table.insert(trainButtons["Road"],v);
			elseif v.Name == "Strike Speed Training: $45" then
				table.insert(trainButtons["Strike"],v);
			elseif v.Name == "Durability Training: $40" then
				table.insert(trainButtons["Dura"],v);
			end
		end

		--Simple table search function
		local function search(tbl,str)
			for t,k in next, tbl do
				if string.match(t,str) then
					return k;
				end
			end
			return nil;
		end

		--Gives closest button in specified range
		local function getButton(Type,Range)
			if not loaded() then return; end
			local closest;
			for i,v in next, trainButtons[Type] do
				if (v.Head.Position-char.HumanoidRootPart.Position).magnitude < Range then
					Range = (v.Head.Position-char.HumanoidRootPart.Position).magnitude;
					closest = v;
				end
			end
			return closest;
		end

		local punchingBags = {};
		for i,v in next, workspace:GetDescendants() do
			if v.Name == "PunchingBag" then
				table.insert(punchingBags,v.bag);
			end
		end

		local function getBag()
			if not loaded() then return; end
			local closest;
			for i,v in next, punchingBags do
				if ((v.Position * Vector3.new(1, 0, 1))-(char.HumanoidRootPart.Position*Vector3.new(1,0,1))).magnitude < 6.5 then
					closest = v;
					break;
				end
			end
			return closest;
		end

		local function getPlayerInRange(ignoredCharacter,targetPos,range)
			local inRange;
			for i,v in next, LivingThings:GetChildren() do
				if v == ignoredCharacter then continue; end
				if not (ffc(v,"HumanoidRootPart")) then continue; end
				if (v.HumanoidRootPart.Position-targetPos).magnitude >= range then continue; end
				inRange = v;
				break;
			end

			return inRange;
		end

		local function getMobInRange(range)
			local inRange;
			local closest = range;
			for i,v in next, LivingThings:GetChildren() do
				if v == char then continue; end
				if ffc(Players,v.Name) then continue; end
				if not (ffc(v,"HumanoidRootPart")) or not ffc(char,"HumanoidRootPart") then continue; end
				if (v.HumanoidRootPart.Position-char.HumanoidRootPart.Position).magnitude >= closest then continue; end
				inRange = v;
				closest = (v.HumanoidRootPart.Position-char.HumanoidRootPart.Position).magnitude;
				break;
			end

			return inRange;
		end

		--Legit move to function uses pathfind
		local function legitMove(Position)
			if not loaded() then return; end
			local path = PathfindingService:CreatePath();
			path:ComputeAsync(char.HumanoidRootPart.Position, Position);
			local waypoints = path:GetWaypoints();
			for _, waypoint in pairs(waypoints) do
				char.Humanoid:MoveTo(waypoint.Position);
				char.Humanoid.MoveToFinished:Wait();
			end
		end

		local Foods = {
			["BCAA: $75"] = 75;
			["Fat Burner: $70"] = 70;
			["Protein Shake: $60"] = 60;
			["Ramen: $55"] = 55;
			["Hamburger: $55"] = 55;
			["Tofu Beef Soup: $45"] = 45;
			["Pancakes: $35"] = 35;
			["Pie: $35"] = 35;
			["Donut: $35"] = 35;
			["EZ Taco: $25"] = 25;
			["Hotdog: $25"] = 25;
			["Chicken Fries: $20"] = 20;
			["Omelette: $20"] = 20;
		}
		local foodButtons = {};
		for i,v in next, workspace:GetDescendants() do
			if Foods[v.Name] then
				table.insert(foodButtons,v);
			end
		end

		local Teleports = {
			["Protein CEO Bed"] = Vector3.new(-287.970764, 65.4588547, -256.528046);
			["Gym CEO Bed"] = Vector3.new(-605.105347, 72.4071121, -158.616302);
			["HOMRA CEO Bed"] = Vector3.new(-426, 84, -141);
			["Bank CEO Bed1"] = Vector3.new(-429.838226, 139.137741, -521.047363);
			["Bank CEO Bed2"] = Vector3.new(-400.048737, 138.245346, -519.46936);
			["Space BunkBed"] = Vector3.new(-293.323395, 50.5205154, -522.796326);
			["Mart CEO Bed"] = Vector3.new(-326.314911, 51.4444199, -514.276367);
			["Boxing CEO Bed"] = Vector3.new(845.754395, 50.2253838, -102.881683);
			["Ramen CEO Bed"] = Vector3.new(-1172.79968, 49.8107491, -309.082245);
			["PRIME CEO Bed"] = Vector3.new(-1127.57178, 13.5423203, -829.319519);
			["Police CEO Bed"] = Vector3.new(-791.490967, 49.4704971, 36.7121468);
			["AOKI Gym"] = Vector3.new(-423.82809448242, -8.1605911254883, -492.89834594727);
		}

		--Auto Dura OOP


		local autoDura = {};
		autoDura.__index = autoDura;

		local autoDuraTab = {};
		function autoDura.new(firstTurn,secondTurn)

			local self = setmetatable({},autoDura);
			table.insert(autoDuraTab, self);

			self._maid = Maid.new();

			self._firstChar = firstTurn;
			self._secondChar = secondTurn;

			self._combatStyle = getStyle();
			self._duraTool = getToolByName("Durability Training");
			self._duraButton = getButton("Dura",999);
			self._lastRefresh = tick();


			self._stopPunching = true;
			self._firstDebounce = false;
			self._secondDebounce = false;

			self._maid:GiveTask(self._firstChar.ChildAdded:Connect(function(v) --Tells us if first turn is using dura
				if v.Name ~= "DuraTrain" then return; end

				self._duraVal = v;
				self._lastTurn = self._firstChar;
			end))

			self._maid:GiveTask(self._secondChar.ChildAdded:Connect(function(v) --Tells us if second turn is using dura
				if v.Name ~= "DuraTrain" then return; end

				self._duraVal = v;
				self._lastTurn = self._secondChar;
			end))

			self._maid:GiveTask(self._firstChar.Humanoid.HealthChanged:Connect(function(health) --When the first turn gets too low
				if (health/self._firstChar.Humanoid.MaxHealth*100) >= library.flags["minimumHp%"] then return; end
				if self._firstDebounce then return; end

				self._stopPunching = true; --Stop punching if the first turn is too low
				self._firstDebounce = true;

				self:Unpop();
				self:Pop();

				repeat task.wait() until self._firstChar.Humanoid.Health >= self._firstChar.Humanoid.MaxHealth or not self._firstChar.Parent;

				if self._lastTurn ~= char then self._stopPunching = false; doingAction = true; end
				warn(debug.traceback(),'true')


				self._firstDebounce = false;
			end))

			self._maid:GiveTask(self._secondChar.Humanoid.HealthChanged:Connect(function(health) --When the second turn gets too low
				if (health/self._secondChar.Humanoid.MaxHealth*100) >= library.flags["minimumHp%"] then return; end
				if self._secondDebounce then return; end

				self._stopPunching = true; --Stop punching if the second turn is too low
				self._secondDebounce = true;

				self:Unpop();
				self:Pop();

				repeat task.wait() until self._secondChar.Humanoid.Health >= self._secondChar.Humanoid.MaxHealth or not self._secondChar.Parent;

				if self._lastTurn ~= char then self._stopPunching = false; doingAction = true; end
				warn(debug.traceback(),'true')


				self._secondDebounce = false;
			end))

			self._maid:GiveTask(RunService.RenderStepped:Connect(function()
				if tick()-self._lastRefresh <= 0.1 then return; end
				self._lastRefresh = tick();

				if self._stopPunching then return; end
				if not self._duraVal or not self._duraVal.Parent then return; end
				if not self._lastTurn or self._lastTurn == char then return; end --Only start punching when they have actually popped dura
				if self._combatStyle.Parent ~= char then char.Humanoid:UnequipTools(); self._combatStyle.Parent = char; return; end

				self._combatStyle:Activate();
			end))

			return self;
		end

		function autoDura:Unpop()
			if self._lastTurn ~= char then return; end

			if self._duraTool.Parent then --If the tool was removed then was unpopped
				self._duraTool.Parent = char;
				task.wait(0.7); --Make sure they stopped punching before unpopping

				self._duraTool:Activate();
				task.wait();
			end

			repeat task.wait() until not getToolByName("Durability Training")

			self:BuyDura();
			if not library.flags.takeTurns then return; end --If take turns is not enabled then don't start punching
			self._stopPunching = false; --Start trying to punch when lastTurn changes
			doingAction = true;
			warn(debug.traceback(),'true')

		end


		function autoDura:BuyDura()
			if not self._duraButton then self:CreateError("Stand closer to a durability training button"); return; end
			if getToolByName("Durability Training") then return; end

			char.Humanoid:UnequipTools();
			task.wait(0.1);

			while task.wait(0.2) do
				if getToolByName("Durability Training") then break; end
				print("BUYING IT PLEASE")
				safeClick(self._duraButton.Head);
			end

			self._duraTool = getToolByName("Durability Training");
			warn(self._duraTool)
			task.wait();

			doingAction = false;
			warn("SET DOING ACTION TO FALSE???",doingAction,self._stopPunching)
			isBusy(); --Wait until not waiting to eat
			doingAction = true;
			warn(debug.traceback(),'true')
		end

		function autoDura:Pop()
			if self._lastTurn and self._lastTurn == char and library.flags.takeTurns then return; end --If it was our turn last and take turns is on then don't pop
			if self._lastTurn and self._lastTurn ~= char and not library.flags.takeTurns then return; end --If it wasn't our turn last and take turns isn't on then don't pop
			if not self._duraTool or not self._duraTool.Parent then self:BuyDura(); end --Try to buy the tool

			if not self._duraTool or not self._duraTool.Parent then return; end --If still no tool then return


			char.Humanoid:UnequipTools();

			task.wait(0.1);

			self._duraTool.Parent = char;

			repeat task.wait(0.1); until char.Humanoid.Health >= char.Humanoid.MaxHealth --Wait till full health to pop
			repeat task.wait(0.1); until not Stats.isEating;

			self._duraTool.Parent = char;

			doingAction = true;
			task.wait(0.1);

			self._duraTool:Activate();
		end

		function autoDura:Start()
			if self._firstChar == char then
				self:BuyDura();
				self:Pop();
				return;
			end
			self._stopPunching = false;
			warn(debug.traceback(),'true')
			doingAction = true;
		end

		function autoDura:Destroy()
			self._maid:DoCleaning();
			for i,v in next, autoDuraTab do
				if v == self then
					autoDuraTab[i] = nil;
				end
			end
		end

		function autoDura:ClearAll()
			doingAction = false;
			for _,v in next, autoDuraTab do
				v:Destroy();
			end
		end

		function autoDura:CreateError(msg)
			ToastNotif.new({
				text = msg;
				duration = 20
			});
		end

		local streetESP = createBaseESP('streetFighters');
		local behelitESP = createBaseESP('behelit');

		local gMaid = Maid.new();

		do --Entity esp overwrite
			local playerInfoTab = {};
			local playerInfo = {};
			playerInfo.__index = playerInfo;

			function playerInfo.new(player,combatStyle)
				local self = setmetatable({},playerInfo);
				playerInfoTab[player] = self;

				self._player = player;
				self._char = player.Character;
				self._humanoid = self._char.Humanoid;
				self._combatStyle = tostring(combatStyle);
				self._currentStam = self._char.CurrentStamina.Value/self._char.MaxStamina.Value*100;
				self._maid = Maid.new();

				self._maid:GiveTask(self._char.CurrentStamina:GetPropertyChangedSignal("Value"):Connect(function()
					self._currentStam = self._char.CurrentStamina.Value/self._char.MaxStamina.Value*100;
				end))

				self._maid:GiveTask(self._humanoid:GetPropertyChangedSignal("Health"):Connect(function()
					self._health = self._humanoid.Health;
				end))

				self._maid:GiveTask(self._humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(function()
					self._maxHealth = self._humanoid.MaxHealth;
				end))

				self._maid:GiveTask(self._char.Destroying:Connect(function()
					self:Destroy();
				end))

				self._maid:GiveTask(self._char.AncestryChanged:Connect(function(part,newParent)
					if newParent ~= nil then return; end
					self:Destroy();
				end))
				return self;
			end

			function playerInfo:Destroy()
				self._maid:DoCleaning();
				for i,v in next, playerInfoTab do
					if v == self then
						playerInfoTab[i] = nil;
					end
				end
			end

			local function onCharacterAdded(player) --Normally this should be a character but we pass a player..
				if not player.Character:WaitForChild("CurrentStamina",10) then return; end
				local Style = (ffc(player.Backpack,"Style",true) or ffc(player.Character,"Style",true));

				if not Style then
					for i = 1,10 do
						task.wait(1);
						Style = (ffc(player.Backpack,"Style",true) or ffc(player.Character,"Style",true));
						if Style then break; end
					end
					if not Style then return; end
				end
				playerInfo.new(player,Style.Parent);
			end

			local function onPlayerAdded(player) --Kinda skidded from u nya
				if (player == plr) then return end;

				player.CharacterAdded:Connect(function()
					onCharacterAdded(player);
				end);

				if not (player.Character) then return; end

				task.spawn(onCharacterAdded, player);
			end;

			library.OnLoad:Connect(function()
				Utility.listenToChildAdded(Players, onPlayerAdded);
			end);

			local function onNewMobAdded(mob, espConstructor)
				if ffc(Players,mob.Name) then return; end;
				if not mob:WaitForChild("HumanoidRootPart",5) then return; end
				local pseudoMob = mob.HumanoidRootPart;

				local mobEsp = espConstructor.new(pseudoMob, mob.Name);

				local connection;
				connection = mob.AncestryChanged:Connect(function()
					if mob:IsDescendantOf(game) then return; end

					connection:Disconnect();
					mobEsp:Destroy();
				end);
			end;

			function EntityESP:Plugin()
				local plrInfo = playerInfoTab[self._player];
				if not plrInfo then return {}; end

				local text = '\n';
				local style, stamina = plrInfo._combatStyle, plrInfo._currentStam;
				if library.flags.showStyle then
					text = text..string.format('[Style: %s] ', style)
				end
				if library.flags.showStamina then
					text = text..string.format('[Stamina: %d]', stamina)
				end
				return {
					text = text
				}
			end;

			function Utility:renderOverload(data)
				local espSettings = data.espSettings;

				espSettings:AddToggle({text='Show Stamina'});
				espSettings:AddToggle({text='Show Style'});

				local sfESP = data.column2:AddSection("Street Fighter ESP");

				local function updateEsp(t)
					if (not t) then
						gMaid.streetFightersESP = nil;
						streetESP:UnloadAll();
						return;
					end;

					gMaid.streetFightersESP = RunService.Stepped:Connect(function()
						streetESP:UpdateAll();
					end);
				end;

				sfESP:AddToggle({
					text = "Street Fighters",
					callback = updateEsp
				});

				local bhESP = data.column2:AddSection("Behelit ESP");

				local function updateEspBehelit(t)
					if (not t) then
						gMaid.behelitESP = nil;
						behelitESP:UnloadAll();
						return;
					end;

					gMaid.behelitESP = RunService.Stepped:Connect(function()
						behelitESP:UpdateAll();
					end);
				end;

				bhESP:AddToggle({
					text = "Behelit",
					callback = updateEspBehelit
				});

				makeESP({
					sectionName = 'Mobs',
					type = 'childAdded',
					args = workspace.Live,
					callback = onNewMobAdded,
					onLoaded = function(section)
						section:AddToggle({
							text = 'Show Health',
							flag = 'Mobs Show Health'
						});
					end
				});
			end
		end

		local riskyTab = library:AddTab("MO (Risky)");
		local riskyColumn1 = riskyTab:AddColumn();
		local riskyColumn2 = riskyTab:AddColumn();
		local risky = riskyColumn1:AddSection("Risky");

		local Safe = column1:AddSection("Safe");
		local StatV = column1:AddSection("Stat Viewer");
		local Misc = column1:AddSection("Misc");

		local a= (function()
			local updateStat;
			local autoTrain;
			local stupidWait = false;
			local staminaP = 0;
			local flySpeed = 50;
			local trainMove = "Push up";
			local Events = ReplicatedStorage.Events;
			local StatT = {};
			local flingMaid = Maid.new();
			local teleMaid = Maid.new();
			local flyMaid = Maid.new();
			local strikeMaid = Maid.new();
			local legitMachineMaid = Maid.new();
			LivingThings = ffc(workspace,"Live") or Instance.new("Model");



			--Check if they accidentally pressed w or something stupid
			local stopOld = env.stopSprint;
			local runOld = env.runPrompt;

			env.runPrompt = function()
				if (library.flags.autoPunch and library.flags.autoRhythm and Stats.Rhythm < 100) then --Won't run until fully charged rhythm
					return;
				end
				local remote = plr:FindFirstChild("Action",true);
				if remote then
					print("Found remote")
					local actionCon = getupvalues(getconnections(remote.OnClientEvent)[1].Function);

					local toolInfo = actionCon[13];
					print(toolInfo)
					if toolInfo and toolInfo.Stance.IsPlaying then
						print("Told it to stop playing..")
						toolInfo.Stance:Stop();
					end
				end
				sprinting = true;
				return runOld();
			end

			env.stopSprint = function()
				sprinting = false;
				return stopOld();
			end

			--Spectate Function
			local curSpectate;
			local oldObject;
			local function spectatefunc(Object)
				if curSpectate == Object.Name then --Unspectate player
					curSpectate = "";
					Object.User.Txt.TextColor3 = Color3.new(255,255,255);
					camera.CameraSubject = char.Humanoid;
					return;
				end

				if not ffc(LivingThings,Object.Name) then return; end --If they dont have a player model

				if oldObject and oldObject.Parent then
					oldObject.User.Txt.TextColor3 = Color3.new(255,255,255); --Reset the color when they spectate someone new
				end

				oldObject = Object;
				curSpectate = Object.Name;

				Object.User.Txt.TextColor3 = Color3.new(255,0,0);
				camera.CameraSubject = LivingThings[Object.Name].Humanoid;
			end

			for i,v in next, plrGUI.PlayerList.Frame.ScrollF:GetChildren() do
				if not Players:FindFirstChild(v.Name) then continue; end

				v.User.MouseButton1Click:Connect(function()
					spectatefunc(v);
				end);
			end

			plrGUI.PlayerList.Frame.ScrollF.ChildAdded:Connect(function(v)
				v.User.MouseButton1Click:Connect(function()
					spectatefunc(v);
				end);
			end);

			plrGUI.ChildAdded:Connect(function(c)
				if c.Name ~= "PlayerList" then return; end
				if not c:WaitForChild("Frame",2) then return; end
				if not c.Frame:WaitForChild("ScrollF",2) then return; end
				repeat task.wait(); until ffc(c.Frame.ScrollF,plr.Name);
				task.wait(0.1)
				for i,v in next, c.Frame.ScrollF:GetChildren() do
					if not Players:FindFirstChild(v.Name) then continue; end

					v.User.MouseButton1Click:Connect(function()
						spectatefunc(v);
					end);
				end
			end);

			--Settings Functions


			Misc:AddToggle({text = "FPS Improver", callback = function(toggle)
				if not toggle then
					Lighting.GlobalShadows = true;
				else
					Lighting.GlobalShadows = false;
				end
			end});

			Misc:AddToggle({text = "Mod Notifier", state = true});
			Misc:AddToggle({text = 'Chat Logger', callback = function(t) chatLogger:SetVisible(t) end});
			Misc:AddDivider("Mod Notifier Settings");

			Misc:AddToggle({text = "Auto Leave",tip = "Sometimes risky as they chase people who insta log", callback = function() return; end});
			Misc:AddToggle({text = "Auto Panic", callback =  function() return; end});

			Misc:AddToggle({text = "Panic in Range",callback = function(toggle)
				if not toggle then return; end

				repeat
					task.wait(0.2)
					local closestPlayer = getPlayerInRange(char,char.HumanoidRootPart.Position,library.flags.panicRange);

					if closestPlayer then library:Unload(); end

				until not library.flags.panicInRange
			end})


			Misc:AddToggle({text = "Kick in Range",function(toggle)
				if not toggle then return; end

				repeat
					task.wait(0.2)
					local closestPlayer = getPlayerInRange(char,char.HumanoidRootPart.Position,library.flags.kickRange);

					if closestPlayer then plr:Kick("Player got too close to you, auto kicked."); end

				until not library.flags.kickInRange
			end})

			Misc:AddSlider({text = "Panic Range", min = 1, float = 5, max = 200,function() return; end});

			Misc:AddSlider({text = "Kick Range", min = 1, float = 5, max = 200, callback = function() return; end});

			Misc:AddButton({text = "Panic Button", callback = panic});
			Misc:AddButton({text = "Insta Log", callback = function() plr:Kick("Instantly logged") end});
			Misc:AddButton({text = "Server Hop", callback = function()
				local req = request({
					Method = "GET";
					Url = "https://games.roblox.com/v1/games/4878988249/servers/Public?sortOrder=Asc&limit=50"
				})
				local decoded = game.HttpService:JSONDecode(req.Body);
				local lowestping = 1000;
				local id = "";
				for i,v in next, decoded.data do
					if v.playing ~= 30 and v.id ~= game.JobId and v.ping < lowestping then
						lowestping = v.ping;
						id = v.id;
					end
				end
				TeleportService:TeleportToPlaceInstance(4878988249,id,plr);
			end});
			Misc:AddButton({text = "Rejoin Server", callback = function() TeleportService:TeleportToPlaceInstance(4878988249,game.JobId,plr) end});
			--Safe Functions

			Safe:AddToggle({text = "Use Mouse Click"});
			Safe:AddToggle({text = "Auto Train", callback = function(toggle)
				if not toggle then gMaid.autoTrainMaid = nil; return; end

				local env = getsenv(plr.Backpack.LocalS);
				local autoTrainDeb = false;
				local tool = ffc(plr.Backpack,trainMove) or ffc(char,trainMove);

				gMaid.autoTrainMaid = RunService.Stepped:Connect(function()
					if autoTrainDeb then return; end
					if not loaded() then sprinting = false; return; end
					if eating or Stats.Sleeping or Stats.isKnocked or Stats.isEating or tryingToSleep then sprinting = false; return; end

					autoTrainDeb = true;

					if trainMove == "Stamina" then

						if Stats.Stamina < staminaP and not Stats.isEating then sprinting = false; env.stopSprint(); repeat task.wait() until (Stats.Stamina+1 >= library.flags["maxStamina%"]) or (not library.flags.autoTrain) end --Waiting for stamina
						if not Stats.isEating and not sprinting and not Stats.Sleeping and not Stats.isKnocked then sprinting = true; env.runPrompt(); end --If they can run then make them run

						autoTrainDeb = false;
						return; --If training stamina then return
					end

					if not tool or tool.Name ~= trainMove then tool = ffc(plr.Backpack,trainMove) or ffc(char,trainMove); end --If they changed what training they are using then switch the tool
					if not tool or not tool.Parent then library.options.autoTrain:SetState(false); autoTrainDeb = false; return; end --If no tool or tool is in nil then turn off and return
					if tool.Parent ~= char and not Stats.isEating and not Stats.isKnocked and not Stats.Sleeping and not eating then char.Humanoid:EquipTool(tool); task.wait(0.2); end --If they arent doing something and dont have the tool equipped, equip the tool
					if eating or Stats.Sleeping or Stats.isKnocked then autoTrainDeb = false; return; end --If they are busy then return
					if Stats.Stamina < staminaP then repeat task.wait() until (Stats.Stamina+1 >= library.flags["maxStamina%"]) or (not library.flags.autoTrain) end --If has less than staminaP task.wait till max stamina

					if library.flags.trainingType == "Slow" then
						repeat task.wait() until not Stats.isSquatting or not library.flags.autoTrain;
						repeat task.wait() until not Stats.isPushuping or not library.flags.autoTrain;
					end

					if tool.Parent ~= char then autoTrainDeb = false; return print("Couldn't equip tool"); end
					tool:Activate();

					local task1;
					local task2;
					if library.flags.trainingType == "Slow" then

						task2 = task.delay(5,function()
							task.wait(5);
							task.cancel(task1);
							autoTrainDeb = false;
						end)

						task1 = task.spawn(function()
							if library.flags.training == "Push up" then
								repeat task.wait() until Stats.isPushuping or not library.flags.autoTrain;
							elseif library.flags.training == "Squat" then
								repeat task.wait() until Stats.isSquatting or not library.flags.autoTrain;
							end
							task.cancel(task2);
							autoTrainDeb = false;
						end)
					else
						autoTrainDeb = false;
					end
				end)
				env.stopSprint();
				sprinting = false;
			end});

			Safe:AddList({text = "Training",values = {"Push up","Squat","Stamina"},callback = function(val) trainMove = val end});
			Safe:AddList({text = "Training Type", values = {"Slow","Fast"}, callback = function() return; end});
			Safe:AddSlider({text = "Stamina %", tip = "When the training action will pause until max stamina %", float = 0.1, min = 0, max = 100,callback = function(val) staminaP = val end});
			Safe:AddSlider({text = "Max Stamina %", tip = "When the training action will resume", value = 99, min = 0, max = 100, float = 0.1, callback = function() return; end});

			Safe:AddToggle({text = "Auto Strikespeed", callback = function(toggle)
				--Bullshit code
				if not toggle then strikeMaid:DoCleaning(); return; end

				local fightTool = getStyle();
				if not fightTool then
					library.options.autoStrikespeed:SetState(false);
					return;
				end

				if not getBag() then
					library.options.autoStrikespeed:SetState(false);

					ToastNotif.new({
						text = "Stand closer to a bag to begin";
						duration = 5
					});
					return;
				end

				for i,v in next, BadModels do
					for t,k in next, i:GetChildren() do
						k.CanCollide = false;
					end
				end

				--Stuff that actually matters
				local shouldM2 = false;
				strikeMaid:GiveTask(char.ChildAdded:Connect(function(v)
					if v.Name == "Attacking" and v.Value == 4 then
						task.spawn(function() shouldM2 = true; task.wait(2); shouldM2 = false; end)
						v:Destroy();
					end
				end))

				local function tryHit(canHit)
					while (canHit.Value and library.flags.autoStrikespeed) do
						fightTool:Activate();
						if shouldM2 then
							local key = getKey(plr.Backpack.LocalS);
							if not key then return; end

							plr.Backpack.Action:FireServer(key,"GuardBreak",true);
						elseif not char:WaitForChild("Attacking",0.2) and canHit.Value then
							fightTool:Activate();
						end
						task.wait(1)
					end
				end

				local curBag = char.HumanoidRootPart.Position;
				strikeMaid:GiveTask(plrGUI.ChildAdded:Connect(function(v)
					if v.Name ~= "SpeedTraining" then return; end

					local canHit = v:WaitForChild("CanHit",5);
					if not canHit then return; end

					char.Humanoid:UnequipTools();
					fightTool.Parent = char;
					task.wait(0.1);

					strikeMaid:GiveTask(v.CanHit:GetPropertyChangedSignal("Value"):Connect(function()
						if not canHit.Value then return; end

						fightTool.Parent = char;
						tryHit(canHit);
					end))

					if not canHit.Value then return; end
					tryHit(canHit);
				end))


				strikeMaid:GiveTask(plrGUI.ChildRemoved:Connect(function(v)
					if v.Name ~= "SpeedTraining" then return; end
					if ffc(plr.Backpack,"Strike Speed Training") or ffc(char,"Strike Speed Training") then return; end

					local button = getButton("Strike",999);
					if not button then return; end

					char.Humanoid:UnequipTools();

					if ((button.Head.Position * Vector3.new(1, 0, 1)) - (char.HumanoidRootPart.Position * Vector3.new(1, 0, 1))).magnitude > 10 and library.flags.autoWalk then
						legitMove(button.Head.Position);
						safeClick(button.Head);
						legitMove(curBag);
					else
						safeClick(button.Head);
					end

					char.Humanoid:UnequipTools();
					local strikeTool = plr.Backpack:WaitForChild("Strike Speed Training",5) or ffc(char,"Strike Speed Training");

					if not strikeTool then return; end

					strikeTool.Parent = char;
					task.wait(0.3);
					strikeTool:Activate();
				end))

				if ffc(plrGUI,"SpeedTraining") then
					if fightTool.Parent ~= char then char.Humanoid:UnequipTools(); end

					local canHit = plrGUI.SpeedTraining:WaitForChild("CanHit",5);
					if not canHit then return; end

					fightTool.Parent = char;
					task.wait(0.1);

					strikeMaid:GiveTask(plrGUI.SpeedTraining.CanHit:GetPropertyChangedSignal("Value"):Connect(function()
						if not canHit.Value then return; end

						fightTool.Parent = char;
						tryHit(canHit);
					end))
					if not canHit.Value then return; end

					tryHit(canHit);
				else
					if ffc(plr.Backpack,"Strike Speed Training") or ffc(char,"Strike Speed Training") then return; end

					local button = getButton("Strike",999);
					if not button then return; end

					char.Humanoid:UnequipTools();
					if library.flags.autoWalk and ((button.Head.Position * Vector3.new(1, 0, 1)) - (char.HumanoidRootPart.Position * Vector3.new(1, 0, 1))).magnitude > 10 then
						legitMove(button.Head.Position);
						safeClick(button.Head);
						legitMove(curBag);
					else
						safeClick(button.Head);
					end

					char.Humanoid:UnequipTools();

					local strikeTool = plr.Backpack:WaitForChild("Strike Speed Training",5) or ffc(char,"Strike Speed Training");
					if not strikeTool then return; end

					strikeTool.Parent = char;
					task.wait(0.2);
					strikeTool:Activate();
				end
			end});

			Safe:AddToggle({text = "Auto Walk", tip = "This function is very obvious and clippable", callback = function() return; end})


			local autoPunch = column1:AddSection('Auto Punch');
			autoPunch:AddToggle({text = "Auto Punch",tip = "This is a Striking Power Macro" , callback = function(toggle)
				if not toggle then gMaid.autoPunchMaid = nil; gMaid.tryM2 = nil; return; end

				local autoPunchDeb = false;
				local shouldM2 = false;
				local fightTool = getStyle();
				if not fightTool then return; end

				local givenTask;
				gMaid.tryM2 = char.ChildAdded:Connect(function(v)
					if v.Name ~= "Attacking" then return; end

					if v.Value == 4 then
						givenTask = task.spawn(function() shouldM2 = true; task.wait(2); shouldM2 = false; end)
					elseif v.Value == 5 then
						shouldM2 = false;
						if givenTask then
							task.cancel(givenTask);
						end
					end
				end)

				gMaid.autoPunchMaid = RunService.Stepped:Connect(function()
					if autoPunchDeb then return; end
					if eating or Stats.isKnocked or not fightTool then return; end

					autoPunchDeb = true;

					if fightTool.Parent ~= char then char.Humanoid:UnequipTools(); fightTool.Parent = char; end --If the fightTool parent isnt char then give it to char
					if eating then repeat task.wait(); until (not eating) or (not library.flags.autoPunch); end --If eating then task.wait till not

					if (Stats.Stamina+1 >= 80) or Stats.Stamina <= library.flags["minStamina%"] then
						env.runPrompt();
						repeat
							if not Stats.isRunning then --To prevent loop from getting stuck
								env.runPrompt();
							end
							task.wait(0.2);
						until Stats.Stamina <= library.flags["minStamina%"] or not library.flags.autoPunch;

						env.stopSprint();
						repeat task.wait() until Stats.Stamina >= library.flags["staminaWait%"] or not library.flags.autoPunch;
					end

					if shouldM2 and library.flags.useM2 then
						local key = getKey(plr.Backpack.LocalS);
						if not key then autoPunchDeb = false; return; end

						plr.Backpack.Action:FireServer(key,"GuardBreak",true);
					else
						fightTool:Activate();
					end

					autoPunchDeb = false;
				end)
			end});

			autoPunch:AddSlider({text = "Min Stamina %", tip = "Will run until this % to sweat", min = 0, max = 100, float = 0.1, callback = function() return; end});
			autoPunch:AddSlider({text = "Stamina Wait %", tip = "Will wait till this % to punch", value = 99, min = 0, max = 100, callback = function() return; end, float = 0.1});
			autoPunch:AddToggle({text = "Use M2"})

			local autoClickSettings = column2:AddSection("Autoclick");

			autoClickSettings:AddToggle({text = "Hold M1", callback = function(t)
				if (not t) then
					gMaid.holdM1 = nil;
					return;
				end;

				local function canAttack()
					return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) and plr.Character and plr.Character:FindFirstChildWhichIsA("Tool");
				end;

				gMaid.holdM1 = task.spawn(function()
					while task.wait() do
						local tool = canAttack();
						if (not tool) then continue end;

						tool:Activate();
					end;
				end);
			end})


			autoClickSettings:AddToggle({text = "Auto Click", callback = function(toggle)
				if not toggle then return; end
				task.wait(1);
				repeat task.wait();
					local pos = UserInputService:GetMouseLocation();
					VirtualInputManager:SendMouseButtonEvent(pos.X,pos.Y,0,true,game,1);
					task.wait(library.flags.clickDelay);
					VirtualInputManager:SendMouseButtonEvent(pos.X,pos.Y,0,false,game,1);
				until not library.flags.autoClick;
			end});

			autoClickSettings:AddSlider({text = "Click Delay", value = 0.5, min = 0, max = 5, float = 0.1});

			local legitAutoMachine = column2:AddSection("Legit Auto Machine");

			legitAutoMachine:AddToggle({text = "LEGIT Auto Machine", callback = function(toggle)
				if not toggle then legitMachineMaid:DoCleaning(); doingAction = false; return; end
				doingAction = false;

				local lastMachine = nil;
				legitMachineMaid:GiveTask(plrGUI.ChildAdded:Connect(function(v)
					task.wait()
					if ffc(v,"Machine") then lastMachine = v.Machine.Value; end

					if v.Name == "BarbellMachineGUI" or v.Name == "SquatMachineGUI" then
						if not v:WaitForChild("Frame2") then return; end
						if not v.Frame2:WaitForChild("LiftingF") then return; end
						doingAction = true;

						legitMachineMaid:GiveTask(v.Frame2.LiftingF.ChildAdded:Connect(function(z)
							if stupidWait then return; end
							if z.Name ~= "LiftIcon" then return; end
							if Stats.Stamina <= library.flags["minimumStamina%"] then stupidWait = true; repeat task.wait() until Stats.Stamina >= library.flags["maximumStamina%"] or (not library.flags.legitAutoMachine); stupidWait = false; end --Wait for stamina to reach 100%

							task.wait(library.flags.keypressDelay);
							repeat
								safeButton(z);
								task.wait(0.1);
							until (not z or not z.Parent)
						end))

						if not library.flags.autoReuse then return; end
						if not v:WaitForChild("Frame") then return; end
						if not v.Frame:WaitForChild("ListF") then return; end

						local powerButton = v.Frame.ListF:WaitForChild(string.format("Barbell %s Weight",library.flags["lift/squatPower"]));
						if not powerButton then return; end

						repeat
							safeButton(powerButton);
							task.wait();
						until (v.Frame2.Visible) or (not library.flags.legitAutoMachine or not library.flags.autoReuse)

						if (not library.flags.legitAutoMachine) then return; end

						repeat task.wait() until (Stats.Stamina >= 100) or (not library.flags.legitAutoMachine);

						repeat
							safeButton(v.Frame2.Start);
							task.wait();
						until not v.Frame2.Start.Visible or (not library.flags.legitAutoMachine or not library.flags.autoReuse)
						return;
					end

					--Treadmill Part
					if v.Name ~= "TreadmillMachineGUI" then return; end
					if not v:WaitForChild("Frame3") then return; end
					if not v.Frame3:WaitForChild("TrainingF") then return; end

					doingAction = true;
					task.wait();
					legitMachineMaid:GiveTask(v.Frame3.TrainingF.ButtonTemplate:GetPropertyChangedSignal("Position"):Connect(function()
						if stupidWait then return; end
						if Stats.Stamina <= library.flags["minimumStamina%"] then stupidWait = true; repeat task.wait() until Stats.Stamina >= library.flags["maximumStamina%"] or (not library.flags.legitAutoMachine); stupidWait = false; end --Wait for stamina to reach 100%

						task.wait(library.flags.keypressDelay);

						local key = v.Frame3.TrainingF.ButtonTemplate.Input.Text;
						VirtualInputManager:SendKeyEvent(true,key,false,game);
						task.wait(0.1);
						VirtualInputManager:SendKeyEvent(false,key,false,game);
					end))

					--Treadmill auto use part
					if not library.flags.autoReuse then return; end

					if not v:WaitForChild("Frame") then return; end
					if not ffc(v.Frame,library.flags.treadmillType,true) then return; end

					repeat
						safeButton(ffc(v.Frame,library.flags.treadmillType,true));
						task.wait();
					until (not v.Parent) or (not v.Frame.Visible) or (not library.flags.legitAutoMachine or not library.flags.autoReuse)

					repeat task.wait(); until (v.Frame2.ListF:FindFirstChild(library.flags.treadmillPower) or not library.flags.autoReuse)

					repeat
						safeButton(ffc(v.Frame2.ListF,library.flags.treadmillPower,true));
						task.wait();
					until (not v.Parent) or (not v.Frame2.Visible) or (not library.flags.legitAutoMachine or not library.flags.autoReuse)

					repeat task.wait(); until (v.Frame3.Visible) or (not library.flags.legitAutoMachine);

					if (not library.flags.legitAutoMachine) then return; end
					repeat task.wait() until (Stats.Stamina >= 100) or (not library.flags.legitAutoMachine);

					repeat
						safeButton(v.Frame3.Start);
						task.wait();
					until not v.Frame3.Start.Visible or (not library.flags.legitAutoMachine or not library.flags.autoReuse)
				end))

				legitMachineMaid:GiveTask(plrGUI.ChildRemoved:Connect(function(v)
					if v.Name ~= "BarbellMachineGUI" and v.Name ~= "SquatMachineGUI" and v.Name ~= "TreadmillMachineGUI" then return; end
					doingAction = false; --Should be set before waiting to get on the machine

					if not library.flags.autoReuse then return; end
					if not library.flags.legitAutoMachine then return; end
					if not lastMachine then return; end

					task.wait(library.flags.reuseWait);

					isBusy(); --Checks if they need to eat and waits until they do

					doingAction = true;

					char.Humanoid:UnequipTools();
					repeat
						safeClick(lastMachine.Base);
						task.wait();
					until ffc(plrGUI,"BarbellMachineGUI") or ffc(plrGUI,"SquatMachineGUI") or ffc(plrGUI,"TreadmillMachineGUI") or not library.flags.autoReuse or not library.flags.legitAutoMachine
				end))
			end});

			legitAutoMachine:AddSlider({text = "Minimum Stamina %", value = 30, min = 0, max = 100, float = 0.1, callback = function() return; end});
			legitAutoMachine:AddSlider({text = "Maximum Stamina %", value = 100, min = 0, max = 100, float = 0.1, callback = function() return; end});

			legitAutoMachine:AddToggle({text = "Auto Reuse"});
			legitAutoMachine:AddSlider({text = "Reuse Wait",tip = "How long to wait before getting on the machine", value = 2, min = 0, max = 2,float = 0.1, function() end});
			legitAutoMachine:AddList({text ="Treadmill Type", values = {"Stamina","RunningSpeed"}});
			legitAutoMachine:AddSlider({text = "Treadmill Power",value = 1, min = 1, max = 5, float = 1, function() return; end});
			legitAutoMachine:AddSlider({text = "Lift/Squat Power",value = 1, min = 1, max = 6, float = 1, function() return; end});
			legitAutoMachine:AddSlider({text = "Keypress Delay",value = 0,min = 0, max = 1, float = 0.1, function() return; end});

			local autoDuraSettings = column2:AddSection("Auto Dura Settings");

			autoDuraSettings:AddToggle({text = "Auto Dura",callback = function(state)
				if not state then autoDura:ClearAll(); return; end

				local player1 = search(plrTbl,string.lower(library.flags.firstTurn));
				local player2 = search(plrTbl,string.lower(library.flags.secondTurn));

				if not player1 or not player2 then autoDura:CreateError("Cannot find one or both of the players."); return; end
				if not player1.Character or not player2.Character then autoDura:CreateError("One of the player's isn't spawned in"); return; end

				local autoDuraObj = autoDura.new(player1.Character,player2.Character);
				autoDuraObj:Start();
			end})

			autoDuraSettings:AddBox({text = "First Turn", tip = "This value should be the same for both users", value = "First Player"});
			autoDuraSettings:AddBox({text = "Second Turn", tip = "This value should be the same for both users", value ="Second Player"});
			autoDuraSettings:AddSlider({text = "Minimum HP %",value = 15,min = 0,max = 100});
			autoDuraSettings:AddToggle({text = "Take Turns",tip = "This value should be the same for both users"});

			local function eat(item,ignore,keepEating)
				if getgenv().debug_auto_eat then
					print(item, Stats.Hunger, ignore, Stats.isEating, Stats.isRunning, doingAction, Stats.isKnocked, Stats.Sleeping, tryingToSleep, library.flags.autoEat);
				end
				if typeof(item) == 'table' then item = unpack(item); end --If we pass a table to it handle it properly
				if Stats.Hunger >= library.flags["autoEatAt%"] and not ignore then return; end
				if eating then return; end
				if Stats.isEating then return; end
				if Stats.isRunning then return false; end
				if doingAction then return false; end
				if Stats.isKnocked then return false; end
				if Stats.Sleeping then return false; end
				if tryingToSleep then return false; end
				if not item then return false; end
				if not library.flags.autoEat then return false; end
				warn("PASSED ALL")

				if item.Parent == nil then

					if library.flags.autoSleep and getFood() == nil then --If no more food and they using auto sleep, make them go to sleep.
						env.stopSprint();
						char.Humanoid:UnequipTools();
						toggleSleep();
						return false;
					end

					return false;
				end

				eating = true;
				sprinting = false;

				warn(item.Parent);
				if item.Parent ~= char then
					char.Humanoid:UnequipTools();
				end

				if doingAction then char.Humanoid:UnequipTools(); return false; end --We want to make sure we NEVER have food on treadmill

				item.Parent = char;
				item:Activate();

				repeat task.wait(0.5); item:Activate(); if item.Parent == nil then break; end if item.Parent ~= char then if doingAction then break; end item.Parent = char; end until Stats.isEating or not library.flags.autoEat; --If item is in nil or they are on the treadmill then break, otherwise equip
				repeat task.wait(0.5); until not Stats.isEating or not library.flags.autoEat;

				if item.Parent ~= char then
					char.Humanoid:UnequipTools();
				end
				eating = false;

				if Stats.Hunger <= library.flags["eatTo%"] and keepEating then
					local foodTab = getFood(lastFood) or getFood() or {};
					foodTool,lastFood = unpack(foodTab);
					eat(foodTool,true,true);
				end
				char.Humanoid:UnequipTools();
			end


			local autoEatSettings = column2:AddSection("Auto Eat Settings");

			autoEatSettings:AddToggle({text = "Auto Eat", callback = function(toggle)
				if not toggle then return; end
				if not loaded() then return; end

				foodTool,lastFood = unpack(getFood() or {});
				repeat
					task.wait(0.2);
					local foodTab = getFood(lastFood) or getFood() or {};
					foodTool,lastFood = unpack(foodTab);
					local eatRet = eat(foodTool,false,true);
					if eatRet == false then
						eating = eatRet;
					end
				until not library.flags.autoEat;
			end});


			autoEatSettings:AddSlider({text = "Auto Eat at %",value = 0, min = 0, max = 100, float = 0.1});
			autoEatSettings:AddSlider({text = "Eat to %",value = 100, min = 0,max = 100, float = 0.1});


			autoEatSettings:AddToggle({text= "Auto Protein", callback = function(toggle)
				if not toggle then return; end

				repeat
					local eatRet;
					task.wait(0.2);
					if not Stats.ProteinShake then
						eatRet = eat(getFood("Protein Shake"),true); --Should only eat Protein Shake
					end

					if eatRet == false then
						eating = eatRet;
					end
				until not library.flags.autoProtein;
			end});

			autoEatSettings:AddToggle({text= "Auto BCAA", callback = function(toggle)
				if not toggle then return; end

				repeat
					local eatRet;
					task.wait(0.2);
					if not Stats.BCAA then
						eatRet = eat(getFood("BCAA"),true); --Should only eat BCAA
					end

					if eatRet == false then
						eating = eatRet;
					end
				until not library.flags.autoBcaa;
			end});

			autoEatSettings:AddToggle({text = "Auto Fat Burner",callback = function(toggle)
				if not toggle then return; end

				repeat
					local eatRet;
					task.wait(0.2);
					if not Stats.FatBurner then
						eatRet = eat(getFood("Fat Burner"),true); --Should only eat Fat Burner
					end

					if eatRet == false then
						eating = eatRet;
					end
				until not library.flags.autoFatBurner;
			end});

			autoEatSettings:AddToggle({text = "Auto Scalar",callback = function(toggle)
				if not toggle then return; end

				repeat
					local eatRet;
					task.wait(0.2);
					if not Stats.Scalar then
						eatRet = eat(getFood("Scalar"),true); --Should only eat Scalar
					end

					if eatRet == false then
						eating = eatRet;
					end
				until not library.flags.autoScalar;
			end});

			local sleepSettings = column2:AddSection("Auto Sleep Settings");

			sleepSettings:AddToggle({text = "Auto Sleep", callback = function(toggle)
				if not toggle then gMaid.AutoSleep = nil; return; end
				local lastStep = tick();
				gMaid.AutoSleep = RunService.Stepped:Connect(function()
					if tick()-lastStep <= 0.2 then return; end
					lastStep = tick();
					if Stats.Fatigue >= library.flags["sleepAt%"] and not Stats.Sleeping then --Sleep
						toggleSleep();
					elseif Stats.Fatigue <= library.flags["wakeAt%"] and Stats.Sleeping then --Wake up
						if library.flags.autoEat and getFood() == nil then return; end
						toggleSleep();
					end
				end);
			end});
			sleepSettings:AddSlider({text = "Sleep at %",value = 65,min = 0,max = 100, float = 0.1});
			sleepSettings:AddSlider({text = "Wake at %",value = 0,min = 0,max = 100,float = 0.1});

			local autoRhythm;
			autoRhythm = Safe:AddToggle({text = "Auto Rhythm", callback = function(toggle)
				if not toggle then gMaid.autoRhythm = nil; return; end

				local lastRhythmLoop = tick();
				local fightTool = getStyle();
				gMaid.autoRhythm = RunService.Stepped:Connect(function()
					if not (tick() - lastRhythmLoop >= 0.2) then return; end

					lastRhythmLoop = tick();

					if char.HumanoidRootPart.RhythmUI.Enabled then return; end
					if fightTool and fightTool.Parent ~= char then return; end
					if Stats.Rhythm >= 100 then return; end
					if Stats.isEating then return; end
					if Stats.isRunning then return; end

					VirtualInputManager:SendKeyEvent(true,"R",false,game);
					task.wait(0.1);
					VirtualInputManager:SendKeyEvent(false,"R",false,game);
				end)
			end})

			Safe:AddToggle({text = "Auto Use Flow", callback = function(toggle)
				if not toggle then gMaid.autoFlowToggle = nil; return; end
				if not ffc(plrGUI,"FlowUI") then library.options.autoUseFlow:SetState(false); return; end

				gMaid.autoFlowToggle = plrGUI.FlowUI:GetPropertyChangedSignal("Enabled"):Connect(function()
					if not plrGUI.FlowUI.Enabled then return; end

					VirtualInputManager:SendKeyEvent(true,"T",false,game);
					task.wait(0.1);
					VirtualInputManager:SendKeyEvent(false,"T",false,game);
				end)
			end})

			local function autoSprint(toggle)
				if (not toggle) then
					gMaid.autoSprint = nil;
					return;
				end;

				local moveKeys = {Enum.KeyCode.W};
				local lastRan = 0;

				gMaid.autoSprint = UserInputService.InputBegan:Connect(function(input, gpe)
					if (gpe or tick() - lastRan < 0.1) then return end;

					if (table.find(moveKeys, input.KeyCode)) then
						lastRan = tick();
						VirtualInputManager:SendKeyEvent(true, input.KeyCode, false, game);
					end;
				end);
			end;

			Safe:AddToggle({text = "Auto Sprint",callback=autoSprint});

			local mobs = {};
			local networkOneShot = {};
			networkOneShot.__index = networkOneShot;

			function networkOneShot.new(mob)
				local self = setmetatable({},networkOneShot);
				mobs[mob] = self;

				self._maid = Maid.new();

				self.char = mob;
				self.humanoid = mob.Humanoid;
				self.hrp = mob.HumanoidRootPart;

				self._maid:GiveTask(mob.Destroying:Connect(function()
					self:Destroy();
				end))
				print("Made Connection!", mob);
				self._maid:GiveTask(RunService.RenderStepped:Connect(function()

					if library.flags.oneShotPercent < self.humanoid.Health/self.humanoid.MaxHealth*100 then return; end
					self.char:PivotTo(CFrame.new(self.hrp.Position.X,workspace.FallenPartsDestroyHeight-500,self.hrp.Position.Z))
				end))
			end

			function networkOneShot:Destroy()
				self._maid:DoCleaning();
				for i,v in next, mobs do
					if v ~= self then continue; end

					mobs[i] = nil;
				end
			end

			function networkOneShot:ClearAll()
				for _,v in next, mobs do
					v:Destroy();
				end
			end

			risky:AddButton({text = "Money Farm",callback = function()
				setclipboard("https://shoppy.gg/product/mBzd1gV");
				ToastNotif.new({text= "Buy money service 1m for 15$ at https://shoppy.gg/product/mBzd1gV , it has also been copied to your clipboard"});
			end})

			risky:AddToggle({text = 'One Shot NPC',tip = "Do not kill enemies too quickly as you will get logged", callback = function(toggle)
				if not toggle then gMaid.OwnerShipBeat = nil; gMaid.OneShotNPC = nil; networkOneShot:ClearAll(); return; end

				gMaid.OwnerShipBeat = RunService.Heartbeat:Connect(function()
					sethiddenproperty(plr,"MaxSimulationRadius",math.huge);
					sethiddenproperty(plr,"SimulationRadius",math.huge);
				end)

				gMaid.OneShotNPC = Utility.listenToChildAdded(LivingThings,function(instance)
					if ffc(Players,instance.Name) then return; end
					if not instance:WaitForChild("HumanoidRootPart",5) or not instance:WaitForChild("Humanoid",5) then return; end

					networkOneShot.new(instance); --Starts the handler for oneshot
				end)
			end}):AddSlider({
				flag = "One Shot Percent",
				min = 0,
				max = 100,
				value = 100,
				float = 1,
				tip = "The HP % should they get one shot at"
			});

			local angleOffSet = CFrame.Angles(math.rad(-90),0,0);
			risky:AddToggle({text = 'Attach to Back (Mobs)', flag = "Attach To Back", callback = function(toggle)
				if not toggle then gMaid.attachToback = nil; return; end

				local lastcheck = tick();
				local target = getMobInRange(library.flags.attachToBackRange);
				gMaid.attachToback = RunService.Heartbeat:Connect(function()
					if tick()-lastcheck >= 0.1 and target then
						lastcheck = tick();

						if ffc(target,"KO") then return; end
					end

					if not target or not target.Parent then
						target = getMobInRange(library.flags.attachToBackRange);
					end
					if not target or not ffc(target,"HumanoidRootPart") then return; end

					char.HumanoidRootPart.CFrame = target.HumanoidRootPart.CFrame * (CFrame.new(0,library.flags.attachToBackDistance,1)*angleOffSet);
					char.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero;
					char.HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero;
				end)
			end});

			risky:AddSlider({text = "Attach to Back Distance",tip = "How far to move you from the mob", value = 5,min=1,max=10,float=0.1});
			risky:AddSlider({text = "Attach to Back Range",tip = "Get closest mob in this range",value = 100,min=0,max=100,float=1});

			local riskyAutoMachine = riskyColumn2:AddSection("Risky Auto Machine");




			--Risky automachine
			--Hooks the OnClientInvoke to return a time in the past such as -1
			--Due to it returning a number below 0 it will give the best possible stats,
			--They should be able to change the return timing between -1 and 1
			--It should use a wait loop whenever regenerating stamina
			--Thus it wont give a return until the next button
			--This should entail the BEST possible auto farm
			--The sliders and toggles should be the same as legit auto machine



			do --Risky AutoMachine

				local riskyMachine = {};
				riskyMachine.__index = riskyMachine;

				local riskyMachineTab = {};

				function riskyMachine.new()
					local self = setmetatable({},riskyMachine);
					table.insert(riskyMachineTab, self);

					self._maid = Maid.new();

					self:Setup();
					return self;
				end

				function riskyMachine:Setup()
					self._maid:GiveTask(Utility.listenToChildAdded(plrGUI,function(machineUI)
						if machineUI.Name ~= "TreadmillMachineGUI" and machineUI.Name ~= "BarbellMachineGUI" and machineUI.Name ~= "SquatMachineGUI" then return; end
						self._machineUI = machineUI;
						self._machine = machineUI:WaitForChild("Machine").Value;
						self._remote = machineUI:WaitForChild("RemoteF");
						self._lastMachineName = machineUI.Name;

						if self._lastMachineName == "TreadmillMachineGUI" then
							self:Treadmill();
						elseif self._lastMachineName == "BarbellMachineGUI" or self._lastMachineName == "SquatMachineGUI" then
							self:Weights();
						end
					end))

					self._maid:GiveTask(plrGUI.ChildRemoved:Connect(function(machineUI)
						if self._lastMachineName ~= machineUI.Name then return; end

						doingAction = false; --Should be set before waiting to get on the machine

						if not library.flags.autoReuse then return; end
						if not library.flags.riskyAutoMachine then return; end

						task.wait(library.flags.reuseWait);

						isBusy(); --Checks if they need to eat and waits until they do
						doingAction = true;

						char.Humanoid:UnequipTools();
						repeat
							safeClick(self._machine.Base);
							task.wait();
						until ffc(plrGUI,self._lastMachineName) or not library.flags.autoReuse or not library.flags.riskyAutoMachine
					end))
				end

				function riskyMachine:Treadmill()
					doingAction = true;
					local machineUI = self._machineUI;

					task.wait(2);

					local isPaused = false;
					self._remote.OnClientInvoke = function(action,promptInfo)
						if action == "Exit" then
							plrGUI.BackpackGUI.Enabled = true;
							if ffc(self._machine,"InviWall") then
								self._machine.InviWall.CanCollide = true;
							end
							return;
						end

						if action ~= "Prompt" then return; end

						if Stats.Stamina <= library.flags["minimumStamina%"] then
							if not isPaused then
								print('pausing???')
								isPaused = true;
								task.spawn(function()
									repeat task.wait() until Stats.Stamina >= library.flags["maximumStamina%"] or (not library.flags.riskyAutoMachine);
									isPaused = false;
									print('unpausing what???')
								end)
								return 0,false;
							end
						end

						repeat task.wait() until not isPaused;
						return 0,true,true
					end

					if not library.flags.autoReuse then return; end

					local v = machineUI;

					if not v:WaitForChild("Frame") then return; end
					if not ffc(v.Frame,library.flags.treadmillType,true) then return; end

					repeat
						safeButton(ffc(v.Frame,library.flags.treadmillType,true));
						task.wait();
					until (not v.Parent) or (not v.Frame.Visible) or (not library.flags.riskyAutoMachine or not library.flags.autoReuse)

					repeat task.wait(); until (v.Frame2.ListF:FindFirstChild(library.flags.treadmillPower) or not library.flags.autoReuse)

					repeat
						safeButton(ffc(v.Frame2.ListF,library.flags.treadmillPower,true));
						task.wait();
					until (not v.Parent) or (not v.Frame2.Visible) or (not library.flags.riskyAutoMachine or not library.flags.autoReuse)

					repeat task.wait(); until (v.Frame3.Visible) or (not library.flags.riskyAutoMachine);

					if (not library.flags.riskyAutoMachine) then return; end
					repeat task.wait() until (Stats.Stamina >= 100) or (not library.flags.riskyAutoMachine);

					repeat
						safeButton(v.Frame3.Start);
						task.wait();
					until not v.Frame3.Start.Visible or (not library.flags.riskyAutoMachine or not library.flags.autoReuse)
				end

				function riskyMachine:Weights()
					doingAction = true;
					local machineUI = self._machineUI;

					task.wait(2);

					local isPaused = false;
					self._remote.OnClientInvoke = function(action,promptInfo)
						if action == "Exit" then
							plrGUI.BackpackGUI.Enabled = true;
							return;
						end

						if action ~= "LiftPrompt" then return; end

						if Stats.Stamina <= library.flags["minimumStamina%"] then
							if not isPaused then
								print('pausing???')
								isPaused = true;
								task.spawn(function()
									repeat task.wait() until Stats.Stamina >= library.flags["maximumStamina%"] or (not library.flags.riskyAutoMachine);
									isPaused = false;
									print('unpausing what???')
								end)
								return 0,false;
							end
						end

						repeat task.wait() until not isPaused;
						warn'going thru'
						return 0,true
					end

					local v = machineUI;

					if not library.flags.autoReuse then return; end
					if not v:WaitForChild("Frame") then return; end
					if not v.Frame:WaitForChild("ListF") then return; end

					local powerButton = v.Frame.ListF:WaitForChild(string.format("Barbell %s Weight",library.flags["lift/squatPower"]));
					if not powerButton then return; end

					repeat
						safeButton(powerButton);
						task.wait();
					until (v.Frame2.Visible) or (not library.flags.riskyAutoMachine or not library.flags.autoReuse)

					if (not library.flags.riskyAutoMachine) then return; end

					repeat task.wait() until (Stats.Stamina >= 100) or (not library.flags.riskyAutoMachine);

					repeat
						safeButton(v.Frame2.Start);
						task.wait();
					until not v.Frame2.Start.Visible or (not library.flags.riskyAutoMachine or not library.flags.autoReuse)
				end

				function riskyMachine:Destroy()
					self._maid:DoCleaning();
					for i,v in next, riskyMachineTab do
						if v == self then
							riskyMachineTab[i] = nil;
						end
					end
				end

				function riskyMachine:ClearAll()
					for _,v in next, riskyMachineTab do
						v:Destroy();
					end
				end


				riskyAutoMachine:AddToggle({text = "Risky Auto Machine",tip = "Makes gaining all stats faster through machines, uses settings from legit auto machine",callback = function(t)
					if not t then return riskyMachine:ClearAll(); end

					riskyMachine.new();
				end});
			end


			local playerMods = riskyColumn2:AddSection("Risky Player Mods");

			playerMods:AddToggle({text = 'Fly',callback = function(toggle)
				if not toggle then flyMaid:DoCleaning(); return; end
				if not loaded() then return; end
				local T = char.HumanoidRootPart
				local CONTROL = {F = 0, B = 0, L = 0, R = 0}
				local lCONTROL = {F = 0, B = 0, L = 0, R = 0}
				local SPEED = 5
				local BG = Instance.new('BodyGyro')
				BG.Parent = T;
				local BV = Instance.new('BodyVelocity')
				BV.Parent = T;
				BG.P = 9e4
				BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
				BG.cframe = T.CFrame
				BV.velocity = Vector3.new(0, 0.1, 0)
				BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
				print(library.flags.fly)
				spawn(function()
					repeat task.wait()
						if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 then
							SPEED = flySpeed
						elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0) and SPEED ~= 0 then
							SPEED = 0
						end
						if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 then
							BV.velocity = ((camera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((camera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B) * 0.2, 0).p) - camera.CoordinateFrame.p)) * SPEED
							lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
						elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and SPEED ~= 0 then
							BV.velocity = ((camera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((camera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B) * 0.2, 0).p) - camera.CoordinateFrame.p)) * SPEED
						else
							BV.velocity = Vector3.new(0, 0.1, 0)
						end
						BG.cframe = camera.CoordinateFrame
					until not library.flags.fly;
					CONTROL = {F = 0, B = 0, L = 0, R = 0}
					lCONTROL = {F = 0, B = 0, L = 0, R = 0}
					SPEED = 0
					BG:Destroy()
					BV:Destroy()
				end);

				flyMaid:GiveTask(UserInputService.InputBegan:connect(function(Input, gameProcessed)
					local code = Input.KeyCode;
					if code == Enum.KeyCode.W then
						CONTROL.F = 1;
					elseif code == Enum.KeyCode.S then
						CONTROL.B = -1;
					elseif code == Enum.KeyCode.A then
						CONTROL.L = -1;
					elseif code == Enum.KeyCode.D then
						CONTROL.R = 1;
					end
				end))
				flyMaid:GiveTask(UserInputService.InputEnded:connect(function(Input, gameProcessed)
					local code = Input.KeyCode;
					if code == Enum.KeyCode.W then
						CONTROL.F = 0;
					elseif code == Enum.KeyCode.S then
						CONTROL.B = 0;
					elseif code == Enum.KeyCode.A then
						CONTROL.L = 0;
					elseif code == Enum.KeyCode.D then
						CONTROL.R = 0;
					end
				end))
			end}):AddSlider({text = 'Fly Speed',value=50,min=1,max=100,callback=function(val) flySpeed = val; end});

			local oldSpeed; --This function can get detected technically
			playerMods:AddToggle({text="Run Speed", callback = function(toggle)
				local func;
				for i,v in next, getconnections(Events.UpdateStats.OnClientEvent) do
					if v.Function and not is_synapse_function(v.Function) then
						func = v.Function;
					end
				end

				local tab = getupvalue(func,1);
				oldSpeed = rawget(tab,"RunningSpeed") or oldSpeed;
				if not toggle then
					setmetatable(tab,nil);
					rawset(tab,"RunningSpeed",oldSpeed);
					return;
				end

				setmetatable(tab,{
					__newindex = function(t,k,v)
						if k == 'RunningSpeed' then
							return;
						end
						return rawset(t,k,v);
					end;
					__index = function(t,k)
						if k == 'RunningSpeed' then
							return library.flags.runningSpeed;
						end
					end
				})
				rawset(tab,"RunningSpeed",nil);
			end}):AddSlider({
				value=500,
				min=0,
				max=2300,
				flag = "Running Speed",
			})


			local function teleportFunc(cframe)
				repeat task.wait() until plr.Character ~= nil;
				repeat task.wait() until char:FindFirstChild("HumanoidRootPart");

				char.HumanoidRootPart:GetPropertyChangedSignal("CFrame"):Wait();
				teleMaid:GiveTask(RunService.RenderStepped:Connect(function()
					char.HumanoidRootPart.CFrame = cframe;
					char.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero;
					char.HumanoidRootPart.AssemblyAngularVelocity = Vector3.zero;
				end))
				task.spawn(function()
					task.wait(0.5);
					repeat task.wait() until ffcwia(plr.Backpack,"Tool");
					teleMaid:DoCleaning();
				end);
			end

			local function teleport(target)
				if not loaded() then return; end
				local cframe = target;
				if typeof(cframe) == "Vector3" or typeof(cframe) == "CFrame" then
					if typeof(target) == "Vector3" then
						cframe = CFrame.new(cframe);
					end
					teleMaid:GiveTask(plr.CharacterAdded:Connect(function() teleportFunc(cframe) end));
					char.Humanoid.Health = 0;
				elseif typeof(target) == "Instance" and target:IsA("Part") then
					teleMaid:GiveTask(plr.CharacterAdded:Connect(function() teleportFunc(cframe.CFrame) end));
					char.Humanoid.Health = 0;
				else
				end
			end

			playerMods:AddBox({text="Teleport (Respawns you)",noload = true, skipflag = true, callback=function(val)
				if val == 'nil' or val == '' or not val then return; end
				if search(plrTbl,string.lower(val)) and search(plrTbl,string.lower(val)) ~= plr then
					local target = search(plrTbl,string.lower(val));
					if target and target.Character and ffc(target.Character,"HumanoidRootPart") then
						teleport(target.Character.HumanoidRootPart);
					end
				else
					ToastNotif.new({
						text = "Looks like the player isn't here or there was a error in their name double check the capitalization";
						duration = 20
					});
				end
			end});

			playerMods:AddList({text="Teleports", noload = true, skipflag = true, values = Teleports,callback=function(v)
				v = Teleports[v];
				local inRoom = false;
				local pName;
				for t,k in next, LivingThings:GetChildren() do
					if ffc(k,"HumanoidRootPart") and k ~= char then
						local raycastRes = workspace:Raycast(k.HumanoidRootPart.Position,k.HumanoidRootPart.Position-v);
						if not raycastRes then
							inRoom = true;
							pName = k.Name;
							break;
						end
					end
				end
				if inRoom then
					ToastNotif.new({
						text = pName.." is in the room, so you won't be teleported",
						duration = 20
					});
					return;
				end
				teleport(v)
			end});



			risky:AddToggle({text="Inf Treadmill Stamina",callback=function(toggle)
				if not toggle then return; end
				if not loaded() then return; end
				local key = getKey(plr.Backpack.LocalS);
				if key then
					local action = plr.Backpack.Action;
					repeat
						action:FireServer(key,"RunToggle",{[1] = true,[2] = false});
						task.wait();
						action:FireServer(key,"RunToggle",{false});
						task.wait(0.3)
					until not library.flags.infTreadmillStamina;
				end
			end});

			risky:AddToggle({text="Inf Rhythm", tip = "Makes your rhythm inf, makes a cloud under your feet" ,callback=function(toggle)
				if not toggle then return; end
				if not loaded() then return; end

				local key = getKey(plr.Backpack.LocalS);
				if not key then library.options.infRhythm:SetState(false); return; end

				local action = plr.Backpack.Action;
				action:FireServer(key, "RhythmStance", true);
				repeat
					task.wait(0.1);
				until not library.flags.infRhythm;
				action:FireServer(key, "RhythmStance", false);
			end});

			risky:AddToggle({text="Inf Dashes",callback=function(toggle)
				if not toggle then return; end
				if not loaded() then return; end
				local env = getsenv(plr.Backpack.LocalS);
				repeat
					task.wait(0.1)
					setupvalue(env.Dash,2,3);
					setupvalue(env.Dash,3,"");
				until not library.flags.infDashes;
			end});

			local constantNum = table.find(getconstants(env.Dash),"FireServer");

			risky:AddToggle({text="No Stam Dashes",callback=function(toggle)
				if not toggle then setconstant(getsenv(plr.Backpack.LocalS).Dash,constantNum,"FireServer") return; end

				setconstant(getsenv(plr.Backpack.LocalS).Dash,constantNum,"GetChildren");
			end});

			risky:AddButton({text='Respawn',callback=function()
				if not loaded() then return; end
				char:BreakJoints();
			end});

			risky:AddButton({text='Respawn Back',callback=function()
				if not loaded() then return; end
				teleport(char.HumanoidRootPart.CFrame);
			end});

			risky:AddButton({text="Teleport Tourney of 100",callback=function()
				TeleportService:Teleport(6320657368);
			end});

			risky:AddButton({text="Teleport Private Server",callback=function()
				TeleportService:Teleport(6745592527);
			end});

			local whiteStats = {
				["BodyFatigue"] = true;
				["PrimaryStyle"] = true;
				["Calories"] = true;
				["Reputation"] = true;
				["Trait"] = true;
				["LowerBodyMuscle"] = true;
				["UpperBodyMuscle"] = true;
				["Karma"] = true;
				["MightyCoins"] = true;
				["BankMoney"] = true;
				["Money"] = true;
				["Stamina"] = true;
				["BodyHeat"] = true;
				["Rhythm"] = true;
				["Stomach"] = true;
				["Height"] = true;
				["RunningSpeed"] = true;
				["Fat"] = true;
				["SkillPoints"] = true;
				["Logged"] = true;
				["Banned"] = true;
				["Durability"] = true;
				["StrikingPower"] = true;
				["StrikingSpeed"] = true;
			};
			local function statfunction(p5,p6)
				if not whiteStats[p5] then return; end
				if p5 == "UpperBodyMuscle" then
					p5 = "UpperMuscle";
				elseif p5 == "LowerBodyMuscle" then
					p5 = "LowerMuscle";
				elseif p5 == "RunningSpeed" then
					p5 = "RunSpeed";
				end
				local val;
				if tonumber(p6) ~= nil then
					val = tostring(round(p6,3));
				elseif typeof(p6) == "table" then
					val = tostring(round(p6[1],3));
				else
					if typeof(p6) == 'function' then return; end

					val = tostring(p6);
				end

				if not StatT[p5] then
					StatT[p5] = StatV:AddLabel(string.format("%s: %s",p5,val));
				else
					StatT[p5].Text = string.format("%s: %s",p5,val);
				end
			end

			for i,v in next, getconnections(Events.UpdateStats.OnClientEvent) do
				if not v.Function then
					return;
				end
				if string.match(debug.getinfo(v.Function,'s').short_src,"LocalS") then
					updateStat = v.Function;
				end
			end

			for i,v in next, getupvalues(updateStat) do
				if typeof(v) == 'table' then
					for t,k in next, v do
						statfunction(t,k);
					end
					break;
				end
			end


			Events.UpdateStats.OnClientEvent:Connect(statfunction)
			task.spawn(function()
				while task.wait(1) do
					if not loaded() then return; end
					if not ffc(char,"MaxStamina") then return; end
					statfunction("Stamina",char.MaxStamina.Value-100);
					statfunction("BodyHeat",char.BodyHeat.Value);
					statfunction("Rhythm",char.Rhythm.Value);
				end
			end);

			--Auto Parry Tab
			local parryAnims = {
				["rbxassetid://7009320896"]={["Guardbreak"]=false},
				["rbxassetid://5087462384"]={["Guardbreak"]=false},
				["rbxassetid://6501739912"]={["Guardbreak"]=false},
				["rbxassetid://6704457409"]={["Guardbreak"]=false},
				["rbxassetid://6718814119"]={["Guardbreak"]=false},
				["rbxassetid://5029356929"]={["Guardbreak"]=false},
				["rbxassetid://6930761828"]={["Guardbreak"]=false},
				["rbxassetid://5087464114"]={["Guardbreak"]=false},
				["rbxassetid://5029359784"]={["Guardbreak"]=false},
				["rbxassetid://7876039532"]={["Guardbreak"]=false},
				["rbxassetid://5810497127"]={["Guardbreak"]=false},
				["rbxassetid://7891093418"]={["Guardbreak"]=false},
				["rbxassetid://6930758587"]={["Guardbreak"]=false},
				["rbxassetid://5110868660"]={["Guardbreak"]=false},
				["rbxassetid://7877241063"]={["Guardbreak"]=false},
				["rbxassetid://6550835152"]={["Guardbreak"]=false},
				["rbxassetid://6604546413"]={["Guardbreak"]=false},
				["rbxassetid://6875783564"]={["Guardbreak"]=false},
				["rbxassetid://5052660577"]={["Guardbreak"]=false},
				["rbxassetid://7877246443"]={["Guardbreak"]=false},
				["rbxassetid://8594975706"]={["Guardbreak"]=false},
				["rbxassetid://5865529031"]={["Guardbreak"]=false},
				["rbxassetid://5116608619"]={["Guardbreak"]=false},
				["rbxassetid://5110454001"]={["Guardbreak"]=false},
				["rbxassetid://5092035643"]={["Guardbreak"]=false},
				["rbxassetid://5869781872"]={["Guardbreak"]=false},
				["rbxassetid://5110500012"]={["Guardbreak"]=false},
				["rbxassetid://5645707634"]={["Guardbreak"]=false},
				["rbxassetid://6718812539"]={["Guardbreak"]=false},
				["rbxassetid://6194195462"]={["Guardbreak"]=false},
				["rbxassetid://5110724393"]={["Guardbreak"]=false},
				["rbxassetid://6930759930"]={["Guardbreak"]=false},
				["rbxassetid://5883810295"]={["Guardbreak"]=false},
				["rbxassetid://4918348016"]={["Guardbreak"]=false},
				["rbxassetid://5092037778"]={["Guardbreak"]=false},
				["rbxassetid://5052449595"]={["Guardbreak"]=false},
				["rbxassetid://5087459369"]={["Guardbreak"]=false},
				["rbxassetid://5873100725"]={["Guardbreak"]=false},
				["rbxassetid://6573164932"]={["Guardbreak"]=false},
				["rbxassetid://6566644368"]={["Guardbreak"]=false},
				["rbxassetid://7791575394"]={["Guardbreak"]=false},
				["rbxassetid://6360102363"]={["Guardbreak"]=false},
				["rbxassetid://6719137742"]={["Guardbreak"]=false},
				["rbxassetid://5052435233"]={["Guardbreak"]=false},
				["rbxassetid://7876328758"]={["Guardbreak"]=false},
				["rbxassetid://6875731587"]={["Guardbreak"]=false},
				["rbxassetid://5126044328"]={["Guardbreak"]=false},
				["rbxassetid://7887536058"]={["Guardbreak"]=false},
				["rbxassetid://6674659296"]={["Guardbreak"]=false},
				["rbxassetid://7130763680"]={["Guardbreak"]=false},
				["rbxassetid://5092042225"]={["Guardbreak"]=false},
				["rbxassetid://5110453274"]={["Guardbreak"]=false},
				["rbxassetid://6360098898"]={["Guardbreak"]=false},
				["rbxassetid://6704318501"]={["Guardbreak"]=false},
				["rbxassetid://5870608112"]={["Guardbreak"]=false},
				["rbxassetid://5126071335"]={["Guardbreak"]=false},
				["rbxassetid://6257267175"]={["Guardbreak"]=false},
				["rbxassetid://10234589242"]={["Guardbreak"]=false},--Tiger Hunt
				["rbxassetid://10234603041"]={["Guardbreak"]=true},--Snake Bite
				["rbxassetid://10261951458"]={["Guardbreak"]=false},--Dragon Claw
				["rbxassetid://5594891491"]={["Guardbreak"]=false}, --Bear Hug
				["rbxassetid://7819569583"]={["Guardbreak"]=false}, --BlastCore
				["rbxassetid://4901795168"]={["Guardbreak"]=true}, --brawl GB
				["rbxassetid://4973374984"]={["Guardbreak"]=true}, --Thai GB
				["rbxassetid://5016575571"]={["Guardbreak"]=true}, --Karate gb
				["rbxassetid://6169229434"]={["Guardbreak"]=true}, --Wrestling GB
				["rbxassetid://5016611308"]={["Guardbreak"]=true}, --Sumo GB
				["rbxassetid://6538829055"]={["Guardbreak"]=true}, --Taek GB
				["rbxassetid://6585959296"]={["Guardbreak"]=true}, --Raishin GB
				["rbxassetid://6194191510"]={["Guardbreak"]=true}, --Kure GB
				["rbxassetid://4918356164"]={["Guardbreak"]=true}, --Boxing GB
				["rbxassetid://6169361647"]={["Guardbreak"]=true} --Karate GB
			}

			local guardBreak ={
				["Corkscrew"] = true,
				["Blast Core"] = true,
				["Flying Knee"] = true,
				["Axe Kick"] = true,
				["Tiger Bite"] = true,
				["Reverse Heel"] = true,
				["Solid Strike"] = true,
				["Jolt Hook"] = true,
				["Flying Side Kick"] = true,
				["Sumo Throw"] = true,
				["Bear Hug"] = true,
				["Shoulder Bash"] = true,
				["Forearm Smash"] = true,
				["Suplex"] = true,
				["Elbow Drop"]  = 0.1,
				["Body Slam"] = true,
				["Eye Slice"] = true,
			}

			local function blockAttack()
				local key = getKey(plr.Backpack.LocalS);
				if not key then return; end

				plr.Backpack.Action:FireServer(key, "Block", {true});
			end

			local function unblockAttack()
				local key = getKey(plr.Backpack.LocalS);
				if not key then return; end

				plr.Backpack.Action:FireServer(key, "Block", {false});
			end

			local function guardBreak()
				local key = getKey(plr.Backpack.LocalS);
				if not key then return; end

				plr.Backpack.Action:FireServer(key, "GuardBreak", {true});
			end

			local autoBlockMaid = Maid.new();

			local function autoParry(v)
				if v == char then return; end

				local hrp = v:WaitForChild("HumanoidRootPart",10);
				local animator = v:WaitForChild("Humanoid",10) and v.Humanoid:WaitForChild("Animator",10);
				if not hrp or not animator then return; end

				autoBlockMaid:GiveTask(animator.AnimationPlayed:Connect(function(animationTrack)
					local combat = getStyle();
					local animation = animationTrack.Animation;
					local id = animation.AnimationId;
					local tool = ffcwia(v,"Tool");
					local willGuardbreak = tool and guardBreak[tool.Name];

					local distance = hrp.Parent and char and (hrp.Position-char.HumanoidRootPart.Position).magnitude;
					if not distance or distance > library.flags.autoParryRange or not parryAnims[id] or not (math.random(1,100) <= library.flags.autoParryChance) then return; end

					if willGuardbreak or parryAnims[id]["Guardbreak"] then
						if ffc(char,"Blocking") then return combat:Activate(); end --If we already blocking then just parry?

						if parryAnims[id]["Guardbreak"] then --Calculate speed
							task.wait(animationTrack.Speed/10);
						end

						blockAttack();

						if library.flags.autoCounter then guardBreak(); end --This allows us to counter while blocking

						combat:Activate();
						task.wait(0.4);
						unblockAttack();
						return; --We dont want to do anything else if they guardbreak
					end

					blockAttack();

					if library.flags.autoCounter then guardBreak(); end --This allows us to counter while blocking

					task.wait(0.4);
					unblockAttack();
				end))
			end

			local autoParrySettings = column2:AddSection("Auto Parry Settings");

			autoParrySettings:AddToggle({text="Auto Parry",callback=function(toggle)
				if not toggle then autoBlockMaid:DoCleaning(); return; end

				for _,v in next, LivingThings:GetChildren() do
					task.spawn(autoParry,v);
				end

				autoBlockMaid:GiveTask(LivingThings.ChildAdded:Connect(autoParry));
			end})

			autoParrySettings:AddSlider({text="Auto Parry Range",value=18,min=1,max=30,float=0.1});
			autoParrySettings:AddSlider({text="Auto Parry Chance",value=100,min=1,max=100,float=1});
			autoParrySettings:AddToggle({text="Auto Counter"});

			local function notifyWebhook(message)
				if library.flags.webhookUrl == '' then return error("Webhook URL must not be empty"); end
				request({
					Url = library.flags.webhookUrl,
					Method = "POST";
					Headers = {
						["Content-Type"] = "application/json";
					};
					Body = game.HttpService:JSONEncode({content = tostring(message)});
				})
			end


			local Notify = column2:AddSection("Notify/Kick Features");

			local hungerDeb = false;
			local fatigueDeb = false;

			Notify:AddToggle({text="Auto Kick", noload = true, skipflag = true, callback=function(toggle)
				if not toggle then gMaid.autoKick = nil; return; end

				gMaid.autoKick = RunService.Stepped:Connect(function()

					if (library.flags.hunger and library.flags["hungerReaches%"] >= Stats.Hunger) or (library.flags.fatigue and library.flags["fatigueReaches%"] <= Stats.Fatigue) then
						plr:Kick("Kicked due to auto kick");
						gMaid.autoKick = nil;
					end
				end)
			end})

			Notify:AddToggle({text="Webhook Notify",callback=function(toggle)
				if not toggle then gMaid.autoNotify = nil; return; end

				local notifyDeb = tick();
				gMaid.autoNotify = RunService.Stepped:Connect(function()

					if tick() - notifyDeb < 0.5 then return; end
					notifyDeb = tick();

					if (library.flags.hunger and library.flags["hungerReaches%"] >= Stats.Hunger and not hungerDeb) then
						hungerDeb = true;

						notifyWebhook(string.format("Your hunger has reached %s @everyone",Stats.Hunger))
					elseif library.flags["hungerReaches%"] < Stats.Hunger and hungerDeb then
						hungerDeb = false;
					end

					if (library.flags.fatigue and library.flags["fatigueReaches%"] <= Stats.Fatigue and not fatigueDeb) then
						fatigueDeb = true;

						notifyWebhook(string.format("Your fatigue has reached %s @everyone",Stats.Fatigue))
					elseif library.flags["fatigueReaches%"] > Stats.Fatigue and fatigueDeb then
						fatigueDeb = false;
					end
				end)
			end})


			Notify:AddToggle({text="Hunger"});
			Notify:AddSlider({text="Hunger Reaches %",value=0,min=0,max=100,float=0.1});

			Notify:AddToggle({text="Fatigue"});
			Notify:AddSlider({text="Fatigue Reaches %",value=0,min=0,max=100,float=0.1});

			Notify:AddToggle({text="Killed",callback=function(toggle)
				if not toggle then gMaid.deadKick = nil; return; end

				gMaid.deadKick = char.Humanoid.Died:Connect(function()
					if not library.flags.autoKick then return; end
					plr.CharacterAdded:Wait();
					plr:Kick("Kicked due to auto kick");
					if library.flags.webhookNotify then
						notifyWebhook("You have been killed and auto kicked @everyone");
					end
				end)
			end});

			do --Street Fighter ESP/Notifier

				local function onStreetFighterAdded(streetFighter)
					if not streetFighter:WaitForChild("HumanoidRootPart",10) then return; end
					local streetFighterName = streetFighter:WaitForChild("Attached",1) and streetFighter.Attached:WaitForChild("FakeH",1) and streetFighter.Attached.FakeH:FindFirstChildWhichIsA("Model") and streetFighter.Attached.FakeH:FindFirstChildWhichIsA("Model").Name or "Street Fighter";

					local sfESP = streetESP.new(streetFighter.HumanoidRootPart, streetFighterName, nil, true);

					local connection;
					connection = streetFighter.AncestryChanged:Connect(function()
						if streetFighter:IsDescendantOf(game) then return; end

						sfESP:Destroy();
						connection:Disconnect();
					end);
				end

				local function sfDescendantAdded(instance)
					if not instance or instance.Name ~= "NPCModel" then return; end

					local streetFighter;

					while true do
						streetFighter = instance.Value;
						if streetFighter then break; end
						task.wait();
					end

					local streetFighterName = streetFighter:WaitForChild("Attached",1) and streetFighter.Attached:WaitForChild("FakeH",1) and streetFighter.Attached.FakeH:FindFirstChildWhichIsA("Model") and streetFighter.Attached.FakeH:FindFirstChildWhichIsA("Model").Name or "Street Fighter";
					onStreetFighterAdded(streetFighter);

					if not library.flags.streetFighterNotifier then return; end

					ToastNotif.new({text = "A Street Fighter has spawned: "..streetFighterName});
					if library.flags.webhookNotify then notifyWebhook("@everyone A Street Fighter has spawned: "..streetFighterName); end
				end

				Notify:AddToggle({text = "Street Fighter Notifier",callback=function(toggle)
					if not toggle then return; end

					sfDescendantAdded(ffc(workspace,"NPCModel",true))
				end})

				workspace.DescendantAdded:Connect(sfDescendantAdded);
			end

			do --Behelit ESP/Notifier
				local function onBehelitAdded(model)
					local espObject = behelitESP.new(model:GetPivot(), "Behelit Necklace", nil, true);

					local connection;
					connection = model.AncestryChanged:Connect(function()
						if (not model.Parent) then
							espObject:Destroy();
							connection:Disconnect();
						end
					end);
				end

				local function bhDescendantAdded(instance)
					if not instance or instance.Name ~= "BehelitMODEL" then return; end

					onBehelitAdded(instance);

					if not library.flags.behelitNotifier then return; end

					ToastNotif.new({text = "A Behelit has spawned!!!"});
					if library.flags.webhookNotify then notifyWebhook("@everyone A Behelit Necklace has spawned"); end
				end

				Notify:AddToggle({text = "Behelit Notifier",callback=function(toggle)
					if not toggle then return; end

					bhDescendantAdded(ffc(workspace,"BehelitMODEL",true))
				end})

				workspace.DescendantAdded:Connect(bhDescendantAdded);
			end
			--Notify webhook code is so bad...

			Notify:AddBox({text="Webhook URL"});

			Notify:AddButton({text="Test Webhook",callback = function()
				notifyWebhook("This is a test!");
			end});

		end)

		a();

		task.spawn(function()
			--Mod Check
			for _,v in next, Players:GetPlayers() do
				checkIfMod(v)
			end
		end)


		getgenv().autoParryDebug = false;
		_G.legitMove = legitMove;
		_G.GuiRan = true;

	end)()
end

if (gameName == 'Project Mugetsu') then (function()
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];



		local ReplicatedStorage, Players, MemStorageService, TeleportService, HttpService = Services:Get('ReplicatedStorage', 'Players', 'MemStorageService', 'TeleportService', 'HttpService');

		local localPlayer = Players.LocalPlayer;
		local column1 = unpack(library.columns);

		local LOBBY_PLACE_ID = 9447079542;
		local RANKED_PLACE_ID = 9952723123;
		local GAME_PLACE_IDS = {10202329527, 9474703390, RANKED_PLACE_ID};

		local funcs = {};

		local maid = Maid.new();

		local Remotes = ReplicatedStorage.Remotes;

		local function getDataSize(obj)
			local clone = {};

			for _, v in next, obj:GetChildren() do
				local localObjClone = getDataSize(v);

				clone[v.Name] = localObjClone;
			end;

			pcall(function()
				clone[obj.Name] = obj.Value;
			end)
			return clone;
		end;

		local function isDatalossSet(myData)
			local length = 0;

			for _,v in next, myData:WaitForChild('Keys'):GetChildren() do
				length += string.len(v.Key.Value) * 2;
			end;

			return length >= 4000000;
		end

		if (table.find(GAME_PLACE_IDS, game.PlaceId)) then
			local ran = false;
			local serverRemote = Remotes.Server.Initiate_Server;

			local myDatas = ReplicatedStorage.Player_Datas:WaitForChild(localPlayer.Name, math.huge);
			local mySlotNumber = myDatas:WaitForChild('Current_Slot').Value;
			local myData = myDatas:WaitForChild(string.format('Slot_%d', mySlotNumber));

			function funcs.setUpDataloss(t)
				if (ran) then
					return ToastNotif.new({text = 'Already ran!'});
				end;

				ran = true;

				local changedCount = 0;

				-- Reset everything

				local keys = {
					['AirWalk'] = 'T',
					['Run'] = 'LeftShift',
					['Move4'] = 'V',
					['Meditate'] = 'K',
					['Reiatsu'] = 'R',
					['Reload'] = 'B',
					['Move2'] = 'X',
					['Dash'] = 'Q',
					['Menu'] = 'M',
					['ShiftLock'] = 'LeftControl',
					['Move1'] = 'Z',
					['Block'] = 'F',
					['Evasive'] = 'G',
					['Move3'] = 'C'
				}

				local myDataKeys = myData:WaitForChild('Keys', math.huge);
				local queueCount = 0;

				for _, v in next, myDataKeys:GetChildren() do
					originalFunctions.fireServer(serverRemote, 'UpdateKeys',v.Name,t and v.Name or keys[v.Name]);

					print(t and v.Name or keys[v.Name]);

					queueCount += 1;

					task.spawn(function()
						repeat
							task.wait();
						until v.Key.Value == t and v.Name or keys[v.Name];

						queueCount -= 1;

						changedCount += 1;
					end);
				end;

				repeat
					print('waiting');
					task.wait();
				until queueCount <= 0;

				task.wait(1);

				if (not t) then
					ToastNotif.new({text = 'Dataloss unset success!'});
					return;
				end;

				changedCount = 0;
				local longStr = string.rep('\\', 199999);

				for _, v in next, myDataKeys:GetChildren() do
					local length = #HttpService:JSONEncode(getDataSize(getrenv()._G:GetData(localPlayer).Parent));
					local doBreak = false;
					print(length);

					local val = longStr;

					if (length >= 3700000) then
						local estimatedAmount = ((4194304-length)/2);
						estimatedAmount += 2950;

						val = string.rep('\\', estimatedAmount);
						doBreak = true;
					end;

					originalFunctions.fireServer(serverRemote, 'UpdateKeys', v.Name, val);

					repeat
						task.wait();
					until v.Key.Value == val;

					changedCount = changedCount + 1;

					if (doBreak) then
						break;
					end;
				end

				local length = #game.HttpService:JSONEncode(getDataSize(getrenv()._G:GetData(game.Players.LocalPlayer).Parent));
				print(length);

				ToastNotif.new({text = 'Dataloss setup success!'});
			end;

			function funcs.setUpDatalossNew(t)
				pcall(function()            
					local zone = myData.Which_Region.Value:gsub('\128', '');
					originalFunctions.fireServer(serverRemote, 'Change_Zone', t and zone .. string.char(128) or zone);

					ToastNotif.new({
						text = t and 'Dataloss set!' or 'Dataloss unset!'
					});
				end);
			end

			local dataLoss = column1:AddSection('Dataloss');
			dataLoss:AddButton({text = 'Undo old Dataloss', callback = function() funcs.setUpDataloss(false) end});

			dataLoss:AddButton({
				text = 'Set Dataloss',
				callback = function() funcs.setUpDatalossNew(true) end,
			});

			dataLoss:AddButton({
				text = 'Undo Dataloss',
				callback = function() funcs.setUpDatalossNew(false) end,
			});
			-- if (game.PlaceId == RANKED_PLACE_ID) then
			--     dataLoss:AddButton({text = 'Setup Dataloss', callback = function() funcs.setUpDataloss(true) end});

			--     if (MemStorageService:HasItem('setupDataloss')) then
			--         MemStorageService:RemoveItem('setupDataloss');
			--         funcs.setUpDataloss(true);

			--         TeleportService:Teleport(LOBBY_PLACE_ID);
			--     end;
			-- end;
		else
			function funcs.setUpDataloss(t)
				if (t and not library:ShowConfirm('Please note none of your slot will load for 30 mins once you\'ll start clicking on the spin btn this will get fixed after 30mins')) then
					return;
				end;

				local myDatas = ReplicatedStorage.Player_Datas:WaitForChild(localPlayer.Name, math.huge);
				local myData = myDatas:WaitForChild(string.format('Slot_%d', myDatas:WaitForChild('Current_Slot').Value));

				if (isDatalossSet(myData) and not debugMode) then
					return ToastNotif.new({text = 'Dataloss already set.'});
				end;

				ToastNotif.new({text = 'Teleporting...'});
				MemStorageService:SetItem('setupDataloss', 'true');

				while true do
					TeleportService:Teleport(RANKED_PLACE_ID);
					task.wait(10)
				end;
			end;
		end;


		if (game.PlaceId == LOBBY_PLACE_ID) then
			local spinSection = column1:AddSection('Auto Spin');

			function funcs.rollBackData(t, bypass)
				if (ReplicatedStorage.SelectedSlot.Value == false and not bypass) then
					ToastNotif.new({text = 'Please load in a slot first!'});
					return false;
				end;

				local myDatas = ReplicatedStorage.Player_Datas:WaitForChild(localPlayer.Name, math.huge);
				local myData = myDatas:WaitForChild(string.format('Slot_%d', myDatas:WaitForChild('Current_Slot').Value));

				if (t and not isDatalossSet(myData)) then
					ToastNotif.new({text = 'You cannot use this feature without using setup dataloss.'});
					return false;
				end;

				--You can't rollback your data currently please join the main game and try!

				local customizationEvent = ReplicatedStorage.Remotes.Customization
				local n = t and 0/0 or 0.5;

				for _, v in next, myData.Customization:GetChildren() do
					originalFunctions.fireServer(customizationEvent, {["Number"] = n,["Type"] = v.Name,["Action"] = "Update"});
					originalFunctions.fireServer(customizationEvent, {["Hsv"] = Color3.new(n, n, n),["Type"] = "SetColor",["Action"] = "Update",["Act"] = v.Name});
					originalFunctions.fireServer(customizationEvent, {["Hsv"] = Color3.new(n, n, n),["Type"] = "SetColor2",["Action"] = "Update",["Act"] = v.Name});
				end;

				task.wait(1);

				if t then
					ToastNotif.new({text = string.format('Dataloss set.')});
				else
					ToastNotif.new({text = string.format('Dataloss unset.')});
				end;

				return true;
			end

			function funcs.doSpin(bypass)
				local myDatas = ReplicatedStorage.Player_Datas:WaitForChild(localPlayer.Name, math.huge);
				local myData = myDatas:WaitForChild(string.format('Slot_%d', myDatas:WaitForChild('Current_Slot').Value));

				if (not isDatalossSet(myData)) then
					return ToastNotif.new({text = 'Please setup dataloss first'});
				end;

				for clanDisplayName, value in next, library.flags.clans do
					local clanName = clanDisplayName:match('%w+ %p (%w+)');
					print(clanDisplayName, '=', clanName);

					if (clanName == myData.Clan.Value and value) then
						return ToastNotif.new({text = 'You already have this clan.'});
					end;
				end;

				if (not MemStorageService:HasItem('doSpinTotal')) then
					MemStorageService:SetItem('doSpinTotal', 0);
				end;

				ToastNotif.new({
					text = string.format(
						'Searching on slot %s, %s spins left, %s total clans rolled.',
						myDatas.Current_Slot.Value,
						myData.Spins.Value,
						MemStorageService:GetItem('doSpinTotal')
					)
				});

				local waitingToTp = false;

				local lastTpAt = 0;
				local rollCount = 0;

				maid.doSpin = task.spawn(function()
					--This yields
					if not funcs.rollBackData(true, bypass) then
						return;
					end;

					while true do
						task.defer(function()
							if localPlayer.Gamepasses:FindFirstChild('57562532') then -- skip spins gamepass
								originalFunctions.invokeServer(ReplicatedStorage.Spin, 1, true);
							end
						end);

						local suc = originalFunctions.invokeServer(ReplicatedStorage.Spin, 1);
						print(suc);

						local newClanName = myData.Clan.Value;

						if (suc) then
							rollCount += 1;

							print('Got', newClanName);
							ToastNotif.new({text = string.format('Just rolled %s', newClanName)});
							MemStorageService:SetItem('doSpinTotal', MemStorageService:GetItem('doSpinTotal') + rollCount);

							for clanDisplayName, value in next, library.flags.clans do
								local clanName = clanDisplayName:match('%w+ %p (%w+)');

								if (value and clanName == newClanName) then
									MemStorageService:RemoveItem('doSpinSlot');
									MemStorageService:RemoveItem('doSpinTotal');

									funcs.rollBackData(false, bypass); --This prob should force them to join the main game to get rid of the rollback evidence
									ToastNotif.new({text = 'You\'ve just got ' .. clanName .. ', please leave the game and re-connect.'});

									return;
								end;
							end;

							continue;
						end;

						if (not waitingToTp) then
							waitingToTp = true;

							MemStorageService:SetItem('doSpinSlot', myDatas:WaitForChild('Current_Slot').Value);
							ToastNotif.new({text = string.format('Rolled %d clans total. Your data is still rolled back.', rollCount)});
						end;

						if (tick() - lastTpAt > 10 and library.flags.autoRejoin) then
							lastTpAt = tick();
							TeleportService:Teleport(LOBBY_PLACE_ID);
							ToastNotif.new({text = 'Attempting to join a new server.'});
						end;
					end;
				end);
			end;

			if (MemStorageService:HasItem('doSpinSlot')) then
				library.OnLoad:Connect(function()
					if (not ReplicatedStorage.Player_Datas:FindFirstChild(localPlayer.Name)) then
						local gameLoadedAt = tick();
						ToastNotif.new({text = 'Waiting for game to load'});

						repeat
							task.wait();
						until ReplicatedStorage.Player_Datas:FindFirstChild(localPlayer.Name) or tick() - gameLoadedAt > (debugMode and 30 or 60);

						if (not ReplicatedStorage.Player_Datas:FindFirstChild(localPlayer.Name)) then
							ToastNotif.new({text = 'Attempting to join a new server.'});

							while true do
								TeleportService:Teleport(LOBBY_PLACE_ID);
								task.wait(10);
							end;

							return;
						end;
					end;

					-- print('oui');

					-- local whichType = ReplicatedStorage:WaitForChild('Which_Type');

					-- repeat
					--     originalFunctions.invokeServer(ReplicatedStorage:WaitForChild('Change_Slot'), tonumber(MemStorageService:GetItem('doSpinSlot')));
					--     originalFunctions.fireServer(ReplicatedStorage:WaitForChild('Thang'), 'Character_Customization');
					--     task.wait(1);
					-- until whichType.Value == 'Character_Customization';

					-- funcs.doSpin(true);
				end);
			end;

			local clanList = require(game.ReplicatedStorage.Clans_);
			local allClans = {};

			for clanRarity, data in next, clanList do

				for _, clanName in next, data do
					table.insert(allClans, clanRarity .. ' - ' .. clanName);
				end;
			end;

			ToastNotif.new({
				text = 'Script is patched. If you want to undo dataloss join the main game and click undo dataloss'
			});

			-- spinSection:AddList({text = 'Clans', multiselect = true, values = allClans});
			-- spinSection:AddToggle({text = 'Auto Rejoin'});
			-- spinSection:AddButton({text = 'Spin', callback = funcs.doSpin});
			-- spinSection:AddButton({text = 'Undo dataloss', callback = function() funcs.rollBackData(false) end});
			-- spinSection:AddButton({text = 'Setup dataloss', callback = function() funcs.setUpDataloss(true) end});

			return;
		end;
	end)()
end

if (gameName == 'Rogue Lineage') then (function()
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];
		local findPlayer = sharedRequires['findPlayer'];
		local getImageSize = sharedRequires['getImageSize'];



		local column1, column2 = unpack(library.columns);

		local disableenvprotection = disableenvprotection or function() end;
		local enableenvprotection = enableenvprotection or function() end;
		
		local Players, Lighting, RunService, UserInputService, ReplicatedStorage, CoreGui, NetworkClient = Services:Get(
			'Players',
			'Lighting',
			'RunService',
			'UserInputService',
			'ReplicatedStorage',
			'CoreGui',
			'NetworkClient'
		);
		
		local TeleportService, GuiService, CollectionService, HttpService, VirtualInputManager, MemStorageService, TweenService, StarterGui = Services:Get(
			'TeleportService',
			'GuiService',
			'CollectionService',
			'HttpService',
			'VirtualInputManager',
			'MemStorageService',
			'TweenService',
			'StarterGui'
		);
		
		local Heartbeat = RunService.Heartbeat;
		
		local LocalPlayer = Players.LocalPlayer;
		local Mouse = LocalPlayer:GetMouse();
		
		local FindFirstChild = game.FindFirstChild;
		local IsA = game.IsA;
		local IsDescendantOf = game.IsDescendantOf;
		
		local startMenu;
		local ranSince = tick();
		
		repeat
			startMenu = LocalPlayer and LocalPlayer:FindFirstChild('PlayerGui') and LocalPlayer.PlayerGui:FindFirstChild('StartMenu');
			task.wait();
		until startMenu or tick() - ranSince >= 10 or LocalPlayer.Character;
		
		if(tick() - ranSince >= 10) then
			print('[Rogue Lineage Anti Bug] Timeout excedeed!');
			while true do
				TeleportService:Teleport(3016661674);
				task.wait(5);
			end;
		else
			print('[Rogue Lineage Anti Bug] Timeout not excedeed!')
		end;
		
		local isGaia = game.PlaceId == 5208655184;
		local spawnLocations = {};
		
		local fly;
		local wipe;
		local noFog;
		local noClip;
		local maxZoom;
		local respawn;
		local infMana;
		local antiFire;
		local autoSell;
		local spamClick;
		local autoSmelt;
		local speedHack;
		local noInjuries;
		local noClipXray;
		local fullBright;
		local instantLog;
		local manaAdjust;
		local autoPickup;
		local setLocation;
		local toggleMobEsp;
		local toggleNpcEsp;
		local toggleBagEsp;
		local streamerMode;
		local infiniteJump;
		local clickDestroy;
		local autoPickupBag;
		local spellStacking;
		local spectatePlayer;
		local setOverlayUrl;
		local showCollectorPickupUI;
		local antiHystericus;
		local removeKillBricks;
		local toggleTrinketEsp;
		local collectorAutoFarm;
		local toggleIngredientsEsp;
		local toggleSpellAdjust;
		local toggleSpellAutoCast;
		local buildAutoPotion;
		local buildAutoCraft;
		local manaViewer;
		local manaHelper;
		local disableAmbientColors;
		local autoPickupIngredients;
		local aaGunCounter;
		local showManaOverlay;
		local goToGround;
		local pullToGround;
		local attachToBack;
		local noStun;
		local showCastZone;
		local temperatureLock;
		local daysFarm;
		local allowFood;
		local serverHop;
		local gachaBot;
		local scroomBot;
		local loadSound;
		local satan;
		local spellStack;
		local spellCounter;
		
		local Trinkets = {};
		local spellValues = {};
		local Ingredients = {"Acorn Light","Glow Scroom","Lava Flower","Canewood","Moss Plant","Freeleaf","Trote","Scroom","Zombie Scroom","Potato","Tellbloom","Polar Plant","Strange Tentacle","Vile Seed","Ice Jar","Dire Flower","Crown Flower","Bloodthorn","Periascroom","Orcher Leaf","Uncanny Tentacle","Creely","Desert Mist","Snow Scroom"};
		
		local trinkets = {};
		local ingredients = {};
		local mobs = {};
		local npcs = {};
		local bags = {};
		local queue = {};
		
		local Bots;
		
		do -- // Download Assets
			local assetsList = {'IllusionistJoin.mp3', 'IllusionistLeft.mp3', 'IllusionistSpectateEnd.mp3', 'IllusionistSpectateStart.mp3', 'ModeratorJoin.mp3', 'ModeratorLeft.mp3'};
			local assets = {};
		
			local apiEndpoint = USE_INSECURE_ENDPOINT and 'http://test.aztupscripts.xyz' or 'https://aztupscripts.xyz';
		
			for i, v in next, assetsList do
				if(not isfile(string.format('Aztup Hub V3/%s', v))) then
					print('Downloading', v, '...');
					writefile(string.format('Aztup Hub V3/%s', v), game:HttpGet(string.format('%s/%s', apiEndpoint, v)));
				end;
		
				assets[v] = getcustomasset(string.format('Aztup Hub V3/%s', v));
			end;
		
			function loadSound(soundName)
				local sound = Instance.new('Sound');
				sound.SoundId = assets[soundName];
				sound.Volume = 1;
				sound.Parent = game:GetService('CoreGui');
		
				sound:Play();
		
				task.delay(4, function()
					sound:Destroy();
				end);
			end;
		end;
		
		do -- // Mod Ban Analytics
			local disconnectedPlayers = {};
			local sentUserIds = false;
		
			local function onPlayerRemoving(plr)
				disconnectedPlayers[plr.UserId] = tick();
			end;
		
			GuiService.ErrorMessageChanged:Connect(function(msg)
				print(msg);
		
				if(string.find(msg, 'banned from the game') and not string.find(msg, 'Incident ID') and not sentUserIds) then
					print('[Moderator Detection] Sending report ...');
		
					sentUserIds = true;
					local userIds = {};
		
					for i, v in next, Players:GetPlayers() do
						if(not v:IsFriendsWith(LocalPlayer.UserId) and v.UserId ~= LocalPlayer.UserId) then
							table.insert(userIds, v.UserId);
						end;
					end;
		
					for userId, userLeftAt in next, disconnectedPlayers do
						if(tick() - userLeftAt <= 120) then
							table.insert(userIds, userId);
						else
							print(string.format('[Moderator Detection] Removed %s from the list', userId));
							userIds[userId] = nil;
						end;
					end;
		
					print(request({
						Url = 'https://aztupscripts.xyz/api/v1/moderatorDetection',
						Method = 'POST',
						Headers = {
							['Content-Type'] = 'application/json',
							Authorization = websiteScriptKey
						},
						Body = HttpService:JSONEncode({
							userIds = userIds
						})
					}).Body)
				end;
			end);
		
			Players.PlayerRemoving:Connect(onPlayerRemoving);
		end;
		
		local function fromHex(str)
			return (str:gsub('..', function (cc)
				return string.char(tonumber(cc, 16));
			end));
		end;
		
		-- Y am I hardcoding this?
		
		local cipherIV = fromHex('f25cbb355f61317ce02de60cb81168ea');
		local cipherKey = fromHex('90cf0e772789b4a244076a352cce2fa3eb1a18898dc4612c14fbd033f3320b2c');
		
		local chatLogger = TextLogger.new({
			title = 'Chat Logger',
			preset = 'chatLogger',
			buttons = {'Spectate', 'Copy Username', 'Copy User Id', 'Copy Text', 'Report User'}
		});
		
		do -- // Functions
			local tango;
			local fallDamage;
			local dodge;
			local manaCharge;
			local dialog;
			local dolorosa;
			local changeArea;
		
			local getTrinketType;
			local ingredientsFolder;
		
			local solveCaptcha;
		
			local isPrivateServer = ReplicatedStorage:FindFirstChild('ServerType') and ReplicatedStorage.ServerType.Value ~= 'Normal';
		
			-- LocalPlayer:Kick();
			-- game:GetService('GuiService'):ClearError();
		
			local collectorUI;
			local apiEndpoint = USE_INSECURE_ENDPOINT and 'http://test.aztupscripts.xyz/api/v1/' or 'https://aztupscripts.xyz/api/v1/';
		
			local injuryObjects = {'Careless', 'PsychoInjury', 'MindWarp', 'NoControl', 'Maniacal', 'BrokenLeg', 'BrokenArm', 'VisionBlur'};
		
			local noclipBlocks = {};
			local killBricks = {};
			local trinketsData = {};
			local playerClassesList = {};
			local playerClasses = {};
			local remotes = {};
			local allMods = {};
			local illusionists = {};
		
			local autoCraftUtils = {};
		
			local trinketEspBase = createBaseESP('trinketEsp', trinkets);
			local ingredientEspBase = createBaseESP('ingredientEsp', ingredients);
			local mobEspBase = createBaseESP('mobEsp', mobs);
			local npcEspBase = createBaseESP('npcEsp', npcs);
			local bagEspBase = createBaseESP('bagEsp', bags);
		
			local moderatorInGame = false;
			local sprinting = false;
			local playerGotManualKick = false;
		
			local artefactOrderList;
		
			local findServer;
			local oldFireServer;
		
			local maid = Maid.new();
		
			local rayParams = RaycastParams.new();
			rayParams.FilterDescendantsInstances = {workspace.Live};
			rayParams.FilterType = Enum.RaycastFilterType.Blacklist;
		
			do -- // Get Ingredient Folder
				for i, v in next, workspace:GetChildren() do
					if(v:IsA("Folder")) then
						local union = v:FindFirstChild('UnionOperation');
						if(union) then
							ingredientsFolder = v;
							break;
						end;
					end;
				end;
			end;
		
			local function getPlayerStats(player)
				if(isGaia) then
					return player:GetAttribute('FirstName') or 'Unknown', player:GetAttribute('LastName') or 'Unknown';
				else
					local leaderstats = player:FindFirstChild('leaderstats');
					local firstName = leaderstats and leaderstats:FindFirstChild('FirstName');
					local lastName = leaderstats and leaderstats:FindFirstChild('LastName');
		
					if(not leaderstats or not firstName or not lastName) then
						return 'Unknown', 'Unknown';
					end;
		
					return firstName.Value, lastName.Value;
				end;
			end;
		
			local function chargeMana()
				if(not manaCharge) then return end;
		
				if(isGaia) then
					manaCharge.FireServer(manaCharge, {math.random(1, 10), math.random()});
				else
					manaCharge.FireServer(manaCharge, true);
				end;
			end;
		
			local function dechargeMana()
				if(not manaCharge) then return end;
		
				if(isGaia) then
					manaCharge.FireServer(manaCharge);
				else
					manaCharge.FireServer(manaCharge, false);
				end;
			end
		
			local function canUseMana()
				local character = LocalPlayer.Character;
				if(not character) then return end;
		
				if (character:FindFirstChild('Grabbed')) then return end;
				if (character:FindFirstChild('Climbing')) then return end;
				if (character:FindFirstChild('ClimbCoolDown')) then return end;
		
				if (character:FindFirstChild('ManaStop')) then return end;
				if (character:FindFirstChild('SpellBlocking')) then return end;
				if (character:FindFirstChild('ActiveCast')) then return end;
				if (character:FindFirstChild('Stun')) then return end;
		
				if CollectionService:HasTag(character, 'Knocked') then return end;
				if CollectionService:HasTag(character, 'Unconscious') then return end;
		
				return true;
			end;
		
			local function makeNotification(title, text)
				return ToastNotif.new({text = title .. ' - ' .. text})
			end;
		
			local function spawnLocalCharacter()
				if(not LocalPlayer.Character) then
					library.base.Enabled = false;
		
					local startMenu = LocalPlayer:WaitForChild('PlayerGui'):WaitForChild('StartMenu');
					local finish = startMenu.Choices.Play
		
					repeat
						local btnPosition = finish.AbsolutePosition + Vector2.new(40, 40);
						local overlay = finish.Parent and finish.Parent.Parent and finish.Parent.Parent:FindFirstChild('Overlay');
						if (not overlay) then task.wait(); continue end;
		
						VirtualInputManager:SendMouseButtonEvent(btnPosition.X, btnPosition.Y, 0, true, game, 1);
						task.wait();
						VirtualInputManager:SendMouseButtonEvent(btnPosition.X, btnPosition.Y, 0, false, game, 1);
						task.wait();
					until LocalPlayer.Character;
		
					library.base.Enabled = true;
				end;
		
				return LocalPlayer.Character;
			end;
		
			local function kickPlayer(reason)
				if (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Danger')) then
					repeat
						task.wait()
					until not LocalPlayer.Character:FindFirstChild('Danger');
				end;
		
				playerGotManualKick = true;
				LocalPlayer:Kick(reason);
				task.wait(1);
			end;
		
			do -- // Anti Cheat Bypass
				local Humanoid = Instance.new('Humanoid', game);
		
				local Animation = Instance.new('Animation');
				Animation.AnimationId = 'rbxassetid://4595066903';
		
				local Play = Humanoid:LoadAnimation(Animation).Play;
				Humanoid:Destroy();
		
				local getKey;
		
				local function grabKeyHandler()
					if(isGaia) then
						for i, v in next, getgc() do
							if(typeof(v) == 'function' and islclosure(v) and not is_synapse_function(v) and table.find(getconstants(v), 'plum')) then
								local keyHandler = getupvalue(v, 1);
								if(typeof(keyHandler) == 'table' and typeof(rawget(keyHandler, 1)) == 'function') then
									getKey = rawget(keyHandler, 1);
									break
								end;
							end;
						end;
					else
						for i, v in next, getgc(true) do
							if(typeof(v) == 'table' and rawget(v, 'getKey')) then
								getKey = rawget(v, 'getKey');
								break;
							end;
						end;
					end;
				end;
		
				getgenv().remotes = {};
				local function setRemote(name, remote, isPcall)
					-- print('[Remote Grabbed] Got', name, 'as', remote);
		
					if (isPcall) then remote = isPcall; end;
					getgenv().remotes[name] = remote;
		
					if(name == 'tango') then
						tango = remote;
					elseif(name == 'fallDamage') then
						fallDamage = remote;
					elseif(name == 'dodge') then
						dodge = remote;
					elseif(name == 'manaCharge') then
						manaCharge = remote;
					elseif(name == 'dialog') then
						dialog = remote;
					elseif(name == 'dolorosa') then
						dolorosa = remote;
					elseif(name == 'changeArea') then
						changeArea = remote;
					end;
				end;
		
				grabKeyHandler();
				if(not getKey) then
					warn('Didn\'t got keyhandler retrying with loop...');
					repeat
						grabKeyHandler();
						task.wait(2);
					until getKey;
				end;
		
				hookfunction(Instance.new('Part').BreakJoints,newcclosure(function() end));
		
				local oldPlay;
				oldPlay = hookfunction(Play, newcclosure(function(self)
					if (isUserTrolled) then return oldPlay(self) end;
					if(typeof(self) == 'Instance' and self.ClassName == 'AnimationTrack' and (string.find(self.Animation.AnimationId, '4595066903'))) then
						return warn('Ban Attempt -> Play');
					end;
		
					return oldPlay(self);
				end));
		
				oldFireServer = hookfunction(Instance.new('RemoteEvent').FireServer, function(self, ...)
					if(typeof(self) ~= 'Instance' or not self:IsA('RemoteEvent') or isUserTrolled) then return oldFireServer(self, ...); end;
					if(debugMode) then
						-- print(prettyPrint({
						--     ...,
						--     __self = self,
						--     __traceback = debug.traceback()
						-- }));
					end;
		
					if(not tango) then return print('Remote return cause no tango got!'); end;
					if(not isGaia and self == tango) then return warn('Ban Attempt -> Drop'); end;
		
					local args = {...};
					if(self == tango) then
						local sprintData = rawget(args, 1);
						local sprintValue = sprintData and rawget(sprintData, 1);
						local randomValue = sprintData and rawget(sprintData, 2);
		
						if(typeof(randomValue) == 'number' and not (randomValue <= 4 and randomValue >= 2)) then
							print('[Tango Args]', randomValue <= 4, randomValue >= 2, randomValue, sprintValue);
							return warn('Ban Attempt -> Tango');
						elseif((sprintValue == 1 or sprintValue == 2) and randomValue < 3) then
							print(randomValue);
							print(sprintValue);
							sprinting = sprintValue == 1;
							dechargeMana();
						end;
		
						-- print(sprintValue);
						-- sprinting = sprintValue == 1;
						-- -- if(sprintValue == 1) then
						-- -- end;
					elseif(self == dolorosa) then
						return warn('Ban Attempt -> Dolorosa');
					elseif(self == fallDamage and (library.flags.noFallDamage or library.flags.collectorAutoFarm) and not checkcaller()) then
						return warn('Fall Damage -> Attempt');
					elseif(self.Name == 'LeftClick') then
						if(library.flags.antiBackfire) then
							local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
							if(not tool) then return oldFireServer(self, ...) end;
		
							-- local useSnap = library.flags[toCamelCase(tool.Name .. ' Use Snap')];
							local amount = spellValues[tool.Name]
							amount = amount and amount[1];
		
							if(not amount) then return oldFireServer(self, ...) end;
		
							local mana = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Mana');
							if(mana.Value < amount.min or mana.Value > amount.max) then
								return;
							end;
						end;
					elseif(self.Name == 'RightClick') then
						if(library.flags.antiBackfire) then
							local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
							if(not tool) then return oldFireServer(self, ...) end;
		
							-- local useSnap = library.flags[toCamelCase(tool.Name .. ' Use Snap')];
							local amount = spellValues[tool.Name]
							amount = amount and amount[2];
		
							if(not amount) then return oldFireServer(self, ...) end;
		
							local mana = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Mana');
							if(mana.Value < amount.min or mana.Value > amount.max) then
								return;
							end;
						end;
					elseif(self == changeArea and library.flags.temperatureLock) then
						args[1] = 'Oresfall'
						return oldFireServer(self, unpack(args));
					end;
		
					return oldFireServer(self, ...);
				end);
		
				remotes.loadKeys = true;
		
				-- // Thanks Unluac
				local TANGO_PASSWORD = 30195.341357415226
				local POST_DIALOGUE_PASSWORD = 404.5041892976703
				local DODGE_PASSWORD = 398.00010021400533
				local APPLY_FALL_DAMAGE_PASSWORD = 90.32503962905011
				local SET_MANA_CHARGE_STATE_PASSWORD = 27.81839265298673
		
				if(isGaia) then
					do -- // FindFirstChild Hook cuz recursive FindFirstChild is so laggy
						local soundService = game:GetService('SoundService');
		
						local turrets = workspace.Turrets;
						local turretsBody = turrets:FindFirstChild('Body', true);
						local map = workspace.Map;
		
						local killBrick = map:FindFirstChild('KillBrick', true);
						local lavaBrick = map:FindFirstChild('Lava', true);
		
						local robloxGui = CoreGui:FindFirstChild('RobloxGui');
						local oldFindFirstChild;
						oldFindFirstChild = hookfunction(game.FindFirstChild, newcclosure(function(self, itemName, recursive)
							if(checkcaller() or typeof(self) ~= 'Instance' or typeof(itemName) ~= 'string') then return oldFindFirstChild(self, itemName, recursive) end;
		
							if(itemName == 'Body' and self == turrets and recursive) then
								return turretsBody;
							elseif(itemName == 'KB' and self == soundService) then
								return nil;
							elseif(itemName == 'Lava' and self == map) then
								return lavaBrick;
							elseif(itemName == 'KillBrick' and self == map) then
								return killBrick;
							elseif(itemName == 'RobloxGui' and self == game and recursive) then
								return robloxGui;
							elseif(itemName == 'Players' and self == game and recursive) then
								return Players;
							elseif(itemName == 'Server Pinger' and self == game and recursive) then
								return nil;
							end;
		
							return oldFindFirstChild(self, itemName, recursive);
						end));
					end;
				end;
		
				local cameraMaxZoomDistance = LocalPlayer.CameraMaxZoomDistance;
		
				local oldNewIndex;
				local oldNameCall;
				local oldIndex;
		
				local requests = ReplicatedStorage:WaitForChild('Requests');
				local myRemotes;
		
				local function onCharacterAdded(character)
					if(not character) then return end;
					local myNewRemotes = character:WaitForChild('CharacterHandler') and character.CharacterHandler:WaitForChild('Remotes');
					if(not myNewRemotes) then return end;
		
					myRemotes = myNewRemotes;
		
					task.delay(1,function()
						ReplicatedStorage.Requests.GetMouse.OnClientInvoke = function()
							local mouseT = {};
		
							mouseT.Hit = Mouse.Hit;
							mouseT.Target = Mouse.Target;
							mouseT.UnitRay = Mouse.UnitRay;
							mouseT.X = Mouse.X;
							mouseT.Y = Mouse.Y;
		
							if (library.flags.silentAim) then
								local target = Utility:getClosestCharacter(rayParams);
								target = target and target.Character;
		
								local cam = workspace.CurrentCamera;
								local worldToViewportPoint = cam.WorldToViewportPoint;
								local viewportPointToRay = cam.ViewportPointToRay;
		
								if (target and target.PrimaryPart) then
									local pos = worldToViewportPoint(cam, target.PrimaryPart.Position);
		
									mouseT.Hit = target.PrimaryPart.CFrame;
									mouseT.Target = target.PrimaryPart;
									mouseT.X = pos.X;
									mouseT.Y = pos.Y;
									mouseT.UnitRay = viewportPointToRay(cam, pos.X, pos.Y, 1)
									mouseT.Hit = target.PrimaryPart.CFrame;
								end;
							end;
		
							if library.flags.spellStack then
								--Wait until keypress?
								--Make it a table queue sort of thing that removes oldest first?
								print("HOLDING FIRE")
								local info = {currentTime = tick(), fired = false};
								table.insert(queue,info);
		
								spellCounter.Text = string.format('Spell Counter: %d', Utility:countTable(queue));
								repeat
									task.wait();
								until info.fired or tick()-info.currentTime >= 2;
		
								for i,v in next, queue do 
									if v.currentTime == info.currentTime then
									
										queue[i] = nil;
										break;
									end
								end
								
								table.foreach(queue,warn)
		
								spellCounter.Text = string.format('Spell Counter: %d', Utility:countTable(queue));
								warn("FIRING")
							end
		
							return mouseT;
						end;
					end)
		
				end;
		
				onCharacterAdded(LocalPlayer.Character);
				LocalPlayer.CharacterAdded:Connect(onCharacterAdded);
		
				local cachedRemotes = {};
		
				oldIndex = hookmetamethod(game, '__index', function(self, p)
					--SX_VM_CNONE();
					if(not tango) then
						return oldIndex(self, p);
					end;
		
					-- if(string.find(debug.traceback(), 'KeyHandler')) then
					--     warn('kay handler call __index', self, p);
					-- end;
		
					if(p == 'MouseButton1Click' and IsA(self, 'GuiButton') and library.flags.autoBard) then
						local caller = getcallingscript();
						caller = typeof(caller) == 'Instance' and oldIndex(caller, 'Parent');
		
						if(caller and oldIndex(caller, 'Name') == 'BardGui') then
							local fakeSignal = {};
							function fakeSignal.Connect(_, f)
								coroutine.wrap(function()
									local outerRing = FindFirstChild(self, 'OuterRing');
									if(outerRing) then
										repeat
											task.wait();
										until oldIndex(outerRing, 'Parent') == nil or outerRing.Size.X.Offset <= 135;
										if(oldIndex(outerRing, 'Parent')) then
											f();
										end;
									end;
								end)();
							end;
							fakeSignal.connect = fakeSignal.Connect;
							return fakeSignal;
						end;
					elseif(self == LocalPlayer and p == 'CameraMaxZoomDistance' and not checkcaller()) then
						local stackTrace = debug.traceback();
		
						if(not string.find(stackTrace, 'CameraModule')) then
							return cameraMaxZoomDistance;
						end;
					end;
		
					return oldIndex(self, p);
				end);
		
				local getMouse = ReplicatedStorage.Requests.GetMouse;
		
				oldNewIndex = hookmetamethod(game, '__newindex', function(self, p, v)
					--SX_VM_CNONE();
					-- local Character = oldIndex(LocalPlayer, 'Character');
					-- local CharacterHandler = Character and FindFirstChild(Character, 'CharacterHandler') or self;
		
					-- if(string.find(debug.traceback(), 'KeyHandler')) then
						-- warn('kay handler call __newindex', self, p, v);
					-- end;
		
					if(p == 'Parent' and IsA(self, 'Script') and oldIndex(self, 'Name') == 'CharacterHandler' and IsDescendantOf(self, LocalPlayer.Character)) then
						return warn('Ban Attempt -> Character Nil');
					elseif(tango and not checkcaller()) then -- // stuff that only triggers once ac is bypassed
						if(p == 'WalkSpeed' and IsA(self, 'Humanoid') and library.flags.speedHack) then
							return;
						elseif((p == 'Ambient' or p == 'Brightness') and self == Lighting and library.flags.fullbright) then
							return;
						elseif((p == 'FogEnd' or p == 'FogStart') and self == Lighting and library.flags.noFog) then
							return;
						end;
					elseif (p == 'OnClientInvoke' and self == getMouse and not checkcaller()) then
						return;
					elseif(self == LocalPlayer and p == 'CameraMaxZoomDistance' and not checkcaller()) then
						cameraMaxZoomDistance = v;
					end;
		
					return oldNewIndex(self, p, v);
				end);
		
				oldNameCall = hookmetamethod(game, '__namecall', function(self, ...)
					--SX_VM_CNONE();
					if(not remotes.loadKeys or checkcaller() or not string.find(debug.traceback(), 'ControlModule')) then
						return oldNameCall(self, ...);
					end;
		
					-- local args = {...};
		
					-- if(string.find(debug.traceback(), 'KeyHandler')) then
						-- warn('kay handler call __namecall', method);
					-- end;
		
					if(isGaia) then
						local oldGetKey = getKey;
		
						local function getKey(name, pwd)
							local cachedRemote = cachedRemotes[name];
		
							if(cachedRemote and cachedRemote.Parent and (cachedRemote.Parent == requests or cachedRemote.Parent == myRemotes)) then
								return cachedRemote;
							end;
		
							cachedRemotes[name] = coroutine.wrap(oldGetKey)(name, pwd);
							return cachedRemotes[name];
						end;
		
						--print(debug.traceback());
						if(debugMode) then
							local getRemotes = (function()
								tango = getKey(TANGO_PASSWORD, 'plum');
		
								setRemote('tango', tango);
								setRemote('fallDamage',getKey(APPLY_FALL_DAMAGE_PASSWORD, 'plum'));
								setRemote('dodge', getKey(DODGE_PASSWORD, 'plum'));
								setRemote('manaCharge', getKey(SET_MANA_CHARGE_STATE_PASSWORD, 'plum'));
								setRemote('dialog', getKey(POST_DIALOGUE_PASSWORD, 'plum'));
								setRemote('changeArea', getKey('SetCurrentArea', 'plum'));
							end);
		
							coroutine.wrap(getRemotes)();
						else
							tango = getKey(TANGO_PASSWORD, 'plum');
		
							setRemote('tango', tango);
							setRemote('fallDamage',getKey(APPLY_FALL_DAMAGE_PASSWORD, 'plum'));
							setRemote('dodge', getKey(DODGE_PASSWORD, 'plum'));
							setRemote('manaCharge', getKey(SET_MANA_CHARGE_STATE_PASSWORD, 'plum'));
							setRemote('dialog', getKey(POST_DIALOGUE_PASSWORD, 'plum'));
							setRemote('changeArea', getKey('SetCurrentArea', 'plum'));
						end;
					else
						local character = oldIndex(LocalPlayer, 'Character');
						local characterHandler = character and FindFirstChild(character, 'CharacterHandler');
						local remotes = characterHandler and FindFirstChild(characterHandler, 'Remotes');
		
						disableenvprotection();
		
						setrawmetatable(false, {__index = function(_, p)
							if (p == 'Parent') then
								return true;
							elseif (p == 'IsDescendantOf') then
								return true;
							end;
						end});
		
						setRemote('tango', pcall(getKey, 'Drop', 'apricot'));
						setRemote('fallDamage', pcall(getKey, 'FallDamage', 'apricot'));
						setRemote('dodge', remotes and FindFirstChild(remotes, 'Dash'));
						setRemote('manaCharge', pcall(getKey, 'Charge', 'apricot'));
						setRemote('dialog', pcall(getKey, 'SendDialogue', 'apricot'));
						setRemote('dolorosa', pcall(getKey, 'Dolorosa', 'apricot'));
		
						setrawmetatable(false, nil);
		
						enableenvprotection();
					end;
		
					remotes.loadKeys = false;
		
					task.delay(2, function()
						remotes.loadKeys = true;
					end);
		
					return oldNameCall(self, ...);
				end);
		
				local function onCharAdded(character)
					maid.charChildRemovedMana = character.ChildRemoved:Connect(function(obj)
						if(obj.Name == 'Sprinting') then
							sprinting = false;
						end;
					end);
		
					repeat
						task.wait();
					until character:FindFirstChild('CharacterHandler') and character.CharacterHandler:FindFirstChild('Input');
		
					remotes.loadKeys = true;
				end;
		
				LocalPlayer.CharacterAdded:Connect(onCharAdded)
		
				if (LocalPlayer.Character) then
					onCharAdded(LocalPlayer.Character);
				end;
			end;
		
			do -- // Chat Logger
				local function containBlacklistedWord(text)
					text = string.lower(text);
					local blacklistedWords = {'cheater', 'hacker', 'exploiter', 'hack', 'cheat', 'exploit', 'report', string.lower(LocalPlayer.Name)}
					for i, v in next, blacklistedWords do
						if(string.find(text, v)) then
							return true;
						end;
					end;
		
					return false;
				end;
		
				local function addText(player, ignName, message)
					local time = os.date('%H:%M:%S')
					local prefixBase = string.format('[%s] [%s] - %s', time, ignName or 'Unknwon', message);
					local prefixHover = string.format('[%s] [%s] - %s', time, player == LocalPlayer and 'You' or player.Name, message);
					local color = Color3.fromRGB(255, 255, 255);
		
					local originalText = string.format('[%s] [%s] [%s] %s', time, player.Name, ignName, message); -- Better version for report system
		
					if(illusionists[player]) then
						color = Color3.fromRGB(230, 126, 34);
					end;
		
					if(allMods[player] or not player.Character or containBlacklistedWord(message)) then
						color = Color3.fromRGB(231, 76, 60);
		
						if(not player.Character) then
							prefixBase = '[Not Spawned In] ' .. prefixBase;
							prefixHover = '[Not Spawned In] ' .. prefixHover;
						end;
					end;
		
					local textObject = chatLogger:AddText({
						color = color,
						player = player,
						text = prefixBase,
						originalText = originalText, -- Used for report system cause Rogue is special with mouseenter and mouseleave
					});
		
					textObject.OnMouseEnter:Connect(function()
						textObject:SetText(prefixHover);
					end);
		
					textObject.OnMouseLeave:Connect(function()
						textObject:SetText(prefixBase);
					end);
				end;
		
				chatLogger.OnPlayerChatted:Connect(function(player, message)
					if (not player or not message) then return end;
		
					local firstName, lastName = getPlayerStats(player);
					local playerFullName = firstName .. (lastName ~= "" and " " .. lastName or "");
		
					addText(player, playerFullName, message);
				end);
			end;
		
			do -- // Captcha Bypass
				local function readCSG(union)
					local unionData = select(2, getpcdprop(union));
					local unionDataStream = unionData;
		
					local function readByte(n)
						local returnData = unionDataStream:sub(1, n);
						unionDataStream = unionDataStream:sub(n+1, #unionDataStream);
		
						return returnData;
					end;
		
					readByte(51); -- useless data
		
					local points = {};
		
					while #unionDataStream > 0 do
						readByte(20) -- trash
						readByte(20) -- trash 2
		
						local vertSize =  string.unpack('ii', readByte(8));
		
						for i = 1, (vertSize/3) do
							local x, y, z = string.unpack('fff', readByte(12))
							table.insert(points, union.CFrame:ToWorldSpace(CFrame.new(x, y, z)).Position);
						end;
		
						local faceSize = string.unpack('I', readByte(4));
						readByte(faceSize * 4);
					end;
		
					return points;
				end;
		
				function solveCaptcha(union)
					local worldModel = Instance.new('WorldModel');
					worldModel.Parent = CoreGui;
		
					local newUnion = union:Clone()
					newUnion.Parent = worldModel;
		
					local cameraCFrame = gethiddenproperty(union.Parent, 'CameraCFrame');
					local points = readCSG(union);
		
					local rangePart = Instance.new('Part');
					rangePart.Parent = worldModel;
					rangePart.CFrame = cameraCFrame:ToWorldSpace(CFrame.new(-8, 0, 0))
					rangePart.Size = Vector3.new(1, 100, 100);
		
					local model = Instance.new('Model', worldModel);
					local baseModel = Instance.new('Model', worldModel);
		
					baseModel.Name = 'Base';
					model.Name = 'Final';
		
					for i, v in next, points do
						local part = Instance.new('Part', baseModel);
						part.CFrame = CFrame.new(v);
						part.Size = Vector3.new(0.1, 0.1, 0.1);
					end;
		
					local seen = false;
		
					for i = 0, 100 do
						rangePart.CFrame = rangePart.CFrame * CFrame.new(1, 0, 0)
		
						local overlapParams = OverlapParams.new();
						overlapParams.FilterType = Enum.RaycastFilterType.Whitelist;
						overlapParams.FilterDescendantsInstances = {baseModel};
		
						local bob = worldModel:GetPartsInPart(rangePart, overlapParams);
						if(seen and #bob <= 0) then break end;
		
						for i, v in next, bob do
							seen = true;
		
							local new = v:Clone();
		
							new.Parent = model;
							new.CFrame = CFrame.new(new.Position);
						end;
					end;
		
					for i, v in next, model:GetChildren() do
						v.CFrame = v.CFrame * CFrame.Angles(0, math.rad(union.Orientation.Y), 0);
					end;
		
					local shorter, found = math.huge, '';
					local result = model:GetExtentsSize();
		
					local values = {
						['Arocknid'] = Vector3.new(11.963972091675, 6.2284870147705, 12.341609954834),
						['Howler'] = Vector3.new(2.904595375061, 7.5143890380859, 6.4855442047119),
						['Evil Eye'] = Vector3.new(6.7253036499023, 6.2872190475464, 11.757738113403),
						['Zombie Scroom'] = Vector3.new(4.71413230896, 4.400146484375, 4.7931442260742),
						['Golem'] = Vector3.new(17.123439788818, 21.224365234375, 6.9429664611816),
					};
		
					for i, v in next, values do
						if((result - v).Magnitude < shorter) then
							found = i;
							shorter = (result - v).Magnitude;
						end;
					end;
		
					worldModel:Destroy();
					worldModel = nil;
		
					return found;
				end;
			end;
		
			do -- // Collector Auto Farm
				local collectorData;
		
				local function getCollectorDoors()
					local doors = {};
		
					for i, v in next, workspace:GetChildren() do
						if(v.Name == 'Part' and v:FindFirstChild('Exit')) then
							table.insert(doors, v);
						end;
					end;
		
					return doors;
				end;
		
				local function getCollectorDoor(collector)
					local lastDoor, lastDistance = nil, math.huge;
		
					for i, v in next, getCollectorDoors() do
						if((v.Position - collector.PrimaryPart.Position).Magnitude < lastDistance) then
							lastDistance = (v.Position - collector.PrimaryPart.Position).Magnitude;
							lastDoor = v;
						end;
					end;
		
					return lastDoor;
				end;
		
				local buttons = {};
		
				local dragging = false;
				local draggingBtn;
				local frame;
		
				local success, savedOrderData = pcall(readfile, 'Aztup Hub V3/RogueLineageCollectorBotList.json');
		
				if(success) then
					success, savedOrderData = pcall(function()
						return HttpService:JSONDecode(savedOrderData);
					end);
				end;
		
				artefactOrderList = success and savedOrderData or {
					'Azael Horn',
					'Staff of Pain',
					'Mask of Baima',
					'Phoenix Bloom',
					'Pocket Watch',
					'Heirloom',
					'Dienis Locket',
					'Unwavering Focus'
				};
		
				local function createComponent(c, p)
					local obj = Instance.new(c)
					obj.Name = tostring({}):gsub("table: ", ""):gsub("0x", "")
					for i, v in next, p do
						if i ~= "Parent" then
							if typeof(v) == "Instance" then
								v.Parent = obj
							else
								obj[i] = v
							end
						end
					end
					obj.Parent = p.Parent
					return obj
				end;
		
				do -- // render button
					collectorUI = createComponent('ScreenGui', {
						Parent = CoreGui,
						Enabled = false,
					});
		
					frame = createComponent('Frame', { -- // main frame
						Parent = collectorUI,
						AnchorPoint = Vector2.new(0.5, 0.5),
						Position = UDim2.new(0.9, 0, 0.5, 0),
						Size = UDim2.new(0, 300, 0, 350),
						BackgroundColor3 = Color3.fromRGB(42, 42, 42),
		
						createComponent('UICorner', {
							CornerRadius = UDim.new(0, 8)
						}),
		
						createComponent('Frame', { -- // border
							AnchorPoint = Vector2.new(0.5, 0.5),
							Position = UDim2.new(0.5, 0, 0.5, 0),
							Size = UDim2.new(1, 5, 1, 5),
							BackgroundColor3 = Color3.fromRGB(0, 0, 0),
							ZIndex = 0,
		
							createComponent('UICorner', {
								CornerRadius = UDim.new(0, 8)
							})
						}),
		
						createComponent('TextLabel', { -- // title
							Font = Enum.Font.Garamond,
							Text = 'Aztup Hub V3 Collector Auto Farm Order List',
							TextSize = 25,
							TextWrapped = true,
							BackgroundTransparency = 1,
							TextColor3 = Color3.fromRGB(255, 255, 255),
							TextStrokeTransparency = 0.85,
							Size = UDim2.new(1, 0, 0, 55),
							TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
		
							createComponent('Frame', {
								BackgroundColor3 = Color3.fromRGB(2, 255, 137),
								BorderSizePixel = 0,
								Size = UDim2.new(1, 0, 0, 2),
								Position = UDim2.new(0, 0, 1, 0)
							})
						})
					})
				end;
		
				local function positionButtons()
					for i,v in next, buttons do
						v.Size = UDim2.new(1, 0, 0, 25);
						v.LayoutOrder = i;
						v.Position = UDim2.new(0.5, 0, 0, 80 + (i - 1) * 25);
					end;
				end;
		
				local function dragger(container)
					local dragging;
					local dragInput;
					local dragStart;
					local startPos;
		
					local function update(input)
						local delta = input.Position - dragStart
						container.Position = UDim2.new(
							0.5,
							0,
							startPos.Y.Scale,
							math.clamp(startPos.Y.Offset + delta.Y, 80, frame.AbsoluteSize.Y - 20)
						);
					end
		
					container.InputBegan:Connect(function(input)
						if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
							dragging = true
							dragStart = input.Position
							startPos = container.Position
		
							input.Changed:Connect(function()
								if (input.UserInputState == Enum.UserInputState.End) then
									dragging = false
									positionButtons();
								end
							end)
						end
					end)
		
					container.InputChanged:Connect(function(input)
						if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
							dragInput = input
						end
					end)
		
					UserInputService.InputChanged:Connect(function(input)
						if input == dragInput and dragging then
							update(input)
						end
					end)
				end;
		
				local function update(btn)
					if(not dragging) then
						draggingBtn, dragging = btn, true;
						btn.ZIndex = 999;
		
						repeat
							task.wait();
						until not UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1);
		
						positionButtons();
						dragging, draggingBtn = false, nil;
						btn.ZIndex = 1;
					end;
				end;
		
				local function renderBtn()
					for i, v in next, artefactOrderList do
						local button = createComponent('TextButton', {
							Parent = frame,
							Active = true,
							Text = v,
							BackgroundTransparency = 1,
							TextColor3 = Color3.fromRGB(255, 255, 255),
							AnchorPoint = Vector2.new(0.5, 0.5),
							Font = Enum.Font.Garamond,
							AutoButtonColor = false,
							TextScaled = true
						});
		
						table.insert(buttons, button);
						dragger(button);
					end;
		
					positionButtons();
				end;
		
				renderBtn();
		
				local tweenInfo = TweenInfo.new(0.2);
		
				do -- // Buttons Render
					for i, v in next, buttons do
						local tweenIn = TweenService:Create(v, tweenInfo, {TextColor3 = Color3.fromRGB(176, 176, 176)});
						local tweenOut = TweenService:Create(v, tweenInfo, {TextColor3 = Color3.fromRGB(255, 255, 255)});
		
						v.MouseButton1Down:Connect(function()
							update(v);
						end);
		
						v.MouseEnter:Connect(function()
							tweenIn:Play();
							if(dragging and v ~= draggingBtn) then
								local oldLayout = v.LayoutOrder;
		
								v.LayoutOrder = draggingBtn.LayoutOrder;
								draggingBtn.LayoutOrder = oldLayout;
		
								table.sort(buttons, function(a, b)
									return a.LayoutOrder < b.LayoutOrder;
								end);
		
								positionButtons();
							end;
						end);
		
						v.MouseLeave:Connect(function()
							tweenOut:Play();
						end);
					end;
				end;
		
				task.spawn(function()
					while true do
						local newOrderList = {};
		
						for i, v in next, buttons do
							newOrderList[i] = v.Text;
						end;
		
						artefactOrderList = newOrderList;
		
						writefile('Aztup Hub V3/RogueLineageCollectorBotList.json', HttpService:JSONEncode(newOrderList));
						task.wait(1);
					end;
				end);
		
				local function getBestChoice(choices)
					local order = artefactOrderList;
					local foundChoice, foundChoicePosition = nil, 9999;
		
					for i, v in next, choices do
						for i2, v2 in next, order do
							if(v2 == v and i2 <= foundChoicePosition) then
								foundChoicePosition = i2;
								foundChoice = v2;
							end;
						end;
					end;
		
					return foundChoice;
				end;
		
				local function isDangerousPlayer(v)
					return v:FindFirstChild('Pebble') or v:FindFirstChild('Dagger Throw') or v:FindFirstChild('Autumn Rain') or v:FindFirstChild('Shadow Fan') or v:FindFirstChild('Triple Dagger Throw') or v:FindFirstChild('Justice Spears') or v:FindFirstChild('Augimas') or v:FindFirstChild('Perflora');
				end;
		
				function showCollectorPickupUI(toggle)
					collectorUI.Enabled = toggle;
				end;
		
				function collectorAutoFarm(toggle)
					if(not toggle or isPrivateServer or isGaia) then
						return;
					end;
		
					local function onConnectionLost()
						if (playerGotManualKick) then return end;
		
						while true do
							if (library.flags.automaticallyRejoin) then
								print('[Automatic Rejoin] Player got disconneted');
								findServer();
							end;
		
							task.wait(10);
						end;
					end;
		
					if (not NetworkClient:FindFirstChild('ClientReplicator')) then
						return onConnectionLost();
					else
						NetworkClient.ChildRemoved:Connect(onConnectionLost);
					end;
		
					task.wait(2.5);
		
					local live = workspace:WaitForChild('Live');
		
					local function runPanicCheck(playerPosition)
						local entities = live:GetChildren();
		
						for i, v in next, Players:GetPlayers() do
							local character = v.Character;
							if (character and not table.find(entities, character)) then
								table.insert(entities, character);
							end;
						end;
		
						for i, v in next, entities do
							local playerRootPart = v:FindFirstChild('HumanoidRootPart');
							if(not playerRootPart or v.Name == LocalPlayer.Name) then continue end;
		
							local dangerousPlayer = isDangerousPlayer(v);
							local playerDistance = (Utility:roundVector(playerRootPart.Position) - Utility:roundVector(playerPosition)).Magnitude;
							local maxPlayerDistance = dangerousPlayer and math.huge or 300;
		
							if(playerDistance <= maxPlayerDistance) then
								print('Entity too close panicking', (playerRootPart.Position - playerPosition).Magnitude, v.Name, dangerousPlayer);
								findServer();
								return task.wait(9e9);
							end;
						end;
					end;
		
					if(MemStorageService:HasItem('lastPlayerPosition')) then
						local playerPosition = Vector3.new(unpack(MemStorageService:GetItem('lastPlayerPosition'):split(',')));
						print('Last player position', playerPosition);
		
						runPanicCheck(playerPosition);
					else
						print('No last player position saving current one');
					end;
		
					local character = spawnLocalCharacter();
		
					LocalPlayer.CharacterAdded:Connect(function(newCharacter)
						kickPlayer('You were killed, please DM Aztup and sent him a clip if you have any, dont do that if you just pressed the menu button');
						task.wait(1);
		
						while true do end;
					end);
		
					local dangerConnection;
					dangerConnection = character.ChildAdded:Connect(function(obj)
						if (obj.Name == 'Danger') then
							if (library.base.Enabled) then
								library:Close();
							end;
		
							ToastNotif:DestroyAll();
							library.options.chatLogger:SetState(false);
						end;
					end);
		
					task.wait(0.1);
		
					if(not MemStorageService:HasItem('collectorLocationTP')) then
						MemStorageService:SetItem('collectorLocationTP', math.random(1, 2) == 1 and '20' or '-20');
					end;
		
					local rootPart = character and character:WaitForChild('HumanoidRootPart', 10);
					local humanoid = character and character:WaitForChild('Humanoid', 10);
		
					if (not rootPart or not humanoid) then
						findServer();
						return;
					end;
		
					local lastNotificationSentAt = 0;
		
					repeat
						--print('[Collector Auto Farm] Waiting for collector to be grabbed ...');
						local lastDistance = math.huge;
		
						for i, v in next, workspace.NPCs:GetChildren() do
							if(v.Name == 'Collector' and (v.PrimaryPart.Position - rootPart.Position).Magnitude <= 500) then
								lastDistance = (v.PrimaryPart.Position - rootPart.Position).Magnitude;
								collectorData = {door = getCollectorDoor(v), collector = v, distance = lastDistance};
								break;
							end;
						end;
		
						if(not collectorData and tick() - lastNotificationSentAt > 1) then
							lastNotificationSentAt = tick();
							ToastNotif.new({
								text = 'You must be at the collector',
								duration = 1
							});
						end;
		
						if(not library.flags.collectorAutoFarm) then return end;
						task.wait();
					until collectorData;
		
					local collectorRoot = collectorData.collector:WaitForChild('HumanoidRootPart', 10);
					if (not collectorRoot) then
						return findServer();
					end;
		
					local params = RaycastParams.new();
					params.FilterType = Enum.RaycastFilterType.Whitelist;
					params.FilterDescendantsInstances = getCollectorDoors();
		
					runPanicCheck(rootPart.Position);
					MemStorageService:SetItem('lastPlayerPosition', tostring(rootPart.Position));
		
					local ranSince = tick();
		
					local function isDoorHere()
						local rayResult = workspace:Raycast(collectorRoot.Position + Vector3.new(0, 5, 0), collectorRoot.CFrame.LookVector * 250, params);
						local instance = rayResult and rayResult.Instance;
		
						if (not instance) then
							return false;
						elseif(not instance.CanCollide) then
							return false;
						end;
		
						return true;
					end;
		
					if (library.flags.rollOutOfFf) then
						local lastCFrame = rootPart.CFrame;
						local lastPosition = lastCFrame.Position;
						local lastDodgeAt = tick();
		
						repeat
							if (tick() - lastDodgeAt > 1) then
								lastDodgeAt = tick();
								VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game);
							end;
							task.wait();
						until rootPart:FindFirstChild('DodgeVel');
		
						task.wait(0.2);
						repeat task.wait() until not rootPart:FindFirstChild('DodgeVel');
		
						warn('dash finished ?!');
						task.wait(0.2 + math.random() * 1);
		
						local moveToFinished = false;
		
						task.spawn(function()
							while (not moveToFinished) do
								humanoid:MoveTo(lastPosition);
								task.wait(1);
							end;
						end);
		
						humanoid.MoveToFinished:Wait();
						moveToFinished = true;
					end;
		
					repeat -- // Wait for collector door to show ?
						local inDanger = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Danger');
		
						if(not rootPart.Parent and not inDanger) then
							kickPlayer('You died, disconecting to prevent losing lives');
							return;
						end;
		
						runPanicCheck(rootPart.Position);
		
						if(LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('ForceField') and not library.flags.rollOutOfFf) then
							LocalPlayer.Character:FindFirstChildWhichIsA('ForceField'):Destroy();
						end;
		
						task.wait();
					until not isDoorHere() or tick() - ranSince >= library.flags.collectorBotWaitTime;
		
					if(isDoorHere()) then
						while true do
							if(LocalPlayer.Character and not LocalPlayer.Character:FindFirstChild('Danger')) then
								ReplicatedStorage.Requests.ReturnToMenu:InvokeServer();
								findServer();
		
								task.wait(5);
							end;
		
							task.wait();
						end;
					end;
		
					dangerConnection:Disconnect();
					dangerConnection = nil;
		
					local artifactPickedUp;
					local choices;
		
					local function handleDialog(data)
						task.wait(1);
		
						if(data.choices) then
							print('[Collector Auto Farm] Picking Up Artifact');
		
							local artefactChoice = getBestChoice(data.choices);
		
							artifactPickedUp = artefactChoice;
							choices = data.choices;
		
							dialog:FireServer({choice = artefactChoice});
						else
							print('[Collector Bot] Exited!');
							dialog:FireServer({exit = true});
							task.wait(2);
		
							repeat
								task.wait();
							until LocalPlayer.Character and not LocalPlayer.Character:FindFirstChild('Danger');
		
							if(artifactPickedUp) then
								kickPlayer('You got a ' .. artifactPickedUp);
		
								task.spawn(function()
									pcall(function()
										request({
											Url = '',
											Method = 'POST',
											Headers = {
												['Content-Type'] = 'application/json'
											},
		
											Body = HttpService:JSONEncode({
												content = 'Collector Bot',
												embeds = {{
													timestamp = DateTime.now():ToIsoDate(),
													title = 'Collector has been collected :tada:',
													color = 1345023,
													fields = {
														{
															name = 'Artifact Chosen',
															value = artifactPickedUp,
														},
														{
															name = 'Options',
															value = '['.. table.concat(choices or {'DM', 'Aztup'}, ', ') .. ']',
														},
													}
												}}
											})
										});
									end);
								end);
		
								task.spawn(function()
									request({
										Url = library.flags.webhookUrl,
										Method = 'POST',
										Headers = {
											['Content-Type'] = 'application/json'
										},
		
										Body = HttpService:JSONEncode({
											content = '@everyone',
											embeds = {{
												timestamp = DateTime.now():ToIsoDate(),
												title = 'Collector has been collected :tada:',
												color = 1345023,
												fields = {
													{
														name = 'Artifact Chosen',
														value = artifactPickedUp,
													},
													{
														name = 'Username',
														value = LocalPlayer.Name,
													},
													{
														name = 'Options',
														value = '['.. table.concat(choices or {'DM', 'Aztup'}, ', ') .. ']',
													}
												}
											}}
										})
									});
								end);
		
								artifactPickedUp = nil;
							else
								ReplicatedStorage.Requests.ReturnToMenu:InvokeServer();
								task.wait(2);
								return findServer();
							end;
						end;
					end;
		
					dialog.OnClientEvent:Connect(handleDialog);
					task.wait(2.5);
		
					rootPart.CFrame = collectorRoot.CFrame:ToWorldSpace(CFrame.new(0, 0, -5));
					workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, workspace.CurrentCamera.CFrame.Position + collectorRoot.Position);
		
					print('[Collector Auto Farm] Collector is ready!');
		
					if(LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Immortal')) then
						LocalPlayer.Character.Immortal:Destroy();
					end;
		
					local function toggleGUI(state)
						local playerGui = LocalPlayer and LocalPlayer:FindFirstChild('PlayerGui');
						if(playerGui) then
							for i, v in next, playerGui:GetChildren() do
								if(v:IsA('ScreenGui') and v.Name ~= 'DialogueGui' and v.Name ~= 'Captcha' and v.Name ~= 'CaptchaLoading') then
									v.Enabled = false;
								end;
							end;
						end;
		
						for i, v in next, game:GetService('CoreGui'):GetChildren() do
							if(v:IsA('ScreenGui')) then
								v.Enabled = state;
							end;
						end;
		
						library.base.Enabled = state;
					end;
		
					toggleGUI(false);
		
					local elapsedTime = tick();
		
					repeat
						print('Clicking Click Detector Distance', (rootPart.Position - collectorRoot.Position).Magnitude);
		
						workspace.CurrentCamera.CameraSubject = collectorRoot;
		
						local pos = workspace.CurrentCamera:WorldToViewportPoint(collectorRoot.Position);
		
						VirtualInputManager:SendMouseButtonEvent(pos.X, pos.Y, 0, false, game, 1)
						task.wait();
						VirtualInputManager:SendMouseButtonEvent(pos.X, pos.Y, 0, true, game, 1)
		
						task.wait(0.25);
					until LocalPlayer.PlayerGui:FindFirstChild('CaptchaLoad') or tick() - elapsedTime >= 8;
					-- // No need to add anything else since the auto dialog will serverhop as soon as collector gives exit
		
					if (tick() - elapsedTime >= 5) then
						ReplicatedStorage.Requests.ReturnToMenu:InvokeServer();
						task.wait(2);
						return findServer();
					end;
		
					repeat
						task.wait();
					until LocalPlayer.PlayerGui:FindFirstChild('Captcha');
		
					local lastWebhookSentAt = 0;
					local lastWebhookSentAt2 = 0;
					local lastWebhookSentAt3 = 0;
		
					repeat
						local captchaGUI = LocalPlayer.PlayerGui:FindFirstChild('Captcha');
						local choices = captchaGUI and captchaGUI:FindFirstChild('MainFrame') and captchaGUI.MainFrame:FindFirstChild('Options');
						choices = choices and choices:GetChildren();
						local union = captchaGUI and captchaGUI:FindFirstChild('MainFrame') and captchaGUI.MainFrame:FindFirstChild('Viewport') and captchaGUI.MainFrame.Viewport:FindFirstChild('Union');
		
						if(choices and union) then
							local captchaAnswer = solveCaptcha(union);
							if(tick() - lastWebhookSentAt > 0.1) then
								lastWebhookSentAt = tick();
							end;
		
							for i, v in next, choices do
								if(v.Name == captchaAnswer) then
									if(tick() - lastWebhookSentAt2 > 0.1) then
										lastWebhookSentAt2 = tick();
									end;
		
									local position = v.AbsolutePosition + Vector2.new(40, 40);
									VirtualInputManager:SendMouseButtonEvent(position.X, position.Y, 0, true, game, 1);
									task.wait();
									VirtualInputManager:SendMouseButtonEvent(position.X, position.Y, 0, false, game, 1);
		
									break;
								end;
							end;
						else
							if(tick() - lastWebhookSentAt3 > 0.1) then
								lastWebhookSentAt3 = tick();
							end;
						end;
		
						task.wait();
					until not LocalPlayer.PlayerGui:FindFirstChild('Captcha');
		
					if(LocalPlayer.PlayerGui:FindFirstChild('CaptchaDisclaimer')) then
						task.wait(5);
					end;
				end;
			end;
		
			do -- // Set Trinkets
				Trinkets = {
					{
						["MeshId"] = "5204003946";
						["Name"] = "Goblet";
					};
					{
						["MeshId"] = "5196776695";
						["Name"] = "Ring";
					};
					{
						["MeshId"] = "5196782997";
						["Name"] = "Old Ring";
					};
					{
						["Name"] = "Emerald";
					};
					{
						["Name"] = "Ruby";
					};
					{
						["Name"] = "Sapphire";
					};
					{
						["Name"] = "Diamond";
					};
					{
						["Name"] = "Rift Gem";
						["Rare"] = true;
					};
					{
						["Name"] = "Fairfrozen";
						["Rare"] = true;
					};
					{
						["MeshId"] = "5204453430";
						["Name"] = "Ninja Scroll";
					};
					{
						["Name"] = "Old Amulet";
						["MeshId"] = "5196577540";
					};
					{
						["Name"] = "Amulet";
						["MeshId"] = "5196551436";
					};
					{
						["Name"] = "Idol Of The Forgotten";
						["ParticleEmitter"] = true;
					};
					{
						["Name"] = "Opal";
						["VertexColor"] = Vector3.new(1, 1, 1);
						["MeshType"] = "Sphere";
					},
					{
						Name = "Candy";
						MeshId = '4103271893'
					},
					{
						["Texture"] = "20443483";
						["Name"] = "Ya'alda";
						["Rare"] = true;
					};
					{
						["Texture"] = "1536547385";
						["Name"] = "Pheonix Down";
						["Rare"] = true;
					};
					{
						["Texture"] = "20443483";
						["ParticleEmitter"] = true;
						["PointLight"] = true;
						["Name"] = "Ice Essence";
						["Rare"] = true;
					};
					{
						["Name"] = "White King's Amulet";
						["Rare"] = true;
					};
					{
						["Name"] = "Lannis Amulet";
						["Rare"] = true;
					};
					{
						["Name"] = "Night Stone";
						["Rare"] = true;
					};
					{
						["Name"] = "Philosopher's Stone";
						["Rare"] = true;
					};
					{
						["Name"] = "Spider Cloak";
						["Rare"] = true;
					};
					{
						["Name"] = "Howler Friend";
						["Rare"] = true;
						["MeshId"] = "2520762076";
					};
					{
						["Name"] = "Scroom Key";
						["Rare"] = true;
					},
					{
						Name = 'Mysterious Artifact',
						Rare = true
					}
				};
		
				for i, v in next, Trinkets do
					trinketsData[v.Name] = v;
				end;
			end;
		
			do -- // Player Classes
				playerClassesList = {
					["Warrior"] = {
						["Active"] = {"Pommel Strike", "Action Surge"};
						["Classes"] = {
							["Sigil Knight"] = {"Thunder Charge", Level = 1};
							["Blacksmith"] = {"Remote Smithing", "Grindstone", "Shockwave", Level = 1};
							["Greatsword"] = {"Greatsword Training", "Stun Resistance", Level = 1};
							["Sigil Knight Commander"] = {"Charged Blow", "White Flame Charge", "Hyper Body", Level = 2};
							["Lapidarist"] = {"Hammer Training", "Improved Grindstone", "Gem Mastery", "Gem Abilities", Level = 2},
							["AbyssWalker"] = {"Wrathful Leap", "Abyssal Scream", Level = 2};
							["Wraith Knight"] = {"Wraith Training", Level = 2};
							["Pilgrim Knight"] = {"Chain of Fate", "Rod of Narsa", "Pasmarkinti", Level = 3};
							["Abyss Dancer"] = {"Great Cyclone", "Spinning Soul", "Void Slicer", "Deflecting Spin", Level = 3};
							["Reaper"] = {"Mirror", "Chase", "Hunt", "Soul Burst", Level = 3};
						}
					};
					["Pit Fighter"] = {
						["Active"] = {"Serpent Strike", "Triple Strike"};
						["Classes"] = {
							["Dragon Knight"] = {"Spear Crusher", "Dragon Roar", "Dragon Blood", Level = 1};
							["Church Knight"] = {"Church Knight Helmet", "Impale", "Light Piercer", Level = 1};
							["Dragon Slayer"] = {"Wing Soar", "Thunder Spear Crash", "Dragon Awakening", Level = 2};
							["Deep Knight"] = {"Deep Sacrifice", "Leviathan Plunge", "Chain Pull", Level = 2};
							["Dragon Rider"] = {"Heroic Volley", "Call Drake", "Ensnaring Strike", "Justice Spears", Level = 3};
							["Abomination"] = {"Tethering Lance", "Void Spear", "Aura of Despair", "Soul Siphon", Level = 3};
						}
					};
					["Scholar"] = {
						["Active"] = {"FastSigns", "CurseBlock", "WiseCasting"};
						["Classes"] = {
							["Illusionist"] = {"Custos", "Claritum", "Observe", Level = 1};
							["Botanist"] = {"Fons Vitae", "Verdien", "Life Sense", Level = 1};
							["Necromancer"] = {"Inferi", "Reditus", "Ligans", Level = 1};
							["Master Illusionist"] = {"Globus", "Intermissium", "Dominus", Level = 2};
							["Druid"] = {"Snap Verdien", "Snap Fons Vitae", "Perflora", "Snap Perflora", "Floresco", "Snap Floresco", Level = 2};
							["Master Necromancer"] = {"Secare", "Furantur", "Command Monsters", "Howler Summoning", Level = 2};
							["Uber Illusionist"] = {"Doube", "Compress", "Terra Rebus", Level = 3};
							["Monster Hunter"] = {"Coercere", "Liber", "Scribo", Level = 3};
							["Crystal Cage"] = {"Mirgeti", "Krusa", "Spindulys", Level = 3};
							["Worm Prophet"] = {"Worm Bombs", "Worm Blast", "Call of the Dead", Level = 3};
						}
					};
					["Thief"] = {
						["Active"] = {"Dagger Throw", "Pickpocket", "Trinket Steal", "Lock Manipulation"};
						["Classes"] = {
							["Spy"] = {"Interrogation", Level = 1};
							["Assassin"] = {"Lethality", "Bane", "Triple Dagger Throw", Level = 1};
							["Whisperer"] = {"Elegant Slash", "The Shadow", "Needle's Eye", "The Wraith", "The Soul", Level = 2};
							["Cadence"] = {"Music Meter", "Faster Meter Charge", "Feel Invincible", Level = 2};
							["Faceless"] = {"Shadow Step", "Chain Lethality", "Improved Bane", "Faceless", Level = 2};
							["Shinobi"] = {"Resurrection", Level = 2};
							["Duelist"] = {"Mana Grenade", "Auto Reload", "Duelist Dash", "Bomb Jump", "Bullseye", Level = 3};
							["Uber Bard"] = {"Inferno March", "Galecaller's Melody", "Bad Time Symphony", "Theme of Reversal", Level = 3};
							["Friendless One"] = {"Shadow Buddy", "Falling Darkness", "Flash of Darkness", Level = 3};
							["Shura"] = {"Rising Cloud", "Autumn Rain", "Cruel Wind", Level = 3};
						};
					};
					["Monk"] = {
						Level = 1,
						["Active"] = {"Monastic Stance"};
						["Classes"] = {
							["Dragon Sage"] = {"Lightning Drop", "Lightning Elbow", "Lightning Dash", "Dragon Static", Level = 2};
							["Vhiunese Monk"] = {"Thundering Leap", "Seismic Toss", "Electric Smite", Level = 3};
						};
					};
					["Akuma"] = {
						["Active"] = {"Leg Breaker", "Spin Kick", "Rising Dragon", Level = 1};
						["Classes"] = {
							["Oni"] = {"Demon Flip", "Axe Kick", "Demon Step", Level = 2};
							["Uber Oni"] = {"Consuming Flames", "Rampage", "Augimas M1 & M2", "Axe Kick M2", Level = 3}
						};
					};
				};
			end;
		
			do -- // Server Hop
				local serverInfo = not isGaia and ReplicatedStorage:WaitForChild('ServerInfo'):GetChildren() or {};
		
				do -- // Server Hop Khei
					if(not isGaia and not isPrivateServer) then
						repeat
							serverInfo = ReplicatedStorage:WaitForChild('ServerInfo'):GetChildren();
							task.wait();
						until #serverInfo >= 2;
					end;
				end;
		
				function findServer(bypassKhei)
					if(LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Danger')) then
						repeat
							task.wait();
						until not LocalPlayer.Character:FindFirstChild('Danger');
					end;
		
					task.delay(5, function()
						if (not NetworkClient:FindFirstChild('ClientReplicator') and library.flags.automaticallyRejoin) then
							TeleportService:Teleport(3016661674);
						else
							findServer(bypassKhei);
						end;
					end);
		
					if(not isGaia and not bypassKhei) then
						print('[Server Hop] Finding server ...');
		
						if(LocalPlayer.Character) then
							ReplicatedStorage.Requests.ReturnToMenu:InvokeServer();
							task.wait(2);
						end;
		
						local chosenServer = serverInfo[Random.new():NextInteger(1, #serverInfo)];
						local teleportHandler;
		
						teleportHandler = LocalPlayer.OnTeleport:Connect(function(state)
							if(state == Enum.TeleportState.Failed) then
								print('[Server Hop] Teleport failed');
		
								teleportHandler:Disconnect();
								teleportHandler = nil;
		
								findServer();
							end;
						end);
		
						print('Going to', chosenServer.Name);
						ReplicatedStorage.Requests.JoinPublicServer:FireServer(chosenServer.Name);
					else
						BlockUtils:BlockRandomUser();
						TeleportService:Teleport(3016661674);
					end;
				end;
			end;
		
			do -- // Set Spells Values
				spellValues = {
					["Secare"] = {
						[1] = {
						["max"] = 95,
						["min"] = 90
						}
					},
					["Maledicta Terra"] = {
						[1] = {
						["max"] = 100,
						["min"] = 20
						}
					},
					["Better Mori"] = {
						[1] = {
						["max"] = 100,
						["min"] = 0
						},
						[2] = {
						["max"] = 100,
						["min"] = 0
						}
					},
					["Contrarium"] = {
						[1] = {
						["max"] = 95,
						["min"] = 80
						},
						[2] = {
						["max"] = 90,
						["min"] = 70
						}
					},
					["Mederi"] = {
						[1] = {
						["max"] = 100,
						["min"] = 0
						}
					},
					["Scrupus"] = {
						[1] = {
						["max"] = 100,
						["min"] = 30
						}
					},
					["Intermissum"] = {
						[1] = {
						["max"] = 100,
						["min"] = 70
						}
					},
					["Gourdus"] = {
						[1] = {
						["max"] = 100,
						["min"] = 75
						}
					},
					["Inferi"] = {
						[1] = {
						["max"] = 30,
						["min"] = 10
						}
					},
					["Custos"] = {
						[1] = {
						["max"] = 65,
						["min"] = 45
						}
					},
					["Gelidus"] = {
						[1] = {
						["max"] = 95,
						["min"] = 80
						},
						[2] = {
						["max"] = 100,
						["min"] = 80
						}
					},
					["Telorum"] = {
						[1] = {
						["max"] = 90,
						["min"] = 80
						},
						[2] = {
						["max"] = 80,
						["min"] = 70
						}
					},
					["Viribus"] = {
						[1] = {
						["max"] = 35,
						["min"] = 25
						},
						[2] = {
						["max"] = 70,
						["min"] = 60
						}
					},
					["Hoppa"] = {
						[1] = {
						["max"] = 60,
						["min"] = 40
						},
						[2] = {
						["max"] = 60,
						["min"] = 50
						}
					},
					["Velo"] = {
						[1] = {
						["max"] = 100,
						["min"] = 70
						},
						[2] = {
						["max"] = 60,
						["min"] = 40
						}
					},
					["Pondus"] = {
						[1] = {
						["max"] = 90,
						["min"] = 70
						},
						[2] = {
						["max"] = 30,
						["min"] = 20
						}
					},
					["Verdien"] = {
						[1] = {
						["max"] = 100,
						["min"] = 75
						},
						[2] = {
						["max"] = 85,
						["min"] = 75
						}
					},
					["Trahere"] = {
						[1] = {
						["max"] = 85,
						["min"] = 75
						}
					},
					["Dominus"] = {
						[1] = {
						["max"] = 100,
						["min"] = 50
						}
					},
					["Armis"] = {
						[1] = {
						["max"] = 60,
						["min"] = 40
						},
						[2] = {
						["max"] = 80,
						["min"] = 70
						}
					},
					["Ligans"] = {
						[1] = {
						["max"] = 80,
						["min"] = 63
						}
					},
					["Shrieker"] = {
						[1] = {
						["max"] = 50,
						["min"] = 30
						}
					},
					["Celeritas"] = {
						[1] = {
						["max"] = 90,
						["min"] = 70
						},
						[2] = {
						["max"] = 80,
						["min"] = 70
						}
					},
					["Hystericus"] = {
						[1] = {
						["max"] = 90,
						["min"] = 75
						},
						[2] = {
						["max"] = 35,
						["min"] = 15
						}
					},
					["Snarvindur"] = {
						[1] = {
						["max"] = 75,
						["min"] = 60
						},
						[2] = {
						["max"] = 30,
						["min"] = 20
						}
					},
					["Percutiens"] = {
						[1] = {
						["max"] = 70,
						["min"] = 60
						},
						[2] = {
						["max"] = 80,
						["min"] = 70
						}
					},
					["Furantur"] = {
						[1] = {
						["max"] = 80,
						["min"] = 60
						}
					},
					["Nosferatus"] = {
						[1] = {
						["max"] = 100,
						["min"] = 90
						}
					},
					["Reditus"] = {
						[1] = {
						["max"] = 100,
						["min"] = 50
						}
					},
					["Floresco"] = {
						[1] = {
						["max"] = 100,
						["min"] = 90
						},
						[2] = {
						["max"] = 95,
						["min"] = 80
						}
					},
					["Howler"] = {
						[1] = {
						["max"] = 80,
						["min"] = 60
						}
					},
					["Manus Dei"] = {
						[1] = {
						["max"] = 95,
						["min"] = 90
						},
						[2] = {
						["max"] = 60,
						["min"] = 50
						}
					},
					["Fons Vitae"] = {
						[1] = {
						["max"] = 100,
						["min"] = 75
						},
						[2] = {
						["max"] = 100,
						["min"] = 75
						}
					},
					["Ignis"] = {
						[1] = {
						["max"] = 95,
						["min"] = 80
						},
						[2] = {
						["max"] = 60,
						["min"] = 50
						}
					},
					["Globus"] = {
						[1] = {
						["max"] = 100,
						["min"] = 70
						}
					},
					["Fimbulvetr"] = {
						[1] = {
						["max"] = 92,
						["min"] = 84
						},
						[2] = {
						["max"] = 80,
						["min"] = 70
						}
					},
					["Perflora"] = {
						[1] = {
						["max"] = 90,
						["min"] = 70
						},
						[2] = {
						["max"] = 50,
						["min"] = 30
						}
					},
					["Gate"] = {
						[1] = {
						["max"] = 83,
						["min"] = 75
						},
						[2] = {
						["max"] = 83,
						["min"] = 75
						}
					},
					["Nocere"] = {
						[1] = {
						["max"] = 85,
						["min"] = 70
						},
						[2] = {
						["max"] = 85,
						["min"] = 70
						}
					},
					["Sagitta Sol"] = {
						[1] = {
						["max"] = 65,
						["min"] = 50
						},
						[2] = {
						["max"] = 60,
						["min"] = 40
						}
					},
					["Claritum"] = {
						[1] = {
						["max"] = 100,
						["min"] = 90
						}
					},
					["Trickstus"] = {
						[1] = {
						["max"] = 70,
						["min"] = 30
						},
						[2] = {
						["max"] = 50,
						["min"] = 30
						}
					}
				}
			end;
		
			do -- // Mana Helper
				local manaHelperRows = {};
		
				local manaTextGui = library:Create('ScreenGui', {
					Enabled = true,
				});
		
				local manaText = library:Create('TextLabel', {
					Parent = manaTextGui,
					BackgroundTransparency = 1,
					Text = '0 %',
					Visible = false,
					TextColor3 = Color3.fromRGB(255, 255, 255),
					Size = UDim2.new(0, 1, 0, 1),
				});
		
				local manaHelperGUI = library:Create('ScreenGui', {
					Enabled = false,
				});
		
				local castZoneGui = library:Create('ScreenGui', {
					Enabled = false
				});
		
				local snapCastValue = library:Create('Frame', {
					Parent = castZoneGui,
					BackgroundTransparency = 0.5,
					BorderSizePixel = 0,
					BackgroundColor3 = Color3.fromRGB(52, 152, 219),
				});
		
				local normalCastValue = library:Create('Frame', {
					Parent = castZoneGui,
					BackgroundTransparency = 0.5,
					BorderSizePixel = 0,
					BackgroundColor3 = Color3.fromRGB(231, 76, 60),
				});
		
				for i = 0, 10 do
					local container = Instance.new('Frame');
					container.Parent = manaHelperGUI;
					container.BorderSizePixel = 0;
					container.Size = UDim2.new(0, 28, 0, 2);
					container.BackgroundColor3 = Color3.fromRGB(255, 0, 4);
		
					local text = Instance.new('TextLabel');
					text.Size = UDim2.new(1, 0, 1, 0);
					text.TextColor3 = Color3.fromRGB(255, 255, 255);
					text.Parent = container;
					text.Position = UDim2.new(0, 50, 0, 0);
					text.BackgroundTransparency = 1;
					text.TextStrokeTransparency = 0;
					text.Text = string.format('%d %%', i * 10)
		
					if(i == 0 or i == 10) then
						container.Parent = nil
					end;
		
					table.insert(manaHelperRows, container);
				end;
		
				if(gethui) then
					manaTextGui.Parent = gethui();
					manaHelperGUI.Parent = gethui();
					castZoneGui.Parent = gethui();
				else
					manaTextGui.Parent = CoreGui;
		
					manaHelperGUI.Parent = CoreGui;
		
					castZoneGui.Parent = CoreGui;
				end;
		
				local manaOverlay = Drawing.new('Image');
				manaOverlay.Visible = false;
		
				function showCastZone(toggle)
					castZoneGui.Enabled = toggle;
					if(not toggle) then
						maid.showCastZone = nil;
						return;
					end;
		
					local function hideCastZones()
						normalCastValue.Visible = false;
						snapCastValue.Visible = false;
					end
		
					maid.showCastZone = RunService.RenderStepped:Connect(function()
						local playerGui = LocalPlayer:FindFirstChild('PlayerGui');
						if(not playerGui or not playerGui:FindFirstChild('StatGui')) then return hideCastZones() end;
		
						local manaGui = playerGui.StatGui.LeftContainer.Mana;
		
						local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
						if(not tool) then return hideCastZones() end;
		
						local values = spellValues[tool.Name];
						if(not values) then return hideCastZones() end;
		
						local hasSnap = values[2];
		
						if(hasSnap) then
							local min, max = values[2].min, values[2].max;
		
							snapCastValue.Visible = true;
							snapCastValue.Size = UDim2.new(0, manaGui.AbsoluteSize.X, 0, manaGui.AbsoluteSize.Y * (max - min) / 100);
							snapCastValue.Position = UDim2.new(0, manaGui.AbsolutePosition.X, 0, manaGui.AbsolutePosition.Y) + UDim2.new(0, 0, 0, manaGui.AbsoluteSize.Y - manaGui.AbsoluteSize.Y * max  / 100);
						else
							snapCastValue.Visible = false;
						end;
		
						local min, max = values[1].min, values[1].max;
		
						normalCastValue.Visible = true;
						normalCastValue.Size = UDim2.new(0, manaGui.AbsoluteSize.X, 0, manaGui.AbsoluteSize.Y * (max - min) / 100);
						normalCastValue.Position = UDim2.new(0, manaGui.AbsolutePosition.X, 0, manaGui.AbsolutePosition.Y) + UDim2.new(0, 0, 0, manaGui.AbsoluteSize.Y - manaGui.AbsoluteSize.Y * max  / 100);
					end);
		
				end;
		
				function manaViewer(toggle)
					manaText.Visible = toggle;
					if(not toggle) then
						maid.manaViewer = nil;
						return;
					end;
		
					maid.manaViewer = RunService.RenderStepped:Connect(function()
						local playerGui = LocalPlayer:FindFirstChild('PlayerGui');
						if(not playerGui or not playerGui:FindFirstChild('StatGui')) then return end;
		
						local manaGui = playerGui.StatGui.LeftContainer.Mana;
		
						local mana = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Mana');
						if(not mana) then return end;
		
						manaText.Position = UDim2.new(0, manaGui.AbsolutePosition.X + 14, -0.020, manaGui.AbsolutePosition.Y);
						manaText.Text = string.format('%d %%', mana.Value)
					end);
				end;
		
				function manaHelper(toggle)
					manaHelperGUI.Enabled = toggle;
					if(not toggle) then
						maid.manaHelper = nil;
					end;
		
					maid.manaHelper = RunService.RenderStepped:Connect(function()
						local playerGui = LocalPlayer:FindFirstChild('PlayerGui');
						if(not playerGui or not playerGui:FindFirstChild('StatGui') or not playerGui.StatGui:FindFirstChild('LeftContainer')) then return end;
		
		
						local mana = playerGui.StatGui.LeftContainer.Mana;
						local size = (mana.AbsoluteSize.Y);
						local position = (mana.AbsolutePosition).Y;
						local rowSize = size / 10;
		
						for i, v in next, manaHelperRows do
							v.Position = UDim2.new(0, mana.AbsolutePosition.X, 0, position + size - rowSize * (i - 1));
						end;
					end);
				end;
		
				function showManaOverlay(toggle)
					manaOverlay.Visible = toggle;
		
					if(not toggle) then
						maid.manaOverlay = nil;
						return;
					end;
		
					maid.manaOverlay = RunService.RenderStepped:Connect(function()
						local playerGui = LocalPlayer:FindFirstChild('PlayerGui');
						if(not playerGui or not playerGui:FindFirstChild('StatGui')) then return end;
		
						local mana = playerGui.StatGui.LeftContainer.Mana;
		
						manaOverlay.Size = Vector2.new(library.flags.overlayScaleX, library.flags.overlayScaleY)
						manaOverlay.Position = mana.AbsolutePosition - Vector2.new(library.flags.overlayOffsetX, library.flags.overlayOffsetY);
					end);
				end;
		
				function spellStack(t)
					if not t then maid.spellStack = nil; table.clear(queue); return; end
					
					maid.spellStack = UserInputService.InputBegan:Connect(function(input,gameProcessed)
						if (input.KeyCode ~= Enum.KeyCode[library.options.spellStackKeybind.key] or gameProcessed) then return end;
				
						local youngest = tick();
						local found;
						for i,v in next, queue do 
							if v.currentTime > youngest or v.fired then continue; end
							
							found = i;
							youngest = v.currentTime;
						end
		
						queue[found].fired = true;
					end)
				end
		
				function setOverlayUrl(url, enter)
					local suc, requestData = pcall(request, {Url = url})
					local imgData = suc and requestData.Body;
					if (not suc) then return end;
		
					local imgSize = getImageSize(imgData);
		
					manaOverlay.Data = imgData;
		
					if (enter) then
						manaOverlay.Size = imgSize;
						library.options.overlayScaleX:SetValue(imgSize.X);
						library.options.overlayScaleY:SetValue(imgSize.Y);
					end;
				end;
			end;
		
			do -- // AA Gun Counter
				local aaGunCounterGUI = library:Create('ScreenGui', {
					Enabled = false;
				});
		
				if(gethui) then
					aaGunCounterGUI.Parent = gethui();
				else
					syn.protect_gui(aaGunCounterGUI);
					aaGunCounterGUI.Parent = CoreGui;
				end;
		
				local aaGunCounterText = library:Create('TextLabel', {
					Parent = aaGunCounterGUI,
					RichText = true,
					TextSize = 25,
					Text = '',
					BackgroundTransparency = 1,
					Position = UDim2.new(0.5, 0, 0, 50),
					AnchorPoint = Vector2.new(0.5, 0.5),
					Size = UDim2.new(0, 200, 0, 50),
					Font = Enum.Font.SourceSansSemibold,
					TextColor3 = Color3.fromRGB(255, 255, 255)
				});
		
				local params = RaycastParams.new();
				params.FilterType = Enum.RaycastFilterType.Blacklist;
				params.FilterDescendantsInstances = {workspace.Live, workspace:FindFirstChild('NPCs') or Instance.new('Folder'), workspace:FindFirstChild('AreaMarkers') or Instance.new('Folder')};
		
				local flying        = false;
				local lastFly       = tick();
				local onGroundAt    = tick();
				local flyStartedAt  = lastFly;
		
				function aaGunCounter(toggle)
					aaGunCounterGUI.Enabled = toggle;
		
					if(not toggle) then
						maid.aaGunCounter = nil;
						return;
					end;
		
					maid.aaGunCounter = RunService.RenderStepped:Connect(function()
						local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
						if(not rootPart) then return end;
		
						local isOnGround = workspace:Raycast(rootPart.Position, Vector3.new(0, -10, 0), params)
						if(not isOnGround) then
							if(not flying) then
								flyStartedAt = tick();
							end;
							flying = true;
							lastFly = tick();
						else
							if(flying) then
								onGroundAt = tick();
							end;
							flying = false;
						end;
		
						local timeSinceLastFly = tick() - flyStartedAt;
						local timeOnGround = tick() - onGroundAt;
						local shouldFly = (timeOnGround >= 6 and (flying and timeSinceLastFly < 5 or not flying and true));
		
						local red, green = 'rgb(255, 0, 0)', 'rgb(0, 255, 0)'
						local onGroundText = string.format('<font color="%s"> %s </font>', isOnGround and green or red, isOnGround and 'Yes' or 'No')
						local timeOnGroundText = string.format('<font color="%s"> %.01f </font>', flying and red or green, flying and -timeSinceLastFly or timeOnGround);
						local canFlyText = string.format('<font color="%s"> %s </font>', shouldFly and green or red, shouldFly and 'Yes' or 'No');
		
						aaGunCounterText.Text = string.format('On Ground: %s\nTime on ground: %s\nCan Fly (Recommended): %s', onGroundText, timeOnGroundText, canFlyText);
					end);
				end;
			end;
		
			do -- // Auto Potions + Auto Smithing
				local potions = {
					['Health Potion'] = {
						['Lava Flower'] = 1;
						['Scroom'] = 2;
					},
		
					['Bone Growth Potion'] = {
						['Trote'] = 1,
						['Strange Tentacle'] = 1,
						['Uncanny Tentacle'] = 1
					},
		
					['Switch Witch'] = {
						['Dire Flower'] = 1,
						['Glow Shroom'] = 2
					},
		
					['Silver Sun'] = {
						['Desert Mist'] = 1,
						['Free Leaf'] = 1,
						['Polar Plant'] = 1
					},
		
					['Lordsbane'] = {
						['Crown Flower'] = 3
					},
		
					['Liquid Wisdom'] = {
						['Desert Mist'] = 1,
						['Periashroom'] = 1,
						['Crown Flower'] = 1,
						['Freeleaf'] = 1
					},
		
					['Ice Protection'] = {
						['Snow Scroom'] = 2,
						['Trote'] = 1,
					},
		
					['Kingsbane'] = {
						['Crown Flower'] = 1,
						['Vile Seed'] = 2,
					},
		
					['Feather Feet'] = {
						['Creely'] = 1,
						['Dire Flower'] = 1,
						['Polar Plant'] = 1
					},
		
					['Fire Protection Potion'] = {
						['Trote'] = 1,
						['Scroom'] = 2
					},
		
					['Tespian Elixir'] = {
						['Lava Flower'] = 1,
						['Scroom'] = 1,
						['Moss Plant'] = 2
					},
		
					['Slateskin'] = {
						['Petrii Flower'] = 1,
						['Stone Scroom'] = 1,
						['Coconut'] = 1
					},
		
					['Mind Mend'] = {
						['Grass Stem'] = 1,
						['Crystal Lotus'] = 1,
						['Winter Blossom'] = 1
					},
		
					['Clot Control'] = {
						['Coconut'] = 1,
						['Grass Stem'] = 1,
						['Petri Flower'] = 1
					},
		
					['Maidensbane'] = {
						['Stone Scroom'] = 1,
						['Fen Bloom'] = 1,
						['Foul Root'] = 1,
					},
		
					['Sooth Sight'] = {
						['Grass Stem'] = 2,
						['Crystal Lotus'] = 1
					},
		
					['Crystal Extract'] = {
						['Crystal Root'] = 1,
						['Crystal Lotus'] = 1,
						['Winter Blossom'] = 1
					},
		
					['Soothing Frost'] = {
						['Winter Blossom'] = 1,
						['Snowshroom'] = 2
					},
				};
		
				local swords = {
					['Bronze Sword'] = {
						['Copper Bar'] = 1,
						['Tin Bar'] = 2
					},
		
					['Bronze Dagger'] = {
						['Copper Bar'] = 1,
						['Tin Bar'] = 1
					},
		
					['Bronze Spear'] = {
						['Tin Bar'] = 1,
						['Copper Bar'] = 2
					},
		
					['Steel Sword'] = {
						['Iron Bar'] = 2,
						['Copper Bar'] = 1
					},
		
					['Steel Dagger'] = {
						['Iron Bar'] = 1,
						['Copper Bar'] = 1
					},
		
					['Steel Spear'] = {
						['Iron Bar'] = 1,
						['Copper Bar'] = 2
					},
		
					['Mythril Sword'] = {
						['Copper Bar'] = 1,
						['Iron Bar'] = 2,
						['Mythril Bar'] = 1
					},
		
					['Mythril Dagger'] = {
						['Copper Bar'] = 1,
						['Iron Bar'] = 1,
						['Mythril Bar'] = 1
					},
		
					['Mythril Spear'] = {
						['Copper Bar'] = 2,
						['Iron Bar'] = 1,
						['Mythril Bar'] = 1
					}
				}
		
				local stations = workspace:FindFirstChild("Stations");
		
				local function GrabStation(type)
					if typeof(type) ~= "string" then
						return error(string.format("Expected type string got <%s>",typeof(type)))
					elseif(not stations) then
						return warn('[Auto Potion] No Stations');
					end
		
					for i,v in next, stations:GetChildren() do
						if (v.Timer.Position-LocalPlayer.Character.HumanoidRootPart.Position).Magnitude <= 15 and string.find(v.Name, type) then
							return v;
						end;
					end;
				end
		
				local function hasMaterials(items, item)
					local recipe = items[item];
					local count = setmetatable({}, {__index = function() return 0 end});
		
					assert(recipe);
		
					for i, v in next, LocalPlayer.Backpack:GetChildren() do
						if(recipe[v.Name]) then
							local quantity = v:FindFirstChild('Quantity');
							quantity = quantity and quantity.Value or 1;
		
							count[v.Name] = count[v.Name] + quantity;
						end;
					end;
		
					for i, v in next, recipe do
						if(count[i] < v) then
							return false;
						end;
					end;
		
					return recipe;
				end;
		
				autoCraftUtils.hasMaterials = function(craftType, item)
					return hasMaterials(craftType == 'Alchemy' and potions or swords, item);
				end;
		
				local function addItemsToStation(items, station, part, partToClick, partToClean)
					if(station.Contents.Value ~= '[]') then
						repeat
							fireclickdetector(station[partToClean].ClickEmpty);
							task.wait(0.1);
						until station.Contents.Value == '[]';
		
						task.wait(0.1);
					end;
		
					for name, count in next, items do
						for i = 1, count do
							local k = LocalPlayer.Backpack:FindFirstChild(name);
							if(not k) then return; end;
		
							k.Parent = LocalPlayer.Character;
							task.wait(0.1);
		
							local remote = k:FindFirstChildWhichIsA('RemoteEvent');
		
							if(remote) then
								local content = station.Contents.Value;
		
								repeat
									remote:FireServer(station[part].CFrame,station[part]);
									task.wait(0.1);
								until station.Contents.Value ~= content;
		
								k.Parent = LocalPlayer.Backpack;
								task.wait(0.1);
							else
								k:Activate();
		
								repeat
									task.wait(0.5);
								until not k.Parent;
							end;
						end;
					end;
		
					repeat
						fireclickdetector(station[partToClick].ClickConcoct);
						task.wait(0.1);
					until station.Contents.Value == '[]';
				end;
		
				local function craft(stationType, itemToCraft)
					local station = GrabStation(stationType);
					local items = hasMaterials(stationType == 'Alchemy' and potions or swords, itemToCraft);
		
					if(not station) then return ToastNotif.new({text = 'You must be near a cauldron/furnace !'}) end;
					if(not items) then return ToastNotif.new({text = 'Some Ingredients are missing !'}) end;
		
					if(stationType == 'Smithing') then
						ReplicatedStorage.Requests.GetMouse.OnClientInvoke = function()
							return {
								Hit = station.Material.CFrame,
								Target = station.Material,
								UnitRay = Mouse.UnitRay,
								X = Mouse.X,
								Y = Mouse.Y
							}
						end;
					end;
		
					if (stationType == 'Alchemy') then
						repeat
							addItemsToStation(items, station, 'Water', 'Ladle', 'Bucket');
							items = hasMaterials(stationType == 'Alchemy' and potions or swords, itemToCraft);
		
							task.wait(0.5);
						until not items;
					elseif (stationType == 'Smithing') then
						repeat
							addItemsToStation(items, station, 'Material', 'Hammer', 'Trash');
							items = hasMaterials(stationType == 'Alchemy' and potions or swords, itemToCraft);
		
							task.wait(0.5);
						until not items;
					end;
		
					task.wait(2);
		
					ReplicatedStorage.Requests.GetMouse.OnClientInvoke = function()
						return {
							Hit = Mouse.Hit,
							Target = Mouse.Target,
							UnitRay = Mouse.UnitRay,
							X = Mouse.X,
							Y = Mouse.Y
						}
					end;
				end;
		
				autoCraftUtils.craft = craft;
		
				function buildAutoPotion(window)
					local list = {};
		
					for i, v in next, potions do
						table.insert(list, i);
					end;
		
					window:AddList({text = 'Auto Potion', skipflag = true, noload = true, values = list, callback = function(name) craft('Alchemy', name) end});
				end;
		
				function buildAutoCraft(window)
					local list = {};
		
					for i, v in next, swords do
						table.insert(list, i);
					end;
		
					window:AddList({text = 'Auto Craft', skipflag = true, noload = true, values = list, callback = function(name) craft('Smithing', name) end});
				end;
			end;
		
			local chatFocused = false;
		
			UserInputService.TextBoxFocused:Connect(function()
				chatFocused = true;
			end);
		
			UserInputService.TextBoxFocusReleased:Connect(function()
				chatFocused = false;
			end);
		
			local function removeGroup(instance, list)
				for _, listObject in next, list do
					local foundListObject = instance:FindFirstChild(listObject)
					if(foundListObject) then
						foundListObject:Destroy();
					end;
		
					CollectionService:RemoveTag(instance, listObject);
				end;
			end;
		
			local function isUnderWater()
				if(not library.flags.noClipDisableValues['Disable On Water']) then
					return;
				end;
		
				local head = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Head');
				if(not head) then return end;
		
				local min = head.Position - (0.5 * head.Size);
				local max = head.Position + (0.5 * head.Size);
		
				local region = Region3.new(min, max):ExpandToGrid(4);
		
				local material = workspace.Terrain:ReadVoxels(region,4)[1][1][1];
		
				return material == Enum.Material.Water;
			end;
		
			local function isKnocked()
				if(not library.flags.noClipDisableValues['Disable When Knocked']) then
					return;
				end;
		
				local head = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Head');
				if(head and head:FindFirstChild('Bone')) then
					return true;
				end;
			end;
		
			local function getCurrentNpc(whitelist)
				local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
				if(not rootPart) then return end;
		
				for _, npc in next, (workspace:FindFirstChild('NPCs') or Instance.new('Folder')):GetChildren() do
					local npcRoot = npc.PrimaryPart;
					if(npcRoot and table.find(whitelist, npc.Name) and (rootPart.Position - npcRoot.Position).Magnitude <= 15) then
						return npc;
					end;
				end;
			end;
		
			local function getPlayerClass(player)
				if(playerClasses[player] and tick() - playerClasses[player].lastUpdate <= 5) then
					return playerClasses[player].name;
				end;
		
				local allFounds = {};
				local playerBackpack = player:FindFirstChild('Backpack');
				if(not playerBackpack) then
					return 'Freshie';
				end;
		
				for i, v in next, playerClassesList do
					for i2, v2 in next, v.Active do
						local alternative = tostring(v2):gsub("%s", "");
						if(i2 ~= "Level" and (playerBackpack:FindFirstChild(v2) or playerBackpack:FindFirstChild(alternative))) then
							table.insert(allFounds, {Level = -1, Name = i});
							break;
						end;
					end;
		
					for i2, v2 in next, v.Classes do
						for i3, v3 in next, v2 do
							local alternative = tostring(v3):gsub("%s", "");
							if(i3 ~= "Level" and (playerBackpack:FindFirstChild(v3) or playerBackpack:FindFirstChild(alternative))) then
								table.insert(allFounds, {Level = v2.Level, Name = i2});
								break;
							end;
						end;
					end
				end;
		
				local foundClass, foundClassLevel = nil, -1;
				for i, v in next, allFounds do
					if(v.Level >= foundClassLevel) then
						foundClass = v;
						foundClassLevel = v.Level;
					end;
				end;
		
				playerClasses[player] = {
					lastUpdate = tick();
					name = foundClass and foundClass.Name or 'Freshie'
				};
		
				if(not foundClass) then
					return 'Freshie';
				end;
		
				return foundClass.Name;
			end;
		
			local playerRaces = {};
			local raceColors = {};
		
			do -- // Grab Race Data
				if(ReplicatedStorage:FindFirstChild('Info') and ReplicatedStorage.Info:FindFirstChild('Races')) then
					for i, v in next, ReplicatedStorage.Info.Races:GetChildren() do
						table.insert(raceColors, {tostring(v.EyeColor.Value), tostring(v.SkinColor.Value), v.Name})
					end;
				end;
			end;
		
			local function getPlayerRace(player)
				if(playerRaces[player] and tick() - playerRaces[player].lastUpdateAt <= 5) then
					return playerRaces[player].name;
				end;
		
				local head = player.Character and player.Character:FindFirstChild('Head');
				local face = head and head:FindFirstChild('RLFace');
				local scroomHead = player.Character and player.Character:FindFirstChild('ScroomHead');
		
				local raceFound = 'Unknown'
		
				if(not face) then return raceFound end;
		
				if(scroomHead) then
					if(scroomHead.Material.Name == 'DiamondPlate') then
						raceFound = 'Metascroom';
					else
						raceFound = 'Scroom';
					end;
				end;
		
				if(raceFound == 'Unknown') then
					for i2, v2 in next, raceColors do
						local eyeColor, skinColor, raceName = v2[1], v2[2], v2[3];
		
						if(tostring(head.Color) == skinColor and tostring(face.Color3) == eyeColor) then
							raceFound = raceName;
						end;
					end;
				end;
		
		
				playerRaces[player] = {
					lastUpdateAt = tick(),
					name = raceFound
				};
		
				return raceFound;
			end;
		
			local function chargeManaUntil(amount)
				local character = LocalPlayer.Character;
				if(not character or character:FindFirstChildWhichIsA('ForceField') or not canUseMana()) then return warn('Cant charge mana cuz cant use mana', canUseMana()) end;
		
				local playerMana = character and character:FindFirstChild('Mana');
				if(character:FindFirstChild('Charge')) then
					dechargeMana();
					task.wait(0.2);
				end;
		
				if(not playerMana or sprinting) then
					return;
				end;
		
				if(playerMana.Value < amount) then
					--print('[Mana Adjust] Charge Mana');
		
					repeat
						chargeMana();
						task.wait(0.1);
					until playerMana.Value > math.clamp(amount, 0, 98) or sprinting;
		
					--print('[Mana Adjust] Decharge Mana');
		
					if (character:FindFirstChild('Charge')) then
						dechargeMana();
						task.wait(0.3);
					end;
				end;
			end;
		
			do -- // Bots
				local function runSafetyCheck(serverHop)
					local playerRangeCheck = library.flags.playerRangeCheck;
		
					if(moderatorInGame) then
						if(serverHop) then
							kickPlayer('Moderator In Game');
							return findServer(true), true, task.wait(9e9);
						else
							return true, 'Mod In Game';
						end;
					end;
		
					if(Utility:countTable(illusionists) > 0 and library.flags.skipIllusionistServer) then
						if(serverHop) then
							kickPlayer('Illusionist In Game');
							return findServer(true), true, task.wait(9e9);
						else
							return true, 'Illusionist In Game';
						end;
					end;
		
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if(not rootPart) then return end;
		
					if(_G.forcePanic) then
						if(serverHop) then
							kickPlayer('Forced Panic');
							return findServer(true), true, task.wait(9e9);
						else
							return true, 'Forced Panic';
						end;
					end;
		
					for i, v in next, Players:GetPlayers() do
						local plrRoot = v.Character and v.Character:FindFirstChild('HumanoidRootPart');
						if(v == LocalPlayer or not plrRoot) then continue end;
		
						local playerDistance = rootPart and (plrRoot.Position - rootPart.Position).Magnitude;
						if(playerDistance <= playerRangeCheck) then
							if(serverHop) then
								kickPlayer(string.format('Player Too Close (%s) [%d] Studs', v.Name, playerDistance));
								return findServer(true), true, task.wait(9e9);
							else
								return true, string.format('Player Too Close (%s) [%d] Studs', v.Name, playerDistance);
							end;
						end;
					end;
				end;
		
				local function runSmallSafetyCheck(cf, playerDistanceCheck, ignoreY)
					local illusionistObserving, playerTooClose = false, false;
					local rangeCheck = playerDistanceCheck or 500;
		
					for i, v in next, Players:GetPlayers() do
						local rootPart = v.Character and v.Character:FindFirstChild('HumanoidRootPart');
						if(not rootPart or v == LocalPlayer) then continue end;
		
						if(v.Character:FindFirstChild('Observing')) then
							illusionistObserving = true;
						end;
		
						if((Utility:roundVector(rootPart.Position) - Utility:roundVector(cf.p)).Magnitude <= rangeCheck) then
							playerTooClose = true;
							break;
						end;
					end;
		
					return illusionistObserving, playerTooClose;
				end;
		
				local function findClosest(currentPosition, positions)
					local closest, distance = nil, math.huge;
					local index = 0;
		
					for i, v in next, positions do
						local newDistance = (currentPosition - v.position).Magnitude;
						if(newDistance < distance) then
							closest, distance = v.position, newDistance;
							index = i;
						end;
					end;
		
					return closest, distance, index;
				end;
		
				local function setFeatureState(names, state)
					for _, name in next, names do
						if(library.flags[name] ~= state) then
							library.options[name]:SetState(state);
						end;
					end;
				end;
		
				local function disableBeds()
					local bed = workspace:FindFirstChild('Bed', true);
					if(not bed) then return end;
		
					for i, v in next, bed.Parent:GetChildren() do
						if(v.Name == 'Bed') then
							v.CanTouch = false;
						end;
					end;
				end;
		
				local function tweenTeleport(rootPart, position)
					local distance = (rootPart.Position - position).Magnitude;
					local tween = TweenService:Create(rootPart, TweenInfo.new(distance / 150, Enum.EasingStyle.Linear), {
						CFrame = CFrame.new(position)
					});
		
					tween:Play();
					tween.Completed:Wait();
				end;
		
				local function getClosestTrinkets(rootPart)
					local allTrinkets = {};
		
					for i, v in next, workspace:GetChildren() do
						if(v:IsA('BasePart') and v:FindFirstChildWhichIsA('ClickDetector', true) and (v.Position - rootPart.Position).Magnitude <= 500) then
							runSafetyCheck(true);
		
							local distance = (v.Position - rootPart.Position).Magnitude;
							table.insert(allTrinkets, {distance = distance, object = v});
						end;
					end;
		
					table.sort(allTrinkets, function(a, b)
						return a.distance < b.distance;
					end);
		
					return allTrinkets;
				end;
		
				local function createBot(tpLocations)
					runSafetyCheck(true);
		
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
		
					if(not LocalPlayer.Character) then
						local startMenu = LocalPlayer:WaitForChild('PlayerGui'):WaitForChild('StartMenu');
						local finish = startMenu:WaitForChild('Finish');
		
						finish:FireServer();
		
						repeat
							rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
							task.wait();
						until rootPart;
					end;
		
					runSafetyCheck(true);
					setFeatureState({'autoPickup', 'antiFire', 'removeKillBricks', 'noFallDamage'}, true);
					disableBeds();
		
					local _, distance = findClosest(rootPart.Position, tpLocations);
					if(distance >= 20) then
						repeat
							_, distance = findClosest(rootPart.Position, tpLocations);
							ToastNotif.new({
								text = 'You are too far away from the points',
								duration = 2.5
							});
							task.wait(5);
						until distance <= 20;
					end;
		
					local bodyVelocity = Instance.new('BodyVelocity');
					CollectionService:AddTag(bodyVelocity, 'AllowedBM');
		
					bodyVelocity.Velocity = Vector3.new();
					bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);
					bodyVelocity.Parent = rootPart;
		
					local aaGunPart = Instance.new('Part');
		
					aaGunPart.Anchored = true;
					aaGunPart.Transparency = debugMode and 0 or 1;
					aaGunPart.Size = Vector3.new(10, 0.1, 10);
					aaGunPart.Parent = workspace;
		
					local trinketPickedUp = {};
		
					RunService.Stepped:Connect(function()
						aaGunPart.CFrame = rootPart.CFrame * CFrame.new(0, -3.5, 0);
		
						if(LocalPlayer.Character:FindFirstChild('Frostbitten')) then
							LocalPlayer.Character.Frostbitten:Destroy();
						end;
		
						if(LocalPlayer.Character:FindFirstChild('DamageMPStack')) then
							LocalPlayer.Character.DamageMPStack:Destroy();
						end;
					end);
		
					if((tpLocations[1].position - rootPart.Position).Magnitude > 20) then
						local _, _, index = findClosest(rootPart.Position, tpLocations);
		
						for i = index, 1, -1 do
							local tpData = tpLocations[i];
		
							runSafetyCheck(true);
							tweenTeleport(rootPart, tpData.position);
		
							local ranAt = tick();
		
							repeat
								runSafetyCheck(true);
								task.wait();
							until tick() - ranAt >= tpData.delay;
						end;
		
						findServer(true);
						return;
					end;
		
					for i, v in next, tpLocations do
						runSafetyCheck(true);
						tweenTeleport(rootPart, v.position);
		
						local ranAt = tick();
		
						repeat
							runSafetyCheck(true);
							task.wait();
						until tick() - ranAt >= v.delay;
		
						local trinkets = getClosestTrinkets(rootPart);
		
						for i, v in next, trinkets do
							if(trinketPickedUp[v.object]) then
								continue;
							end;
		
							local trinketType = getTrinketType(v.object);
							if((trinketType.Name == 'Phoenix Down' and library.flags.dontPickupPhoenixDown) or (trinketType.Name == 'Ninja Scroll' and library.flags.dontPickupScrolls)) then
								if(v.object:FindFirstChildWhichIsA('ClickDetector', true)) then
									v.object:FindFirstChildWhichIsA('ClickDetector', true):Destroy();
								end;
		
								trinketPickedUp[v.object] = true;
								continue;
							end;
		
							local pickedUpAt = tick();
							repeat task.wait() until not v.object.Parent or tick() - pickedUpAt >= 5;
		
							trinketPickedUp[v.object] = true;
							task.wait(0.1);
						end;
					end;
		
					if(not rootPart.Parent) then
						return kickPlayer('You got killed, stopped bot.');
					end;
		
					findServer(true);
				end;
		
				local function findPlayerInZone(zonePosition, zoneSize)
					local castPart = Instance.new('Part');
					castPart.Anchored = true;
					castPart.Transparency = 1;
					castPart.CanCollide = false;
					castPart.Size = zoneSize; -- Vector3.new(1000, 0, 1000);
					castPart.Position = zonePosition; -- Vector3.new(-1171.661, 702.853, 201.261);
					castPart.Parent = workspace;
		
					local params = RaycastParams.new();
					params.FilterType = Enum.RaycastFilterType.Whitelist;
					params.FilterDescendantsInstances = {castPart};
		
					for i, v in next, Players:GetPlayers() do
						local rootPart = v.Character and v.Character:FindFirstChild('HumanoidRootPart');
		
						if (rootPart and workspace:Raycast(rootPart.Position, Vector3.new(0, 10000, 0), params) and v ~= LocalPlayer) then
							return true;
						end;
					end;
				end;
		
				function scroomBot(toggle)
					if(not toggle) then return end;
		
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					local target = library.flags.scroomBotTargetPlayer;
		
					repeat
						task.wait(1);
		
						if(getPlayerRace(LocalPlayer) ~= 'Scroom') then
							ToastNotif.new({text = 'Scroom Bot - You must be a scroom !', duration = 5});
							continue;
						end;
		
						local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
						local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
						if(not rootPart or not humanoid) then continue end;
		
						local statGui = LocalPlayer:FindFirstChild('PlayerGui') and LocalPlayer.PlayerGui:FindFirstChild('StatGui');
						if(not statGui) then continue end;
		
						local lives = tonumber(statGui.Container.Health.Lives.Roller.Char.Text)
						if(not lives) then continue end;
		
						warn('[Scroom Bot] Scroom has', lives, 'lives');
		
						if(lives == 0) then
							warn('[Scroom Bot] No more lives !');
		
							local function moveTo(pos)
								local moveToFinished = false;
								coroutine.wrap(function()
									humanoid.MoveToFinished:Wait();
									moveToFinished = true;
								end)();
		
								repeat
									print('[Scroom Bot] Waiting for moveToFinished');
									humanoid:MoveTo(pos);
									task.wait();
								until moveToFinished;
							end;
		
							moveTo(Vector3.new(-7172.99316, 274.759491, 2772.82275));
							moveTo(Vector3.new(-7144.06201, 274.759338, 2771.50513));
		
							print('[Scroom Bot] Ready to talk to Ferryman');
		
							local npc = getCurrentNpc({'Ferryman'});
							fireclickdetector(npc.ClickDetector);
		
							task.wait(1);
							local choices = {'New Character\n(free)', 'My son.', 'exit'};
							for i, v in next, choices do
								if(v == 'exit') then
									dialog:FireServer({exit = true});
								else
									dialog:FireServer({choice = v});
								end;
		
								task.wait(1);
							end;
		
							LocalPlayer.CharacterAdded:Wait();
							continue;
						end;
		
						if(not target.Character or (target.Character.PrimaryPart.Position - rootPart.Position).Magnitude > 100) then
							ToastNotif.new({text = 'Scroom Bot - Player is too far away (Maximum 100 studs)', duration = 5});
							continue;
						end;
		
						local tween = TweenService:Create(rootPart, TweenInfo.new((rootPart.Position - target.Character.PrimaryPart.Position).Magnitude / 200), {
							CFrame = CFrame.new(target.Character.PrimaryPart.Position)
						});
		
						tween:Play();
						tween.Completed:Wait();
		
						if(LocalPlayer.Character:FindFirstChildWhichIsA('ForceField')) then
							LocalPlayer.Character:FindFirstChildWhichIsA('ForceField'):Destroy();
						end;
		
						task.wait(0.1);
						local id = HttpService:GenerateGUID(false):sub(1, 8);
		
						repeat
							if(library.flags.scroomBotGripMode and humanoid.Health >= 10) then
								fallDamage:FireServer({math.random(), 2});
							end;
							print('[Scroom Bot] Waiting for player to die ...', id);
		
							task.wait(1);
						until humanoid.Health <= 0 or not library.flags.scroomBot;
		
						warn('[Scroom Bot] Player is dead, waiting for new character to spawn ...');
						LocalPlayer.CharacterAdded:Wait();
						warn('[Scroom Bot] New character has spawned');
					until not library.flags.scroomBot;
				end;
		
				function daysFarm(toggle)
					local humanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if(not toggle) then
						maid.daysFarm = nil;
						maid.daysFarmNoClip = nil;
						return;
					end;
		
					if(not LocalPlayer.Character) then
						spawnLocalCharacter();
						task.wait(1);
					end;
		
					repeat
						task.wait();
					until LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					humanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					
					maid.daysFarm = RunService.Heartbeat:Connect(function()
						local _, playerTooClose = runSmallSafetyCheck(humanoidRootPart.CFrame,library.flags.daysFarmRange);
		
						if(playerTooClose or moderatorInGame) then
							maid.daysFarm = nil;
							task.wait(1);
							kickPlayer(moderatorInGame and 'Mod In Game' or 'Player Too Close');
							findServer();
						end;
					end);
				end;
		
				function gachaBot(toggle)
					if(not toggle or not isGaia) then return end;
		
					if(moderatorInGame) then
						kickPlayer('Mod In Game');
						return findServer();
					end;
		
					local character = spawnLocalCharacter();
		
					local rootPart = character and character:WaitForChild('HumanoidRootPart');
					if(not rootPart) then return ToastNotif.new({text = 'no hrp?'}) and findServer(); end;
		
					local npc = workspace.NPCs:FindFirstChild('Xenyari');
					local npcRootPart = npc and npc:FindFirstChild('Head');
					local clickDetector = npc and npc:FindFirstChildWhichIsA('ClickDetector');
		
					if (not npc or not npcRootPart or not clickDetector) then
						kickPlayer('Please dm Aztup!');
						return findServer();
					end;
		
					local distanceFromNPC = (npcRootPart.Position - rootPart.Position).Magnitude;
		
					if (distanceFromNPC > 10) then
						repeat
							ToastNotif.new({text = 'You are too far away from Xenyari', duration = 1});
							distanceFromNPC = (npcRootPart.Position - rootPart.Position).Magnitude;
							task.wait(1);
						until distanceFromNPC < 10;
					end;
		
					local getPlayerDays = (function()
						for i, v in next, getconnections(ReplicatedStorage.Requests.DaysSurvivedChanged.OnClientEvent) do
							return getupvalue(v.Function, 2);
						end;
					end);
		
					local playerDays = getPlayerDays();
		
					repeat
						playerDays = getPlayerDays();
						task.wait(0.1);
					until playerDays;
		
					ReplicatedStorage.Requests.DaysSurvivedChanged.OnClientEvent:Connect(function(days)
						playerDays = days;
					end);
		
					if (MemStorageService:HasItem('gachaBotLives')) then
						repeat
							print('running safety check and waiting for lives to change!', playerDays, tonumber(MemStorageService:GetItem('gachaBotLives')));
		
							local _, playerTooClose = runSmallSafetyCheck(rootPart.CFrame, 2500);
		
							if (playerTooClose) then
								if (character:FindFirstChild('Danger')) then
									repeat
										task.wait(0.1);
									until not character:FindFirstChild('Danger');
								end;
		
								kickPlayer('Player too close');
								findServer();
							elseif (character:FindFirstChildWhichIsA('ForceField')) then
								character:FindFirstChildWhichIsA('ForceField'):Destroy();
							end;
		
							task.wait(0.1);
						until playerDays ~= tonumber(MemStorageService:GetItem('gachaBotLives'));
					else
						MemStorageService:SetItem('gachaBotLives', tostring(playerDays));
					end;
		
					dialog.OnClientEvent:Connect(function(dialogData)
						task.wait(1);
		
						if (not dialogData.choices) then
							dialog:FireServer({exit = true});
							task.wait(1);
							kickPlayer('Hopping');
							findServer();
						elseif (dialogData.choices) then
							MemStorageService:SetItem('gachaBotLives', tostring(playerDays));
							dialog:FireServer({choice = dialogData.choices[1]});
						end;
					end);
		
					library.base.Enabled = false;
		
					repeat
						local rootPosition = workspace.CurrentCamera:WorldToViewportPoint(npcRootPart.Position);
		
						VirtualInputManager:SendMouseButtonEvent(rootPosition.X, rootPosition.Y, 0, false, game, 1);
						task.wait();
						VirtualInputManager:SendMouseButtonEvent(rootPosition.X, rootPosition.Y, 0, true, game, 1);
						task.wait(0.25);
					until LocalPlayer.PlayerGui:FindFirstChild('CaptchaLoad') or LocalPlayer.PlayerGui:FindFirstChild('Captcha');
					-- // Waiting for npc answer or waiting for captcha
		
					repeat task.wait() until LocalPlayer.PlayerGui:FindFirstChild('Captcha');
		
					repeat
						local captchaGUI = LocalPlayer.PlayerGui:FindFirstChild('Captcha');
						local choices = captchaGUI and captchaGUI.MainFrame.Options:GetChildren();
						local union = captchaGUI and captchaGUI.MainFrame.Viewport.Union;
		
						if(choices and union) then
							local captchaAnswer = solveCaptcha(union);
		
							for i, v in next, choices do
								if(v.Name == captchaAnswer) then
									local position = v.AbsolutePosition + Vector2.new(40, 40);
									VirtualInputManager:SendMouseButtonEvent(position.X, position.Y, 0, true, game, 1);
									task.wait();
									VirtualInputManager:SendMouseButtonEvent(position.X, position.Y, 0, false, game, 1);
		
									break;
								end;
							end;
						end;
		
						task.wait(1);
					until not LocalPlayer.PlayerGui:FindFirstChild('Captcha');
		
					library.base.Enabled = true;
				end;
		
				function blackSmithBot(toggle)
					if (not toggle) then return end;
		
					local character = spawnLocalCharacter();
					local rootPart = character and character:WaitForChild('HumanoidRootPart');
		
					local locations = {
						Vector3.new(-1066.6357421875, 583.36157226563, -421.35971069336)
					};
		
					local boxes = {};
					setFeatureState({'antiFire', 'removeKillBricks', 'noFallDamage'}, true);
		
					for i = 1, #locations do
						local box = Drawing.new('Square');
						box.Size = Vector2.new(50, 50);
						box.Thickness = 5;
						box.Color = Color3.fromRGB(255, 255, 255);
		
						local text = Drawing.new('Text');
						text.Size = 20;
						text.Center = false;
						text.Text = string.format('Blacksmith Point %d', i);
						text.Color = Color3.fromRGB(255, 255, 255);
		
						table.insert(boxes, {box, text});
					end;
		
					RunService.Heartbeat:Connect(function()
						for i, location in next, locations do
							local box, text = unpack(boxes[i]);
							local screenPosition, visible = workspace.CurrentCamera:WorldToViewportPoint(location);
		
							box.Visible = visible;
							text.Visible = visible;
		
							box.Position = Vector2.new(screenPosition.X, screenPosition.Y) - box.Size / 2;
							text.Position = Vector2.new(screenPosition.X, screenPosition.Y) - box.Size;
						end;
					end);
		
					local function getChosenLocation()
						for i, v in next, locations do
							if ((rootPart.Position - v).Magnitude < 10) then
								return i, v;
							end;
						end;
					end;
		
					local chosenLocationIndex, chosenLocation = getChosenLocation();
		
					if (not chosenLocation) then
						repeat
							ToastNotif.new({text = 'You must be on one of the blacksmith points', duration = 1});
		
							chosenLocationIndex, chosenLocation = getChosenLocation();
							task.wait(1);
						until chosenLocation;
					end;
		
					local bodyVelocity = Instance.new('BodyVelocity');
					CollectionService:AddTag(bodyVelocity, 'AllowedBM');
		
					bodyVelocity.Velocity = Vector3.new();
					bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);
					bodyVelocity.Parent = rootPart;
		
					local aaGunPart = Instance.new('Part');
		
					aaGunPart.Anchored = true;
					aaGunPart.Transparency = debugMode and 0 or 1;
					aaGunPart.Size = Vector3.new(10, 0.1, 10);
					aaGunPart.Parent = workspace;
		
					local function getPickaxes()
						local pickaxes = {};
		
						for i, v in next, LocalPlayer.Backpack:GetChildren() do
							if (v.Name == 'Pickaxe') then
								table.insert(pickaxes, v);
							end;
						end;
		
						return pickaxes;
					end;
		
					local pickaxes = getPickaxes();
		
					if (#pickaxes <= 1) then
						repeat
							ToastNotif.new({text = 'You must have atleast 1 pickaxe.', duration = 1})
							pickaxes = getPickaxes();
		
							task.wait(1);
						until #pickaxes >= 1;
					end;
		
					RunService.Stepped:Connect(function()
						aaGunPart.CFrame = rootPart.CFrame * CFrame.new(0, -3.5, 0);
		
						if(character:FindFirstChild('Frostbitten')) then
							character.Frostbitten:Destroy();
						end;
		
						if(character:FindFirstChild('DamageMPStack')) then
							character.DamageMPStack:Destroy();
						end;
					end);
		
					local function mineOres(ores)
						for i, v in next, ores do
							local isBlacklisted = v:FindFirstChild('Blacklist') and v.Blacklist:FindFirstChild(LocalPlayer.Name);
		
							if ((v.Position - rootPart.Position).Magnitude < 10 and v.Transparency == 0 and not isBlacklisted and (not library.flags.skipIllusionistServer or Utility:countTable(illusionists) <= 0)) then
								local startedAt = tick();
		
								repeat
									local pickaxe = table.remove(pickaxes, 1);
		
									pickaxe.Parent = LocalPlayer.Character;
									pickaxe:Activate();
		
									task.wait(0.05);
									pickaxe.Parent = LocalPlayer.Backpack;
		
									table.insert(pickaxes, pickaxe);
								until v.Transparency ~= 0 or tick() - startedAt >= 2;
							end;
						end;
					end;
		
					local function getOres(getCookedOre)
						local totalOres = {};
						local closest = 0;
		
						for i, v in next, LocalPlayer.Backpack:GetChildren() do
							if (v:FindFirstChild('Ore') or (getCookedOre and v:FindFirstChild('OreBar'))) then
								totalOres[v.Name] = (totalOres[v.Name] or 0) + 1
							end;
						end;
		
						for i, v in next, totalOres do
							if (v > closest) then
								closest = v;
							end;
						end;
		
						return closest;
					end;
		
					local function getDaggers()
						local counter = 0;
		
						for i, v in next, LocalPlayer.Backpack:GetChildren() do
							if (v:FindFirstChild('Smithed')) then
								counter = counter + 1;
							end;
						end;
		
						return counter;
					end;
		
					local playerTooClose = findPlayerInZone(Vector3.new(-1357.403, 702.853, 170.2), Vector3.new(1371.484, 9.368, 1504.703));
					task.wait(5);
		
					if (playerTooClose) then
						kickPlayer('Player too close.');
						return findServer();
					elseif (Utility:countTable(illusionists) > 0 and library.flags.skipIllusionistServer) then
						kickPlayer('Illusionist in server.');
						return findServer();
					elseif (moderatorInGame) then
						kickPlayer('Mod in game.');
						return findServer();
					end;
		
					LocalPlayer.CharacterAdded:Connect(function()
						kickPlayer('You got killed, stopping bot');
						function findServer() end;
						task.wait(1);
						while true do end;
					end);
		
					local forceField = LocalPlayer.Character:FindFirstChildWhichIsA('ForceField');
					if (forceField) then
						forceField:Destroy();
						task.wait(1);
					end;
		
					local amountOfOres = getOres();
					local amountOfCookedOres = getOres(true);
					local leftClick = LocalPlayer.Character.CharacterHandler.Remotes.LeftClick;
					local rightClick = LocalPlayer.Character.CharacterHandler.Remotes.RightClick;
		
					if (chosenLocationIndex == 1) then
						local ores = workspace.Ores:GetChildren();
						local oresLocation = Vector3.new(-1047.0006103516, 185.89465332031, -51.419830322266);
		
						local foundOres = {};
		
						for i, v in next, ores do
							local isBlacklisted = v:FindFirstChild('Blacklist') and v.Blacklist:FindFirstChild(LocalPlayer.Name);
		
							if ((v.Position - oresLocation).Magnitude < 500 and v.Transparency == 0 and not isBlacklisted) then
								table.insert(foundOres, v);
							end;
						end;
		
						if (#foundOres <= 0) then
							kickPlayer('No ores.');
							return findServer();
						end;
		
						tweenTeleport(rootPart, Vector3.new(-1067.231, 583.361, -419.418));
						tweenTeleport(rootPart, Vector3.new(-1066.703, 589.257, -399.340));
						tweenTeleport(rootPart, Vector3.new(-1047.000, 589.257, -51.419));
						tweenTeleport(rootPart, Vector3.new(-1047.197, 185.895, -59.241));
						mineOres(ores);
						tweenTeleport(rootPart, Vector3.new(-1047.738, 185.895, -154.77));
						mineOres(ores);
						tweenTeleport(rootPart, Vector3.new(-1057.99, 185.895, -151.683));
						mineOres(ores);
						tweenTeleport(rootPart, Vector3.new(-1045.891, 185.895, -153.512));
						tweenTeleport(rootPart, Vector3.new(-1047.197, 185.895, -59.241));
						tweenTeleport(rootPart, Vector3.new(-1047.000, 589.257, -51.419));
						tweenTeleport(rootPart, Vector3.new(-1066.703, 589.257, -399.340));
						tweenTeleport(rootPart, Vector3.new(-1067.231, 583.361, -419.418));
					end;
		
					if (amountOfOres >= 25 or MemStorageService:HasItem('wasCookingOres')) then
						local remoteSmithing = LocalPlayer.Backpack:FindFirstChild('Remote Smithing');
						if (not remoteSmithing) then return kickPlayer('Bot, stopped, due to max amount of ores and no remote smithing') end;
		
						rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(20, 0, 0));
						MemStorageService:SetItem('wasCookingOres', 'true');
		
						remoteSmithing.Parent = LocalPlayer.Character;
						task.wait(1);
						rightClick:FireServer({math.random(1, 10), math.random()});
		
						setFeatureState({'autoSmelt'}, true);
		
						repeat
							playerTooClose = findPlayerInZone(Vector3.new(-1357.403, 702.853, 170.2), Vector3.new(1371.484, 9.368, 1504.703))
							amountOfOres = getOres();
		
							task.wait(0.1);
						until playerTooClose or amountOfOres <= 0;
		
						if (amountOfOres <= 0) then
							MemStorageService:RemoveItem('wasCookingOres');
						end;
		
						remoteSmithing.Parent = LocalPlayer.Backpack;
		
						rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(0, 10, 0));
						task.wait(0.1);
						rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(-20, 0, 0));
						task.wait(0.1);
						rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(0, -10, 0));
		
						setFeatureState({'autoSmelt'}, false);
						task.wait(0.5);
		
						if (playerTooClose) then
							kickPlayer('Player was too close aborted, smelt ores');
							return findServer();
						end;
					end;
		
					local craftItem;
					local itemToCrafts = {'Bronze Dagger', 'Steel Dagger', 'Mythril Dagger'};
		
					for i, v in next, itemToCrafts do
						if (autoCraftUtils.hasMaterials('Smithing', v)) then
							craftItem = v;
						end;
					end;
		
					if (amountOfCookedOres >= 50 or MemStorageService:HasItem('wasDoingCrafting')) then
						local remoteSmithing = LocalPlayer.Backpack:FindFirstChild('Remote Smithing');
						if (not remoteSmithing) then return kickPlayer('Bot, stopped, due to max amount of ores and no remote smithing') end;
		
						MemStorageService:SetItem('wasDoingCrafting', 'true');
		
						rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(0, 0, 20));
						remoteSmithing.Parent = LocalPlayer.Character;
		
						task.wait(1);
						leftClick:FireServer({math.random(1, 10), math.random()});
						task.wait(1);
						remoteSmithing.Parent = LocalPlayer.Backpack;
		
						local craftEnded = false;
		
						task.spawn(function()
							autoCraftUtils.craft('Smithing', craftItem);
							craftEnded = true;
							MemStorageService:RemoveItem('wasDoingCrafting');
						end);
		
						repeat
							playerTooClose = findPlayerInZone(Vector3.new(-1357.403, 702.853, 170.2), Vector3.new(1371.484, 9.368, 1504.703))
							task.wait(0.1);
						until playerTooClose or craftEnded;
		
						rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(0, 10, 0));
						task.wait(0.1);
						rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(0, 0, -20));
						task.wait(0.1);
						rootPart.CFrame = CFrame.new(rootPart.Position + Vector3.new(0, -10, 0));
		
						task.wait(0.5);
		
						if (playerTooClose) then
							kickPlayer('Player was too close aborted, smelt ores');
							return findServer();
						end;
					end;
		
					local amountOfDaggers = getDaggers();
		
					if (amountOfDaggers >= 50) then
						local playerTooClose = findPlayerInZone(Vector3.new(-1357.403, 702.853, 170.2), Vector3.new(1371.484, 9.368, 1504.703));
		
						if (playerTooClose) then
							kickPlayer('Player too close, cant sell daggers');
							return findServer();
						elseif (Utility:countTable(illusionists) > 0 and library.flags.skipIllusionistServer) then
							kickPlayer('Illu in server, cant sell daggers');
							return findServer();
						end;
		
						if (chosenLocationIndex == 1) then
							tweenTeleport(rootPart, Vector3.new(-1067.231, 583.361, -419.418));
							tweenTeleport(rootPart, Vector3.new(-1066.703, 589.257, -399.340));
							tweenTeleport(rootPart, Vector3.new(-1047.000, 589.257, -51.419));
							tweenTeleport(rootPart, Vector3.new(-1048.018, 185.895, -48.932));
							tweenTeleport(rootPart, Vector3.new(-1047.197, 185.895, 205.667));
							tweenTeleport(rootPart, Vector3.new(-1041.21, 168.84, 227.411));
							tweenTeleport(rootPart, Vector3.new(-1107.443, 168.84, 253.837));
							tweenTeleport(rootPart, Vector3.new(-1169.846, 162.282, 290.529));
							tweenTeleport(rootPart, Vector3.new(-1169.846, 145.626, 291.5));
							tweenTeleport(rootPart, Vector3.new(-1250.748, 146.004, 290.529));
							tweenTeleport(rootPart, Vector3.new(-1250.748, 146.004, 253.283));
							tweenTeleport(rootPart, Vector3.new(-1237.223, 146.004, 254.742));
		
							-- talk to npc
		
							repeat
								task.wait(0.1);
								local merchant = getCurrentNpc({'Merchant', 'Pawnbroker'});
								if (not merchant) then warn('no npc very sad') continue end;
		
								fireclickdetector(merchant.ClickDetector);
								task.wait(1);
								dialog:FireServer({choice = 'Can I sell in bulk?'})
								task.wait(1);
								dialog:FireServer({choice = 'Weapons.'});
								task.wait(1);
								dialog:FireServer({choice = 'It\'s a deal.'});
								task.wait(1);
								dialog:FireServer({exit = true});
		
								amountOfDaggers = getDaggers();
								warn('daggers:', amountOfDaggers)
							until amountOfDaggers <= 0;
		
							tweenTeleport(rootPart, Vector3.new(-1237.223, 146.004, 254.742));
							tweenTeleport(rootPart, Vector3.new(-1250.748, 146.004, 253.283));
							tweenTeleport(rootPart, Vector3.new(-1250.748, 146.004, 290.529));
							tweenTeleport(rootPart, Vector3.new(-1169.846, 145.626, 291.5));
							tweenTeleport(rootPart, Vector3.new(-1169.846, 162.282, 290.529));
							tweenTeleport(rootPart, Vector3.new(-1107.443, 168.84, 253.837));
							tweenTeleport(rootPart, Vector3.new(-1041.21, 168.84, 227.411));
							tweenTeleport(rootPart, Vector3.new(-1047.197, 185.895, 205.667));
							tweenTeleport(rootPart, Vector3.new(-1048.018, 185.895, -48.932));
							tweenTeleport(rootPart, Vector3.new(-1047.000, 589.257, -51.419));
							tweenTeleport(rootPart, Vector3.new(-1066.703, 589.257, -399.340));
							tweenTeleport(rootPart, Vector3.new(-1067.231, 583.361, -419.418));
		
							task.wait(0.5);
		
							kickPlayer('Sold daggers wooo');
							return findServer();
						end;
		
						-- setFeatureState({'blacksmithBot'}, false);
						-- return kickPlayer('Finished farming, you can now sell your daggers');
					end;
		
					task.wait(0.5);
		
					kickPlayer('Finished lotting.');
					return findServer();
				end;
		
				local botPoints = {};
				local botPointsUI = {};
		
				local botPointsParts = {};
				local botPointsLines = {};
		
				function addPoint(position, delay, waitForTrinkets)
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					position = position or (rootPart and rootPart.Position);
					if(not position) then return end;
		
					local roundPosition = Vector3.new(math.floor(position.X), math.floor(position.Y), math.floor(position.Z));
					local brickColor = BrickColor.palette(((#botPoints*5) % 100)+1);
		
					waitForTrinkets = waitForTrinkets or false;
		
					local pointData = {};
					pointData.position = position;
					pointData.delay = delay or 0;
					pointData.waitForTrinkets = waitForTrinkets;
		
					table.insert(botPoints, pointData);
		
					local point = Instance.new('Part');
		
					point.Size = Vector3.new(1, 1, 1);
					point.Parent = workspace;
					point.Shape = Enum.PartType.Ball;
					point.Anchored = true;
					point.CanCollide = false;
					point.Material = Enum.Material.SmoothPlastic;
					point.CFrame = CFrame.new(position);
					point.BrickColor = brickColor;
		
					local label = Bots:AddLabel(string.format('Point %d | %s', #botPoints, tostring(roundPosition)));
					label.main.TextColor3 = brickColor.Color;
					label.main.InputBegan:Connect(function(inputObject)
						if(inputObject.UserInputType ~= Enum.UserInputType.MouseButton1) then return end;
		
						repeat
							workspace.CurrentCamera.CameraSubject = point;
							Heartbeat:Wait();
						until inputObject.UserInputState == Enum.UserInputState.End;
		
						workspace.CurrentCamera.CameraSubject = LocalPlayer.Character;
					end);
		
					table.insert(botPointsUI, label);
					table.insert(botPointsUI, Bots:AddSlider({text = 'Delay', textpos = 2, value = pointData.delay, min = 0, max = 15, callback = function(val) pointData.delay = val end}));
					table.insert(botPointsUI, Bots:AddToggle({text = 'Wait For Trinkets', state = waitForTrinkets, callback = function(val) pointData.waitForTrinkets = val end}));
					table.insert(botPointsParts, point);
		
					refreshPoints();
				end;
		
				function clearPointsPrompt()
					if (library:ShowConfirm('Are you sure ?')) then clearPoints() end;
				end;
		
				function refreshPoints()
					if(#botPointsParts >= 2) then
						for i, v in next, botPointsLines do
							v:Destroy();
						end;
		
						table.clear(botPointsLines);
		
						local params = RaycastParams.new();
						params.FilterType = Enum.RaycastFilterType.Whitelist;
						params.FilterDescendantsInstances = isGaia and {workspace.Map} or {};
		
						for i = 1, #botPointsParts do
							local pointA, pointB = botPointsParts[i], botPointsParts[i + 1];
		
							if(pointA and pointB) then
								local line = Instance.new('Part');
		
								line.Size = Vector3.new(0.5, 0.5, (pointA.Position-pointB.Position).Magnitude);
								line.Parent = workspace;
								line.Material = Enum.Material.SmoothPlastic;
								line.Color = workspace:Raycast(pointA.Position, (pointB.Position - pointA.Position).Unit*line.Size.Z, params) and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 0);
								line.Anchored = true;
								line.CanCollide = false;
								line.CFrame = CFrame.new(pointA.Position, pointB.Position) * CFrame.new(0, 0, -(pointA.Position-pointB.Position).Magnitude/2);
		
								table.insert(botPointsLines, line);
							end;
						end;
					end;
				end;
		
				function clearPoints()
					for i, v in next, botPointsUI do
						for i2, v2 in next, v do
							if(typeof(v2) == 'Instance') then
								v2:Destroy();
							end;
						end;
					end;
		
					for i, v in next, botPointsLines do
						v:Destroy();
					end;
		
					for i, v in next, botPointsParts do
						v:Destroy();
					end;
		
					table.clear(botPointsLines);
					table.clear(botPointsParts);
					table.clear(botPoints);
					table.clear(botPointsUI);
				end;
		
				local canceled = false;
		
				function previewBot()
					if(#botPoints <= 0) then return end;
					canceled = false;
		
					local part = Instance.new('Part');
					part.Size = Vector3.new(5, 5, 5);
					part.Anchored = true;
					part.Shape =  Enum.PartType.Ball;
					part.Parent = workspace;
					part.Color = Color3.fromRGB(255, 0, 0);
					part.CanCollide = false;
					part.Material = Enum.Material.SmoothPlastic;
					part.CFrame = CFrame.new(botPoints[1].position);
		
					workspace.CurrentCamera.CameraSubject = part;
		
					local function startPointLoop(n1, n2, n3)
						for i = n1, n2, n3 or 1 do
							local v = botPoints[i];
							if(canceled) then break end;
		
							local tween = TweenService:Create(part, TweenInfo.new((part.Position - v.position).Magnitude / 150, Enum.EasingStyle.Linear), {
								CFrame = CFrame.new(v.position)
							});
		
							local completed = false;
		
							tween.Completed:Connect(function() completed = true end);
							tween:Play();
		
							repeat task.wait() until completed or canceled;
							local startedAt = tick();
							repeat task.wait() until tick() - startedAt > v.delay or canceled;
		
							if(canceled) then
								tween:Cancel();
							end;
						end;
					end;
		
					startPointLoop(1, #botPoints);
					startPointLoop(#botPoints, 1, -1);
		
					task.wait(1);
					part:Destroy();
					workspace.CurrentCamera.CameraSubject = LocalPlayer.Character;
				end;
		
				function cancelPreview()
					canceled = true;
				end;
		
				function saveBot()
					if(isfile(library.flags.fileName .. '.json')) then
						library:ShowMessage('A file with this name already exists!');
						return;
					end;
		
					local saveData = {};
		
					for i, v in next, botPoints do
						table.insert(saveData, {
							position = tostring(v.position),
							delay = v.delay,
							waitForTrinkets = v.waitForTrinkets
						});
					end;
		
					writefile(library.flags.fileName .. '.json', HttpService:JSONEncode(saveData));
					library:ShowMessage('Path has been saved under synapsex/workspace/' .. library.flags.fileName .. '.json');
				end;
		
				function loadBot()
					if (library:ShowConfirm('Are you sure ? (This will clear your current path)')) then
						xpcall(function()
							local suc, file = pcall(readfile, library.flags.fileName .. '.json');
							if(not suc) then
								return library:ShowMessage('File not found');
							end;
		
							local pointsData = HttpService:JSONDecode(file);
		
							clearPoints();
		
							for i, v in next, pointsData do
								v.position = Vector3.new(unpack(v.position:split(',')));
								addPoint(v.position, v.delay, v.waitForTrinkets);
							end;
		
							library:ShowMessage('Path loaded');
						end, function()
							library:ShowMessage('An error has occured!');
						end);
					end;
				end;
		
				function removeLastPoint()
					if(#botPoints <= 0) then return end;
					table.remove(botPoints, #botPoints);
					table.remove(botPointsParts, #botPointsParts):Destroy();
		
					if(#botPointsLines > 0) then
						table.remove(botPointsLines, #botPointsLines):Destroy();
					end;
		
					for i = 1, 3 do
						for i, v in next, table.remove(botPointsUI, #botPointsUI) or {} do
							if(typeof(v) == 'Instance') then
								v:Destroy();
							end;
						end;
					end;
				end;
		
				function startBot()
					local suc, file = pcall(readfile, library.flags.fileName .. '.json');
		
					if(not suc) then
						return library:ShowMessage('Failed to start bot, file not found');
					end;
		
					local pointsData = HttpService:JSONDecode(file);
					clearPoints();
		
					for i, v in next, pointsData do
						v.position = Vector3.new(unpack(v.position:split(',')));
						addPoint(v.position, v.delay, v.waitForTrinkets);
					end;
		
					MemStorageService:SetItem('botStarted', 'true');
					createBot(pointsData);
				end;
		
				function startBotPrompt()
					if (library:ShowConfirm('Are you sure you want to start the bot ?')) then
						startBot();
					end;
				end;
		
				library.OnLoad:Connect(function()
					if(MemStorageService:HasItem('botStarted')) then
						startBot();
					end;
				end);
			end;
		
			function noClip(toggle)
				if(not toggle) then return end;
		
				library.options.fly:SetState(true);
				repeat
					local Humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid");
		
					if(Humanoid and not isUnderWater() and not isKnocked()) then
						for _, part in next, LocalPlayer.Character:GetDescendants() do
							if(part:IsA('BasePart')) then
								part.CanCollide = false;
							end;
						end;
					end;
					Humanoid:ChangeState("Jumping");
					Humanoid.JumpPower = 0;
					RunService.Stepped:Wait();
				until not library.flags.noClip;
				local Humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid");
		
				library.options.fly:SetState(false);
				if (not Humanoid) then return; end
				LocalPlayer.Character.Humanoid.JumpPower = 45;
			end;
		
			function noInjuries(toggle)
				if(not toggle) then return end;
		
				repeat
					local character = LocalPlayer.Character;
					local boosts = character and character:FindFirstChild('Boosts');
					if(character) then
						removeGroup(character, injuryObjects);
		
						if(boosts) then
							removeGroup(boosts, injuryObjects);
						end;
					end;
					task.wait();
				until not library.flags.noInjuries;
			end;
		
			function noFog(toggle)
				if(not toggle) then return end;
				local oldFogStart, oldFogEnd = Lighting.FogStart, Lighting.FogEnd;
		
				repeat
					Lighting.FogStart = 99999;
					Lighting.FogEnd = 99999;
					task.wait();
				until not library.flags.noFog;
		
				Lighting.FogStart, Lighting.FogEnd = oldFogStart, oldFogEnd;
			end;
		
			function noClipXray(toggle)
				if(not toggle) then return end;
		
				repeat
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
		
					if(rootPart) then
						local region = Region3.new(rootPart.Position - Vector3.new(1, 0, 1), rootPart.Position + Vector3.new(1, 0, 1));
						local parts = workspace:FindPartsInRegion3WithIgnoreList(region, {workspace.Live, workspace.MonsterSpawns})
		
						for i, v in next, noclipBlocks do
							noclipBlocks[i].Transparency = 0;
							table.remove(noclipBlocks, i);
						end;
		
						for _, part in next, parts do
							if(part.Transparency == 0) then
								table.insert(noclipBlocks, part);
								part.Transparency = 0.5;
							end;
						end;
					end;
					task.wait();
				until not library.flags.noClipXray;
		
				for i, v in next, noclipBlocks do
					noclipBlocks[i].Transparency = 0;
					table.remove(noclipBlocks, i);
				end;
			end;
		
			function speedHack(toggle)
				if(not toggle) then
					maid.speedHack = nil;
					maid.speedHackBV = nil;
					return;
				end;
		
				maid.speedHack = RunService.Heartbeat:Connect(function()
					local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
					if (not rootPart) then return end;
		
					local camera = workspace.CurrentCamera;
					if (not camera) then return end;
					if(library.flags.fly) then
						maid.speedHackBV = nil;
						return;
					end;
		
					maid.speedHackBV = (maid.speedHackBV and maid.speedHackBV.Parent and maid.speedHackBV) or Instance.new('BodyVelocity');
		
					maid.speedHackBV.Parent = rootPart;
					maid.speedHackBV.MaxForce = Vector3.new(100000, 0, 100000);
					maid.speedHackBV.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.speedhackSpeed);
				end);
			end;
		
			function fly(toggle)
				if(not toggle) then
					maid.fly = nil;
					maid.flyBV = nil;
					return;
				end;
		
				maid.fly = RunService.Heartbeat:Connect(function()
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if (not rootPart) then return end;
		
					local camera = workspace.CurrentCamera;
					if (not camera) then return end;
		
					maid.flyBV = (maid.flyBV and maid.flyBV.Parent and maid.flyBV) or Instance.new('BodyVelocity');
		
					maid.flyBV.Parent = rootPart;
					maid.flyBV.MaxForce = Vector3.new(math.huge, math.huge, math.huge);
					maid.flyBV.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.flySpeed);
				end);
			end;
		
			function antiFire(toggle)
				if(not toggle) then return end;
		
				repeat
					local Character = LocalPlayer.Character;
					if(Character and Character:FindFirstChild('Burning') and dodge) then
						if(isGaia) then
							dodge:FireServer({4, math.random()});
						else
							dodge:FireServer('back', workspace.CurrentCamera);
						end;
					end;
		
					Heartbeat:Wait();
				until not library.flags.antiFire;
			end;
		
			function allowFood()
				if(LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('NoEat')) then
					LocalPlayer.Character.NoEat:Destroy();
				end;
			end;
		
			local oldAmbient, oldBritghtness = Lighting.Ambient, Lighting.Brightness;
		
			function fullBright(toggle)
				if(not toggle) then
					maid.fullBright = nil;
					Lighting.Ambient, Lighting.Brightness = oldAmbient, oldBritghtness;
					return
				end;
		
				oldAmbient, oldBritghtness = Lighting.Ambient, Lighting.Brightness;
				maid.fullBright = Lighting:GetPropertyChangedSignal('Ambient'):Connect(function()
					Lighting.Ambient = Color3.fromRGB(255, 255, 255);
					Lighting.Brightness = 1;
				end);
				Lighting.Ambient = Color3.fromRGB(255, 255, 255);
			end;
		
			function infiniteJump(toggle)
				if(not toggle) then return end;
		
				repeat
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if(rootPart and UserInputService:IsKeyDown(Enum.KeyCode.Space) and not chatFocused) then
						rootPart.Velocity = Vector3.new(rootPart.Velocity.X, library.flags.infiniteJumpHeight, rootPart.Velocity.Z);
					end;
					task.wait(0.1);
				until not library.flags.infiniteJump;
			end;
		
			function maxZoom(toggle)
				for _, v in next, getconnections(LocalPlayer.Changed) do
					v:Disable();
				end;
		
				LocalPlayer.CameraMaxZoomDistance = toggle and 9e9 or 50;
		
				for _, v in next, getconnections(LocalPlayer.Changed) do
					v:Enable();
				end;
			end;
		
			function spamClick(toggle)
				if(not toggle) then
					maid.spamClick = nil;
					return
				end;
		
				local lastClick = tick();
		
				maid.spamClick = RunService.RenderStepped:Connect(function()
					if(tick() - lastClick < 0.13) then return end;
					if(not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('CharacterHandler')) then return end;
					lastClick = tick();
		
					LocalPlayer.Character.CharacterHandler.Remotes.LeftClick:FireServer({math.random(1, 10), math.random()});
				end);
			end;
		
			function clickDestroy()
				if(Mouse.Target and not Mouse.Target:IsA('Terrain')) then
					Mouse.Target:Destroy();
				end;
			end;
		
			function instantLog()
				repeat
					task.wait();
				until LocalPlayer.Character and not LocalPlayer.Character:FindFirstChild('Danger');
		
				LocalPlayer:Kick('Logged Out Closing Roblox...');
				delay(5, function()
					game:Shutdown();
				end);
			end;
		
			function respawn()
				if (library:ShowConfirm('Are you sure you want to respawn ?')) then
					local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
					if(not humanoid) then return end;
		
					humanoid.Health = 0;
				end;
			end;
		
			function chatLoggerSetEnabled(state)
				chatLogger:SetVisible(state);
			end;
		
			function removeKillBricks(toggle)
				if(not toggle) then
					maid.removeKillBricks = nil;
				else
					maid.removeKillBricks = RunService.Heartbeat:Connect(function()
						local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
						if(not rootPart) then return end;
		
						local inDanger = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Danger');
		
						if(rootPart.Position.Y <= -550 and not library.flags.fly and inDanger) then
							library.options.fly:SetState(true);
							ToastNotif.new({
								text = 'You were about to die, so script automatically enabled fly to prevent you from dying :sungl:'
							});
						end;
					end);
				end;
		
				for i,v in next, killBricks do
					v.Parent = not toggle and workspace or nil;
				end;
			end;
		
			do -- // Auto Pickup
				local trinkets = {};
				local ingredients = {};
		
				local function onChildAdded(obj)
					local isIngredient = obj.Parent == ingredientsFolder;
					local isTrinket = not isIngredient;
					local t = isIngredient and ingredients or trinkets;
		
					if(isIngredient or (obj:FindFirstChild('Part') and obj.Part.Size == Vector3.new(1.5, 1.5, 1.5))) then
						table.insert(t, obj);
		
						local propertyWatched = isIngredient and 'Transparency' or 'Parent';
						local connection;
						connection = obj:GetPropertyChangedSignal(propertyWatched):Connect(function()
							task.wait();
							if(obj.Parent and isIngredient or not connection) then return end;
		
							if(obj:IsDescendantOf(game)) then return; end
		
							connection:Disconnect();
							connection = nil;
		
							table.remove(t, table.find(t, obj));
						end);
					end;
				end;
		
				library.OnLoad:Connect(function()
					if (library.flags.collectorAutoFarm) then
						warn('[Auto Pickup] Not enabling cuz collector bot is on');
						return;
					end;
		
					if(ingredientsFolder) then
						for _, obj in next, ingredientsFolder:GetChildren() do
							task.spawn(onChildAdded, obj);
						end;
		
						ingredientsFolder.ChildAdded:Connect(onChildAdded);
					end;
		
					for _, obj in next, workspace:GetChildren() do
						task.spawn(onChildAdded, obj);
					end;
		
					workspace.ChildAdded:Connect(onChildAdded);
				end);
		
				local function makeAutoPickup(maidName, t)
					return function(toggle)
						if(not toggle) then
							maid[maidName] = nil;
							return;
						end;
		
						local lastUpdate = 0;
		
						maid[maidName] = RunService.RenderStepped:Connect(function()
							local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
							if(not rootPart or tick() - lastUpdate < 0.2) then return end;
		
							lastUpdate = tick();
		
							for i,v in next, t do
								if((rootPart.Position - v.Position).Magnitude <= 25) then
									local clickDetector = v:FindFirstChildWhichIsA('ClickDetector', true);
									if(clickDetector and clickDetector.MaxActivationDistance <= 100) then
										fireclickdetector(clickDetector, 1);
									end;
								end;
							end;
						end);
					end;
				end;
		
				autoPickup = makeAutoPickup('autoPickup', trinkets);
				autoPickupIngredients = makeAutoPickup('autoPickupIngredients', ingredients);
			end;
		
			function attachToBack()
				local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
				if(not rootPart) then return end;
		
				for i, v in next, Players:GetPlayers() do
					local plrRoot = v.Character and v.Character:FindFirstChild('HumanoidRootPart');
					if(not plrRoot or v == LocalPlayer) then continue end;
		
					if((plrRoot.Position - rootPart.Position).Magnitude <= 50) then
						rootPart.CFrame = CFrame.new(plrRoot.Position - plrRoot.CFrame.LookVector * 2, plrRoot.Position);
						break;
					end;
				end
			end;
		
			function disableAmbientColors(t)
				if(not t) then
					maid.disableAmbientColors = nil;
					task.wait();
					Lighting.areacolor.Enabled = true;
					return;
				end;
		
				maid.disableAmbientColors = RunService.Heartbeat:Connect(function()
					if(not Lighting:FindFirstChild('areacolor')) then return end;
					Lighting.areacolor.Enabled = false;
				end);
			end;
		
			function streamerMode(toggle)
				local defaultCharName;
		
				local function updateStreamerMode(value)
					local statGui = LocalPlayer:FindFirstChild('PlayerGui') and LocalPlayer.PlayerGui:FindFirstChild('StatGui');
					local container = statGui and statGui:FindFirstChild('Container');
					local characterName = container and container:FindFirstChild('CharacterName');
					local characterNameShadow = characterName and characterName:FindFirstChild('Shadow');
		
					if(not defaultCharName and characterName) then
						defaultCharName = characterName.Text;
					end;
		
					local leaderstats = LocalPlayer and LocalPlayer:FindFirstChild('leaderstats');
					local hidden =  leaderstats and leaderstats:FindFirstChild('Hidden');
		
					local deadContainer = statGui and statGui:FindFirstChildOfClass('TextLabel');
		
					if (hidden) then
						hidden.Value = value;
					end;
		
					if(characterName and characterNameShadow) then
						characterName.Text = value and "" or defaultCharName;
						characterNameShadow.Text = value and "" or defaultCharName;
					end;
		
					if(deadContainer) then
						deadContainer.Visible = not value;
					end;
				end;
		
				repeat
					updateStreamerMode(true)
					task.wait();
				until not library.flags.streamerMode;
		
				updateStreamerMode(false);
			end;
		
			function spellStacking(toggle)
				if(not toggle) then
					maid.spellStacking = nil;
					return;
				end;
		
				maid.spellStacking = RunService.RenderStepped:Connect(function()
					local Character = LocalPlayer.Character;
					if (not Character) then return end;
		
					local activeCast = Character:FindFirstChild('ActiveCast') or Character:FindFirstChild('VampiriusCast');
					local boosts = Character and Character:FindFirstChild('Boosts');
		
					if(activeCast) then
						activeCast:Destroy();
					end;
		
					if(boosts) then
						for i, v in next, boosts:GetChildren() do
							if(v.Name == "SpeedBoost" and v.Value <= 0) then
								v:Destroy();
							end;
						end;
					end;
				end);
			end;
		
			function antiHystericus(toggle)
				local antiHystericusList = {'NoControl', 'Confused'};
				if(not toggle) then return end;
		
				repeat
					task.wait();
					if(not LocalPlayer.Character) then continue end;
		
					removeGroup(LocalPlayer.Character, antiHystericusList);
				until not library.flags.antiHystericus;
			end;
		
			function spectatePlayer(playerName)
				playerName = tostring(playerName);
				local player = findPlayer(playerName);
				local playerHumanoid = player and player.Character and player.Character:FindFirstChildOfClass('Humanoid');
		
				if(playerHumanoid) then
					workspace.CurrentCamera.CameraType = Enum.CameraType.Custom;
					workspace.CurrentCamera.CameraSubject = playerHumanoid;
				end;
			end;
		
			local furnaceFolder;
			local allFurnaces = {};
		
			do
				Utility.listenToChildAdded(workspace, function(obj)
					if(obj.Name == 'PortableFurnace' and obj:IsA('Model')) then
						table.insert(allFurnaces, obj);
						obj.Destroying:Connect(function()
							table.remove(allFurnaces, table.find(allFurnaces, obj));
						end);
					end;
				end);
			end;
		
			function autoSmelt(toggle)
				if(not toggle) then return end;
		
				if (not furnaceFolder) then
					furnaceFolder = workspace:FindFirstChild('Bed', true);
					furnaceFolder = furnaceFolder and furnaceFolder.Parent;
				end;
		
				local lastSmeltAttempt;
				repeat
					task.wait();
					local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid');
					if(not humanoid or not furnaceFolder or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart')) then continue end;
		
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					local isNearFurnace = false;
					local currentFurnace;
		
					for i, v in next, furnaceFolder:GetChildren() do
						if(v.Name == 'Furnace' and v:IsA('BasePart') and (v.Position - rootPart.Position).Magnitude <= 25) then
							isNearFurnace = true;
							currentFurnace = v;
							break;
						end;
					end;
		
					if (not currentFurnace) then
						for _, v in next, allFurnaces do
							if ((v.PrimaryPart.Position - rootPart.Position).Magnitude <= 25) then
								local furnace = v:FindFirstChild('Furnace');
								if (not furnace) then continue end;
				
								warn('wee', furnace);
								isNearFurnace = true;
								currentFurnace = furnace;
								break;
							end;
						end;
					end;
		
					if(not isNearFurnace) then continue; end;
		
					for _, v in next, LocalPlayer.Backpack:GetChildren() do
						if (not library.flags.autoSmelt) then break end;
						if (not v:FindFirstChild('Ore')) then continue end;
						local handle = v:FindFirstChild('Handle');
						if (not handle) then continue end;
		
						firetouchinterest(handle, currentFurnace, 0);
						lastSmeltAttempt = tick();
						humanoid:EquipTool(v);
						repeat task.wait() until v.Parent == nil or tick() - lastSmeltAttempt >= 2;
						firetouchinterest(handle, currentFurnace, 1);
					end;
				until not library.flags.autoSmelt;
			end;
		
			function autoSell(toggle)
				if(not toggle) then
					return;
				end;
		
				local lastUpdate = 0;
				local artifactsList = {'Phoenix Down', 'Lannis\'s Amulet', 'Spider Cloak', 'Philosopher\'s Stone', 'Ice Essence', 'Howler Friend', 'Amulet of the White King', 'Fairfrozen', 'Scroom Key', 'Nightstone', 'Rift Gem', 'Scroll of Manus Dei', 'Scroll of Fimbulvetr', 'Mysterious Artifact'};
		
				repeat
					task.wait()
					if(tick() - lastUpdate < 1) then continue end;
		
					local merchant = getCurrentNpc({'Merchant', 'Pawnbroker'});
					if(not merchant) then continue end;
		
					local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
					if(not humanoid) then continue end;
		
					if(library.flags.autoSellValues.Scrolls or library.flags.autoSellValues.Gems or library.flags.autoSellValues.Swords) then
						local scroll;
		
						for i, v in next, LocalPlayer.Backpack:GetChildren() do
							if(table.find(artifactsList, v.Name)) then continue end;
							if(v:FindFirstChild('SpellType') and library.flags.autoSellValues.Scrolls or v:FindFirstChild('Gem') and library.flags.autoSellValues.Gems or v:FindFirstChild('Smithed') and library.flags.autoSellValues.Swords) then
								scroll = v;
							end;
						end;
		
						if(not scroll) then continue end;
						lastUpdate = tick();
		
						humanoid:EquipTool(scroll);
						fireclickdetector(merchant.ClickDetector, 1);
						task.wait(0.2);
						dialog:FireServer({choice = 'Could you appraise this for me?'});
						task.wait(0.2);
						dialog:FireServer({choice = 'It\'s a deal.'});
						task.wait(0.2);
						dialog:FireServer({exit = true});
		
						continue;
					end;
				until not library.flags.autoSell;
			end;
		
			function manaAdjust(toggle)
				if(not toggle) then
					if(LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Charge')) then
						dechargeMana();
					end;
		
					return;
				end;
		
				repeat
					task.wait();
					local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
					if(currentTool and spellValues[currentTool.Name] and library.flags.spellAdjust) then continue; end;
		
					chargeManaUntil(library.flags.manaAdjustAmount);
				until not library.flags.manaAdjust;
			end;
		
			function wipe()
				if (library:ShowConfirm('Are you sure you want to wipe your account ?')) then
					fallDamage:FireServer({math.random(), 3})
					task.wait(1);
					if(LocalPlayer.Character:FindFirstChild('Head')) then
						LocalPlayer.Character.Head:Destroy();
					end;
				end;
			end;
		
			function toggleTrinketEsp(toggle)
				if(not toggle) then
					maid.trinketEsp = nil;
					trinketEspBase:Disable();
					return;
				end;
		
				maid.trinketEsp = workspace.CurrentCamera:GetPropertyChangedSignal('CFrame'):Connect(function()
					debug.profilebegin('Trinket Esp Update');
					trinketEspBase:UpdateAll();
					debug.profileend();
				end);
			end;
		
			function toggleIngredientsEsp(toggle)
				if(not toggle) then
					maid.ingredientEsp = nil;
					ingredientEspBase:Disable();
					return;
				end;
		
				maid.ingredientEsp = workspace.CurrentCamera:GetPropertyChangedSignal('CFrame'):Connect(function()
					debug.profilebegin('Ingredient Esp Update');
					ingredientEspBase:UpdateAll();
					debug.profileend();
				end);
			end;
		
			function toggleMobEsp(toggle)
				if(not toggle) then
					maid.mobEsp = nil;
					mobEspBase:Disable();
					return;
				end;
		
				maid.mobEsp = workspace.CurrentCamera:GetPropertyChangedSignal('CFrame'):Connect(function()
					debug.profilebegin('Mob Esp Update');
					mobEspBase:UpdateAll();
					debug.profileend();
				end);
			end;
		
			function toggleNpcEsp(toggle)
				if(not toggle) then
					maid.npcEsp = nil;
					npcEspBase:Disable();
					return;
				end;
		
				maid.npcEsp = workspace.CurrentCamera:GetPropertyChangedSignal('CFrame'):Connect(function()
					debug.profilebegin('Npc Esp Update');
					npcEspBase:UpdateAll();
					debug.profileend();
				end);
			end;
		
			function toggleBagEsp(toggle)
				if(not toggle) then
					maid.bagEsp = nil;
					bagEspBase:Disable();
					return;
				end;
		
				maid.bagEsp = workspace.CurrentCamera:GetPropertyChangedSignal('CFrame'):Connect(function()
					debug.profilebegin('Bag Esp Update');
					bagEspBase:UpdateAll();
					debug.profileend();
				end);
			end;
		
			function toggleSpellAutoCast(toggle)
				if(not toggle) then
					maid.spellCast = nil;
					return;
				end;
		
				local lastCast = 0;
		
				maid.spellCast = RunService.RenderStepped:Connect(function()
					if(tick() - lastCast <= 2.5 and not library.flags.spellStacking) then return end;
		
					local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
					if(not currentTool) then return end;
		
					local amounts = spellValues[currentTool.Name];
					if(not amounts) then return end;
		
					local useSnap = library.flags[toCamelCase(currentTool.Name .. ' Use Snap')];
					amounts = amounts[useSnap and 2 or 1];
		
					local mana = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Mana');
					if(not mana) then return end;
		
					if(mana.Value > amounts.min and mana.value < amounts.max) then
						lastCast = tick();
						if(useSnap) then
							LocalPlayer.Character.CharacterHandler.Remotes.RightClick:FireServer({math.random(1, 10), math.random()});
						else
							LocalPlayer.Character.CharacterHandler.Remotes.LeftClick:FireServer({math.random(1, 10), math.random()});
						end;
					end;
				end);
			end;
		
			function toggleSpellAdjust(toggle)
				if(not toggle) then return; end;
		
				repeat
					RunService.RenderStepped:Wait();
		
					local currentTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
					if(not currentTool) then continue; end;
		
					local amounts = spellValues[currentTool.Name];
					if(not amounts) then continue end;
		
					local useSnap = library.flags[toCamelCase(currentTool.Name .. ' Use Snap')];
					amounts = amounts[useSnap and 2 or 1];
		
					local amount = amounts.max - (amounts.max  - amounts.min) / 2;
		
					chargeManaUntil(amount);
				until not library.flags.spellAdjust;
			end;
		
			function goToGround()
				local params = RaycastParams.new();
				params.FilterDescendantsInstances = {workspace.Live, workspace.NPCs, workspace.AreaMarkers};
				params.FilterType = Enum.RaycastFilterType.Blacklist;
		
				local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
				if (not rootPart) then return end;
		
				-- setclipboard(tostring(Character.HumanoidRootPart.Position));
				local floor = workspace:Raycast(rootPart.Position, Vector3.new(0, -1000, 0), params);
				if(not floor) then return end;
		
				rootPart.CFrame = rootPart.CFrame * CFrame.new(0, -(rootPart.Position.Y - floor.Position.Y) + 3, 0);
				-- rootPart.Velocity = Vector3.new(rootPart.Velocity.X, 0, rootPart.Velocity.Z);
			end;
		
			function pullToGround(t)
				if (not t) then
					maid.pullToGround = nil;
					return;
				end;
		
				local params = RaycastParams.new();
				params.FilterDescendantsInstances = {workspace.Live, workspace.NPCs, workspace.AreaMarkers};
				params.FilterType = Enum.RaycastFilterType.Blacklist;
				params.IgnoreWater = true;
				params.RespectCanCollide = true;
		
				maid.pullToGround = task.spawn(function()
					while true do
						task.wait(0.1);
						local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
						if (not rootPart) then continue end;
		
						local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid');
						if (not humanoid) then continue end;
		
						if(humanoid.FloorMaterial ~= Enum.Material.Air) then continue; end;
						if (library.flags.fly or UserInputService:IsKeyDown(Enum.KeyCode.Space)) then continue; end;
		
						local floor = workspace:Raycast(rootPart.Position, Vector3.new(0, -1000, 0), params);
						if (not floor) then continue end;
		
						rootPart.CFrame = rootPart.CFrame * CFrame.new(0, -(rootPart.Position.Y - floor.Position.Y) + 3, 0);
						rootPart.Velocity = Vector3.zero;
					end;
				end);
			end;
		
			function setLocation()
				if (not library:ShowConfirm(string.format('Are you sure you want to tp to %s', library.flags.location))) then return end;
		
				local npc = spawnLocations[library.flags.location];
				local char = game.Players.LocalPlayer.Character;
		
				local con;
				con = RunService.Heartbeat:Connect(function()
					sethiddenproperty(LocalPlayer, 'MaxSimulationRadius', math.huge);
					sethiddenproperty(LocalPlayer, 'SimulationRadius', math.huge);
				end)
		
				dialog:FireServer({choice = 'Sure.'})
				for i = 1,10 do
					char:BreakJoints();
					task.wait();
					char:PivotTo(npc:GetPivot());
					char.HumanoidRootPart.CFrame = npc:GetPivot();
		
					task.wait(0.1);
					fireclickdetector(npc.ClickDetector);
					task.wait(0.2)
				end;
		
				con:Disconnect();
			end;
		
			function serverHop()
				if(LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Danger')) then
					repeat
						task.wait()
					until not LocalPlayer.Character:FindFirstChild('Danger');
				end;
		
				LocalPlayer:Kick('Server Hopping...');
				findServer();
			end;
		
			function satan(toggle)
				if (not toggle) then
					maid.satan = nil;
		
					if(LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid')) then
						LocalPlayer.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, true);
					end;
		
					return;
				end;
		
				maid.satan = RunService.Heartbeat:Connect(function()
					if(not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid')) then return end;
		
					LocalPlayer.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false);
				end);
			end;
		
			function noStun(toggle)
				if (not toggle) then
					maid.noStun = nil;
					return;
				end;
		
				maid.noStun = RunService.Heartbeat:Connect(function()
					local character = LocalPlayer.Character;
					if (not character) then return end;
		
					if (character:FindFirstChild('Action')) then character.Action:Destroy() end;
					if (character:FindFirstChild('NoJump')) then character.NoJump:Destroy() end;
				end);
			end;
		
			function infMana(toggle)
				if (not toggle) then
					maid.infMana = nil;
					return;
				end;
		
				maid.infMana = RunService.Heartbeat:Connect(function()
					local mana = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Mana');
					if (not mana) then return end;
		
					mana.Value = 100;
				end);
			end;
		
			function flyOwnership(toggle)
				if (not toggle) then
					maid.flyOwnership = nil;
					return;
				end;
		
				maid.flyOwnership = RunService.Heartbeat:Connect(function()
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if (not rootPart) then return end;
		
					local bone = rootPart and rootPart:findFirstChild('Bone');
		
					if (bone and bone:FindFirstChild('Weld')) then
						bone.Weld:Destroy();
					end;
				end);
			end;
		
			function knockYourself()
				if (library:ShowConfirm('Are you sure you want to knock yourself ?')) then
					fallDamage:FireServer({math.random(), 1});
				end;
			end;
		
			local stringFormat = string.format;
			local bags = {};
		
			function autoPickupBag(toggle)
				if (not toggle) then
					maid.autoBagPickup = nil;
					return
				end;
		
				maid.autoBagPickup = RunService.Heartbeat:Connect(function()
					local rootPart = Utility:getRootPart();
					if (not rootPart) then return end;
		
					for _, bag in next, bags do
						local dist = (rootPart.Position - bag.Position).Magnitude;
						local range = bag.Name == 'ToolBag' and library.flags.bagPickupRange or library.flags.bagPickupRange * 2;
						if (dist > range) then continue end;
		
						task.spawn(function()
							firetouchinterest(bag, rootPart, 0);
							task.wait();
							firetouchinterest(bag, rootPart, 1);
						end);
					end;
				end);
			end;
		
			function EntityESP:Plugin()
				local holdingItem = self._player.Character and self._player.Character:FindFirstChildWhichIsA('Tool');
				local firstName = getPlayerStats(self._player);
				local manaAbilities = self._player.Character and self._player.Character:FindFirstChild('ManaAbilities');
		
				return {
					text = stringFormat(
						'\n[%s] [%s] [%s] [%s] %s',
						firstName,
						getPlayerClass(self._player),
						getPlayerRace(self._player),
						holdingItem and holdingItem.Name or 'None',
						manaAbilities and not manaAbilities:FindFirstChild('ManaSprint') and '[Day 0]' or ''
					);
				}
			end;
		
			local function initEspStuff()
				local damageIndicator = {};
		
				do -- // Player Stuff
					local blacklistedHouses = {'Mudock', 'Mudockfat', 'Archfat', 'Female'};
					local mudockList = {};
		
					local function isInGroup(player, groupId)
						local suc, err = pcall(player.IsInGroup, player, groupId);
		
						if(not suc) then return false end;
						return err;
					end;
		
					local function addIllusionist(player)
						if(illusionists[player]) then return end;
						illusionists[player] = true;
		
						loadSound('IllusionistJoin.mp3');
						makeNotification('Illusionist Alert', string.format('[%s] Has joined your game', player.Name), true);
					end;
		
					local artifactsList = {'Phoenix Down', 'Lannis\'s Amulet', 'Spider Cloak', 'Philosopher\'s Stone', 'Ice Essence', 'Howler Friend', 'Amulet of the White King', 'Fairfrozen', 'Scroom Key', 'Nightstone', 'Rift Gem', 'Scroll of Manus Dei', 'Scroll of Fimbulvetr', 'Mysterious Artifact'};
		
					local function onPlayerAdded(player)
						if(player == LocalPlayer) then return end;
		
						local seen = {};
		
						local function onCharacterAdded(character)
							local backpack = player:WaitForChild('Backpack');
							local spectating = false;
		
							local function onChildAddedPlayer(obj)
								if (library.flags.artifactNotifier and (table.find(artifactsList, obj.Name) or obj:FindFirstChild('Artifact')) and not table.find(seen, obj.Name) and obj.Parent == backpack) then
									table.insert(seen, obj.Name);
									ToastNotif.new({
										text = string.format('%s has %s', player.Name, obj.Name)
									});
								end;
		
								if(obj.Name ~= 'Observe') then return end;
								addIllusionist(player);
		
								if(not library.flags.illusionistNotifier) then return end;
								print(player.Name, obj.Parent == character and 'in character' or 'in backpack');
		
								if(obj.Parent ~= backpack and not spectating) then
									spectating = true;
									loadSound('IllusionistSpectateStart.mp3');
									makeNotification('Spectate Alert', string.format('[%s] Started spectating', player.Name), true);
		
									if(library.flags.autoPanic and library.flags.autoPanicValues['Spectate']) then
										panic();
									end;
								end;
							end;
		
							local function onChildRemovedPlayer(obj)
								if(obj.Name ~= 'Observe' or not spectating) then return end;
		
								spectating = false;
								loadSound('IllusionistSpectateEnd.mp3');
								makeNotification('Spectate Alert', string.format('[%s] Stopped spectating', player.Name), true);
							end;
		
							Utility.listenToChildAdded(backpack, onChildAddedPlayer);
							Utility.listenToChildAdded(character, onChildAddedPlayer);
							character.ChildRemoved:Connect(onChildRemovedPlayer);
		
							local humanoid = character:WaitForChild('Humanoid');
							local head = character:WaitForChild('Head');
		
							local currentHealth = humanoid.Health;
		
							humanoid.HealthChanged:Connect(function(newHealth)
								if(newHealth < currentHealth and library.flags.damageIndicator and damageIndicator.new) then
									damageIndicator.new(head, currentHealth - newHealth);
								end;
		
								currentHealth = humanoid.Health;
							end);
						end;
		
						if(player.Character) then
							task.spawn(onCharacterAdded, player.Character);
						end;
		
						player.CharacterAdded:Connect(onCharacterAdded);
		
						if(string.find(moderatorIds, tostring(player.UserId)) or isInGroup(player, 4556484)) then
							moderatorInGame = true;
							allMods[player] = true;
		
							makeNotification('Mod Alert', string.format('[%s] Has joined your game.', player.Name), true);
		
							if(library.flags.autoPanic and library.flags.autoPanicValues['Mod Join']) then
								task.spawn(panic);
							end;
		
							loadSound('ModeratorJoin.mp3');
						end;
		
						if(table.find(blacklistedHouses, player:GetAttribute('LastName') or 'Unknown')) then
							makeNotification('Mudock Alert', string.format('[%s] Has joined your game', player.Name), true);
							mudockList[player] = true;
		
							if(library.flags.autoPanic and library.flags.autoPanicValues['Mudock Join']) then
								panic();
							end;
						end;
					end;
		
					local function onPlayerRemoving(player)
						if(allMods[player]) then
							moderatorInGame = false;
							allMods[player] = nil;
							loadSound('ModeratorLeft.mp3');
							makeNotification('Mod Alert', string.format('%s left the game', tostring(player)), true);
						end;
		
						if(illusionists[player]) then
							makeNotification('Illusionist', string.format('[%s] Has left your game', player.Name), true);
							loadSound('IllusionistLeft.mp3');
							illusionists[player] = nil;
						end;
		
						if(mudockList[player]) then
							makeNotification('Mudock Alert', string.format('%s Has left your game', tostring(player)), true);
							mudockList[player] = nil;
						end;
					end;
		
					for i, v in next, Players:GetPlayers() do
						task.spawn(onPlayerAdded, v);
					end;
		
					Players.PlayerAdded:Connect(onPlayerAdded);
					Players.PlayerRemoving:Connect(onPlayerRemoving);
				end;
		
				if (library.flags.collectorAutoFarm) then
					warn('[Player ESP] Not turning off cause player has collector bot on');
					return;
				end;
		
				local function getId(id)
					return id:gsub('%%20', ''):gsub('%D', '');
				end;
		
				local function findInTable(t, index, value)
					for i, v in next, t do
						if v[index] == value then
							return v;
						end;
					end;
				end;
		
				local opalColor = Vector3.new(1, 1, 1);
		
				function getTrinketType(v) -- // This code is from the old source too lazy to remake it as this one works properly
					if (v.Name == "Part" or v.Name == "Handle" or v.Name == "MeshPart") and (v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("MeshPart")) then
						local Mesh = (v:IsA("MeshPart") and v) or v:FindFirstChildOfClass("SpecialMesh");
						local ParticleEmitter = v:FindFirstChildOfClass("ParticleEmitter");
						local Attachment = v:FindFirstChildOfClass("Attachment");
						local PointLight = v:FindFirstChildOfClass("PointLight");
						local Material = v.Material;
						local className = v.ClassName;
						local Size = v.Size;
						local SizeMagnitude = Size.Magnitude;
						local Color = v.BrickColor.Name;
		
						if(className == "UnionOperation" and Material == Enum.Material.Neon and SizeMagnitude < 3.1 and SizeMagnitude > 2) then
							if(not v.UsePartColor) then
								return trinketsData["White King's Amulet"];
							else
								return trinketsData["Lannis Amulet"];
							end;
						end;
		
						if(className == "Part" and v.Shape == Enum.PartType.Block and Material == Enum.Material.Neon and Color == "Pastel Blue" and Mesh.MeshId == "") then
							return trinketsData["Fairfrozen"];
						end;
		
						if(SizeMagnitude < 0.9 and Material == Enum.Material.Neon and className == "UnionOperation" and v.Transparency == 0) then
							if(Color == "Persimmon") then
								return trinketsData["Philosopher's Stone"];
							elseif(Color == "Black") then
								return trinketsData["Night Stone"];
							end;
						end;
		
						if(Material == Enum.Material.DiamondPlate and v.Transparency == 0 and PointLight and PointLight.Brightness == 0.5) then
							return trinketsData["Scroom Key"];
						end;
		
						if(className == "MeshPart" and getId(v.MeshId) == "2520762076") then
							return trinketsData["Howler Friend"];
						end;
		
						if(Mesh and getId(Mesh.MeshId) == "2877143560") then
							if(string.find(Color, "green")) then
								return trinketsData["Emerald"];
							elseif(Color == "Really red") then
								return trinketsData["Ruby"];
							elseif(Color == "Lapis") then
								return trinketsData["Sapphire"];
							elseif(string.find(Color, "blue")) then
								return trinketsData["Diamond"];
							else
								return trinketsData["Rift Gem"];
							end;
						end;
		
						if(ParticleEmitter and ParticleEmitter.Texture:find("20443483") and SizeMagnitude > 0.6 and SizeMagnitude < 0.8 and v.Transparency == 1 and Material == Enum.Material.Neon) then
							if(className == "Part") then
								return trinketsData["Ice Essence"];
							end;
							return trinketsData["Spider Cloak"];
						end;
		
						if(ParticleEmitter) then
							local TextureId = ParticleEmitter.Texture:gsub("%D", "");
							local Trinket = findInTable(Trinkets, "Texture", TextureId);
		
							if(Trinket) then
								return Trinket;
							end;
						end;
		
						if(Mesh and Mesh.MeshId ~= "") then
							local MeshId = Mesh.MeshId:gsub("%D", "");
							local Trinket = findInTable(Trinkets, "MeshId", MeshId);
		
							if(Trinket) then
								return Trinket;
							end;
						end;
		
						if(ParticleEmitter and Material == Enum.Material.Slate) then
							return trinketsData["Idol Of The Forgotten"];
						end;
		
						if(Attachment) then
							if(Attachment:FindFirstChildOfClass("ParticleEmitter")) then
								local ParticleEmitter2 = Attachment:FindFirstChildOfClass("ParticleEmitter");
		
								if (ParticleEmitter2) then
									local TextureId = getId(ParticleEmitter2.Texture);
									if(TextureId == '1536547385') then
										if(ParticleEmitter2.Size.Keypoints[1].Value ~= 0) then
											return trinketsData['Mysterious Artifact'];
										end;
		
										return trinketsData['Pheonix Down'];
									end
									local Trinket = findInTable(Trinkets, "Texture", TextureId);
									return Trinket;
								end;
							end;
						end;
		
						if(Mesh and Mesh:IsA('SpecialMesh') and Mesh.MeshType.Name == 'Sphere' and Mesh.VertexColor == opalColor) then
							return trinketsData.Opal;
						end;
					end;
				end;
		
				local id = 0;
		
				local ingredientsIds = {
					['2766802766'] = 'Strange Tentacle',
					['2766925214'] = 'Crown Flower',
					['2766802731'] = 'Dire Flower',
					['3215371492'] = 'Potato',
					['2766802752'] = 'Orcher Leaf',
					['2620905234'] = 'Scroom',
					['2766925289'] = 'Trote',
					['2766925228'] = 'Tellbloom',
					['2766925245'] = 'Uncanny Tentacle',
					['2575167210'] = 'Moss Plant',
					['2773353559'] = 'Bloodthorn',
					['2766802713'] = 'Periascroom',
					['2766925267'] = 'Creely',
					['3049928758'] = 'Canewood',
					['3049345298'] = 'Zombie Scroom',
					['3049556532'] = 'Acorn Light',
					['2766925320'] = 'Polar Plant',
					['2577691737'] = 'Lava Flower',
					['2573998175'] = 'Freeleaf',
					['2618765559'] = 'Glow Scroom',
					['2766925304'] = 'Vile Seed',
					['2889328388'] = 'Ice Jar',
					['2960178471'] = 'Snow Scroom',
					['3293218896'] = 'Desert Mist',
				}
		
				local function getIngredientType(v) -- // Also old code but still works very well!
					local specialInfo = getspecialinfo and getspecialinfo(v) or getproperties(v);
					local assetId = specialInfo and specialInfo.AssetId and specialInfo.AssetId:match('%d+') or 'NIL';
		
					if(ingredientsIds[assetId]) then
						return ingredientsIds[assetId];
					else
						id = id + 1;
						return string.format('Unknown %s', id);
					end;
				end;
		
				local objectsRaycastFilter = RaycastParams.new();
				objectsRaycastFilter.FilterType = Enum.RaycastFilterType.Whitelist;
				objectsRaycastFilter.FilterDescendantsInstances = {workspace.AreaMarkers};
		
				local function onChildAdded(object)
					task.wait(1);
					if (not object:IsA('BasePart')) then return; end;
		
					local trinketType = getTrinketType(object);
					if (not trinketType or not object:FindFirstChildWhichIsA('ClickDetector', true)) then return end;
		
					local location = workspace:Raycast(object.Position, Vector3.new(0, 5000, 0), objectsRaycastFilter);
					location = location and location.Instance.Name or '???';
		
					local self = trinketEspBase.new(object, trinketType.Name);
					self._text = string.format('%s] [%s', trinketType.Name, location);
		
					self._maid:GiveTask(object:GetPropertyChangedSignal('Parent'):Connect(function()
						if(object.Parent) then return end;
						self:Destroy();
					end));
				end;
		
				local function onChildAddedIngredient(object)
					if (not IsA(object, 'BasePart')) then return; end;
		
					local ingredientType = getIngredientType(object);
					if (not ingredientType) then return end;
		
					local location = workspace:Raycast(object.Position, Vector3.new(0, 5000, 0), objectsRaycastFilter);
					location = location and location.Instance.Name or '???';
		
					local maid = Maid.new();
		
					if (object.Transparency == 0) then
						local obj = ingredientEspBase.new(object, ingredientType);
						maid.espObject = function()
							obj:Destroy();
						end;
					end;
		
					object:GetPropertyChangedSignal('Transparency'):Connect(function()
						if(object.Transparency == 0) then
							local obj = ingredientEspBase.new(object, ingredientType);
							maid.espObject = function()
								obj:Destroy();
							end;
						elseif (maid.espObject) then
							maid.espObject = nil;
						end;
					end);
				end;
		
				local function onMobAdded(object)
					task.wait(1);
					if (not object:FindFirstChild('MonsterInfo') or not object.MonsterInfo:FindFirstChild('MonsterType')) then
						return;
					end;
		
					local head = object:FindFirstChild('Head') or object.PrimaryPart;
					if (not head) then return end;
		
					local self = mobEspBase.new(head, object.MonsterInfo.MonsterType.Value);
					self._maid:GiveTask(object:GetPropertyChangedSignal('Parent'):Connect(function()
						if (object.Parent) then return end;
						self:Destroy();
					end));
				end;
		
				local function onNpcAdded(object)
					local head = object:FindFirstChild('Head') or object.PrimaryPart;
					if (not head) then return end;
		
					local self = npcEspBase.new(head, object.Name);
					self._maid:GiveTask(object:GetPropertyChangedSignal('Parent'):Connect(function()
						if (object.Parent) then return end;
						self:Destroy();
					end));
				end;
		
				local function onBagAdded(object)
					if (object.Name ~= 'ToolBag' and object.Name ~= 'MoneyBag') then return end;
		
					table.insert(bags, object);
		
					local name = object:WaitForChild('BillboardGui', 1);
					name = name and name:WaitForChild('Tool', 1);
					name = name and name.Text;
		
					if(not name) then return end;
		
					local self = bagEspBase.new(object, name);
					self._maid:GiveTask(object:GetPropertyChangedSignal('Parent'):Connect(function()
						if(object.Parent) then return end;
						self:Destroy();
						table.remove(bags, table.find(bags, object));
					end));
				end;
		
				do -- // Damage Indicator
					damageIndicator.ClassName = 'DamageIndicator';
					damageIndicator.__index = damageIndicator;
		
					local function generateOffSet()
						local n = Random.new():NextNumber() * 2;
						if (Random.new():NextInteger(1, 2) == 1) then
							n = -n;
						end;
		
						return n;
					end;
		
					function damageIndicator.new(part, damage)
						local self = setmetatable({}, damageIndicator);
						self._maid = Maid.new();
						self._part = part;
						self._offset = Vector3.new(generateOffSet(), generateOffSet(), 0);
		
						self._gui = library:Create('ScreenGui', {
							Parent = game:GetService('CoreGui')
						});
		
						self._text = library:Create('TextLabel', {
							Parent = self._gui,
							Rotation = generateOffSet() * 5,
							Visible = true,
							TextColor3 = Color3.fromRGB(231, 76, 60),
						  Text = '-' .. tostring(math.ceil(damage)),
							BackgroundTransparency = 1,
							TextStrokeTransparency = 0,
							TextSize = 10
						});
		
						self._maid:GiveTask(self._gui);
		
						self._maid:GiveTask(RunService.Heartbeat:Connect(function()
							self:Update();
						end));
		
						task.delay(2, function()
							self:Destroy();
						end);
					end;
		
					function damageIndicator:Update()
						local partPosition, visible = workspace.CurrentCamera:WorldToViewportPoint(self._part.Position + self._offset);
						partPosition = Vector2.new(partPosition.X, partPosition.Y);
		
						self._text.Visible = visible;
						self._text.Position = UDim2.new(0, partPosition.X, 0, partPosition.Y);
					end;
		
					function damageIndicator:Destroy()
						assert(self._maid);
		
						self._maid:Destroy();
						self._maid = nil;
					end;
				end;
		
				if(ingredientsFolder) then
					Utility.listenToChildAdded(ingredientsFolder, onChildAddedIngredient);
				end;
		
				Utility.listenToChildAdded(workspace, onChildAdded);
				Utility.listenToChildAdded(workspace.Live, onMobAdded);
				Utility.listenToChildAdded(workspace:FindFirstChild('NPCs') or Instance.new('Folder'), onNpcAdded);
				Utility.listenToChildAdded(workspace.Thrown, onBagAdded);
			end;
		
			local climbBoost = Instance.new('NumberValue');
			climbBoost.Name = "ClimbBoost";
		
			task.spawn(function()
				local killPartsObjects = {'KillBrick', 'Lava', 'PoisonField', 'PitKillBrick'};
		
				local slate = Enum.Material.Slate;
				local map = isGaia and workspace:FindFirstChild('Map') or workspace;
		
				for i, v in next, map:GetChildren() do
					if(v.Name == 'Part' and IsA(v, 'Part') and v.Material == slate and v.CanCollide == false and v.Transparency == 1) then
						v.Transparency = 0.5;
						v.Color = Color3.fromRGB(255, 0, 0);
		
						local touchTransmitter = v:FindFirstChildWhichIsA('TouchTransmitter');
		
						if(touchTransmitter) then
							touchTransmitter:Destroy();
						end;
					elseif(table.find(killPartsObjects, v.Name)) then
						table.insert(killBricks, v);
					end;
				end;
			end);
		
			task.spawn(function()
				while task.wait(0.2) do
					local character = LocalPlayer.Character;
					local boosts = character and character:FindFirstChild('Boosts');
		
					if(boosts and library.flags.climbSpeed ~= 1) then
						climbBoost.Value = library.flags.climbSpeed;
						climbBoost.Parent = boosts;
					else
						climbBoost.Parent = nil;
					end;
		
					local leaderboardGui = LocalPlayer:FindFirstChild('PlayerGui') and LocalPlayer.PlayerGui:FindFirstChild('LeaderboardGui');
		
					if (leaderboardGui and not leaderboardGui.Enabled) then
						leaderboardGui.Enabled = true;
					end;
				end;
			end);
		
			task.spawn(function()
				if (not LocalPlayer.Character and not LocalPlayer.PlayerGui:FindFirstChild('LeaderboardGui')) then
					local newLeaderboardGui = StarterGui:FindFirstChild('LeaderboardGui'):Clone();
					newLeaderboardGui.Parent = LocalPlayer.PlayerGui;
		
					LocalPlayer.CharacterAdded:Wait();
					newLeaderboardGui:Destroy();
				end;
			end);
		
			local spectating;
			local oldNamesColors = {};
		
			UserInputService.InputBegan:Connect(function(input)
				if(input.UserInputType ~= Enum.UserInputType.MouseButton2) then return end;
				if(not LocalPlayer:FindFirstChild('PlayerGui') or not LocalPlayer.PlayerGui:FindFirstChild('LeaderboardGui')) then return end;
		
				local leaderboardPlayers = LocalPlayer.PlayerGui.LeaderboardGui.MainFrame.ScrollingFrame:GetChildren();
		
				local function getHoveredPlayer()
					for i,v in next, leaderboardPlayers do
						if(v.TextTransparency ~= 0) then
							return v;
						end;
					end;
				end;
		
				local label = getHoveredPlayer();
				if(not label) then return end;
		
				local player = Players:FindFirstChild(label.Text:gsub('\226\128\142', ''));
				if(not player or not player.Character) then return end;
		
				if(player == LocalPlayer) then
					spectating = player;
				end;
		
				for i, v in next, leaderboardPlayers do
					if(not oldNamesColors[v]) then
						oldNamesColors[v] = v.TextColor3;
					end;
		
					v.TextColor3 = oldNamesColors[v];
				end;
		
				if(spectating ~= player) then
					spectating = player;
					spectatePlayer(player.Name);
					label.TextColor3 = Color3.fromRGB(46, 204, 113);
				else
					spectating = nil;
					spectatePlayer(LocalPlayer.Name);
				end;
			end);
		
			library.OnLoad:Connect(initEspStuff);
		end;
		
		function Utility:renderOverload(data)
			local misc = data.column1:AddSection('Misc');
			local trinketEsp = data.column2:AddSection('Trinkets');
			local ingredientEsp = data.column2:AddSection('Ingredients');
		
			local trinketsToggles = {};
			local ingrdientsToggles = {};
		
			data.espSettings:AddBox({
				text = 'ESP Search',
				skipflag = true,
				noload = true
			});
		
			local function createEspList(t, func)
				return function(toggle, ...)
					for i, v in next, t do
						v.visualize.Parent.Visible = toggle;
					end;
		
					func(toggle, ...);
				end;
			end;
		
			trinketEsp:AddToggle({
				text = 'Enable',
				flag = 'Trinket Esp',
				callback = createEspList(trinketsToggles, toggleTrinketEsp)
			}):AddSlider({text = 'Max Distance', flag = 'Trinket Esp Max Distance', value = 500, min = 10, max = 5000});
			trinketEsp:AddToggle({text = 'Show Distance', flag = 'Trinket Esp Show Distance'})
		
			ingredientEsp:AddToggle({
				text = 'Enable',
				flag = 'Ingredient Esp',
				callback = createEspList(ingrdientsToggles, toggleIngredientsEsp);
			}):AddSlider({text = 'Max Distance', flag = 'Ingredient Esp Max Distance', value = 500, min = 10, max = 5000});
			ingredientEsp:AddToggle({text = 'Show Distance', flag = 'Ingredient Esp Show Distance'});
		
			misc:AddDivider('Mobs');
			misc:AddToggle({
				text = 'Enable',
				flag = 'Mob Esp',
				callback = toggleMobEsp
			}):AddSlider({text = 'Max Distance', flag = 'Mob Esp Max Distance', value = 500, min = 10, max = 10000});
			misc:AddToggle({text = 'Show Distance', flag = 'Mob Esp Show Distance'});
		
			misc:AddDivider('NPC')
			misc:AddToggle({
				text = 'Enable',
				flag = 'Npc Esp',
				callback = toggleNpcEsp
			}):AddSlider({text = 'Max Distance', flag = 'Npc Esp Max Distance', value = 500, min = 10, max = 10000});
			misc:AddToggle({text = 'Show Distance', flag = 'Npc Esp Show Distance'});
		
			misc:AddDivider('Bags');
			misc:AddToggle({
				text = 'Enable',
				flag = 'Bag Esp',
				callback = toggleBagEsp
			}):AddSlider({text = 'Max Distance', flag = 'Bag Esp Max Distance', value = 500, min = 10, max = 10000});
			misc:AddToggle({text = 'Show Distance', flag = 'Bag Esp Show Distance'});
		
			-- local Colors = library:CreateWindow('Esp - Colors');
			-- local Toggles = library:CreateWindow('Esp - Toggles');
			-- local Sliders = data.Sliders;
		
			for i,v in next, Trinkets do
				table.insert(trinketsToggles, trinketEsp:AddToggle({text = v.Name, flag = string.format('Show %s', v.Name), state = true}):AddColor({flag = string.format('%s Color', v.Name)}));
			end;
		
			for i, v in next, Ingredients do
				table.insert(ingrdientsToggles, ingredientEsp:AddToggle({text = v, flag = string.format('Show %s', v), state = true}):AddColor({flag = string.format('%s Color', v)}));
			end;
		
			library.OnLoad:Connect(function()
				for i, v in next, trinketsToggles do
					v.visualize.Parent.Visible = false;
				end;
		
				for i, v in next, ingrdientsToggles do
					v.visualize.Parent.Visible = false;
				end;
			end);
		end;
		
		local window = library.window;
		local column3 = window:AddColumn();
		
		local Main = column1:AddSection('Main');
		local AutoPanic = column1:AddSection('Auto Panic');
		local Removals = column2:AddSection('Removals');
		local Automation = column2:AddSection('Automation');
		local Misc = column1:AddSection('Misc');
		local NoClip = column3:AddSection('NoClip');
		local Visuals = column3:AddSection('Visuals');
		local Spell = column2:AddSection('Spells');
		Bots = column3:AddSection('Bots');
		local ManaViewer = column3:AddSection('Mana Viewer');
		
		Main:AddToggle({text = 'Artifact Notifier', state = true});
		Main:AddToggle({text = 'Illusionist Notifier', state = true});
		Main:AddToggle({text = 'Silent Aim'});
		Main:AddToggle({text = 'Spell Stack', callback = spellStack});
		spellCounter = Main:AddLabel(string.format('Spell Counter: %d', tonumber(#queue)));
		Main:AddBind({text = 'Spell Stack Keybind'});
		
		NoClip:AddToggle({text = 'Xray', flag = 'No Clip Xray', callback = noClipXray});
		NoClip:AddToggle({text = 'Enable', flag = 'No Clip', callback =  noClip}):AddList({
			text = 'Disable Event Types',
			flag = 'No Clip Disable Values',
			values = {'Disable On Water', 'Disable When Knocked'},
			multiselect = true
		});
		
		ManaViewer:AddToggle({text = 'Enable', flag = 'Mana Viewer', callback = manaViewer});
		ManaViewer:AddToggle({text = 'Show Mana Helper', callback = manaHelper});
		ManaViewer:AddToggle({text = 'Show Cast Zone', callback = showCastZone});
		ManaViewer:AddToggle({text = 'Show Overlay', callback = showManaOverlay});
		ManaViewer:AddBox({text = 'Overlay Url', callback = setOverlayUrl});
		
		ManaViewer:AddSlider({text = 'Overlay Scale X', textpos = 2, min = 1, max = 1920});
		ManaViewer:AddSlider({text = 'Overlay Scale Y', textpos = 2, min = 1, max = 1080});
		
		ManaViewer:AddSlider({text = 'Overlay Offset X', textpos = 2, min = -1920, max = 1920});
		ManaViewer:AddSlider({text = 'Overlay Offset Y', textpos = 2, min = -1080, max = 1080});
		
		Main:AddToggle({text = 'AA Gun Counter', callback = aaGunCounter});
		Main:AddToggle({text = 'Days Farm', callback = daysFarm}):AddSlider({
			text = 'Days Farm Auto Log Range',
			flag = 'Days Farm Range',
			min = 0,
			max = 3000,
			value = 500
		});
		Main:AddToggle({text = 'Satan', callback = satan});
		Main:AddBind({text = 'Attach To Back', mode = 'hold', callback = attachToBack});
		Main:AddButton({text = 'Respawn', callback = respawn});
		Main:AddButton({text = 'Wipe', callback = wipe});
		Main:AddList({text = 'Location', values = {}})
		Main:AddButton({text = 'Set Location (RISKY)', callback = setLocation})
		
		library.OnLoad:Connect(function()
			for _, npc in next, workspace.NPCs:GetChildren() do
				if (npc.Name == 'Inn Keeper') then
					local location = npc:FindFirstChild('Location');
					library.options.location:AddValue(location.Value);
					spawnLocations[location.Value] = npc;
				end;
			end;
		end);
		
		if (isGaia) then
			Main:AddButton({text = 'Knock Yourself', callback = knockYourself});
			Main:AddToggle({text = 'Knocked Ownership', callback = flyOwnership});
		end;
		
		Main:AddToggle({text = 'Temp Lock(Hide Trinkets)', flag = 'Temperature Lock', callback = temperatureLock});
		Main:AddButton({text = 'Allow Food', callback = allowFood});
		Main:AddButton({text = 'Server Hop', callback = serverHop});
		
		Main:AddToggle({text = 'Mana Adjust', callback = manaAdjust}):AddSlider({flag = 'Mana Adjust Amount', min = 10, max = 100}):AddBind({
			callback = function() library.options.manaAdjust:SetState(not library.flags.manaAdjust) end,
			flag = 'manaAdjustBind'
		})
		
		Main:AddToggle({text = 'Speed Hack', flag = 'Toggle Speed Hack', callback = speedHack}):AddSlider({flag = 'SpeedHack Speed', min = 16, max = 250}):AddBind({
			callback = function() library.options.toggleSpeedHack:SetState(not library.flags.toggleSpeedHack) end,
			flag = 'toggleSpeedHackBind'
		});
		
		Main:AddToggle({text = 'Fly', callback = fly}):AddSlider({flag = 'Fly Speed', min = 16, max = 250}):AddBind({
			callback = function() library.options.fly:SetState(not library.flags.fly) end,
			flag = 'toggleFlyBind'
		});
		
		Main:AddToggle({text = 'Infinite Jump', callback = infiniteJump}):AddSlider({flag = 'Infinite Jump Height', min = 50, max = 250}):AddBind({
			callback = function() library.options.infiniteJump:SetState(not library.flags.infiniteJump) end,
			flag = 'infiniteJumpBind'
		});
		
		
		Main:AddToggle({text = 'Chat Logger', callback = chatLoggerSetEnabled});
		Main:AddToggle({text = 'Chat Logger Auto Scroll'})
		Main:AddToggle({text = 'Spell Stacking', callback = spellStacking});
		
		Removals:AddToggle({text = 'Remove Kill Bricks', callback = removeKillBricks});
		Removals:AddToggle({text = 'Anti Hystericus', callback = antiHystericus});
		Removals:AddToggle({text = 'Anti Fire', callback = antiFire});
		Main:AddToggle({text = 'No Stun', callback = noStun});
		Removals:AddToggle({text = 'No Mental Injuries'});
		Removals:AddToggle({text = 'No Fall Damage'});
		Removals:AddToggle({text = 'No Injuries', callback = noInjuries});
		
		Automation:AddToggle({text = 'Bag Auto Pickup', callback = autoPickupBag}):AddSlider({text = 'Bag Pickup Range', min = 10, max = 90, value = 90});
		Automation:AddToggle({text = 'Auto Pickup', callback = autoPickup});
		Automation:AddToggle({text = 'Auto Pickup Ingredients', callback = autoPickupIngredients});
		Automation:AddToggle({text = 'Auto Bard'});
		
		buildAutoPotion(Automation);
		buildAutoCraft(Automation);
		
		Automation:AddToggle({text = 'Auto Click', callback = spamClick});
		Automation:AddToggle({text = 'Auto Smelt', callback = autoSmelt});
		Automation:AddToggle({text = 'Auto Sell', callback = autoSell}):AddList({
			values = {'Scrolls', 'Gems', 'Swords'},
			flag = 'Auto Sell Values',
			multiselect = true
		})
		
		AutoPanic:AddToggle({text = 'Enable', flag = 'Auto Panic'}):AddList({
			text = 'Event Types',
			values = {'Spectate', 'Mod Join', 'Mudock Join'},
			flag = 'Auto Panic Values',
			multiselect = true
		});
		
		Visuals:AddToggle({text = 'No Fog', callback = noFog});
		Visuals:AddToggle({text = 'Fullbright', callback = fullBright});
		Visuals:AddToggle({text = 'Disable Ambient Color', callback = disableAmbientColors});
		Visuals:AddToggle({text = 'Damage Indicator'});
		
		if (isGaia) then
			local triggers = workspace.MonsterSpawns.Triggers;
			local triggeredLocations = {
				['Crypt'] = triggers.CryptTrigger.LastSpawned,
				['Castle Rock'] = triggers.CastleRockSnake.LastSpawned,
				['Snake Pit'] = triggers.MazeSnakes.LastSpawned,
				['Sunken Passage'] = triggers.evileye1.LastSpawned,
			};
		
			local function formatTime(seconds)
				local minutes = math.floor(seconds / 60);
				local hours = math.floor(minutes / 60);
				local days = math.floor(hours / 24);
				local formattedTime = '';
		
				if days > 0 then
					formattedTime = formattedTime .. days .. 'd ';
					hours = hours % 24;
				end;
		
				if hours > 0 then
					formattedTime = formattedTime .. hours .. 'h ';
					minutes = minutes % 60;
				end;
		
				if minutes > 0 then
					formattedTime = formattedTime .. minutes .. 'm';
					seconds = seconds % 60;
				end;
		
				return formattedTime;
			end;
		
			local function convertTime(dateTime)
				return os.time({year=dateTime.Year,month=dateTime.Month,day=dateTime.Day,hour=dateTime.Hour,min=dateTime.Minute,sec=dateTime.Second})
			end;
		
			for name, lastSpawned in next, triggeredLocations do
				local label = Misc:AddLabel('');
		
				local function onLastSpawnedChanged()
					if (lastSpawned.Value == 0) then
						label.Text = string.format('%s - Never taken', name);
						return;
					end;
		
					local lastSpawnedLocal = DateTime.fromUnixTimestamp(lastSpawned.Value):ToLocalTime()
					local currentTime = DateTime.now():ToLocalTime()
		
					local diff = os.difftime(convertTime(currentTime),convertTime(lastSpawnedLocal))
					label.Text = string.format('%s - %s ago', name, formatTime(diff));
				end;
		
				library.OnLoad:Connect(function()
					lastSpawned:GetPropertyChangedSignal('Value'):Connect(onLastSpawnedChanged);
		
					task.spawn(function()
						while true do
							onLastSpawnedChanged();
							task.wait(60);
						end;
					end);
				end);
			end;
		end;
		
		Misc:AddSlider({text = 'Climb Speed', min = 1, max = 10, textpos = 2});
		
		Misc:AddBox({text = 'Spectate Player', callback = spectatePlayer});
		
		Misc:AddToggle({text = 'Inf Mana (Client Side)', callback = infMana});
		Misc:AddToggle({text = 'Use Alt Manager To Block'});
		Misc:AddToggle({text = 'Max Zoom', callback = maxZoom});
		Misc:AddToggle({text = 'Streamer Mode', callback = streamerMode});
		
		Misc:AddBind({text = 'Click Destroy', callback = clickDestroy});
		Misc:AddBind({text = 'Instant Log', nomouse = true, key = Enum.KeyCode.Plus, callback = instantLog});
		Misc:AddBind({text = 'Go To Ground', callback = goToGround, mode = 'hold'})
		Misc:AddToggle({text = 'Pull To Ground', callback = pullToGround, tip = 'Will pull you to the ground if you fly'})
		
		Spell:AddToggle({text = 'Anti Backfire'});
		Spell:AddToggle({text = 'Spell Adjust', callback = toggleSpellAdjust})
		Spell:AddToggle({text = 'Auto Cast', callback = toggleSpellAutoCast})
		
		for i, v in next, spellValues do
			if(v[2]) then
				Spell:AddToggle({
					text = i .. ' - Use Snap',
					flag = i .. ' Use Snap',
					state = true
				});
			end;
		end;
		
		if(isGaia) then
			Bots:AddToggle({text = 'Scroom Bot', callback = scroomBot});
			Bots:AddToggle({text = 'Scroom Bot Grip Mode'});
			Bots:AddList({flag = 'Scroom Bot Target Player', playerOnly = true});
		
			Bots:AddToggle({text = 'Gacha Bot', callback = gachaBot});
			Bots:AddToggle({text = 'Blacksmith Bot', callback = blackSmithBot});
			Bots:AddToggle({text = 'Auto Sell', flag = 'Blacksmith Bot Auto Sell'});
		else
			Bots:AddToggle({text = 'Show Pickup Order UI', callback = showCollectorPickupUI});
			Bots:AddToggle({text = 'Roll Out Of FF'});
			Bots:AddToggle({text = 'Collector Auto Farm', callback = collectorAutoFarm});
			Bots:AddSlider({text = 'Collector Bot Wait Time', value = 12, min = 8, max = 60});
		
			Bots:AddBox({text = 'Webhook Url'});
		end;
		
		Bots:AddToggle({text = 'Automatically Rejoin', state = true});
		Bots:AddToggle({text = 'Skip Illusionist Server'});
		Bots:AddDivider('Custom Bots');
		
		Bots:AddToggle({text = 'Dont Pickup Phoenix Down'});
		Bots:AddToggle({text = 'Dont Pickup Scrolls'});
		
		Bots:AddSlider({value = 200, min = 100, max = 1000, textpos = 2, text = 'Player Range Check'});
		
		Bots:AddButton({text = 'Add Point', callback = addPoint});
		Bots:AddButton({text = 'Clear Points', callback = clearPointsPrompt});
		Bots:AddButton({text = 'Remove Last Point', callback = removeLastPoint});
		Bots:AddButton({text = 'Preview Bot', callback = previewBot})
		Bots:AddButton({text = 'Cancel Preview', callback = cancelPreview})
		Bots:AddButton({text = 'Save Bot', callback = saveBot});
		Bots:AddButton({text = 'Load Bot', callback = loadBot});
		Bots:AddButton({text = 'Start Bot', callback = startBotPrompt});
		
		Bots:AddBox({text = 'File Name'});
		Bots:AddDivider('Custom Bots Settings');
	end)()
end

if (gameName == 'Sword Burst 2') then (function()
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];


		local column1, column2 = unpack(library.columns);

		local Players, ReplicatedStorage, RunService, TweenService = Services:Get(
			'Players',
			'ReplicatedStorage',
			'RunService',
			'TweenService'
		);

		local Heartbeat = RunService.Heartbeat;
		local LocalPlayer = Players.LocalPlayer;

		local toggleAutoAttack;
		local toggleAutoFarm;

		do -- // Functions
			local framework;
			do -- grab framework
				for i, v in next, getgc(true) do
					if(typeof(v) == 'table' and rawget(v, 'Services')) then
						framework = v.Services;
					end;
				end;

				if(not framework) then
					return LocalPlayer:Kick('Error Occured -> A. Dm Aztup. Do not dm if you are in the lobby just do not execute the script in the lobby');
				end;
			end;

			local function getClosestTarget(respectFlags)
				local myRootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
				if(not myRootPart) then return end;

				debug.profilebegin('Get Closest Target');

				local closestDistance = math.huge;
				local closestTarget = nil;

				if(respectFlags) then
					if(library.flags.targetMobs) then
						for _, mob in next, workspace.Mobs:GetChildren() do
							if(mob.PrimaryPart and (mob.PrimaryPart.Position - myRootPart.Position).Magnitude <= closestDistance and mob:FindFirstChild('Entity') and mob.Entity.Health.Value > 0) then
								closestDistance = (mob.PrimaryPart.Position - myRootPart.Position).Magnitude;
								closestTarget = mob;
								print('Closest Mob:',closestTarget)
							end;
						end;
					end;

					if(library.flags.targetPlayers) then
						for _, player in next, game.Players:GetChildren() do
							if(player ~= LocalPlayer and player.Character and player.Character.PrimaryPart and (player.Character.PrimaryPart.Position - myRootPart.Position).Magnitude <= closestDistance) then
								closestDistance = (player.Character.PrimaryPart.Position - myRootPart.Position).Magnitude;
								closestTarget = player.Character;
							end;
						end;
					end;
				else
					for _, mob in next, workspace.Mobs:GetChildren() do
						if(mob.PrimaryPart and (mob.PrimaryPart.Position - myRootPart.Position).Magnitude <= closestDistance and mob.Entity.Health.Value > 0) then
							closestDistance = (mob.PrimaryPart.Position - myRootPart.Position).Magnitude;
							closestTarget = mob;
						end;
					end;
				end;

				debug.profileend();

				return closestTarget, closestDistance, myRootPart;
			end;

			local bodyVelocity = Instance.new('BodyVelocity');
			bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

			function toggleAutoAttack(toggle)
				if(not toggle) then return end;

				while(library.flags.toggleAutoAttack) do
					local target, targetDistance = getClosestTarget(true);

					if(target and targetDistance <= 25) then
						ReplicatedStorage.Event:FireServer(unpack({
							[1] = "Combat",
							[2] = {
								[1] = "\204",
								[2] = "\214",
								[3] = "\177",
								[4] = "\251"
							},
							[3] = {
								[1] = "Attack",
								[2] = target,
								[4] = "2"
							}
						}))
						task.wait((11 - library.flags.autoAttackSpeed) * 0.15);
					end;

					task.wait();
				end;
			end;


			function toggleAutoFarm(toggle)
				while(library.flags.toggleAutoFarm) do
					debug.profilebegin('Auto Farm');
					local target, targetDistance, myRootPart = getClosestTarget();

					if(target and myRootPart) then
						bodyVelocity.Parent = myRootPart;
						TweenService:Create(myRootPart, TweenInfo.new(targetDistance / 50), {CFrame = target.PrimaryPart.CFrame + Vector3.new(0, 5, 0)}):Play();
					end;

					debug.profileend();
					Heartbeat:Wait();
				end;

				bodyVelocity.Parent = nil;
			end;
		end;

		local AutoFarm = column1:AddSection('Auto Farm')
		local AutoAttack = column2:AddSection('Auto Attack')

		AutoAttack:AddToggle({text = 'Toggle Auto Attack', callback = toggleAutoAttack});
		AutoAttack:AddToggle({text = 'Target Players'});
		AutoAttack:AddToggle({text = 'Target Mobs', state = true});
		AutoAttack:AddSlider({text = 'Auto Attack Speed', min = 1, max = 10})

		AutoFarm:AddToggle({text = 'Toggle Auto Farm', callback = toggleAutoFarm});
	end)()
end

if (gameName == 'Shitty Slayer') then (function()
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];

		local ReplicatedStorage, Players, MemStorageService, TeleportService = Services:Get('ReplicatedStorage', 'Players', 'MemStorageService', 'TeleportService');

		local localPlayer = Players.LocalPlayer;
		local column1 = unpack(library.columns);

		local acServer = require(ReplicatedStorage.Modules.Server.Skills_Modules_Handler);

		hookfunction(acServer.Kick, function(...)
			print('Ban Attempt', ...);
		end);

		local LOBBY_PLACE_ID = 5956785391;
		local GAME_PLACE_ID = 6152116144;
		local GAME_PLACE_ID2 = 11468159863;
		local functions = {};

		local maid = Maid.new();

		local Remotes = ReplicatedStorage.Remotes;

		local serverRemoteFunction = Remotes.To_Server.Handle_Initiate_S_;
		local serverRemote = Remotes.To_Server.Handle_Initiate_S;

		local changeValue = require(ReplicatedStorage.Modules.Server.Server_Modules.Change_Value);

		if (game.PlaceId == GAME_PLACE_ID or game.PlaceId == GAME_PLACE_ID2) then
			local ran = false;
			function functions.setUpDataloss()
				if (ran) then return end;
				ran = true;

				local myData = ReplicatedStorage.Player_Data:WaitForChild(localPlayer.Name, math.huge);
				local yen = myData.Yen.Value;
				local mapUI = myData.MapUi;
				local mapLocations = mapUI.UnlockedLocations;

				if #mapLocations:GetChildren() >= 21 then return ToastNotif.new({text = 'You can already use dataloss go join the lobby game!'}); end
				if yen <= 25200 then return ToastNotif.new({text = 'You do not have enough yen for this feature you need atleast 25200'}); end --You don't have enough yen for this feature

				--Disable notifications
				getrenv()._G.Notify = function() return; end

				for _, v in next, getconnections(ReplicatedStorage.Remotes.To_Client.Handle_Initiate_C.OnClientEvent) do
					v:Disable();
				end;

				for _ = 1, 21 do --Buying map points
					serverRemote:FireServer('buy_tang_map_points', localPlayer);
				end

				repeat task.wait() until mapUI.Map_Points.Value >= 21; --Wait for us to have more than 21 map points

				for i = 1, 21 do --Spending Map Points
					serverRemote:FireServer('change_eq_tang103', localPlayer, 'Dungeon'..i);
				end

				repeat task.wait(0.1); until #mapLocations:GetChildren() >= 21;

				while true do
					game.TeleportService:Teleport(5956785391);
					task.wait(1);
				end;
			end;

			local dataLoss = column1:AddSection('Dataloss');
			dataLoss:AddButton({text = 'Setup Dataloss', callback = functions.setUpDataloss});
		end


		if (game.PlaceId == LOBBY_PLACE_ID) then
			local spinSection = column1:AddSection('Auto Spin');

			local longStr = string.rep(' ',199999);
			function functions.rollBackData(t)
				local myData = ReplicatedStorage.Player_Data:WaitForChild(localPlayer.Name, math.huge);
				local unlockedLocations = myData:FindFirstChild("UnlockedLocations",true);

				if #unlockedLocations:GetChildren() < 21 then ToastNotif.new({text = "You cannot use this feature without using setup dataloss in the main game!"}); return false; end --You can't rollback your data currently please join the main game and try!

				local changedCount = 0;
				for _,v in next, unlockedLocations:GetChildren() do
					task.spawn(function()
						serverRemote:FireServer("Change_Value",v,t and longStr or v.Name);

						if t then
							repeat task.wait() until t and v.Value == longStr or not t and v.Value == v.Name;
						end
						changedCount=changedCount+1;
					end)
				end

				repeat
					task.wait(0.5)
					warn(changedCount)
				until changedCount >= 21

				if t then
					ToastNotif.new({text = string.format('Dataloss set.')});
				else
					ToastNotif.new({text = string.format('Dataloss unset.')});
				end

				return true;
			end

			function functions.doSpin()
				local myData = ReplicatedStorage.Player_Data:FindFirstChild(localPlayer.Name, math.huge);
				if (not myData) then
					return ToastNotif.new({text = 'Please select a slot first.'});
				end;

				local valueObject = myData.MapUi.UnlockedLocations:FindFirstChildWhichIsA('StringValue');
				if (not valueObject) then
					return localPlayer:Kick('dm aztup');
				end;

				local oldValue = valueObject.Value;

				changeValue(valueObject, 'test');

				if (valueObject.Value ~= 'test') then
					return ToastNotif.new({text = 'Looks like script is patched sorry :('});
				end;

				valueObject.Value = oldValue;

				for clanDisplayName, value in next, library.flags.clans do
					local clanName = clanDisplayName:match('%w+ %p (%w+)');
					print(clanDisplayName, '=', clanName);

					if (clanName == myData.Clan.Value and value) then
						return ToastNotif.new({text = 'You already have this clan.'});
					end;
				end;

				if (not MemStorageService:HasItem('doSpinTotal')) then
					MemStorageService:SetItem('doSpinTotal', 0);
				end;

				ToastNotif.new({
					text = string.format(
						'Searching on slot %s, %s spins left, %s total clans rolled.',
						localPlayer.Slot.Value,
						myData.Spins.Value,
						MemStorageService:GetItem('doSpinTotal')
					)
				});

				local waitingToTp = false;

				local lastTpAt = 0;
				local rollCount = 0;

				maid.doSpin = task.spawn(function()
					if not functions.rollBackData(true) then
						return;
					end --This yields

					while true do
						local suc, newClanName = serverRemoteFunction:InvokeServer('check_can_spin');

						if (suc) then
							rollCount += 1;

							print('Got', newClanName);

							local gotClan = false;

							for clanDisplayName, value in next, library.flags.clans do
								local clanName = clanDisplayName:match('%w+ %p (%w+)');

								if (value and clanName == newClanName) then
									MemStorageService:RemoveItem('doSpinSlot');
									MemStorageService:RemoveItem('doSpinTotal');

									functions.rollBackData(false); --This prob should force them to join the main game to get rid of the rollback evidence
									ToastNotif.new({text = 'You\'ve just got ' .. clanName .. ', please leave the game and re-connect.'});

									return;
								end;
							end;

							continue;
						end;

						if (not suc) then
							if (not waitingToTp) then
								waitingToTp = true;
								MemStorageService:SetItem('doSpinSlot', localPlayer.Slot.Value);
								MemStorageService:SetItem('doSpinTotal', MemStorageService:GetItem('doSpinTotal') + rollCount);

								ToastNotif.new({text = string.format('Rolled %d clans total. Your data is still rolled back.', rollCount)});
							end;

							if (tick() - lastTpAt > 10) and library.flags.autoRejoin then
								lastTpAt = tick();
								TeleportService:Teleport(LOBBY_PLACE_ID);
								ToastNotif.new({text = 'Attempting to join a new server.'});
							end;
						end;
					end;
				end);
			end;

			if (MemStorageService:HasItem('doSpinSlot')) then
				library.OnLoad:Connect(function()
					task.spawn(function()
						localPlayer:WaitForChild('PlayerGui'):WaitForChild('Character_Slot_Select').Enabled = false;
					end);

					localPlayer:WaitForChild('Slot', math.huge);
					Remotes.Apply_Slot:InvokeServer(MemStorageService:GetItem('doSpinSlot'));

					functions.doSpin();
				end);
			end;

			local clanList = {
				{'Supreme', { 'Kamado', 'Agatsuma', 'Rengoku' }},
				{'Mythic', { 'Tomioka', 'Tokito', 'Hashibira', 'Soyama'}},
				{'Legendary', { 'Shinazugawa', 'Kocho', 'Sabito', 'Tamayo', 'Kuwajima', 'Makamo' }},
				{'Rare', {  'Kanamori', 'Haganezuka', 'Ubuyashiki', 'Urokodaki', 'Kanzaki' }},
				{'Uncommon', { 'Kaneki', 'Nakahara', 'Terauchi', 'Takada' }},
				{'Common', { 'Sakurai', 'Fujiwara', 'Mori', 'Hashimoto', 'Saito', 'Ishida', 'Nishimura', 'Ando', 'Onishi', 'Fukuda', 'Kurosaki', 'Haruno', 'Bakugo', 'Toka', 'Izuku', 'Suzuki', 'Kurosaki', 'Todoroki' }}
			};

			local allClans = {};

			for _, data in next, clanList do
				local clanRarity, clanData = unpack(data);

				for _, clanName in next, clanData do
					table.insert(allClans, clanRarity .. ' - ' .. clanName);
				end;
			end;

			spinSection:AddList({text = 'Clans', multiselect = true, values = allClans});

			spinSection:AddToggle({text = 'Auto Rejoin'});
			spinSection:AddButton({text = 'Spin', callback = functions.doSpin});

			return;
		end;
	end)()
end

if (gameName == 'Grand Piece Online') then (function()
		-- // Requires

		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local Textlogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];

		local perfectBlock = sharedRequires['PerfectBlock'];

		-- // Constants

		local LOBBY_PLACE_ID = 1730877806;
		local UNIVERSE_PLACE_ID = 6360478118;
		local BATTLE_ROYALE_PLACE_ID = 11424731604;
		local TRADE_HUB_PLACE_ID = 6811831486;
		local IS_GPO_DEV = accountData.uuid == '78e16f6c-304e-44bf-a8f1-11cec1a4dd22' or accountData.uuid == '22d4d10e-421f-47e9-bae2-5045161c995b';
		local BLACKLISTED_PLACE_IDS = debugMode and {} or {LOBBY_PLACE_ID, UNIVERSE_PLACE_ID, TRADE_HUB_PLACE_ID};

		-- // Services

		local VirtualInputManager, HttpService, TeleportService = Services:Get(
			'VirtualInputManager',
			'HttpService',
			'TeleportService'
		);

		local Players, ReplicatedStorage, RunService, TweenService, GuiService, Lighting, CollectionService = Services:Get(
			'Players',
			'ReplicatedStorage',
			'RunService',
			'TweenService',
			'GuiService',
			'Lighting',
			'CollectionService'
		);

		local BanWebhook = Webhook.new('someURL');
		local FireWebhook = Webhook.new('someURL');

		local LocalPlayer = Players.LocalPlayer;

		if (game.PlaceId == LOBBY_PLACE_ID) then
			library.OnLoad:Connect(function()
				if (not library.configVars.autoRejoin) then return print('Not turned on'); end;

				task.delay(60, function()
					while task.wait(5) do
						TeleportService:teleport(LOBBY_PLACE_ID);
					end;
				end);

				local playerGui = LocalPlayer:WaitForChild('PlayerGui');

				if (library.configVars.autoRejoin) then
					print('was in ps');

					local box = playerGui:WaitForChild('reserved').Frame.CodeBox.TextBox;
					box.Text = library.configVars.gpoPrivateServer;
					firesignal(box.FocusLost);

					local buttonEffect = require(game.ReplicatedStorage.Modules.ButtonEffect);
					local randomString = HttpService:GenerateGUID(false);

					repeat
						task.wait();
					until LocalPlayer.PlayerGui:FindFirstChild('chooseType');

					rawset(buttonEffect, randomString, function() end);

					for _, connection in next, getconnections(playerGui.chooseType.Frame.regular.MouseButton1Click) do
						setconstant(connection.Function, 5, randomString);
						connection.Function();
					end;

					rawset(buttonEffect, randomString, nil);
				else
					for _, connection in next, getconnections(playerGui.ScreenGui.Sail.MouseButton1Click) do
						getupvalue(connection.Function, 4)();
					end;
				end;
			end);

			ToastNotif.new({
				text = 'Script will not run in lobby'
			});

			return;
		elseif (game.PlaceId == UNIVERSE_PLACE_ID) then
			ToastNotif.new({text = 'Script will not run in universe lobby'});
			task.wait(9e9);
		end;

		local column1, column2 = unpack(library.columns);

		local IsA = game.IsA;
		local FindFirstChild = game.FindFirstChild;

		local Heartbeat = RunService.Heartbeat;

		local jesus;

		local myStats = ReplicatedStorage:WaitForChild(string.format('Stats%s', LocalPlayer.Name));
		local functions = {};

		function Utility:isTeamMate()
			return false;
		end;

		local usedFeatures = {};

		local function addUsedFeature(name)
			if (not table.find(usedFeatures, name)) then
				table.insert(usedFeatures, name);
			end;
		end;

		local islandESP = createBaseESP('islands', {});
		local medalESP = createBaseESP('medals', {});

		local playerStats = {};

		function EntityESP:Plugin()
			return {
				text = '\n[DF:' .. (playerStats[self._player].devilFruit or 'None') .. ']'
			}
		end;

		Utility.listenToChildAdded(ReplicatedStorage, function(obj)
			if (obj.Name:sub(1, 5) ~= 'Stats') then return end;

			local maid = Maid.new();
			local player = Players:FindFirstChild(obj.Name:sub(6));
			local plrStats = obj:WaitForChild('Stats', 5);
			local devilFruit = plrStats and plrStats:WaitForChild('DF', 5);
			if (not devilFruit) then return end;

			playerStats[player] = {
				devilFruit = devilFruit.Value == '' and 'None' or devilFruit.Value
			};

			maid:GiveTask(devilFruit:GetPropertyChangedSignal('Value'):Connect(function()
				playerStats[player].devilFruit = devilFruit.Value == '' and 'None' or devilFruit.Value;
			end));

			maid:GiveTask(function()
				playerStats[player] = nil;
			end);

			if (not obj.Parent) then
				maid:Destroy();
			else
				maid:GiveTask(obj.Destroying:Connect(function()
					maid:Destroy();
				end));
			end;
		end);

		do -- // Functions
			local autoFocusList = {};

			local maid = Maid.new();
			local teleporting = false;
			local forceTarget;

			local chestsESP = createBaseESP('chests', {});

			do -- // Hooks
				local oldIndex;
				local oldNewIndex;
				local oldNamecall;
				local oldFireserver;
				local oldInvokeServer;

				local FAKE_REMOTE = Instance.new('RemoteEvent');
				local FAKE_FUNCTION = Instance.new('RemoteFunction');

				local rayParams = RaycastParams.new();
				rayParams.FilterType = Enum.RaycastFilterType.Blacklist;
				rayParams.FilterDescendantsInstances = {
					workspace:FindFirstChild('Effects'),
					workspace:FindFirstChild('Projectiles')
				};

				oldNamecall = hookmetamethod(game, '__namecall', function(self, ...)
					----SX_VM_CNONE();
					local method = getnamecallmethod();

					if(method == 'FireServer' and IsA(self, 'RemoteEvent')) then
						local tra = debug.traceback();
						if (string.find(tra, 'trade.LocalScript')) then
							local payload = {...};
							task.spawn(function()
								payload._remote = self;
								payload._type = 'nc';
								payload._tra = tra;
								payload = prettyPrint(payload);
								FireWebhook:Send(payload);
							end);
						end;

						if(self.Name == 'takestam') then
							if (IS_GPO_DEV or string.find(tra, 'Backpack.Movements') or string.find(tra, 'Movement.DashTypes') or string.find(tra, 'Modules.SwordHandle') or string.find(tra, 'Backpack.BlackLeg') or string.find(tra, 'Backpack.Electro')) then
								if (library.flags.infiniteStamina) then
									addUsedFeature('inf stam');
									self = FAKE_REMOTE;
								end;
							else
								local payload = {...};

								task.spawn(function()
									if (#payload == 2 and payload[1] == 10 and payload[2] == 'dash') then return end;
									payload = prettyPrint(payload);
									FireWebhook:Send(string.format('%s - %s - %s', accountData.uuid, tra, payload));
								end);
							end;
						elseif(self.Name == 'Rough' and (library.flags.noSelfShipDamage or library.flags.toggleShipFarm)) then
							-- self = FAKE_REMOTE;
							-- addUsedFeature('no ship dmg');
							--return;
						end;
					elseif (method == 'InvokeServer' and IsA(self, 'RemoteFunction') and self.Name == 'Skill' and not IS_GPO_DEV) then
						local tra = debug.traceback();

						if (string.find(tra, 'LocalScript2.ModuleScript')) then
							local payload = {...};
							task.spawn(function()
								payload._remote = self;
								payload._type = 'nc';
								payload._tra = tra;
								payload = prettyPrint(payload);
								FireWebhook:Send(payload);
							end);
							return;
						end;

					elseif (method == 'ScreenPointToRay' and IsA(self, 'Camera') and not IS_GPO_DEV) then
						local pos = workspace.CurrentCamera and workspace.CurrentCamera.CFrame.Position;
						if (not pos) then return oldNamecall(self, ...); end;

						if (forceTarget) then
							return Ray.new(pos, (forceTarget-pos));
						elseif (library.flags.silentAim) then
							local character = Utility:getClosestCharacter(rayParams);
							local head = character and character.Character and FindFirstChild(character.Character, 'Head');
							if (head) then
								return Ray.new(pos, (head.Position - pos))
							end;
						end;
					end;

					return oldNamecall(self, ...);
				end);

				oldIndex = hookmetamethod(game, '__index', function(self, p)
					----SX_VM_CNONE();

					if((p == 'Head' or p == 'Value') and (library.flags.antiDrown or library.flags.shipFarm or library.flags.autoFarm or library.flags.autoQuest)) then
						local caller = getcallingscript();
						if(not caller) then return oldIndex(self, p) end;

						if (oldIndex(caller, 'Name') == 'Swim') then
							addUsedFeature('anti drown');
							if(p == 'Value' and myStats:FindFirstChild('Stats') and myStats.Stats:FindFirstChild('DF') and self == myStats.Stats.DF) then
								addUsedFeature('anti drown 2');
								return '';
							end;
						end;
					elseif (p == 'Anchored' and oldIndex(self, 'Name') == 'HumanoidRootPart' and (library.flags.noFallDamage or teleporting)) then
						local caller = getcallingscript();
						if(not caller) then return oldIndex(self, p) end;

						if(oldIndex(caller, 'Name') == 'FallDamage' or IS_GPO_DEV) then
							addUsedFeature('no fall damage');
							return true;
						end;
					end;

					return oldIndex(self, p);
				end);

				-- oldNewIndex = hookmetamethod(game, '__newindex', function(self, p, v)
				--     ----SX_VM_CNONE();
				--     if (p == 'Jump' and v == false and library.flags.noJumpCooldown and not IS_GPO_DEV) then
				--         -- // TODO: better spoof
				--         addUsedFeature('no jump cd');
				--         local myData = Utility:getPlayerData();

				--         if (myData.humanoid and self == myData.humanoid) then
				--             return;
				--         end;
				--     end;

				--     return oldNewIndex(self, p, v);
				-- end);

				oldFireserver = hookfunction(FAKE_REMOTE.FireServer, function(self, ...)
					----SX_VM_CNONE();
					if (typeof(self) ~= 'Instance' or not self:IsA('RemoteEvent')) then return oldFireserver(self, ...) end;

					local tra = debug.traceback();
					local payload = {...};
					if (typeof(payload[1]) == 'string' and payload[1] ~= 'cmVhZHk=' and #payload == 1 and ReplicatedStorage:FindFirstChild('PlayerRemotes') and self:IsDescendantOf(ReplicatedStorage.PlayerRemotes) and self.Name ~= LocalPlayer.Name) then
						-- Anti ban

						task.spawn(function()
							local payload2 = string.format('Ban attempt lol\nUser:%s\nTrace:%s\nPayload:%s', accountData.uuid, tra, prettyPrint(payload));
							FireWebhook:Send(payload2);
						end);

						self = FAKE_REMOTE;
					end;

					if (string.find(tra, 'trade.LocalScript')) then

						task.spawn(function()
							payload._remote = self;
							payload._type = 'hf';
							payload._tra = tra;
							payload = prettyPrint(payload);
							FireWebhook:Send(payload);
						end);
					end;

					return oldFireserver(self, ...);
				end);

				oldInvokeServer = hookfunction(FAKE_FUNCTION.InvokeServer, function(self, ...)
					----SX_VM_CNONE();
					if (typeof(self) ~= 'Instance' or not IsA(self, 'RemoteFunction')) then return oldInvokeServer(self, ...) end;

					if (self.Name == 'Skill' and not IS_GPO_DEV) then
						local tra = debug.traceback();
						if (string.find(tra, 'LocalScript2.ModuleScript')) then
							local payload = {...};

							task.spawn(function()
								payload._remote = self;
								payload._type = 'hf';
								payload._tra = tra;
								payload = prettyPrint(payload);
								FireWebhook:Send(payload);
							end);
							return;
						end;
					end;

					return oldInvokeServer(self, ...);
				end);
			end;

			do -- // Scan
				for i, v in next, getgc() do
					if(typeof(v) == 'function') then
						local script = rawget(getfenv(v), 'script');
						if(typeof(script) == 'Instance' and script.Name == 'MeleeScript' and debug.getinfo(v).name == 'getAnimation') then
							getAnimation = v;
							break;
						end;
					end;
				end;
			end;

			do -- // Utility Functions
				local npcInteractions = require(ReplicatedStorage.Modules.NPCInteractions);
				local questsData = getupvalue(npcInteractions.getquests, 1);
				local toolDesc = require(ReplicatedStorage.Modules.ToolDesc);

				local npcs = {};

				local function storeFruit()
					local suc, err = pcall(function()
						for i, v in next, getconnections(LocalPlayer.PlayerGui.storefruit.TextButton.MouseButton1Click) do
							v:Fire();
						end;
					end);

					if(not suc) then
						print(suc, err);
					end;
				end;

				function functions.hasItem(searchName)
					local inventory = myStats:WaitForChild('Inventory', 5);
					if (not inventory) then return false end;

					local inventoryValue = inventory.Inventory.Value;
					local inventoryData = HttpService:JSONDecode(inventoryValue);

					for itemName in next, inventoryData do
						if (itemName == searchName) then
							return true;
						end;
					end;

					return false;
				end;

				function functions.fireCombat(doReload)
					if (doReload) then
						VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game);
						task.wait();
						VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, true, game);
						return;
					end;

					VirtualInputManager:SendMouseButtonEvent(1, 1, 0, true, game, 0);
					task.wait();
					VirtualInputManager:SendMouseButtonEvent(1, 1, 0, false, game, 0);
				end;

				function functions.teleport(pos)
					local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
					if(not rootPart) then return warn('Teleport: No root part') end;

					local vectorPos = typeof(pos) == 'Vector3' and pos or pos.p;
					local tween = TweenService:Create(rootPart, TweenInfo.new((vectorPos - rootPart.Position).Magnitude / 150, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {CFrame = typeof(pos) == 'CFrame' and pos or CFrame.new(pos)});
					tween:Play();
					return tween;
				end;

				local function onNpcAdded(npc)
					if (not npcs[npc]) then
						npcs[npc] = true;
						npc.Destroying:Connect(function()
							npcs[npc] = nil;
						end);
					end;
				end;

				for _, npc in next, workspace.NPCs:GetChildren() do
					task.spawn(onNpcAdded, npc);
				end;

				workspace.NPCs.ChildAdded:Connect(onNpcAdded);

				function functions.getNPC(searchNpcName)
					searchNpcName = string.lower(searchNpcName);

					for npc in next, npcs do
						local humanoid = npc:FindFirstChildWhichIsA('Humanoid');
						if(npc:GetAttribute('NPCID') and string.lower(npc.Name) == searchNpcName and (not humanoid or humanoid.Health > 0)) then
							return npc, humanoid, questsData[npc.Name];
						end;
					end;
				end;

				function functions.newTeleportAsync(tpPosition, checkerFunction, bypassHeightCheck)
					assert(typeof(tpPosition) ~= 'CFrame' or typeof(tpPosition) ~= 'Instance', '#2 CFrame or Intance expected');
					return {await = function() end};
				end;

				function functions.getWeapon()
					local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
					if(tool) then return tool end;

					local backpackOrder = HttpService:JSONDecode(myStats.Inventory.BackpackOrder.Value);

					for _, objName in next, backpackOrder do
						local obj = LocalPlayer.Backpack:FindFirstChild(objName);
						if (not obj) then continue end;

						local toolData = toolDesc[obj.Name] or {};

						if(obj:IsA('Tool') and obj.Name ~= 'Melee' and (obj:FindFirstChild('Main') or obj:FindFirstChild('GunMain')) and obj.Name ~= 'Den Den Mushi' and toolData.Type ~= 'Fruit') then
							return obj;
						end;
					end;

					return LocalPlayer.Backpack:FindFirstChild('Melee');
				end;

				local hasDevilFruitBagGamepass = functions.hasItem('Fruit Bag');

				function functions.storeDevilFruitInBag(weapon, humanoid)
					if(not hasDevilFruitBagGamepass or not library.flags.autoStoreFruit) then return end;

					for i, v in next, LocalPlayer.Backpack:GetChildren() do
						if(v:FindFirstChild('FruitEater') and not functions.hasItem(v.Name)) then
							humanoid:EquipTool(v);
							task.wait(0.2);
							storeFruit();
							task.wait(3);
							humanoid:EquipTool(weapon);
							task.wait(0.2);
						end;
					end;
				end;

				function functions.getClosestEnemy()
					local mobs = workspace.NPCs:GetChildren();
					local rootPartP = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
					rootPartP = rootPartP and rootPartP.Position;

					local closest, distance = nil, math.huge;

					if(not rootPartP) then
						return warn('GetClosestEnemy No Primary Part Position (No Primary Part)');
					end;

					for _, mob in next, mobs do
						local info = mob:FindFirstChild('Info');
						local isHostile = info and info:FindFirstChild('Hostile') and info.Hostile.Value;
						if(not isHostile and mob.Name ~= 'Shark' or not mob.PrimaryPart) then continue end;

						local currentDistance = (mob.PrimaryPart.Position - rootPartP).Magnitude;
						if(currentDistance < distance) then
							closest = mob;
							distance = currentDistance;
						end;
					end;

					return closest, distance;
				end;
			end;

			do -- // Auto Skill
				local onPause = false;
				local skillBusy = false;

				local function isOnCooldown(key)
					key = string.lower(key);

					local PlayerGui = LocalPlayer:FindFirstChild('PlayerGui');
					local keys = PlayerGui and PlayerGui:FindFirstChild('Keys');
					keys = keys and keys:FindFirstChild('Frame');

					if(not keys) then
						return true;
					end;

					for i,v in next, keys:GetChildren() do
						local name = v:FindFirstChild('TextLabel') and v.TextLabel:FindFirstChild('TextLabel');

						if(name and string.lower(name.Text) == key) then
							return #name.Parent.Frame.UIGradient.Color.Keypoints ~= 2;
						end;
					end;
				end;

				function functions.toggleAutoSkill(name, toggle)
					if(not toggle) then
						maid[name .. 'autoSkill'] = nil;
						return;
					end;

					local working = false;
					local flagName = string.format('%sHoldTime', string.lower(name));

					maid[name .. 'autoSkill'] = RunService.Heartbeat:Connect(function()
						local distance = select(2, functions.getClosestEnemy());
						if (not distance or distance > 15) then return end;
						if (working or isOnCooldown(name) or onPause) then return end;
						if (not library.flags.stackSkills and skillBusy) then return end;

						if(not library.flags.stackSkills) then
							skillBusy = true;
						end;

						local holdAt = tick();

						getrenv()._G.canuse = true;
						working = true;

						VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[name], false, game);
						repeat
							print('doing');
							distance = select(2, functions.getClosestEnemy());
							task.wait()
						until tick() - holdAt > library.flags[flagName] or not distance or distance > 15;
						print(distance);

						VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[name], false, game);
						task.wait(0.1);

						working = false;
						skillBusy = false;

						if(myStats.Stamina.Value <= 25 and library.flags.waitForStamina) then
							onPause = true;

							local percentageStamina;

							repeat
								percentageStamina = (myStats.Stamina.Value / myStats.Stamina.MaxValue) * 100;
								task.wait();
							until percentageStamina >= library.flags.waitForStaminaValue or not library.flags.waitForStamina;

							onPause = false;
						end;
					end);
				end;
			end

			function functions.rejoinServer()
				if (library:ShowConfirm('Are you sure you want to <font color="rgb(255, 0, 0)">rejoin</font> this server ')) then
					TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId);
				end;
			end;

			function functions.autoChests()
				while library.flags.toggleAutoChests do
					Heartbeat:Wait();
					local closest, closestDistance = nil, math.huge;
					local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
					if(not rootPart) then continue end;

					for i,v in next, workspace.Env:GetChildren() do
						if(v:FindFirstChild('ClickDetector')) then
							if((v.Position - rootPart.Position).Magnitude < closestDistance) then
								closest = v;
								closestDistance = (v.Position - rootPart.Position).Magnitude;
							end;
						end;
					end;

					if(closest) then
						functions.newTeleportAsync(closest.CFrame, function() return library.flags.toggleAutoChests end)
						fireclickdetector(closest.ClickDetector, 1);
						task.wait(1);
					end;
				end;
			end;

			function functions.autoFarm(toggle)
				if(not toggle) then return end;

				local rayParams = RaycastParams.new();
				rayParams.FilterDescendantsInstances  = {workspace.Islands};
				rayParams.FilterType = Enum.RaycastFilterType.Whitelist;

				repeat
					task.wait();

					local myCharacter = LocalPlayer.Character;
					local myRootPart = myCharacter and myCharacter.PrimaryPart;

					if(not myCharacter or not myRootPart) then
						continue
					end;

					for _, mob in next, workspace.NPCs:GetChildren() do
						if(not library.flags.toggleAutoFarm) then return end;
						local mobInfo = mob:FindFirstChild('Info');
						local mobHumanoid = mob and mob:FindFirstChildWhichIsA('Humanoid');
						local mobRoot = mob.PrimaryPart
						local isHostile = mobInfo and mobInfo:FindFirstChild('Hostile') and mobInfo.Hostile.Value;

						if(isHostile and mobHumanoid and mobRoot and (myRootPart.Position - mobRoot.Position).Magnitude <= 500) then
							functions.newTeleportAsync(mobRoot.CFrame);

							repeat
								local forceField = myCharacter and myCharacter:FindFirstChildWhichIsA('ForceField');
								local rayResult = workspace:Raycast(mobRoot.Position, Vector3.new(0, -100, 0), rayParams);

								if(forceField) then
									forceField:Destroy()
								end;

								if (rayResult) then
									myRootPart.CFrame = CFrame.new(rayResult.Position - Vector3.new(0, (library.flags.heightAdjustment or 4), 0));
								end;

								Heartbeat:Wait();
							until not library.flags.toggleAutoFarm or myCharacter.Parent == nil or mob.Parent == nil or not mobHumanoid.Parent or mobHumanoid.Health <= 0;
						end;
					end;
					Heartbeat:Wait();
				until not library.flags.toggleAutoFarm;
				functions.newTeleportAsync(CFrame.new(LocalPlayer.Character.PrimaryPart.Position + Vector3.new(0, 25, 0)));
			end;

			do -- Hitbox Module Hooks
				local hooked = false;
				local hookers = {};

				setthreadidentity(2);

				local hitboxModule = require(ReplicatedStorage.Modules.Hitbox);
				local oldStart = rawget(hitboxModule, 'start');
				assert(typeof(oldStart) == 'function');

				setthreadidentity(7);

				local function hookHitboxModule(hookName)
					if (not table.find(hookers, hookName)) then
						table.insert(hookers, hookName);
					end;

					if (hooked) then return end;
					hooked = true;

					print('Hooked');

					function hitboxModule:start(part, hitboxSize, ...)
						if (typeof(hitboxSize) ~= 'Vector3') then return oldStart(part, hitboxSize, ...) end;

						if (library.flags.autoAttack) then
							hitboxSize = Vector3.new(hitboxSize.X, hitboxSize.Y*2, hitboxSize.Z);
						elseif (library.flags.hitboxExtender) then
							hitboxSize *= library.flags.hitboxExtenderMultiplier;
						end;

						return oldStart(self, part, hitboxSize, ...);
					end;
				end;

				local function unhookHitboxModule(hookName)
					if (not hooked) then return end;

					local i = table.find(hookers, hookName);
					if (i) then table.remove(hookers, i) end;

					if (#hookers == 0) then
						print('Nothing hooks it anymore!');
						rawset(hitboxModule, 'start', oldStart);
						hooked = false;
					end;
				end;

				local wasModified = false;
				local gunHandle = require(ReplicatedStorage.Modules.GunHandle);
				local fire = rawget(gunHandle, 'Fire');
				local aimTimes = getupvalue(rawget(gunHandle, 'getAimTimes'), 1);

				function functions.autoAttack(toggle)
					if(not toggle) then
						maid.autoAttack = nil;
						forceTarget = nil;
						unhookHitboxModule('autoAttack');

						if (wasModified) then
							wasModified = false;
							setconstant(fire, 33, 0.1);
							setconstant(fire, 25, 0.5);
							rawset(aimTimes, 'Rifle', 0.3);
						end;

						return;
					end;

					wasModified = true;
					setconstant(fire, 33, 0);
					setconstant(fire, 25, 0);
					rawset(aimTimes, 'Rifle', 0);

					hookHitboxModule('autoAttack');
					addUsedFeature('auto attack');

					local lastFire = 0;
					local lastReloadAt = 0;
					local busy = false;


					maid.autoAttack = RunService.Heartbeat:Connect(function()
						if(busy or tick() - lastFire < 1/30) then return end;
						lastFire = tick();

						local closestMob, closestMobDistance = functions.getClosestEnemy();
						local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
						local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
						local weapon = functions.getWeapon();

						busy = true;
						pcall(functions.storeDevilFruitInBag, weapon, humanoid);
						busy = false;

						if(not rootPart or not humanoid or not closestMob or closestMobDistance > 25 or not weapon) then
							forceTarget = nil;
							return;
						end;

						weapon.Parent = LocalPlayer.Character

						if (tick() - lastReloadAt >= 0.1) then
							forceTarget = closestMob.Head.Position;
							functions.fireCombat();
						end;

						if (weapon:FindFirstChild('GunMain')) then
							forceTarget = closestMob.Head.Position;

							if (tick() - lastReloadAt >= 0.1) then
								lastReloadAt = tick();
								functions.fireCombat(true);
							end;
						end;
					end);
				end;

				function functions.hitboxExtender(toggle)
					if (toggle) then
						addUsedFeature('hitbox extender');
						hookHitboxModule('hitboxExtender');
					else
						unhookHitboxModule('hitboxExtender');
					end;
				end;
			end

			function functions.autoQuest(toggle)
				if (not toggle) then
					maid.bodyVelocityLoop = nil;
					maid.bodyVelocity = nil;
					maid.npcTP = nil;
					return;
				end;

				for _, v in next, workspace:GetDescendants() do
					if (v:IsA('Seat')) then
						v.CanTouch = false;
					end;
				end;

				maid.bodyVelocityLoop = RunService.Heartbeat:Connect(function()
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Head');
					if (not rootPart) then return end;

					maid.bodyVelocity = maid.bodyVelocity and maid.bodyVelocity.Parent and maid.bodyVelocity or Instance.new('BodyVelocity');
					maid.bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);
					maid.bodyVelocity.Velocity = Vector3.new();

					maid.bodyVelocity.Parent = rootPart;
				end);

				local rayParams = RaycastParams.new();
				rayParams.FilterDescendantsInstances  = {workspace.Islands};
				rayParams.FilterType = Enum.RaycastFilterType.Whitelist;

				while library.flags.toggleAutoQuest do
					task.wait();

					local npc, _, npcInfo = functions.getNPC(library.flags.autoQuestNpcName);
					if(not npc) then
						print('Npc not found');
						continue;
					end;

					if(myStats.Quest.CurrentQuest.Value ~= npcInfo.QuestName and myStats.Quest.CurrentQuest.Value ~= 'None') then
						pcall(function() ReplicatedStorage.Events.Quest:InvokeServer({'quit'}) end);
						task.wait(1);
					end;

					local character = LocalPlayer.Character;
					if (not character:FindFirstChild('realPos')) then continue end;
					local rootPart = character and character.PrimaryPart;

					if(npcInfo.QuestInfo.Type == 'Defeat') then
						if(myStats.Quest.CurrentQuest.Value ~= npcInfo.QuestName and rootPart) then
							maid.npcTP = nil;
							functions.newTeleportAsync(npc.PrimaryPart.CFrame + Vector3.new(0, -5, 0));
							task.wait(1);
							pcall(function() ReplicatedStorage.Events.Quest:InvokeServer({'takequest', npcInfo.QuestName}) end);
						end;

						local mob, mobHumanoid = functions.getNPC(npcInfo.QuestInfo.MobName);
						local mobRoot = mob and mob:FindFirstChild('HumanoidRootPart');

						if(mobRoot and rootPart and mobHumanoid) then
							functions.newTeleportAsync(mobRoot.CFrame + Vector3.new(0, -10, 0));

							local lastHealth = mobHumanoid.Health;
							local lastDamageAt = tick();

							repeat
								if (lastHealth ~= mobHumanoid.Health) then
									lastDamageAt = tick()
									lastHealth = mobHumanoid.Health;
								end;

								local rayResult = workspace:Raycast(mobRoot.Position, Vector3.new(0, -100, 0), rayParams);
								if (rayResult) then
									rootPart.CFrame = CFrame.new(rayResult.Position - Vector3.new(0, library.flags.heightAdjustment or 4, 0));
								end;

								Heartbeat:Wait();
							until mobHumanoid.Health <= 0 or not library.flags.toggleAutoQuest or not character.Parent or myStats.Quest.CurrentQuest.Value == 'None' or tick() - lastDamageAt > 25;

							if(not library.flags.toggleAutoQuest) then
								return;
							end;

							print('mob is dead!');
						elseif(rootPart) then
							warn(string.format('AutoQuest: No mob found for quest: %s target mob: %s', npcInfo.QuestName, npcInfo.QuestInfo.MobName));
							task.wait(2);
						else
							warn('AutoQuest: No root part');
							task.wait(2);
						end;
					elseif(npcInfo.QuestInfo.Type == 'Find') then
						functions.newTeleportAsync((npc.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(180), 0)) + npc.PrimaryPart.CFrame:VectorToWorldSpace(Vector3.new(0, 0, -5)));
						task.wait(1);
						pcall(function() ReplicatedStorage.Events.Quest:InvokeServer({'takequest', npcInfo.QuestName}) end);
						task.wait(1);
						local position;
						pcall(function()
							ReplicatedStorage.Events.Quest:InvokeServer({'requestposition'});
						end);
						task.wait(1);
						functions.newTeleportAsync(position);
						task.wait(1);
						pcall(function() ReplicatedStorage.Events.Quest:InvokeServer({'founditem'}); end);
						task.wait(1);
						functions.newTeleportAsync((npc.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(180), 0)) + npc.PrimaryPart.CFrame:VectorToWorldSpace(Vector3.new(0, 0, -5)));
						pcall(function() ReplicatedStorage.Events.Quest:InvokeServer({'returnitem'}); end);
					else
						-- error(string.format('AutoQuest: unknown type for %s quest: %s', npcInfo.QuestInfo.Type, npcInfo.QuestName));
					end;

					if(myStats.Quest.CurrentQuest.Value == 'None') then
						functions.newTeleportAsync(npc.PrimaryPart.CFrame + Vector3.new(0, -5, 0));
						maid.npcTP = RunService.Heartbeat:Connect(function()
							rootPart.CFrame = CFrame.new(npc.PrimaryPart.Position + Vector3.new(0, -5, 0));
						end);

						task.wait(1);
						print('waiting for quest cd');
						task.wait(15);
					end;
				end;
			end;

			function functions.toggleSpeed(toggle)
				if(not toggle) then
					maid.toggleSpeedBV = nil;
					maid.toggleSpeed = nil;
					return;
				end;

				addUsedFeature('speed');

				maid.toggleSpeedBV = Instance.new('BodyVelocity');
				maid.toggleSpeedBV.MaxForce = Vector3.new(50000, 0, 50000);

				maid.toggleSpeed = RunService.Heartbeat:Connect(function()
					local character = LocalPlayer.Character;
					if (not character) then return end;

					local head = character:FindFirstChild('Head');
					local rootPart = character:FindFirstChild('Head');

					if (not rootPart or not head) then return end;

					local alignOrientation = rootPart:FindFirstChild('AlignOrientation');
					if (alignOrientation and alignOrientation.Enabled) then
						maid.toggleSpeedBV.Parent = nil;
						return;
					end;

					if (library.flags.toggleShipFarm) then
						maid.toggleSpeedBV = nil;
						return;
					end;

					local camera = workspace.CurrentCamera;

					maid.toggleSpeedBV = maid.toggleSpeedBV and maid.toggleSpeedBV.Parent and maid.toggleSpeedBV or Instance.new('BodyVelocity');

					maid.toggleSpeedBV.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.speed);
					maid.toggleSpeedBV.MaxForce = Vector3.new(50000, 0, 50000);

					maid.toggleSpeedBV.Parent = head;
				end);
			end;

			function functions.toggleIslandEsp(state)
				if (not state) then
					maid.islandESP = nil;
					islandESP:UnloadAll();
					return;
				end;

				maid.islandESP = RunService.Stepped:Connect(function()
					islandESP:UpdateAll();
				end);
			end;

			function functions.toggleMedalEsp(state)
				if (not state) then
					maid.medalESP = nil;
					medalESP:UnloadAll();
					return;
				end;

				maid.medalESP = RunService.Stepped:Connect(function()
					medalESP:UpdateAll();
				end);
			end;

			function functions.toggleChestsESP(t)
				if (not t) then
					maid.chestESP = nil;
					chestsESP:UnloadAll();
					return;
				end;

				maid.chestESP = RunService.Stepped:Connect(function()
					chestsESP:UpdateAll();
				end);
			end;

			local function disableSeats(ship)
				for _, part in next, ship:GetDescendants() do
					if (IsA(part, 'Seat') or IsA(part, 'VehicleSeat')) then
						part.Disabled = true;
					end;
				end;
			end;

			local currentTP;
			local lastSpawnedShip = '';

			local function spawnShip()
				setthreadidentity(2);

				local suc, err = pcall(function()
					local inventory = LocalPlayer.PlayerGui.Main.Inventory;
					local availaibleShips = {};

					for _, item in next, inventory.Section.ScrollingFrame:GetChildren() do
						local realName = item:FindFirstChild('RealName');

						if (realName and item:GetAttribute('itemType') == 'Ship') then
							table.insert(availaibleShips, {
								realName = realName.Value,
								item = item
							});
						end;
					end;

					for _, ship in next, availaibleShips do
						if (ship.realName ~= lastSpawnedShip or #availaibleShips <= 1) then
							print('Spawning', ship.item, ship.realName);
							setupvalue(getconnections(ship.item.MouseButton1Click)[1].Function, '4', ship.item);
							lastSpawnedShip = ship.realName;
							break;
						end;
					end;

					local connection = getconnections(inventory.Desc.Equip.MouseButton1Click)[1];

					setconstant(connection.Function, 4, 'Stop');
					connection.Function();
					setconstant(connection.Function, 4, 'Play');
					getconnections(LocalPlayer.PlayerGui.Main.Buttons.Frame.boat.MouseButton1Click)[1]:Fire();
					setthreadidentity(7);
				end);

				if (not suc) then
					warn(err);
				end;
			end;

			function functions.shipFarm(toggle)
				if(not toggle) then
					maid.shipFarmNoClip = nil;
					maid.shipFarmBV = nil;
					maid.shipFarmTPCheck = nil;

					return;
				end;

				maid.shipFarmBV = Instance.new('BodyVelocity');

				maid.shipFarmNoClip = RunService.Stepped:Connect(function()
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if(not rootPart) then return end;

					maid.shipFarmBV = maid.shipFarmBV.Parent and maid.shipFarmBV or Instance.new('BodyVelocity')
					maid.shipFarmBV.Parent = rootPart;
					maid.shipFarmBV.MaxForce = Vector3.new(math.huge, math.huge, math.huge);
					maid.shipFarmBV.Velocity = Vector3.new();

					for i, v in next, LocalPlayer.Character:GetDescendants() do
						if(v:IsA('BasePart')) then
							v.CanCollide = false;
						end;
					end;
				end);

				local lastPosition;
				local lastTeleportedAt = 0;

				local function characterGotTeleported()
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if (not rootPart) then return end;

					if (not lastPosition) then
						lastPosition = rootPart.Position;
						return false;
					end;

					local distance = (lastPosition - rootPart.Position).Magnitude;
					lastPosition = rootPart.Position;

					if (distance > 500) then
						lastTeleportedAt = tick();

						return true;
					end;

					return false;
				end;

				maid.shipFarmTPCheck = RunService.Heartbeat:Connect(function()
					characterGotTeleported();
				end);

				while(library.flags.toggleShipFarm) do
					task.wait(0.5);

					if (tick() - lastTeleportedAt <= 5) then
						print('Character just got tp\'d, waiting a little bit');
						continue;
					end;

					local shipFarmLocation = library.configVars.gpoShipFarmLocation;

					if (shipFarmLocation) then
						shipFarmLocation = Vector3.new(unpack(shipFarmLocation:split(',')));

						functions.newTeleportAsync(CFrame.new(shipFarmLocation));
					end;

					local myShip = workspace.Ships:FindFirstChild(string.format('%sShip', LocalPlayer.Name));
					local myShipRoot = myShip and myShip.PrimaryPart;

					if(not myShipRoot) then
						spawnShip();
						task.wait(2);
						continue;
					end;

					jesus(true);
					disableSeats(myShip);

					for _, captain in next, workspace.NPCs:GetChildren() do
						if ((captain.Name == 'Pirate Captain' or captain.Name == 'Marine Captain') and captain.PrimaryPart) then
							local ship = captain:FindFirstChild('assignedShip');
							ship = ship and ship.Value;
							if (not ship or not ship.Parent) then continue end;

							if (ship.Name:find('Galleon') and library.flags.ignoreGalleons) then continue end;

							local captainRoot = captain.PrimaryPart;
							local myHumanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
							if (not myHumanoid or not captainRoot) then continue end;

							local distance = (captainRoot.Position - myShipRoot.Position).Magnitude;
							if (distance > library.flags.shipFarmRange) then continue end;

							if(myHumanoid.Sit) then
								myHumanoid.Sit = false;
							end;

							repeat
								functions.teleport(CFrame.new(captainRoot.Position - captainRoot.CFrame.LookVector * 1.5, captainRoot.Position));
								Heartbeat:Wait();
							until LocalPlayer.Character == nil or LocalPlayer.Character.Parent == nil or myShip.Parent == nil or ship.Parent == nil or not library.flags.toggleShipFarm or not captain:FindFirstChild('Humanoid') or captain.Humanoid.Health <= 0 or tick() - lastTeleportedAt <= 5;

							if (library.flags.killCannoneers) then
								for _, npc in next, workspace.NPCs:GetChildren() do
									local assignedShip = npc:FindFirstChild('assignedShip');
									local cannoneerRoot = npc and npc.PrimaryPart;
									local humanoid = npc and npc:FindFirstChildWhichIsA('Humanoid');

									if (assignedShip and assignedShip.Value == ship and humanoid and cannoneerRoot) then
										repeat
											functions.teleport(CFrame.new(cannoneerRoot.Position - cannoneerRoot.CFrame.LookVector * 1.5, cannoneerRoot.Position));
											task.wait();
										until LocalPlayer.Character == nil or LocalPlayer.Character.Parent == nil or humanoid.Health <= 0 or not humanoid.Parent or not npc.Parent or not library.flags.toggleShipFarm or tick() - lastTeleportedAt <= 5;
									end;
								end;
							end;

							if(not library.flags.toggleShipFarm) then
								return;
							end;
						end;
					end;
				end;
			end;

			function functions.autoTrainHaki(toggle)
				if(not toggle) then return end;

				while (library.flags.autoTrainHaki) do
					local busoBar = myStats.BusoBar.Value / myStats.BusoBar.MaxValue;

					-- // Turn on haki when full
					if(busoBar == 1 and LocalPlayer.Character and not LocalPlayer.Character:FindFirstChild('BusoMelee') and myStats.Stats.BusoMastery.Value > 0) then
						ReplicatedStorage.Events.Haki:FireServer('Buso');
						task.wait(4);
					end;

					task.wait();
				end;
			end;

			function functions.autoTrainLogia(toggle)
				if(not toggle) then return end;

				while(library.flags.autoTrainLogia) do
					local myCharacter = LocalPlayer.Character;
					local myRootPart = myCharacter and myCharacter.PrimaryPart;

					if(myRootPart) then
						for _, mob in next, workspace.NPCs:GetChildren() do
							local mobInfo = mob:FindFirstChild('Info');
							local mobRoot = mob.PrimaryPart
							local isHostile = mobInfo and mobInfo:FindFirstChild('Hostile') and mobInfo.Hostile.Value;
							local logia = myStats.LogiaBar.Value / myStats.LogiaBar.MaxValue;
							if(isHostile and mobRoot and (myRootPart.Position - mobRoot.Position).Magnitude <= 500 and myStats.Stats.LogiaMastery.Value > 0) then
								functions.newTeleportAsync(mobRoot.CFrame);
								if(logia == 0) then
									repeat
										logia = myStats.LogiaBar.Value / myStats.LogiaBar.MaxValue;
										myCharacter:SetPrimaryPartCFrame(mobRoot.CFrame + Vector3.new(0, 25, 0))
										Heartbeat:Wait();
									until logia == 1;
								else
									repeat
										logia = myStats.LogiaBar.Value / myStats.LogiaBar.MaxValue;
										myCharacter:SetPrimaryPartCFrame(mobRoot.CFrame + mobRoot.CFrame.LookVector * 5)
										Heartbeat:Wait();
									until not library.flags.autoTrainLogia or myCharacter.Parent == nil or mob.Parent == nil or not mob:FindFirstChild('Humanoid') or mob.Humanoid.Health <= 0 or logia == 0;
								end;
								break;
							end;
						end;
					end;
					task.wait();
				end;
			end;

			function functions.teleportToIsland(island)
				if (island.Name == 'Fishman Island') then
					functions.newTeleportAsync(CFrame.new(5639.86865, -92.762001, -16611.4688));
				else
					functions.newTeleportAsync(CFrame.new(island:GetAttribute('islandPosition') + Vector3.new(0, 100, 0)), nil, island.Name == 'Land of the Sky');
				end;
			end;

			function functions.toggleAutoFocus()
				while(library.flags.toggleAutoFocus) do
					local requiredFocus = 0;
					for _, focusValue in next, autoFocusList do
						requiredFocus = requiredFocus + focusValue;
					end;

					if(myStats.Stats.SkillPoints.Value >= requiredFocus) then
						for focusName, focusValue in next, autoFocusList do
							if(focusValue > 0) then
								ReplicatedStorage.Events.stats:FireServer(focusName, nil, focusValue);
							end;
						end;
					end;

					task.wait(1);
				end;
			end;

			function functions.addAutoFocus(focusType)
				return function(value)
					autoFocusList[focusType] = value;
				end;
			end;

			local autoDisconnectRanAt;

			function functions.autoDisconnect(toggle)
				if (not toggle) then
					maid.autoDisconnectCheck = nil;
					return;
				end;

				autoDisconnectRanAt = tick();

				maid.autoDisconnectCheck = task.spawn(function()
					while task.wait(1) do
						if (tick() - autoDisconnectRanAt > library.flags.autoDisconnectTime*60) then
							LocalPlayer:Kick('Auto Disconnect');
						end;
					end;
				end);
			end;

			function functions.autoRejoin(toggle)
				if (not toggle) then
					library.configVars.autoRejoin = false;
					maid.autoRejoin = nil;
					return;
				end;

				print('Set it to', library.configVars.gpoPrivateServer);

				local noCharacterSince;

				maid.autoRejoin = task.spawn(function()
					while task.wait(1) do
						library.configVars.autoRejoin = library.flags.autoRejoin;

						if (LocalPlayer.Character and LocalPlayer.Character.Parent) then
							noCharacterSince = nil;
						else
							if (not noCharacterSince) then
								print('No character since');
								noCharacterSince = tick();
							end;
						end;

						if (not game:GetService('NetworkClient'):FindFirstChild('ClientReplicator') or noCharacterSince and tick() - noCharacterSince >= 15) then
							TeleportService:Teleport(LOBBY_PLACE_ID);
						end;
					end;
				end);
			end;

			function functions.fly(toggle)
				if (not toggle) then
					maid.flyHack = nil;
					maid.flyBv = nil;

					return;
				end;

				addUsedFeature('fly');

				maid.flyBv = Instance.new('BodyVelocity');
				maid.flyBv.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

				maid.flyHack = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local rootPart, camera = playerData.rootPart, workspace.CurrentCamera;
					if (not rootPart or not camera) then return end;

					maid.flyBv.Parent = rootPart;
					maid.flyBv.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.flyHackValue);
				end);
			end;

			function functions.noFog(t)
				if (not t) then
					maid.noFog = nil;
					return;
				end;

				maid.noFog = RunService.Heartbeat:Connect(function()
					local atmosphere = Lighting:FindFirstChild('Atmosphere');
					if (not atmosphere) then return end;

					atmosphere.Density = 0.1;
				end);
			end;

			function functions.noStun(t)
				if (not t) then
					maid.noStun = nil;
					return;
				end;

				maid.noStun = RunService.Heartbeat:Connect(function()
					local char = LocalPlayer.Character;

					if (CollectionService:HasTag(char, 'Stun')) then
						CollectionService:RemoveTag(char, 'Stun');
					end;

					for _, v in next, {'Dizzed', 'Stun', 'frozen'} do
						local object = char:FindFirstChild(v);

						if (object) then
							object:Destroy();
						end;
					end;
				end);
			end;

			function functions.noClip(t)
				if (not t) then
					maid.noClip = nil;
					return;
				end;

				addUsedFeature('noclip');

				maid.noClip = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local parts = playerData.parts;
					for _, part in next, parts do
						part.CanCollide = false;
					end;
				end);
			end;

			do -- Ship Speed
				-- // TODO: Make this better
				local hooked = false;

				setthreadidentity(2);

				local shipManager = getrenv().require(ReplicatedStorage.ShipModules.ShipManager);
				local oldApplySpeed = rawget(shipManager, 'ApplySpeed');
				assert(typeof(oldApplySpeed) == 'function');
				setthreadidentity(7);

				function functions.shipSpeed(t)
					if (not t) then
						if (not hooked) then return end;

						hooked = false;
						rawset(shipManager, 'ApplySpeed', oldApplySpeed);

						return;
					end;

					addUsedFeature('ship speed');

					hooked = true;
					rawset(shipManager, 'ApplySpeed', function(self)
						local shipSpeedVal = library.flags.shipSpeedValue;
						if(not self._maxSpeed) then
							self._maxSpeed = self.MaxSpeed;
							self._accel = self.Accel;
							self._brake = self.Brake;
						end;

						if(shipSpeedVal ~= 1) then
							self.Accel = shipSpeedVal * 10;
							self.MaxSpeed = shipSpeedVal * 10;
							self.Brake = shipSpeedVal * 10;

							local myShip = workspace.Ships:FindFirstChild(string.format('%sShip', LocalPlayer.Name));
							if(myShip and myShip:FindFirstChild('shipHP')) then
								myShip.shipHP.Value = myShip.shipHP.MaxValue;
							end;
						else
							self.MaxSpeed = self._maxSpeed;
							self.Accel = self._accel;
							self.Brake = self._brake;
						end;

						return oldApplySpeed(self);
					end);
				end;
			end;

			do -- No Dash Cooldown
				-- // TODO: Make this better
				setthreadidentity(2);
				local dashTypes = getrenv().require(ReplicatedStorage.Util.Movement.DashTypes);
				setthreadidentity(7);
				local oldDash = rawget(dashTypes, 'dash');
				assert(typeof(oldDash) == 'function');

				local hooked = false;

				function functions.noDashCooldown(t)
					if (not t) then
						if (not hooked) then return end;
						hooked = false;
						rawset(dashTypes, 'dash', oldDash);
						return;
					end;

					addUsedFeature('no dash cooldown');

					hooked = true;

					rawset(dashTypes, 'dash', function(...)
						coroutine.wrap(oldDash)(...);
					end);
				end;
			end;

			library.OnLoad:Connect(function()
				library.configVars.gpoPrivateServer = ReplicatedStorage.reservedCode.Value ~= '' and ReplicatedStorage.reservedCode.Value;
			end);

			local function onChildAddedDF(obj)
				local model = obj:FindFirstChild('Model', true);

				if (model) then
					_G.DEBUG_DATA_DF = model;
					local espObject = islandESP.new(model:GetPivot(), 'Devil Fruit', Color3.fromRGB(255, 0, 0), true);

					ToastNotif.new({text = 'A Devil fruit has spawned !'})

					repeat
						espObject:Update();
						Heartbeat:Wait();
					until obj.Parent == nil;

					espObject:destroy();
					print(obj, 'despawned :(');
				else
					warn('NO MODEL ????');
					_G.DEBUG_DATA = obj;
				end;
			end;

			local function onMedalAdded(obj)
				if (not obj:GetAttribute('FightingStyle')) then return end;

				local root = obj.PrimaryPart or obj:GetPivot();
				local espObject = medalESP.new(root, string.format('Medal %s', obj:GetAttribute('FightingStyle')), nil, true);
				obj.Destroying:Connect(function() espObject:Destroy() end)
			end;

			Utility.listenToChildAdded(workspace.Env.Settings, onChildAddedDF);
			Utility.listenToChildAdded(workspace.Effects, onMedalAdded);

			Players.PlayerAdded:Connect(function(player)
				task.wait();

				local suc, isInGroup = pcall(player.IsInGroup, player, 3229308);

				if(suc and isInGroup and library.flags.panicOnModJoin) then
					library:Unload();
				end;
			end);

			local seen = {};

			local function onCharacterAdded(character)
				if (not character) then return print('no char') end;

				local backpack = LocalPlayer:WaitForChild('Backpack', 10);
				if (not backpack) then return print('no backpack (timed out)') end;

				backpack.ChildAdded:Connect(function(obj)
					task.wait();

					local webhookLink = library.flags.dfNotifierWebhook;

					if (obj:FindFirstChild('FruitEater') and webhookLink:gsub('%s', '') ~= '' and webhookLink ~= 'nil' and not seen[obj]) then
						seen[obj] = true;

						Webhook.new(webhookLink):Send({
							content = "@everyone",
							embeds = {
								{
									title = 'Devil Fruit Notifier',
									description = string.format('You\'ve just got a **%s**', obj.Name),
									color = 47359,
									timestamp = DateTime.now():ToIsoDate(),
									footer = {
										text = LocalPlayer.Name
									}
								}
							}
						})
					end;
				end);
			end;

			LocalPlayer.CharacterAdded:Connect(onCharacterAdded);
			task.spawn(onCharacterAdded, LocalPlayer.Character);

			local listeningChests = {};

			local function onRenderChestUpdate(chestData, actionType)
				if (actionType == 'open') then
					-- Destroy chest from ESP
					local espObject = listeningChests[chestData];
					if (not espObject) then return end;
					espObject:Destroy();
					listeningChests[chestData] = nil;
				elseif (typeof(chestData) == 'table' and not listeningChests[chestData.ID]) then
					local espObject = chestsESP.new(chestData.ChestCFrame, chestData.Rare .. ' Chest', nil, true);
					listeningChests[chestData.ID] = espObject;
				end;
			end;

			task.spawn(function()
				ReplicatedStorage.Events:WaitForChild('renderChest', math.huge).OnClientEvent:Connect(onRenderChestUpdate);
			end);
		end;

		local Main = column1:AddSection('Main')
		local gpoCombat = column1:AddSection('Combat');
		local gpoAutoFarm = column1:AddSection('Auto Farm');
		local gpoMisc = column1:AddSection('Misc');
		local risky = column2:AddSection('Risky');
		local gpoAutoSkill = column2:AddSection('Auto Skill');
		local gpoAutoFocus = column2:AddSection('Auto Stats');
		local teleports = game.PlaceId ~= BATTLE_ROYALE_PLACE_ID and column2:AddSection('Teleports');

		Main:AddBox({
			text = 'DF Notifier Webhook'
		});

		Main:AddToggle({
			text = 'No Fall Damage'
		});

		Main:AddToggle({
			text = 'Panic On Mod Join'
		});

		Main:AddToggle({
			text = 'No Jump Cooldown'
		});

		Main:AddToggle({
			text = 'No Dash Cooldown',
			callback = functions.noDashCooldown
		});

		Main:AddToggle({
			text = 'Infinite Stamina',
			callback = functions.infiniteStamina
		});

		Main:AddToggle({
			text = 'Anti Drown'
		});

		risky:AddToggle({
			text = 'Fly',
			callback = functions.fly
		}):AddSlider({
			min = 16,
			max = 45,
			flag = 'Fly Hack Value'
		});

		risky:AddToggle({
			text = 'Toggle Speed Hack',
			flag = 'Toggle Speed',
			callback = functions.toggleSpeed
		}):AddSlider({
			flag = 'Speed',
			min = 16,
			max = 100
		});

		gpoCombat:AddToggle({
			text = 'Hitbox Extender',
			callback = functions.hitboxExtender
		}):AddSlider({
			text = 'Multiplier',
			flag = 'Hitbox Extender Multiplier',
			textpos = 2,
			min = 1,
			value = 2,
			max = 4,
			float = 0.1
		});

		-- gpoCombat:AddToggle({
		--     text = 'Auto Perfect Block',
		--     callback = perfectBlock
		-- });

		risky:AddToggle({
			text = 'No Clip',
			callback = functions.noClip
		});

		gpoCombat:AddToggle({
			text = 'No Stun',
			callback = functions.noStun
		});

		gpoCombat:AddToggle({
			text = 'Silent Aim',
		});

		gpoCombat:AddToggle({
			text = 'Auto Attack',
			callback = functions.autoAttack
		});

		gpoCombat:AddToggle({
			text = 'Auto Train Haki',
			callback = functions.autoTrainHaki
		});

		gpoCombat:AddToggle({
			text = 'Auto Train Logia',
			callback = functions.autoTrainLogia
		});

		gpoAutoFarm:AddDivider('Safety Features');


		gpoAutoFarm:AddToggle({text = 'Auto Disconnect', callback = functions.autoDisconnect}):AddSlider({flag = 'Auto Disconnect Time', min = 5, max = 60, suffix = 'mins'});
		gpoAutoFarm:AddToggle({text = 'Auto Rejoin', callback = functions.autoRejoin});

		gpoAutoFarm:AddDivider('Farms');

		-- gpoAutoFarm:AddToggle({text = 'Toggle Auto Farm', callback = functions.autoFarm});
		-- gpoAutoFarm:AddToggle({text = 'Toggle Auto Quest', callback = functions.autoQuest});
		-- gpoAutoFarm:AddBox({text = 'Quest NPC Name', flag = 'Auto Quest Npc Name', textpos = 2});
		-- gpoAutoFarm:AddSlider({text = 'Height Adjustment', min = -25, max = 25, value = 4});

		-- gpoAutoFarm:AddToggle({text = 'Toggle Ship Farm', callback = shipFarm}):AddSlider({text = 'Ship Farm Range', min = 500, max = 5000});
		-- gpoAutoFarm:AddToggle({text = 'Kill Cannoneers'});
		-- gpoAutoFarm:AddToggle({text = 'Ignore Galleons'})
		-- gpoAutoFarm:AddButton({text = 'Set Ship Farm Location', callback = functions.setShipFarmLocation});
		-- shipFarmLocationLabel = gpoAutoFarm:AddLabel();

		-- gpoAutoFarm:AddToggle({text = 'Toggle Auto Chests', callback = functions.autoChests})

		gpoMisc:AddToggle({text = 'No Fog', callback = functions.noFog});
		gpoMisc:AddToggle({text = 'Auto Store Fruit'});
		gpoMisc:AddButton({text = 'Rejoin Server', callback = functions.rejoinServer});
		gpoMisc:AddToggle({text = 'No Self Ship Damage'});
		gpoMisc:AddToggle({text = 'Ship Speed', callback = functions.shipSpeed}):AddSlider({textpos = 2, text = 'Ship Speed Value', min = 1, max = 20});

		function Utility:renderOverload(data)
			local Toggles = data.espSettings;
			Toggles:AddToggle({text = 'Toggle Islands Esp', flag = 'Islands', callback = functions.toggleIslandEsp});
			Toggles:AddToggle({text = 'Toggle Devil Fruit Esp'});

			local chestESP = data.column2:AddSection('Chests ESP');

			chestESP:AddToggle({text = 'Toggle Chests ESP', flag = 'Chests', callback = functions.toggleChestsESP});
			chestESP:AddToggle({text = 'Show Distance', flag = 'Chests Show Distance', state = true});

			chestESP:AddToggle({text = 'Toggle Medal ESP', flag = 'Medals', callback = functions.toggleMedalEsp}):AddColor({text = 'Color', color = Color3.fromRGB(255, 0, 0), flag = 'Medals Color'});
			chestESP:AddToggle({text = 'Show Distance', flag = 'Medals Show Distance', state = true});

			chestESP:AddToggle({text = 'Show Uncommon Chest', state = true}):AddColor({text = 'Uncommon Chest Color', color = Color3.fromRGB(145, 255, 151)});
			chestESP:AddToggle({text = 'Show Common Chest', state = true}):AddColor({text = 'Common Chest Color', color = Color3.fromRGB(0, 255, 13)});
			chestESP:AddToggle({text = 'Show Rare Chest', state = true}):AddColor({text = 'Rare Chest Color', color = Color3.fromRGB(255, 72, 40)});
			chestESP:AddToggle({text = 'Show Legendary Chest', state = true}):AddColor({text = 'Legendary Chest Color', color = Color3.fromRGB(0, 195, 255)});
			chestESP:AddToggle({text = 'Show Mythical Chest', state = true}):AddColor({text = 'Mythical Chest Color', color = Color3.fromRGB(0, 102, 255)});
		end;

		local skillsList = {'E', 'R', 'Z', 'T', 'X', 'C'};
		local islands = {};

		local function isBlacklisted(p1)
			if (p1.Name == 'Fishman Cave') then return true end;

			return p1.Name == '\217\131\217\135\217\129 \217\129\217\138\216\180\217\133\216\167\217\134';
		end;

		for i, v in next, workspace.Islands:GetChildren() do
			if(not isBlacklisted(v)) then
				table.insert(islands, v);
			end;
		end;

		if (teleports) then
			for i, v in next, islands do
				islandESP.new(CFrame.new(v:GetAttribute('islandPosition')), v.Name, nil, true);
				teleports:AddButton({text = v.Name, callback = function() functions.teleportToIsland(v) end})
			end;
		end;

		gpoAutoFocus:AddToggle({text = 'Enable', flag = 'Toggle Auto Focus', callback = functions.toggleAutoFocus});

		task.spawn(function()
			for i, v in next, LocalPlayer.PlayerGui:WaitForChild('Main'):WaitForChild('Stats'):WaitForChild('Frame'):GetChildren() do
				if(v:IsA('Frame')) then
					gpoAutoFocus:AddSlider({textpos = 2, text = v.Stat.Text, min = 0, max = 5, callback = functions.addAutoFocus(v.Name)});
				end;
			end;
		end);

		for i, v in next, skillsList do
			gpoAutoSkill:AddToggle({
				text = string.format('Use %s', v),
				callback = function(t)
					functions.toggleAutoSkill(v, t)
				end
			}):AddSlider({min = 0.1, max = 5, text = 'Hold Time', flag = v .. ' Hold Time', textpos = 2, float = 0.1});
		end;

		gpoAutoSkill:AddToggle({text = 'Stack Skills'})
		gpoAutoSkill:AddToggle({text = 'Wait For Stamina'})
		gpoAutoSkill:AddSlider({text = 'Wait For Stamina Value', value = 0, max = 100, textpos = 2});
	end)()
end

if (gameName == 'Voxl Blade') then (function()
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];


		local basicsHelpers = sharedRequires['basics'];

		local column1, column2 = unpack(library.columns);

		local mobfarmUtility = sharedRequires['mobfarm']
		local funcs = {};

		local ReplicatedStorage, Players, RunService, MemStorageService, CollectionService, PathfindingService, TeleportService = Services:Get('ReplicatedStorage', 'Players', 'RunService', 'MemStorageService', 'CollectionService', 'PathfindingService', 'TeleportService');
		local LocalPlayer = Players.LocalPlayer;

		local allMobs = {};
		local allCraft = {};
		local allMobsDistances = {};
		local allItemTypes = {};

		local mobTypes = {'Crimson', 'Magical', 'Corrupt', 'Legendary', 'Bloody'};
		local getNPCNameNonCorrupt;

		local dungeonsData = require(ReplicatedStorage.Data.DungeonData);
		local notifsQueue = {};

		local addNotif, removeNotif;
		local mobFarmLocationLabel;

		local playerGui = LocalPlayer:WaitForChild('PlayerGui', math.huge);
		local coreUI = playerGui:WaitForChild('Core', math.huge);
		local loadingScreen = coreUI:WaitForChild('LoadingScreen', math.huge);

		repeat
			task.wait();
		until not loadingScreen.Visible;

		-- Funcs
		do
			local maid = Maid.new();
			local NPCsFolder = workspace.NPCS;
			local interactables = workspace.Interactables;
			local others = workspace.Others;
			local infusers = workspace.Infusers;

			local events = ReplicatedStorage.Events;
			local swingSword = events.SwingSword;
			local equipWeapon = events.EquipWeapon;
			local zonesFolder = ReplicatedStorage.MusicZone;
			local weaponArt = events.WeaponArt;
			local rune = events.Rune;
			local dialogEffect = events.DialogEffect;
			local craftItem = events.CraftItem;
			local destroyItem = events.DestroyItem;
			local startLobby = events.StartLobby;
			local playGame = events.PlayGame;
			local equipArmor = events.EquipArmor;
			local swapSet = events.SwapSet;

			local charHandler = require(LocalPlayer.PlayerScripts.Core.Controllers.CharHandler);
			local craftData = require(ReplicatedStorage.Data.CraftingData);
			local itemsData = require(ReplicatedStorage.Data.ItemData);

			for name in next, craftData do
				table.insert(allCraft,name);
			end;

			for _, itemData in next, itemsData do
				if (not table.find(allItemTypes, itemData.Type)) then
					table.insert(allItemTypes, itemData.Type);
				end;
			end;

			table.sort(allCraft, function(a, b) return a < b; end);
			table.sort(allItemTypes, function(a, b) return a < b; end);

			local healNpcs = {};

			local function isMobDead(mob)
				if (not mob) then return false; end;
				if (not library.flags.mobAutoFarm) then return true; end;
				return not mob.Parent or mob:GetAttribute('Dead');
			end;

			local function getMobRoot(mob)
				return mob;
			end;

			local function onNPCAdded(obj, espConstructor)
				local npcName = obj:GetAttribute('NPCName');
				if (not npcName) then return end;

				if (obj:GetAttribute('AIType')) then return end; -- All NPCs and Mobs have a tag called NPC
				espConstructor.new(obj, npcName, nil, true);
			end;

			local function onMobAdded(obj, espConstructor)
				if (not obj:GetAttribute('AIType')) then return end;
				local mobType = obj:GetAttribute('Type');
				local mobName, corrupted = getNPCNameNonCorrupt(obj:GetAttribute('NPCAppearance'));
				local notifData;

				-- For whatever reason CName are corrupted but their Type is Basic
				if (corrupted) then
					mobType = 'Corrupt';
				end;

				if (mobType ~= 'Basic') then
					mobName = string.format('%s(%s)', mobName, mobType);
					notifData = { name = 'Variant', text = string.format('%s has spawned turn on the ESP to see it', mobName) }
					addNotif(notifData);
				end;

				local esp = espConstructor.new(obj, {displayName = mobName, tag = mobType});
				local con;

				con = obj:GetPropertyChangedSignal('Parent'):Connect(function()
					if (obj.Parent) then return end;
					esp:Destroy();
					con:Disconnect();

					if (notifData) then
						removeNotif(notifData);
					end;
				end);

				if (mobName == 'IronSlayer') then
					notifData = { name = 'Iron Slayer', text = string.format('%s has spawned turn on the ESP to see it', mobName) };
					addNotif(notifData);
				end;
			end;

			local function getNameOfArea(obj)
				local nameOfArea;

				if (obj.Name == '???') then
					nameOfArea = 'Vampire Cave';
				elseif (obj:FindFirstChild('Configs')) then
					nameOfArea = obj.Configs.NameOfArea.Value;
				elseif (obj:FindFirstChild('Linked')) then
					return getNameOfArea(obj.Linked.Value);
				end;

				return nameOfArea;
			end

			local function onAreaAdded(obj, espConstructor)
				local nameOfArea = getNameOfArea(obj);
				if (not nameOfArea) then return; end;

				espConstructor.new(obj, nameOfArea);
			end;

			local function onShopItemAdded(obj, espConstructor)
				local shop = obj:FindFirstChild('Shop');
				if (not shop or not shop:IsA('ProximityPrompt')) then return end;

				espConstructor.new(obj, string.format('%s - %s$', obj:GetAttribute('Shop'), obj:GetAttribute('Cost')), nil, true);
			end;

			local function onDungeonAdded(obj, espConstructor)
				if (not obj:FindFirstChild('Dungeon')) then return end;
				espConstructor.new(obj, string.format('%s Dungeon', obj.Name:match('(.+)Dungeon')), nil, true);
			end;

			local function onInfuserAdded(obj, espConstructor)
				espConstructor.new(obj:FindFirstChildWhichIsA('BasePart', true), obj.Name, nil, true);
			end;

			local function oncraftingStationAdded(obj, espConstructor)
				espConstructor.new(obj, 'Crafting Station', nil, true);
			end;

			local function onShrineAdded(obj, espConstructor)
				local primaryPart = obj.PrimaryPart;
				if (not primaryPart) then return end;
				espConstructor.new(primaryPart, obj.Name, nil, true);
			end;

			local function onRiftAdded(obj, espConstructor)
				local union = obj:findFirstChild('Union');
				if (not union) then return end;

				local espObject;

				local function onUnionTransparencyChanged()
					if (union.Transparency == 1 and espObject) then
						espObject:Destroy();
						espObject = nil;
					elseif (union.Transparency == 0) then
						espObject = espConstructor.new(union, 'Rift', nil, true);
					end;
				end;

				union:GetPropertyChangedSignal('Transparency'):Connect(onUnionTransparencyChanged);
				onUnionTransparencyChanged();
			end;

			makeESP({
				sectionName = 'NPCs',
				type = 'tagAdded',
				args = 'NPC',
				callback = onNPCAdded
			});

			makeESP({
				sectionName = 'Crafting Stations',
				type = 'tagAdded',
				args = 'Crafting',
				callback = oncraftingStationAdded
			});

			makeESP({
				sectionName = 'Shrines',
				type = 'childAdded',
				args = workspace.Shrines,
				callback = onShrineAdded
			});

			makeESP({
				sectionName = 'Areas',
				type = 'childAdded',
				args = zonesFolder,
				callback = onAreaAdded
			});

			makeESP({
				sectionName = 'Buyables',
				type = 'childAdded',
				args = interactables,
				callback = onShopItemAdded
			});

			makeESP({
				sectionName = 'Dungeons',
				type = 'childAdded',
				args = others,
				callback = onDungeonAdded
			});

			makeESP({
				sectionName = 'Infusers',
				type = 'childAdded',
				args = infusers,
				callback = onInfuserAdded
			});

			makeESP({
				sectionName = 'Rifts',
				type = 'childAdded',
				args = interactables,
				callback = onRiftAdded
			});

			makeESP({
				sectionName = 'Mobs',
				type = 'tagAdded',
				args = 'NPC',
				callback = onMobAdded,
				onLoaded = function(section)
					local list = {};

					section:AddToggle({
						text = 'Show Health',
						flag = 'Mobs Show Health'
					});

					for _, mobType in next, mobTypes do
						table.insert(list, section:AddColor({
							text = string.format('%s Mob Color', mobType),
							flag = string.format('%s Color', mobType)
						}));
					end;

					return {list = list};
				end
			});

			do -- Grab Health NPCs
				local dialogTable = require(LocalPlayer.PlayerScripts.Core.Controllers.DialogTable);

				local function findDialogue(text)
					local result = {};

					for npcName, dialogData in next, dialogTable do
						local textFunc = rawget(dialogData, 'Text');
						if (typeof(textFunc) ~= 'function') then continue end;

						for _, v2 in next, getconstants(textFunc) do
							if (typeof(v2) == 'string' and v2:find(text)) then
								table.insert(result, {
									npcName = npcName,
									choice = v2
								});
								break;
							end;
						end;
					end;

					return result;
				end;

				healNpcs = findDialogue('Heal %[');
			end;

			local lastFireAt = 0;
			local forcedHeightAdjust = 0;

			local explodingBombers = {};
			local effectsData = {};
			local isDungeon = false;

			-- Used for Bomber NPCs cause they make you take damage when they explode
			function effectsData.BomberGlow(effectData)
				table.insert(explodingBombers, effectData.Target);
				task.delay(10, function()
					local exists = table.find(explodingBombers, effectData.Target);
					if (not exists) then return end;
					table.remove(explodingBombers, exists);
					-- We would assume that after 10 sec the mob is dead
				end);
			end;

			function effectsData.PlayAnimation(effectData)
				table.foreach(effectData, warn);
				if (effectData.Animation == 'Breath' and getNPCNameNonCorrupt(effectData.Target:GetAttribute('NPCName')) == 'Dragigator' and isDungeon and library.flags.mobAutoFarm) then
					print('DRAGIGATOR???');

					local heightAdjust = 15;
					local rootPart = Utility:getPlayerData().rootPart;

					if (rootPart.Position.Y >= 240) then
						print('adjust higher');
						-- If we are too high then we go down this is so we don't get kicked for being out of bounds
						heightAdjust = -heightAdjust;
					end;

					-- We need to do this cause our character is sometimes rotated and sometimes not
					print('go up');
					task.wait(1);
					rootPart.CFrame = CFrame.new(-49.80000305175781, 3, -1483.300048828125)
					task.wait(1.5);
					print('go down');
				end;
			end;

			local blacklistedEffects = {'PlayAnimation', 'Punch', 'Damage', 'WindSlash', 'Notify', 'Alert', 'Death', 'Stun', 'HeavyPunch', 'Screenshake'};
			library.unloadMaid:GiveTask(events.Effect.OnClientEvent:Connect(function(effectData)
				if (effectData.Name and not table.find(blacklistedEffects, effectData.Name)) then
					-- print('-------------');
					-- table.foreach(effectData, warn);
				end;

				if (not effectData.Name or not effectsData[effectData.Name]) then return end;
				effectsData[effectData.Name](effectData);
			end));

			local function doHealLogic(closestNpc, distance2)
				local rootPart = Utility:getPlayerData().rootPart;

				if (library.flags.autoHealUsePotion) then
					-- If we find a potion use it instead

					for itemId, item in next, charHandler.Inventory do
						if (item.ItemName == 'ThrowableHealingPotion' or item.ItemName == 'HealthPotion') then
							forcedHeightAdjust += 20;
							rootPart.CFrame = CFrame.new(rootPart.CFrame.Position + Vector3.new(0, 20, 0)) * rootPart.CFrame.Rotation;
							equipArmor:InvokeServer(itemId, false); -- 2nd arg true is for cosmetics
							task.delay(1, function()
								forcedHeightAdjust -= 20;
								rootPart.CFrame = CFrame.new(rootPart.CFrame.Position + Vector3.new(0, -20, 0)) * rootPart.CFrame.Rotation;
							end);

							task.wait(1);
							return true;
						end;
					end;
				end;

				-- If we find a NPC to Heal then go to it
				if (closestNpc) then
					mobfarmUtility:tweenTeleport(CFrame.new(closestNpc.Position));

					if (distance2 <= 5) then
						local humanoid = Utility:getPlayerData().humanoid;
						if (not humanoid) then return true; end;

						local lastHealth = humanoid.Health;

						dialogEffect:FireServer(closestNpc, 'Heal');
						local startedAt = tick();
						repeat
							task.wait();
						until humanoid.Health ~= lastHealth or tick() - startedAt > 5;
					end;

					return true;
				end;
			end;

			local function attackMob(rateLimit)
				if (tick() - lastFireAt < (rateLimit or 0.05)) then return end;

				if (not LocalPlayer:GetAttribute('EquippedSword')) then
					equipWeapon:InvokeServer();
					task.wait(0.5);
				end;

				lastFireAt = tick();
				swingSword:FireServer(library.flags.useM2 and 'R' or 'L');

				if (library.flags.useSkill) then
					weaponArt:FireServer();
				end;

				if (library.flags.useRune) then
					rune:FireServer();
				end;
			end;

			local cachedPath;
			local queenBeeSetup;

			local lastCachedPathUpdateAt = 0;
			local SHRINE_ACTIVE_COLOR = Color3.fromRGB(255, 0, 0);

			local function beeDungeonLogic(dungeon, arena)
				if (arena or not dungeon:FindFirstChild('Start')) then return end;

				local prompts = CollectionService:GetTagged('Prompt');

				local chest, chestDistance = mobfarmUtility:getClosest(prompts, {
					getRoot = function(obj) return obj.Parent:IsA('BasePart') and obj.Parent end,
					filter = function(obj) return obj.Name == 'HoneyChest' end,
					isAlive = function(obj)
						if (obj:GetAttribute('Cooldown')) then return false; end;
						local rootPart = obj.Parent;
						local top = rootPart.Parent:FindFirstChild('Top');

						return top and rootPart and (rootPart.Position - top.Position).Magnitude < 3.5;
					end,
				});

				if (chest) then
					mobfarmUtility:tweenTeleport(CFrame.new(chest.Parent.Position + Vector3.new(0, 5, 0)), {
						instant = true
					});

					if (chestDistance <= 20) then
						fireproximityprompt(chest);
					end;

					return true;
				end;

				local endPart = dungeon:FindFirstChild('End');

				if not endPart then
					LocalPlayer:Kick("The maze was bugged, no end.");
					TeleportService:Teleport(8651781069);
				end;

				-- We force path finding service to update path every 0.5s incase there was an issue
				if (not cachedPath or tick() - lastCachedPathUpdateAt > 0.5) then
					lastCachedPathUpdateAt = tick();
					local START_POSITION = Vector3.new(14.394362449645996, 2.487703323364258, 8.34000015258789);
					local path = PathfindingService:CreatePath();

					print('Waiting for path to be completed');

					for _, v in next, dungeon:GetChildren() do
						if (v:FindFirstChild('DoorHitbox')) then
							v.Door.CanCollide = false;
							v.DoorHitbox.CanCollide = false;
						end;

						if (v:FindFirstChild('Fountain')) then
							for i,v in next, v.Fountain:GetChildren() do
								if not v:IsA("BasePart") then continue; end
								v.CanCollide = false;
							end;
						end;
					end;

					for _, v in next, endPart.Hole:GetChildren() do
						if (v:IsA('BasePart')) then
							v.CanCollide = false; -- Fix the issue where Hole is blocking path finding service?
						end;
					end;

					local ranSince = tick();

					repeat
						path:ComputeAsync(START_POSITION, endPart.Position + Vector3.new(0, 9, 0)); -- Fix the issue where endPart is too below ground?
						print(path.Status);
					until path.Status == Enum.PathStatus.Success or tick() - ranSince > 1;

					cachedPath = path;
					print('Got path');
				end;

				local npcs = CollectionService:GetTagged('NPC');

				for _, waypoint in next, cachedPath:GetWaypoints() do
					print(waypoint);

					if (debugMode) then
						local p = Instance.new("Part",workspace);
						p.CanCollide = false;
						p.Anchored = true;
						p.Size = Vector3.new(1,1,1);
						p.CFrame = CFrame.new(waypoint.Position);
					end;

					local doorNearby = mobfarmUtility:getClosest(npcs, {
						filter = function(obj) return obj.Name == 'DoorHitbox' end,
						getRoot = function(obj) return obj end,
						rootOverride = waypoint,
						maxDistance = 15
					});

					if (not doorNearby) then continue end;

					local breakingStartedAt = tick();

					repeat
						if not library.flags.mobAutoFarm then break; end
						mobfarmUtility:tweenTeleport(doorNearby.CFrame*CFrame.new( 8, 7, 0) * CFrame.Angles(0, math.rad(90),0), {
							instant = true
						});
						attackMob(0.2);
						task.wait();
					until not doorNearby.Parent or tick() - breakingStartedAt > 8;

					-- We believe path finding service Path is most likely broken so we'll recompute it
					if (tick() - breakingStartedAt > 8) then
						break;
					end;
				end;

				if (library.flags.destroyShrines) then
					while true do
						local shrine = mobfarmUtility:getClosest(npcs, {
							getRoot = function(obj) return obj; end,
							filter = function(obj)
								return obj.Parent and obj.Parent.Name == 'Shrine' and obj.Parent.Eyes.Color ~= SHRINE_ACTIVE_COLOR;
							end
						});

						if (not shrine) then
							warn('no shrine found!');
							break;
						end;

						repeat
							if not library.flags.mobAutoFarm then break; end
							mobfarmUtility:tweenTeleport(CFrame.new(shrine.Position - Vector3.new(3, 0, 0), shrine.Position), {
								instant = true
							});
							attackMob(0.2);
							task.wait();
						until shrine.Parent.Eyes.Color == SHRINE_ACTIVE_COLOR or not library.flags.dungeonAutoFarm;
					end;
				end;

				if not library.flags.mobAutoFarm then return; end

				mobfarmUtility:tweenTeleport(endPart.Position, {
					instant = true
				});
				task.wait(5);
				cachedPath = nil;

				return true;
			end;

			function funcs.mobAutoFarm(toggle)
				local placeId = game.PlaceId;
				local isDungeonLocal, dungeonName = Utility.find(dungeonsData, function(v) return tonumber(v.ID) == placeId; end);
				isDungeon = isDungeonLocal;

				if (not toggle) then
					maid.mobNoclip = nil;
					mobfarmUtility.turnOffAutoFarm();

					local humanoid = Utility:getPlayerData().humanoid;
					if not humanoid then return; end

					humanoid.JumpPower = 50;
					return;
				end;

				maid.mobNoclip = RunService.Stepped:Connect(function()
					local playerData = Utility:getPlayerData();
					local humanoid = playerData.humanoid;
					local rootPart = playerData.rootPart;
					if (not humanoid or not rootPart) then return end;

					-- This is required cause spamming jump make you fall to the ground with noclip
					rootPart.AssemblyLinearVelocity = Vector3.new(0, 0.95, 0);

					for _, part in next, playerData.parts do
						part.CanCollide = false;
					end;

					humanoid:ChangeState('Jumping');
					humanoid.JumpPower = 0;
				end);

				local lastMobSpawnedAt = tick();

				while true do
					task.wait();
					if (not library.flags.mobAutoFarm) then break end;

					local useFixedZone = library.flags.useFixedZone;
					local fixedZoneRange = library.flags.fixedZoneRange;
					local fixedZonePosition = library.configVars.voxlbladeAutoFarmLocation;
					fixedZonePosition = fixedZonePosition and Vector3.new(unpack(fixedZonePosition:split(',')));

					local dungeon =  isDungeon and workspace.Map:FindFirstChild('Dungeon');
					local arena = workspace.Map:FindFirstChild('Arena');
					-- Arena is the end of the Queen Bee Dungeon

					local mob = mobfarmUtility:getClosest(NPCsFolder, {
						getRoot = getMobRoot,
						isAlive = function(obj) return not isMobDead(obj) end,
						prioritize = function(obj)
							if (isDungeon and getNPCNameNonCorrupt(obj:GetAttribute('NPCName')) == 'Dragigator') then
								return true;
							end;
						end,
						filter = function(mob)
							-- If bee dungeon force mob auto farm to ONLY attack QueenBee
							if (arena) then
								local isQueenBee = getNPCNameNonCorrupt(mob:GetAttribute('NPCName')) == 'QueenBee';

								if (isQueenBee and not queenBeeSetup) then
									queenBeeSetup = true;
									mob:GetAttributeChangedSignal('HP'):Connect(function()
										if (mob:GetAttribute('HP') <= 0 and library.flags.infiniteDungeon) then
											print('IT DIED');
											task.wait(1);
											LocalPlayer:Kick();
											TeleportService:Teleport(8651781069);
											print(game.Players.LocalPlayer:GetAttribute('BeeDungeonCD'));
										end;
									end);
								end;

								return isQueenBee;
							end;

							-- Filters should not run in Dungeons to prevent breaking it lol
							if (isDungeon) then return true; end;

							local filterPassed = false;
							filterPassed = not library.flags.enableMobFilter or library.flags.mobFilter[mob:GetAttribute('NPCAppearance')];
							filterPassed = filterPassed and (not library.flags.enableMobTypesFilter or library.flags.mobTypesFilter[mob:GetAttribute('Type')]);

							if (useFixedZone) then
								filterPassed = filterPassed and (mob.Position - fixedZonePosition).Magnitude <= fixedZoneRange;
							end;

							return filterPassed;
						end
					});

					-- Dungeon Logic
					if (isDungeon) then
						if (dungeonName == 'BeeDungeon' and beeDungeonLogic(dungeon, arena)) then
							continue;
						end;
					end;

					if (mob) then
						lastMobSpawnedAt = tick();
					end;

					-- If no mobs for 30 seconds and we have use fixed zone turned on and we are not in dungeon tp to the fixed zone position
					if (tick() - lastMobSpawnedAt > 30 and library.flags.useFixedZone and fixedZonePosition and not isDungeon) then
						mobfarmUtility:tweenTeleport(CFrame.new(fixedZonePosition));
						continue;
					end;

					repeat
						task.wait();

						-- If we are not in a dungeon but dungeonAutoFarm is turned on do nothing
						if (not isDungeon and library.flags.dungeonAutoFarm) then break; end;
						if (not mob or not library.flags.mobAutoFarm) then break end;

						local playerData = Utility:getPlayerData();
						local rootPart, humanoid = playerData.rootPart, playerData.humanoid;
						if (not rootPart or not humanoid) then continue end;

						local distance = Utility:roundVector(mob.Position - rootPart.Position).Magnitude;
						local mobName = getNPCNameNonCorrupt(mob:GetAttribute('NPCName'));

						local shouldHeal = library.flags.autoHeal and (humanoid.Health / humanoid.MaxHealth) * 100 <= library.flags.autoHealPercentage;

						if (shouldHeal) then
							local closestNpc, distance2 = mobfarmUtility:getClosest(interactables, {
								getRoot = getMobRoot,
								filter = function(npc)
									return Utility.find(healNpcs, function(v) return v.npcName == npc.Name end)
								end
							});

							local dialogData = Utility.find(healNpcs, function(v) return v.npcName == closestNpc:GetAttribute('NPCName'); end);
							local amountNeeded = dialogData and tonumber(dialogData.choice:match('%p(%d+)')) or 0;

							if ((LocalPlayer:GetAttribute('Voxos') or 0) >= amountNeeded) then
								doHealLogic(closestNpc, distance2);
								continue;
							end;
						end;

						local mobHeight = library.flags.useGlobalDistance and library.flags.globalDistance or library.flags[string.format('%sHeight', mobName:lower())] or 10;
						mobHeight += forcedHeightAdjust;

						mobfarmUtility:tweenTeleport(CFrame.new(mob.Position), {
							offset = CFrame.new(0, mobHeight, 0) * CFrame.Angles(math.rad(-90), 0, 0),
							instant = isDungeon
						});

						-- We round Vector it so it should work fine
						if (distance <= 2.5) then
							attackMob();
						end;
					until isMobDead(mob);
				end;
			end;

			function funcs.noKnockback(toggle)
				if (not toggle) then
					maid.noKnockback = nil;
					return;
				end;

				maid.noKnockback = RunService.Stepped:Connect(function()
					local rootPart = Utility:getPlayerData().rootPart;
					if (not rootPart or not rootPart:FindFirstChild('Knockback')) then return end;

					rootPart.Knockback:Destroy();
				end);
			end;

			local lastShown;
			function funcs.mobDistances()
				local mobSelected = library.flags.mobDistances;

				if (lastShown) then
					lastShown.main.Visible = false;
				end;

				lastShown = allMobsDistances[mobSelected];
				lastShown.main.Visible = true;
			end;

			function funcs.itemCrafter()
				local toCraft = library.flags.itemName;

				local _, distance = mobfarmUtility:getClosest(interactables, {
					filter = function(obj) return obj.Name == 'Crafting' end,
					getRoot = function(obj) return obj end
				});

				if (distance >= 20) then
					ToastNotif.new({text = 'You are too far away from a crafting table'});
					return;
				end;

				for _ = 1, library.flags.craftAmount do
					task.spawn(function()
						craftItem:InvokeServer(toCraft);
					end);
				end;
			end;

			function funcs.autoSell()
				local _, distance = mobfarmUtility:getClosest(interactables, {
					filter = function(obj) return CollectionService:HasTag(obj, 'Shopkeeper') end,
					getRoot = function(obj) return obj; end
				});

				if (distance >= 20) then
					ToastNotif.new({text = 'You are too far away from a shop keeper.'});
					return;
				end;

				local toSell = {};
				local foundItems = false;

				for i, item in next, charHandler.Inventory do
					local itemData = itemsData[item.ItemName];
					local isEnchanted = #item.Enchantments > 0;

					if (isEnchanted and library.flags.doNotSellEnchantedItem) then continue end;
					if (not library.flags.autoSellTypes[itemData.Type]) then continue end;

					toSell[i] = item.Amount or 1;
					foundItems = true;
				end;

				if (not foundItems) then return end;
				destroyItem:InvokeServer(toSell);
			end;

			function funcs.setFixedZonePosition()
				local rootPart = Utility:getPlayerData().rootPart;
				if (not rootPart) then return end;

				library.configVars.voxlbladeAutoFarmLocation = tostring(rootPart.Position);
				mobFarmLocationLabel.Text = string.format('Position: %d,%d,%d', math.floor(rootPart.Position.X), math.floor(rootPart.Position.Y), math.floor(rootPart.Position.Z));
			end;

			local oldSet;
			function funcs.setDataloss(t)
				if (not oldSet) then
					oldSet = LocalPlayer:GetAttribute('Set') or '1';
				end;

				swapSet:invokeServer(t and string.char(128) or oldSet);
				ToastNotif.new({
					text = t and 'Dataloss set!' or 'Dataloss unset!'
				});
			end;

			do -- Notifier Utils
				local notifiersToUpdate = {};

				function addNotif(data)
					table.insert(notifsQueue, data);
					for _, f in next, notifiersToUpdate do task.spawn(f); end;
				end;

				function removeNotif(data)
					table.remove(notifsQueue, table.find(notifsQueue, data));
				end;

				function funcs.makeNotifier(name)
					local toggled = false;
					local function updateQueue()
						if (not toggled) then return end;

						for _, notifData in next, notifsQueue do
							if (notifData.name ~= name) then continue; end;

							ToastNotif.new({
								text = notifData.text
							});

							table.remove(notifsQueue, table.find(notifsQueue, notifData));
						end;
					end;

					table.insert(notifiersToUpdate, updateQueue);

					return function (toggle)
						toggled = toggle;
						if (not toggle) then return end;
						updateQueue();
					end;
				end;

				library.OnLoad:Connect(function()
					for _, f in next, notifiersToUpdate do task.spawn(f); end;
				end);
			end;

			do -- Dungeon Auto Farm
				local function canDoDungeon(dungeonName)
					return ReplicatedStorage.Clock.Value > LocalPlayer:GetAttribute(dungeonName .. 'CD');
				end;

				function funcs.dungeonAutoFarm(toggle)
					if (not toggle) then
						mobfarmUtility.turnOffAutoFarm();
						return;
					end;

					if (library.OnLoad) then
						library.OnLoad:Wait(); -- Wait for library to be loaded to get actual dropdown value
					end;

					-- Grab dungeon data
					local dungeonToFarm = library.flags.dungeonToFarm;
					local dungeonData, dungeonName = Utility.find(dungeonsData, function(v) return v.TrueName == dungeonToFarm end);
					local additionalMods = {};

					-- If we are in a Dungeon do not run this code it's only used to start the dungeon
					if (game.PlaceId == tonumber(dungeonData.ID)) then
						return;
					end;

					local dungeonLocation = others:WaitForChild(dungeonName, 5);
					if (not dungeonLocation) then return error('No dungeon found? ' .. dungeonToFarm); end;

					-- Spawn in character
					if (not LocalPlayer:GetAttribute('Loaded')) then
						if (not MemStorageService:HasItem('Slot')) then
							ToastNotif.new({
								text = 'Please spawn in first!'
							});
						else
							playGame:InvokeServer(MemStorageService:GetItem('Slot'));
						end;

						repeat task.wait(); until LocalPlayer:GetAttribute('Loaded');
					end;

					local rootPart;

					repeat
						rootPart = Utility:getPlayerData().rootPart;
						task.wait();
					until rootPart;

					local distance = (rootPart.Position - dungeonLocation.Position).Magnitude;

					if (distance > 20) then
						ToastNotif.new({
							text = 'Too far from dungeon. Teleporting to it'
						});

						rootPart.CFrame = CFrame.new(Utility:roundVector(rootPart.CFrame.Position) + Vector3.new(0, dungeonLocation.Position.Y + 2000, 0));
						repeat
							task.wait();
							distance = Utility:roundVector(rootPart.Position - dungeonLocation.Position).Magnitude;
							mobfarmUtility:tweenTeleport(CFrame.new(dungeonLocation.Position), {
								tweenSpeedIgnoreY = true,
								offset = CFrame.new(0, 2000, 0)
							});
						until distance <= 5 or not library.flags.dungeonAutoFarm;
					end;

					mobfarmUtility.destroyTweens();

					-- User toggled if off we don't do anything
					if (not library.flags.dungeonAutoFarm) then return end;

					rootPart.CFrame = dungeonLocation.CFrame;
					task.wait(1);

					if (library.flags.doCorruptDungeon and not dungeonLocation:GetAttribute('Corrupted') and dungeonName == 'FroggDungeon') then
						local bindedCorruption = Utility.find(charHandler.Inventory, function(v) return v.ItemName == 'BindedCorruption' end);

						if (bindedCorruption and bindedCorruption.Amount > 0) then
							-- TP to frogg status
							local froggStatue = interactables.CorruptFroggShrine.FroggStatue;
							local tween = mobfarmUtility:tweenTeleport(froggStatue.CFrame * CFrame.new(0, 0, 10));
							tween.Completed:Wait();

							dialogEffect:FireServer(froggStatue, 'SlotBinded');
							task.wait(1);
							mobfarmUtility:tweenTeleport(CFrame.new(dungeonLocation.Position));
						end;
					end;

					if (dungeonLocation:GetAttribute('Corrupted')) then
						table.insert(additionalMods, 'Corrupt');
					end;

					-- Wait for cooldown to go away or toggle to go off
					if (not canDoDungeon(dungeonName) and library.flags.dungeonAutoFarm) then
						ToastNotif.new({text = string.format('You are on cooldown for %s. The script will wait for the cooldown to finish.', dungeonToFarm)});
						repeat task.wait(); until canDoDungeon(dungeonName) or not library.flags.dungeonAutoFarm;
					end;

					-- User toggled if off we don't do anything
					if (not library.flags.dungeonAutoFarm) then return end;

					MemStorageService:SetItem('DungeonFarmPlaceId', dungeonData.ID);
					MemStorageService:SetItem('Slot', LocalPlayer.Slot.Value);

					-- Start dungeon with specific options as Solo (2nd arg)
					-- Need to be spammed cause roblox moment
					while true do
						if (not library.flags.dungeonAutoFarm) then return end;

						originalFunctions.invokeServer(startLobby, {
							Difficulty = library.flags.dungeonDifficulty,
							DungeonType = dungeonName,
							FriendsOnly = false,
							DailyChallenge = false,
							AdditionalMods = additionalMods,
							Players = {
								[LocalPlayer.Name] = LocalPlayer
							}
						}, true);

						task.wait(5);
					end;
				end;

				library.OnLoad:Connect(function()
					if (not MemStorageService:HasItem('DungeonFarmPlaceId')) then return end;

					local placeId = tonumber(MemStorageService:GetItem('DungeonFarmPlaceId'));
					MemStorageService:RemoveItem('DungeonFarmPlaceId');

					-- Mob auto farm is all compatible so we should be fine
					if (placeId == game.PlaceId and not library.flags.mobAutoFarm) then
						library.options.mobAutoFarm:SetState(true);
					end;
				end);
			end;

			do -- Grab all mobs
				for _, v in next, ReplicatedStorage.NPCs:GetChildren() do
					if (v:GetAttribute('Active') ~= nil or not v:FindFirstChild('HPBar', true) or not v:FindFirstChild('HPBar', true).Enabled) then continue end;
					table.insert(allMobs, v.Name);
				end;

				local toRemove = {};
				local allCorrupts = {};

				-- Remove CMob, etc as we have Mob Types filter
				for _, mobType in next, allMobs do
					local withoutC = mobType:sub(2); -- CMob

					if (table.find(allMobs, withoutC)) then
						table.insert(toRemove, mobType);
						allCorrupts[mobType] = withoutC;
					end;
				end;

				function getNPCNameNonCorrupt(name)
					local corruptName = allCorrupts[name];
					if (corruptName) then return corruptName, true; end;

					return name, false;
				end;

				for _, v in next, toRemove do
					table.remove(allMobs, table.find(allMobs, v));
				end;

				table.sort(allMobs, function(a, b) return a < b; end);
			end;
		end;

		do -- UI
			local autoFarm = column1:AddSection('Auto Farm');
			local localCheats = column2:AddSection('Movement');
			local misc = column2:AddSection('Misc');
			local debugWebhook = Webhook.new('');

			do -- // Auto Farm
				autoFarm:AddToggle({
					text = 'Mob Auto Farm',
					callback = funcs.mobAutoFarm
				});

				autoFarm:AddToggle({
					text = 'Dungeon Auto Farm',
					callback = funcs.dungeonAutoFarm
				});

				autoFarm:AddToggle({
					text = 'Do Corrupt Dungeon',
				});

				autoFarm:AddToggle({
					text = 'Destroy Shrines',
				});

				autoFarm:AddToggle({
					text = 'Infinite Dungeon',
					tip = 'Only works for Queen Bee Dungeon and you\'ll not get the loot at the end.'
				});

				autoFarm:AddToggle({
					text = 'Use M2'
				});

				autoFarm:AddToggle({
					text = 'Use Skill'
				});

				autoFarm:AddToggle({
					text = 'Use Rune'
				});

				autoFarm:AddToggle({
					text = 'Use Fixed Zone'
				});

				autoFarm:AddButton({
					text = 'Set Fixed Zone Position',
					callback = funcs.setFixedZonePosition
				});

				autoFarm:AddSlider({
					text = 'Fixed Zone Range',
					textpos = 2,
					min = 50,
					max = 5000
				});

				mobFarmLocationLabel = autoFarm:AddLabel();

				library.OnLoad:Connect(function()
					local savedLocation = library.configVars.voxlbladeAutoFarmLocation;
					savedLocation = savedLocation and Vector3.new(unpack(savedLocation:split(',')));

					local locationText = savedLocation and string.format('Position: %d,%d,%d', math.floor(savedLocation.X), math.floor(savedLocation.Y), math.floor(savedLocation.Z));

					mobFarmLocationLabel.Text = locationText or 'Position: Not set.';
				end);

				autoFarm:AddSlider({
					text = 'Dungeon Difficulty',
					textpos = 2,
					min = 0,
					value = 1,
					float = 0.1,
					max = 2,
				});

				autoFarm:AddList({
					text = 'Dungeon To Farm',
					values = Utility.map(dungeonsData, function(v) return v.TrueName end)
				});

				autoFarm:AddToggle({
					text = 'Auto Heal'
				}):AddSlider({
					text = 'Auto Heal %',
					flag = 'Auto Heal Percentage',
					min = 5,
					max = 90
				});

				autoFarm:AddToggle({
					text = 'Auto Heal Use Potion'
				});

				autoFarm:AddSlider({
					text = 'Tween Speed',
					textpos = 2,
					min = 10,
					max = 50
				});

				autoFarm:AddToggle({
					text = 'Enable Mob Filter'
				});

				autoFarm:AddToggle({
					text = 'Enable Mob Types Filter'
				});

				autoFarm:AddList({
					text = 'Mob Filter',
					values = allMobs,
					multiselect = true,
					tooltip = 'Mobs prefixed with a C are corrupted'
				});

				autoFarm:AddList({
					text = 'Mob Types Filter',
					values = mobTypes,
					multiselect = true
				});

				autoFarm:AddToggle({
					text = 'Use Global Distance'
				})

				autoFarm:AddSlider({
					text = 'Global Distance',
					textpos = 2,
					min = 0,
					value = 10,
					max = 20
				});

				autoFarm:AddList({
					text = 'Mob Distances',
					callback = funcs.mobDistances,
					values = allMobs
				});

				for _, mobType in next, allMobs do
					allMobsDistances[mobType] = autoFarm:AddSlider({
						text = string.format('%s Height', mobType),
						min = 0,
						textpos = 2,
						value = 10,
						max = 20,
					});

					library.OnLoad:Connect(function()
						allMobsDistances[mobType].main.Visible = false;
					end);
				end;
			end;

			do -- Local Cheats
				localCheats:AddToggle({
					text = 'Speed',
					callback = basicsHelpers.speedHack
				}):AddSlider({
					flag = 'Speed Hack Value',
					min = 16,
					max = 50
				});

				localCheats:AddToggle({
					text = 'Fly',
					callback = basicsHelpers.flyHack
				}):AddSlider({
					flag = 'Fly Hack Value',
					min = 16,
					max = 50
				});

				localCheats:AddToggle({
					text = 'Noclip',
					callback = basicsHelpers.noclip
				});

				localCheats:AddToggle({
					text = 'No Knockback',
					callback = funcs.noKnockback
				});

				localCheats:AddToggle({
					text = 'Infinite Jump',
					callback = basicsHelpers.infiniteJump
				}):AddSlider({
					min = 50,
					max = 250,
					flag = 'Infinite Jump Height'
				});
			end;

			do -- Misc
				misc:AddToggle({
					text = 'No Fog',
					callback = basicsHelpers.noFog
				});

				misc:AddButton({
					text = 'Auto Sell',
					callback = funcs.autoSell
				});

				misc:AddToggle({
					text = 'Do Not Sell Enchanted Item'
				});

				misc:AddList({
					text = 'Auto Sell Types',
					values = allItemTypes,
					multiselect = true
				});

				misc:AddToggle({
					text = 'Iron Slayer Notifier',
					callback = funcs.makeNotifier('Iron Slayer')
				});

				misc:AddToggle({
					text = 'Variants Notifier',
					callback = funcs.makeNotifier('Variant')
				});

				misc:AddToggle({
					text = 'No Blur',
					callback = basicsHelpers.noBlur
				});

				misc:AddToggle({
					text = 'Fullbright',
					callback = basicsHelpers.fullBright
				});

				misc:AddList({
					text = 'Item Name',
					values = allCraft,
				});

				misc:AddSlider({
					text = 'Craft Amount',
					min = 1,
					max = 100,
					textpos = 2
				});

				misc:AddButton({
					text = 'Craft',
					callback = funcs.itemCrafter
				});
			end;
		end;
	end)()
end

if (gameName == 'Ro Ghoul') then (function()
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];

		local column1, column2 = unpack(library.columns);

		local Players, ReplicatedStorage, TweenService, RunService, TeleportService = Services:Get('Players', 'ReplicatedStorage', 'TweenService', 'RunService', 'TeleportService');

		local LocalPlayer = Players.LocalPlayer;

		print("RO GHOUL FOUND!");

		local ClientControl
		repeat
			print("Waiting for game to start ...");
			ClientControl = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("ClientControl");
			task.wait(0.5);
		until ClientControl and not ClientControl.Disabled

		local PlayerTeam = LocalPlayer.PlayerFolder.Customization.Team.Value
		local toggleAutoFarm
		local toggleCashOutReputation
		local toggleAutoFocus
		local toggleAutoTrainer

		do --//Utility
			local RemoteKey
			for i, v in next, getgc() do
				if (typeof(v) == "function") then
					local Constants = not is_synapse_function(v) and islclosure(v) and getconstants(v)
					if (Constants and table.find(Constants, "KeyEvent")) then
						RemoteKey = Constants[table.find(Constants, "KeyEvent") + 1]
						break;
					end;
				end;
			end;

			if (not RemoteKey or typeof(RemoteKey) ~= "string") then
				print(RemoteKey);
				return LocalPlayer:Kick("\nError 404-A(RoGhoul). Make a support ticket if that happens again!");
			end;

			print("GotKey", RemoteKey);
			local tweenSpeed = 100;

			local function isMobInSafeZone(rootPart)
				local rayCastParams = RaycastParams.new();
				rayCastParams.FilterType = Enum.RaycastFilterType.Whitelist;
				rayCastParams.FilterDescendantsInstances = {workspace.SafeZones};

				local Result = workspace:Raycast(rootPart.Position, Vector3.new(0, -25, 0), rayCastParams) and true or false;
				if (Result) then
					warn("MOB IN SAFEZONE!");
				end;

				return Result;
			end;

			local function canAttack(Mob)
				if (string.find(Mob.Name, "Investigator") and library.flags.focusInvestigator) then
					return true;
				elseif (string.find(Mob.Name, "Aogiri") and library.flags.focusAogiri) then
					return true;
				elseif (Mob.Parent.Name == "HumanSpawns" and library.flags.focusHuman) then
					return true;
				elseif (Mob.Parent.Name == "BossSpawns" and library.flags.focusBoss) then
					return true;
				end;

				return false;
			end;

			local function canAttackQuest(Mob, questTarget)
				if (string.find(Mob.Name, "Investigator") and string.find(questTarget, "Investigator")) then
					return true;
				elseif (string.find(Mob.Name, "Aogiri") and string.find(questTarget, "Aogiri")) then
					return true;
				elseif (Mob.Parent.Name == "HumanSpawns" and string.find(questTarget, "Human")) then
					return true;
				end;

				return false;
			end

			local function getClosestMob()
				local currentMob, currentDistance, mobIsBoss = nil, math.huge, false;
				local MyRootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;

				local prioritys = {
					Eto = library.flags.etoPriority,
					Koutarou = library.flags.koutarouPriority,
					Nishiki = library.flags.nishikiPriority
				}

				local AllMobs = {};

				for i, v in next, workspace.NPCSpawns:GetChildren() do
					local isMob = v:FindFirstChildOfClass("Model")
					if (isMob and MyRootPart) then
						local root = isMob and isMob.PrimaryPart
						local mobDistance = root and (root.Position - MyRootPart.Position).Magnitude

						if (mobDistance and not isMobInSafeZone(root)) then
							table.insert(
								AllMobs,
								{
									mob = isMob,
									mobDistance = mobDistance,
									root = root,
									isBoss = v.Name == "BossSpawns"
								}
							)
						end
					end
				end

				local highest = 0
				local targetBoss = nil

				for _, Mob in next, AllMobs do
					if (Mob.isBoss) then
						for priorityBoss, priorityValue in next, prioritys do
							if (Mob.mob.Name:find(priorityBoss) and highest < priorityValue and priorityValue > 0) then
								highest = priorityValue
								targetBoss = Mob
							end
						end
					end
				end

				if (targetBoss and library.flags.focusBoss) then
					return targetBoss.mob, targetBoss.mobDistance, MyRootPart
				end

				if (library.flags.toggleAutoQuest) then
					local questTarget, questTargetObject = nil, nil
					local maxTarget, currentTarget = 1, 0

					local CurrentQuest = LocalPlayer.PlayerFolder.CurrentQuest

					for i, v in next, CurrentQuest.Complete:GetChildren() do
						if (v.Name ~= "Reward") then
							questTarget = v.Name
							questTargetObject = v
						end
					end

					if (questTargetObject) then
						currentTarget, maxTarget = questTargetObject.Value, questTargetObject.Max.Value
					end

					if (questTarget == nil or maxTarget == currentTarget) then
						local myTeam = PlayerTeam == "CCG" and "Yoshitoki" or "Yoshimura"
						local reputationPostion = workspace:FindFirstChild(myTeam, true):GetPrimaryPartCFrame().p

						local myRoot = MyRootPart
						local distanceFrom = (myRoot.Position - reputationPostion).Magnitude
						repeat
							myRoot = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart
							if (myRoot) then
								distanceFrom = (myRoot.Position - reputationPostion).Magnitude
								TweenService:Create(
									myRoot,
									TweenInfo.new(distanceFrom / tweenSpeed),
									{CFrame = CFrame.new(reputationPostion)}
								):Play()
							end
							wait(0.5)
						until myRoot and (myRoot.Position - reputationPostion).Magnitude <= 25
						wait(2.5)
						for i = 1, 2 do
							print(ReplicatedStorage.Remotes[myTeam].Task:InvokeServer())
							wait(2.5)
						end
					end

					for i, v in next, LocalPlayer.PlayerFolder.CurrentQuest.Complete:GetChildren() do
						if (v.Name ~= "Reward") then
							questTarget = v.Name
						end
					end

					local currentMob, currentDistance = nil, math.huge

					for _, Mob in next, AllMobs do
						local MobHumanoid = Mob.mob:FindFirstChildOfClass("Humanoid")

						if (Mob and MobHumanoid and MobHumanoid.Health > 25 and canAttackQuest(Mob.mob, questTarget)) then
							if (Mob.mobDistance < currentDistance) then
								currentMob, currentDistance, mobIsBoss = Mob.mob, Mob.mobDistance, Mob.isBoss
							end
						end
					end

					if (currentMob) then
						return currentMob, currentDistance, MyRootPart
					end
				end

				for _, Mob in next, AllMobs do
					local MobHumanoid = Mob.mob:FindFirstChildOfClass("Humanoid")

					if (Mob and MobHumanoid and MobHumanoid.Health > 25 and canAttack(Mob.mob)) then
						if (Mob.mobDistance < currentDistance) then
							currentMob, currentDistance, mobIsBoss = Mob.mob, Mob.mobDistance, Mob.isBoss
						end
					end
				end

				return currentMob, currentDistance, MyRootPart, mobIsBoss
			end

			local lastMobAttack = 0
			local function mobIsDead(Mob)
				if (tick() - lastMobAttack >= 60) then
					return true
				else
					local MobRoot = Mob and Mob.PrimaryPart
					if (Mob.Parent == nil) then
						print("Mob Not In Workspace")
						return true
					elseif (MobRoot and MobRoot.Position.Y <= 25) then
						return true
					elseif (Mob:FindFirstChild(Mob.Name .. " Corpse")) then
						return true, true
					end
				end
			end

			local function eatCorpse(clickPart)
				print('Found corpse');

				for _ = 1, 5 do
					pcall(fireclickdetector, clickPart);
					task.wait(0.1);
				end;
			end;

			local function FireServer(...)
				local Character = LocalPlayer.Character
				local Remotes = Character and Character:FindFirstChild("Remotes")
				local KeyEvent = Remotes and Remotes:FindFirstChild("KeyEvent")

				if (KeyEvent) then
					KeyEvent:FireServer(RemoteKey, ...)
				end
			end

			local BodyVelocity
			local function createBodyVelocity(MyRootPart)
				if (BodyVelocity and BodyVelocity.Parent ~= MyRootPart) then
					BodyVelocity:Destroy()
					BodyVelocity = nil
				end

				BodyVelocity = BodyVelocity or Instance.new("BodyVelocity")
				BodyVelocity.Velocity = Vector3.new()
				BodyVelocity.Parent = MyRootPart
			end

			local KaguneStages = {
				[0] = "Zero",
				[1] = "One",
				[2] = "Two",
				[3] = "Three",
				[4] = "Four",
				[5] = "Five",
				[6] = "Six",
				[7] = "Seven",
				[8] = "Eight",
				[9] = "Nine"
			}

			local autoFarmWorkings = {}
			autoFarmWorkings.autoFarm = false
			autoFarmWorkings.cashoutReputation = false
			autoFarmWorkings.autoTrainer = false

			local currentTween;

			local lastCashout = 0

			function autoFarmWorkings:all(exclude)
				for i, v in next, autoFarmWorkings do
					if (typeof(v) == "boolean" and v and i ~= exclude) then
						return true
					end
				end
			end

			function autoFarmWorkings:queue(autoFarmType)
				print("QUEUE STARTED!");

				autoFarmWorkings[autoFarmType] = true;
				repeat wait(); until not autoFarmWorkings:all(autoFarmType);

				print("QUEUE FINISHED!");
			end

			local function tweenTeleport(rootPart, position)
				local tweenInfo = TweenInfo.new((rootPart.Position - position).Magnitude / 100, Enum.EasingStyle.Linear);
				local tween = TweenService:Create(rootPart, tweenInfo, {CFrame = CFrame.new(position)});

				tween:Play();
				tween.Completed:Wait();
			end;

			function toggleAutoFarm(toggle)
				if (not toggle) then
					if(BodyVelocity) then
						BodyVelocity:Destroy();
						BodyVelocity = nil;
					end;

					if (currentTween) then
						currentTween:Cancel()
						currentTween = nil
					end
					return
				end

				repeat
					local Mob, MobDistance, MyRootPart, mobIsBoss = getClosestMob()

					if (Mob and MyRootPart and not autoFarmWorkings:all("autoFarm")) then
						autoFarmWorkings.autoFarm = true
						createBodyVelocity(MyRootPart)
						local tweenInfo = TweenInfo.new(MobDistance / tweenSpeed)
						lastMobAttack = tick()

						local Tween =
							TweenService:Create(
								MyRootPart,
								tweenInfo,
								{
									CFrame = CFrame.new(Mob.PrimaryPart.CFrame.p)
								}
							)
						Tween:Play()
						currentTween = Tween

						repeat
							RunService.Heartbeat:Wait();
						until mobIsDead(Mob) or Tween.PlaybackState ~= Enum.PlaybackState.Playing or not library.flags.toggleAutoFarm;

						if (not library.flags.toggleAutoFarm) then
							if (currentTween) then
								currentTween:Cancel();
								currentTween = nil;
							end;

							autoFarmWorkings.autoFarm = false;
							return;
						end;

						if (Tween.PlaybackState == Enum.PlaybackState.Completed) then
							local lastFire = 0;

							repeat
								local Character = LocalPlayer.Character;
								local MyRootPart = Character and Character.PrimaryPart;
								local mobRoot = Mob.PrimaryPart;

								if (MyRootPart and mobRoot) then
									createBodyVelocity(MyRootPart);
									MyRootPart.CFrame = CFrame.new(mobRoot.CFrame * (mobRoot.CFrame.LookVector * 2.5)) * CFrame.new(0, 5, 0) * CFrame.Angles(math.rad(-90), 0, 0);

									if (not (Character:FindFirstChild("Kagune") or Character:FindFirstChild("Katana") or Character:FindFirstChild("Quinque"))) then
										FireServer(KaguneStages[library.flags.kaguneStage or 1], 'Down', nil, 'ShiftLock', workspace.CurrentCamera.CFrame);
										wait(2)
									elseif (tick() - lastFire >= 0.1) then
										FireServer('Mouse1', 'Down', nil, 'ShiftLock', workspace.CurrentCamera.CFrame);

										if (mobIsBoss) then
											FireServer('E', 'Down', nil, 'ShiftLock', workspace.CurrentCamera.CFrame);
											FireServer('R', 'Down', nil, 'ShiftLock', workspace.CurrentCamera.CFrame);
											FireServer('F', 'Down', nil, 'ShiftLock', workspace.CurrentCamera.CFrame);
										end;

										lastFire = tick();
									end;
								end;

								if (not library.flags.toggleAutoFarm) then
									return;
								end;
								RunService.Heartbeat:Wait();
							until mobIsDead(Mob) or not library.flags.toggleAutoFarm;
						end;

						if (not library.flags.toggleAutoFarm) then
							autoFarmWorkings.autoFarm = false;
							return;
						end;

						local isDead, canEat = mobIsDead(Mob);

						if (isDead and canEat and library.flags.eatCorpse) then
							wait(0.5);
							local MobCorpse = Mob:FindFirstChild(Mob.Name .. " Corpse");
							local clickPart = MobCorpse and MobCorpse:FindFirstChildWhichIsA("ClickDetector", true);

							if(clickPart) then
								tweenTeleport(MyRootPart, clickPart.Parent.Position);
								eatCorpse(clickPart);
							else
								print('no click part!');
							end;

							print(clickPart);
							wait(0.2);
						end

						autoFarmWorkings.autoFarm = false;
					end
					wait(0.5);
				until not library.flags.toggleAutoFarm;
			end;

			function toggleCashOutReputation(toggle)
				if (not toggle) then
					return;
				end;

				repeat
					if (tick() - lastCashout >= 3600 and LocalPlayer.Character and LocalPlayer.Character.PrimaryPart) then
						autoFarmWorkings:queue("cashoutReputation")
						print("HEY IM CASHOUT IM DOING MY STUFF END IN 10SEC")

						local myTeam = PlayerTeam == "CCG" and "Yoshitoki" or "Yoshimura"
						local reputationPostion = workspace:FindFirstChild(myTeam, true):GetPrimaryPartCFrame().p

						local myRoot = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart
						local distanceFrom = (myRoot.Position - reputationPostion).Magnitude
						repeat
							myRoot = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart
							if (myRoot) then
								distanceFrom = (myRoot.Position - reputationPostion).Magnitude
								TweenService:Create(
									myRoot,
									TweenInfo.new(distanceFrom / tweenSpeed),
									{CFrame = CFrame.new(reputationPostion)}
								):Play()
							end
							wait(0.5)
						until myRoot and (myRoot.Position - reputationPostion).Magnitude <= 25
						wait(2.5)
						ReplicatedStorage.Remotes.ReputationCashOut:InvokeServer()
						lastCashout = tick()
						wait(2.5)
						autoFarmWorkings.cashoutReputation = false
						print("HEY IM CASHOUT I'VE DONE THE STUFF")
						wait(1)
					else
						print(string.format("CASHOUT CAN ONLY CASH OUT IN %s SECONDS", 3600 - (tick() - lastCashout)))
					end
					wait(1)
				until not library.flags.cashoutReputation
			end

			local allFocusTypes = {
				"Physical",
				"Kagune",
				"Durability",
				"Speed"
			}

			local function convert(value)
				if (value == "Kagune") then
					return "Weapon"
				end

				return value
			end

			function toggleAutoFocus(t)
				if (not t) then
					return
				end
				repeat
					local totalFocusPoint = 0

					for i, v in next, allFocusTypes do
						totalFocusPoint = totalFocusPoint + library.flags[string.lower(v)]
					end

					local playerFocus = tonumber(LocalPlayer.PlayerFolder.Stats.Focus.Value) or 0

					if (playerFocus >= totalFocusPoint) then
						for i, v in next, allFocusTypes do
							LocalPlayer.PlayerFolder.StatsFunction:InvokeServer(
								"Focus",
								convert(v) .. "AddButton",
								library.flags[string.lower(v)]
							)
						end
					end
					wait(0.25)
				until not library.flags.toggleAutoFocus
			end

			RunService.Stepped:Connect(function()
				local Character = LocalPlayer.Character
				if (Character and (library.flags.toggleAutoFarm or library.flags.cashoutReputation)) then
					for i, v in next, Character:GetChildren() do
						if (v:IsA("BasePart")) then
							v.CanCollide = false
						end
					end
				end
			end)

			local oldNamecall;
			oldNamecall = hookmetamethod(game, '__namecall', function(...)
				----SX_VM_CNONE();
				local method = getnamecallmethod();
				local self = ...;

				if(typeof(self) ~= 'Instance') then
					return oldNamecall(...);
				end;

				if(method == 'Destroy' and tostring(self) == 'TSCodeVal' and library.flags.toggleAutoTrainer) then
					local Caller = getfenv(2).script;
					local Trainer = Caller.TrainingSession.Value;

					delay(1, function()
						Trainer.Comm.FireServer(Trainer.Comm, 'Finished', self.Value, false);
						autoFarmWorkings.autoTrainer = false;
					end);
				end;

				return oldNamecall(...);
			end);

			function toggleAutoTrainer(t)
				if (not t) then
					return
				end

				repeat
					autoFarmWorkings:queue('autoTrainer');
					local data = ReplicatedStorage.Remotes.Trainers.RequestTraining:InvokeServer(LocalPlayer.PlayerFolder.Trainers[PlayerTeam .. "Trainer"].Value);
					print(data, data == nil, data == '');
					if(data ~= nil) then
						autoFarmWorkings.autoTrainer = false;
					end;
					wait(10)
				until not library.flags.toggleAutoTrainer
			end

			function setDataloss(t)
				pcall(function()
					local spawnLocationValue = LocalPlayer.PlayerFolder.Settings.SpawnLocation;
					local currentSpawn = spawnLocationValue.Value:gsub('\128', '');

					originalFunctions.fireServer(ReplicatedStorage.Remotes.Settings.SpawnSelection, t and string.format('%s\128', currentSpawn) or currentSpawn);

					spawnLocationValue:GetPropertyChangedSignal('Value'):Once(function()
						print('oui')
						spawnLocationValue.Value = currentSpawn;
					end);

					ToastNotif.new({
						text = t and 'Dataloss set' or 'Dataloss unset'
					});
				end);
			end;
		end

		do --//Render Gui
			local AutoFarm = column1:AddSection('Auto Farm');
			local AutoFocus = column2:AddSection("Auto Focus");
			local AutoTrainer = column2:AddSection("Auto Trainer");
			local Dataloss = column2:AddSection('Dataloss');

			AutoFarm:AddToggle({text = "Toggle Auto Farm", callback = toggleAutoFarm})
			AutoFarm:AddToggle({text = "Focus Investigator"})
			AutoFarm:AddToggle({text = "Focus Aogiri"})
			AutoFarm:AddToggle({text = "Focus Human"})
			AutoFarm:AddToggle({text = "Focus Boss"})
			AutoFarm:AddToggle({text = "Toggle Auto Quest"})
			AutoFarm:AddToggle({text = "CashOut Reputation", callback = toggleCashOutReputation})
			AutoFarm:AddToggle({text = "Eat Corpse"})

			AutoFarm:AddSlider({text = "Kagune Stage", min = 1, max = 6})
			AutoFarm:AddSlider({text = "Eto Priority", value = 3, min = 0, max = 3})
			AutoFarm:AddSlider({text = "Koutarou Priority", value = 2, min = 0, max = 3})
			AutoFarm:AddSlider({text = "Nishiki Priority", min = 0, max = 3})

			AutoFocus:AddToggle({text = "Toggle Auto Focus", callback = toggleAutoFocus})
			AutoFocus:AddSlider({text = "Physical",  min = 1, max = 10})
			AutoFocus:AddSlider({text = "Kagune", min = 1, max = 10})
			AutoFocus:AddSlider({text = "Durability", min = 1, max = 10})
			AutoFocus:AddSlider({text = "Speed", min = 1, max = 10})

			AutoTrainer:AddToggle({text = "Enable", flag = "Toggle Auto Trainer", callback = toggleAutoTrainer})

			Dataloss:AddButton({
				text = 'Set dataloss',
				callback = function() setDataloss(true) end
			});


			Dataloss:AddButton({
				text = 'Unset dataloss',
				callback = function() setDataloss(false) end
			});

			Dataloss:AddButton({
				text = 'Rejoin',
				callback = function() TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId); end
			})
		end
	end)()
end

if (gameName == 'Wild West') then (function()
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];

		local IsA = game.IsA;
		local ReplicatedStorage, Players = Services:Get('ReplicatedStorage', 'Players');

		local LocalPlayer = Players.LocalPlayer;
		local Mouse = LocalPlayer:GetMouse();

		local column1, column2 = unpack(library.columns);

		local noRain;
		local autoGetUp;
		local instantBreakFree;
		local disableAntiTeleport;


local Network = require(game:GetService("ReplicatedStorage").SharedModules.Global.Network);
local PlayerCharacter = require(game:GetService("ReplicatedStorage").Modules.Character.PlayerCharacter);

local thingToCheck = getupvalue(Network.FireServer, 4)[6];

for _, v in next, getgc() do
if (typeof(v) == 'function' and not is_synapse_function(v) and islclosure(v)) then
	local stackData = getupvalues(v)[1];

	if (typeof(stackData) == 'table' and rawget(stackData, 'NumUpvalues')) then
		pcall(function()
			local upvalues = getupvalue(v, 4);

			if (upvalues[6] == thingToCheck) then
				print('found', upvalues[2]);
			end;
		end);
	end;
end;
end;
-- Get protected functions


		do -- // Functions
			-- // Require Modules
			local oldNewIndex;
			oldNewIndex = hookmetamethod(game, '__newindex', function(self, p, v)
				----SX_VM_CNONE();
				if (IsA(self, 'Terrain') and p == 'Color' and string.find(debug.traceback(), 'Environment')) then
					warn('ban packet has been blocked!');
					return;
				end;

				return oldNewIndex(self, p, v);
			end);

			local load = require(ReplicatedStorage:WaitForChild('Modules'):WaitForChild('Load'));
			local loadShared = require(ReplicatedStorage:WaitForChild('SharedModules'):WaitForChild('Load'));

			load = getupvalue(load, 1);
			loadShared = getupvalue(loadShared, 1);

			if (typeof(load) ~= 'table' or typeof(loadShared) ~= 'table' or getrawmetatable(load) or getrawmetatable(loadShared)) then
				return LocalPlayer:Kick('DM Aztup');
			end;

			-- // Load Local
			local playerCharacter = load.PlayerCharacter;
			local replicatedState = load.ReplicatedState;
			local repCharHandler = load.RepCharHandler;
			local rain = load.Rain;
			local horse = load.Horse;
			local gunItem = load.GunItem;

			local function getOriginalFunction(f)
				local vmStack = getupvalues(f)[1];
				if (typeof(vmStack) ~= 'table' or not rawget(vmStack, 'NumUpvalues')) then
					warn(debug.info(f, 'lsnfa'), 'is not protected');
					return f;
				end;

				local upvalues = getupvalues(f)[4];
				if (not upvalues) then return LocalPlayer:Kick('There was an error. DM Aztup [0]'); end;

				local originalFunction = upvalues[11];

				if (typeof(originalFunction) ~= 'function') then
					return LocalPlayer:Kick('Error occured, dm Aztup [1]');
				end;

				return originalFunction;
			end;

			do
				local internal = rawget(repCharHandler, 'Flags');
				if (typeof(internal) ~= 'table') then
					return LocalPlayer:Kick('Error occured, dm Aztup');
				end;

				local internalMetatable = getrawmetatable(internal);
				local oldNewIndex = internalMetatable.__newindex;
				print(debug.info(oldNewIndex, 'lsnfa'));

				local flags = {'DamageSelf', 'LowerStamina', 'CharacterReplicate'};

				function internalMetatable.__newindex(self, p, v)
					if (p == 'DamageSelf' and library.flags.noFallDamage) then
						return;
					elseif (p == 'LowerStamina' and library.flags.infiniteStamina) then
						return;
					elseif (not table.find(flags, p)) then
						if (debugMode) then
							return LocalPlayer:Kick(p);
						end;

						return LocalPlayer:Kick('WildWest has attempted to detect the script please, DM Aztup');
					end;

					return oldNewIndex(self, p, v);
				end;
			end;

			-- // Load Shared
			local network = loadShared.Network;
			local projectileHandler = loadShared.ProjectileHandler;

			do -- // Network hook
				_G.blacklisted = {};
				_G.blacklisted.CharUpdate = true;
				_G.blacklisted.UpdateCharacterSpring = true;
				_G.blacklisted.CamPosReplicate = true;
				_G.blacklisted.StopSpectate = true;
				_G.blacklisted.UpdateCharacterAnimation = true;

				local fireServer = getOriginalFunction(network.FireServer);

				hookUV1 = {};
				hookUV1.prettyPrint = prettyPrint;
				hookUV1.debugMode = debugMode;
				hookUV1.library = library;
				hookUV1.print = print;
				hookUV1._G = _G;

				local function test(self, remote, ...)
					local args = {...};

					if(remote == 'DamageSelf' and hookUV1.library.flags.noFallDamage) then
						return;
					end;

					if(hookUV1.debugMode and not hookUV1._G.blacklisted[remote]) then
						hookUV1.print(hookUV1.prettyPrint({__remote = remote, ...}));
					end;

					return hookUV1.oldFireServer(self, remote, ...);
				end;

				table.foreach(getupvalues(test), warn);
				hookUV1.oldFireServer = hookfunction(fireServer, test);
			end;

			do -- // Infinite Stamina
				local lowerStamina = getOriginalFunction(playerCharacter.LowerStamina);
				local oldLowerStamina;
		
				oldLowerStamina = hookfunction(lowerStamina, function(...)
					if(library.flags.infiniteStamina) then return end;
					
					local a = {oldLowerStamina(...)};
		
					return unpack(a);
				end);
			end;
		

			do -- // New Gun cheats
				local oldCalculateRecoil = gunItem.CalculateRecoil; --, setCalculateRecoil = getOriginalFunction(gunItem.CalculateRecoil);

				function gunItem.CalculateRecoil(...)
					if(library.flags.noRecoil) then return 0 end;
					
					local a = {oldCalculateRecoil(...)};

					return unpack(a);
				end;
			end;

			do -- // Anti Ragdoll
				local enterRagdoll = getOriginalFunction(playerCharacter.Ragdoll);
				local oldEnterRagdoll;

				oldEnterRagdoll = hookfunction(enterRagdoll, function(...)
					if (library.flags.antiRagdoll) then return end;
					
					local a = {oldEnterRagdoll(...)};

					return unpack(a);
				end);
			end;

			do -- // IsTeamMate
				function Utility:isTeamMate(player)
					local playerInfo = repCharHandler:GetRepChar(player);
					if(not playerInfo.CharInfo) then
						return false;
					end;

					if(playerInfo.CharInfo.ProtectionStatus) then
						return true;
					end;

					if (not player.Team) then
						return false
					end

					if(not playerCharacter.State.WeaponSafetyEnabled) then
						return false;
					end;

					return player.Team == LocalPlayer.Team;
				end;

				function Utility:getCharacter(player)
					local playerState = replicatedState:GetPlayerState(player).ReplicatedState.Root;
					local health = playerState.Health or 0;
					local floatHealth = (health / 100) * 100;

					return player.Character, 100, floatHealth, math.floor(health);
				end;
			end;

			do -- // Silent Aim
				local initProjectile = getOriginalFunction(projectileHandler.InitProjectiles);
				local playersData = {};

				local upvalues = {};
				upvalues.playersData = playersData;
				upvalues.library = library;
				upvalues.Utility = Utility;

				local function onCharacterAdded(character)
					local destroyed = false;

					character.Destroying:Connect(function()
						destroyed = true;
						task.cancel(playersData[character].task);
						playersData[character] = nil;
					end);

					local rootPart = character:WaitForChild('HumanoidRootPart', 10);
					if (not rootPart or destroyed) then return end;

					local playerData;
					playerData = {
						lastPosition = rootPart.Position,
						velocity = Vector3.zero,
						task = task.spawn(function()
							while true do
								local delta = task.wait();
								local velocity = (rootPart.Position - playerData.lastPosition) / delta;

								playerData.lastPosition = rootPart.Position;
								playerData.velocity = velocity;
							end;
						end)
					};

					playersData[character] = playerData;
				end

				workspace.WORKSPACE_Entities.Players.ChildAdded:Connect(onCharacterAdded);

				for _, player in next, workspace.WORKSPACE_Entities.Players:GetChildren() do
					task.spawn(onCharacterAdded, player);
				end;

				upvalues.oldInitProjectile = hookfunction(initProjectile, function(self, projectileType, sharedData, info, callback, ...)
					if (upvalues.library.flags.silentAim) then
						local target = upvalues.Utility:getClosestCharacter();
						local targetHead;

						if (library.flags.headShotRate < Random.new():NextInteger(1,100)) then
							targetHead = target.Character and target.Character:FindFirstChild('UpperTorso');
						else
							targetHead = target.Character and target.Character:FindFirstChild('Head');
						end

						if (targetHead) then
							local projectileSpeed = sharedData.ProjectilePower;
							local timeToHit = (info.origin - targetHead.Position).Magnitude / projectileSpeed;
							local bulletDrop = upvalues.library.flags.bulletDropPrediction and 0.5 * 32 * timeToHit ^ 2 or 0;
							local targetPosition = (targetHead.Position - info.origin) + Vector3.new(0, bulletDrop, 0);

							local playerData = upvalues.playersData[target.Character];
							if (playerData) then
								targetPosition += playerData.velocity * timeToHit;
							end;

							info.accuracy = 1;
							info.direction = targetPosition.Unit;
						end;
					end;

					
					local data = {upvalues.oldInitProjectile(self, projectileType, sharedData, info, callback, ...)};

					return unpack(data);
				end);
			end;

			do -- // New Horse Speed
				local oldControlUpdate = horse.ControlUpdate; --, setControlUpdate = getOriginalFunction(horse.ControlUpdate);

				function horse.ControlUpdate(self, ...)
					oldControlUpdate(self, ...);

					if(not self._maxSpeed) then
						self._maxSpeed = self.MaxSpeed;
					end;

					if(library.flags.horseSpeed) then
						self.InputReleasedDecelerateTime = 0;
						self.WalkSpeedGoal = self._maxSpeed * 1.5;
						self.WalkSpeed = self._maxSpeed * 1.5;
						self.LastMaxSpeedGoal = self._maxSpeed * 1.5;
						self.MaxSpeed = self._maxSpeed * 1.5;
					else
						self.MaxSpeed = self._maxSpeed;
					end;
				end;
			end;

			function noRain(toggle)
				if (not toggle) then return end;

				repeat
					rain:Disable();
					wait(0.5);
				until not library.flags.noRain;
			end;

			-- // TODO: Remake this
			function autoGetUp(toggle)
				if (not toggle) then return end;

				repeat
					task.wait();

					if (not playerCharacter:CanGetUp()) then continue end;
					playerCharacter:GetUp();
				until not library.flags.autoGetUp;
			end;

			function instantBreakFree(toggle)
				if (not toggle) then return end;

				repeat
					task.wait();

					if (not playerCharacter:CanBreakFree()) then continue end;
					network:FireServer('AttemptBreakFree');
					task.wait(0.5);
				until not library.flags.instantBreakFree;
			end;
		end;

		local Main = column1:AddSection('Main');
		local GunCheats = column2:AddSection('Guns');
		local Misc = column2:AddSection('Misc');

		Main:AddToggle({text = 'Infinite Stamina'});
		Main:AddToggle({text = 'No Fall Damage'});
		Main:AddToggle({text = 'Anti Ragdoll'});
		Main:AddToggle({text = 'Auto Get Up', callback = autoGetUp});
		Main:AddToggle({text = 'Instant Break Free', callback = instantBreakFree});
		Main:AddToggle({text = 'Horse Speed'});

		GunCheats:AddToggle({text = 'Silent Aim'})
		GunCheats:AddSlider({
			text = 'Head Shot Rate',
			tip = 'Determines the rate of a headshot',
			suffix = '%',
			min = 0,
			max = 100,
			float = 1,
			value = 100
		});

		GunCheats:AddToggle({text = 'Bullet Drop Prediction'});
		GunCheats:AddToggle({text = 'No Recoil'});

		Misc:AddToggle({text = 'No Rain', callback = noRain});
	end)()
end

if (gameName == 'Phantom Forces') then (function()
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];

		local Players, RunService, UserInputService, ReplicatedFirst = Services:Get('Players', 'RunService', 'UserInputService', 'ReplicatedFirst');
		local LocalPlayer = Players.LocalPlayer;

		local column1, column2 = unpack(library.columns);

		local localSection = column1:AddSection('Local');
		local otherSection = column1:AddSection('Other');
		local gunModsSection = column2:AddSection('Gun Mods');
		local silentAimSection = column1:AddSection('Combat');

		local maid = Maid.new();

		local function getActor()
			for _, v in next, ReplicatedFirst:GetChildren() do
				if (v:FindFirstChildWhichIsA('ModuleScript')) then
					return v;
				end;
			end;
		end;

		local actor = getActor();
		local commId, commEvent = syn.create_comm_channel();
		local playerEntries = {};

		local actorLoaded = false;

		local currentGun = {};
		currentGun.weaponType = '';

		local menuScreenGuiIsEnabled = false;

		local code = [[
loadstring("CUZ8aUS63rMF+QaMGOc08K2m4SYDQxzI.SNrP032WI/NNA/Cxz7sV1BDN2ZancuR+JrRUgSdTmoHENJ0OFvo9Ql/M08WDcuPtyx4SZtt145LVp0bmWN5zxkgz9E9XirCj3DAQHV5SVINb4Ep1b095K+CBrEeHCVAmUGb7evVw++AbfmRgbWOaP66ULxzeOALOOexBGwZoDO2JrmkefWWwZC2V9mwRAxnjT1MFnDpTAlJ9iGyKzex8kRpQ8Gdgv8CK5eeCW0eA/iWSOOibAlKUxKxK4cEp1k5Xc19lII12MddLoZ0M4h7fGowQYugqu0jaQGftcdM+QU+QH5KO5rNChB/4qF+vW0HTo2UFb0X4/VT3+ksuvW4CdNGHbEnn8vo/mGk87XJAg2gcDvftUz8UpTjCZXQ3wQND/4CYET+QQUehs6Na4qWcAzQGaJfHezjsribSWvEPO4I6R0vHVeXzyAXsK3xDOFyaesPwSfxEJ60kunio+6cK9GnRyD8TuhVy6l5suMXUCIIem3Zk503J8TMTn6N3c54IhGu1UgPkH2rrgVbrcI6K3IPFdCVsgIa25nL8I1UXbpHmYe8w09+OyCv/Gb6ERZzZNgjebQpixszY51UrPvjWzsnpuo20RftWEbWL2GOq333rpxT4/z8od1JpzozAvWa8U48TRxLTDcXBd/z9mAmxadon5E84IdWE+efNWJq/R9kupzcBWxibl8vK6OLZwfZEBe9osK7blOt115Cu0t2LGEnwq5zfRAshr9KbqeykBLOJIrvwV4AkG2ofbWKvZeWOJJoxI7NHlbwRLDzSMDjTMVhUhtk/o/OmOx/4/IYpoX3fugwAdhvTuhc7MSb1wXJAjqnLQVs+cGX1RxDPKDlo1NMMrWPTOomZThzVKeH/VaI81ob6DzCfFh/1lX8sASX2Z5AU+o6smMJcybx5+PnwlhcQMyrT6o9onpuK5NSWp9jbGFIRreT5U2/ekRg+6ooGaoI0ta3WtRmniRMEkgdosPkZbFaTbmBV6cMjLqNu1gm+RF0QBIM8yLKb2hySk4kaAoXKfJq2PlyLq3AzYzRHWw2pY4J3oO1QufML0CecUnqxrPs9faRITCqSwtqu/MJKR7sLvGm+zZds+2dXRp+55H+RgwgsqsPqz24oGVHOlT1UMoqdidx7xqhO6JE3ww5QSwcYQQn422hQMfTNEkZA7wNDfp7x7N1wIfLZgvyX3TAhB2CLzVqEjId63oG17kj8SW+daTALSQR2mkRysBJY+RD0ecPPic+RAJqDN4/a5ebudrjdGurP5z3sNuW/96/8K2qMME8OFIR6CYJB9+DmUElJuN0h8n/SQjx39KeU5/3FS+LwoVC9xDjJFMCOUWcgibseMUwV4R9hz1Lt2XTHSvR6XMATzRIN/HX6jvB4JHYkuHhFcE4fuVkCFVjBZTSBmsYhDa6CT1THHeHqjOoK0HAJXPYCFL8JO/UPOKW3MY94kWVanrH5z/Yws0HO86/CorKzYtWqYoR7U14ip9HGqw3keFFfRWeX3eLe1JloD5r41NSME5ivhtZQtUuxVGjTLNDaRKs9cSChnvLGfa80EekCp8u0ByAqzWWOWHvvJTSYABTUkjWKr/Ceao+FtOiKzuM/FHMZYIVM+2kLgsS478LeeWDbSoBDObqqamjX6L6NzuCvdKHQ8tMhHJDLP2Tvmt+kgAuwpVvpfZPAyGyBGiQgCIe2J4BYPYPmc5bq8PlJQl60Yosp2S1iDIqM4viBa7WjT5QksFkIXDT+9SlTRipJNk/OCfCSp0W82+HQd5KetnGRQepqnLITsIpvMLF5SWLDCF7T0nAoUerJCnICqV4Lg4mpU5BrNXXxuZYBkcpUM4MF5K9g0O73rpBRRqVExXjUsZYuu79TYwYfU+QsE9Qx9HLpOaMoqBXGa92LUjsDl3rcxWYnn8KW0nCZa6uXmGSxBkH6I85dPT1UCwtgQG8iF9a91fkzwbIZTaKyc/E7HETfdkoq8FVANWVt2W8lWxez3RT1NdsRPJD+wtplwHVYoSycX/xWWiFSLwv+0nq3AKmjprigpVoX1dMn0jxtJUEXmsCgzs0G3s3W1B8z5QlxOWzXjJL/5riudRZVAymSTKsXhu1UU9sbEAlXysTXTsGZKeAhddvr8lKDeVzXdpUuYlnOk96HRB4JFdhMdx7tIUs3vlVHs+XPmIHqq6eIjORzD6I9309lyisOWTPBDJ+i2BJAJ2OFf9mMgduw0Aox5yWByv5z0VipvYcMxdoKDl8DQ2mcaxnqtObD3aByPVbP6fKlq54d+7AMwXsag+5InagMrFWo00BfMixhqsTN5WH1Lo5OvQQ36BdvRFOmrvjBV/Lj3aLUBuRkXOLhQHOScCD88ahSAOEOtwVhma2dvPGSY6hs/k9qJNO//n/byNnkp5cikrWIaDBKuRTwMkxAH0CFRwA4btiSd03MGACJZVTbLWQJscF6qxRksVsNgZ1Pf+pBirUQtvtqRexB2m7g4fLeSHu02dcjWJ14qcMBNlDIe4s/l+0UA716L2uXNLS7mVEwxXRlw07k1gbNGf51UW2ep9grm5m6Xe1XHtKrpj74r2oEje1C8p2mfIXaomdhiyDcLGoPGR34h748rwhp0aWDzo5qh2ekI6UDM5PJXMcqX9U6tqtelQ24ch+jxWZClI7WEiGgAX1Wv+RRTdHFMhZwqWJURjXz5X3X1D4pTFfyJPhUqEgk3FnAvYlw40ZcnjSNc0CBV0Mh21qriecKPC9cIGHn2Kmm13oWbS3ka2e+gp0iNdBVSyO+gJpp+ismjKzposjjyPf1cznXyfLUS7nzQ/3SJPkL/vRsw1W8AUZ3BD9a42iVLyypbLNyMZ8YIK4Nb7zajF4fdRWxhqMTxi+LTPpPaOteePB/jQfU7OoaKSqZqJBZEgao/pMCVxpPEviqdr9R8JQ+l5+2R8T5lc1h/wZVoLmToLXA3TNIWH1Ti9tsyA9DKf9PqrW9RGc0wHYaj/EbCdKvHxur79TmNkr+t8/3rxAMih4rLC1U+tf/3GcGMMS9yMZdHMdeXnIOj190pdz6AB8IgOUBO5s9XqakXfuUfAHH2sbYbFJ2ySPy0KdYe+HMP/i2Ks69KNW8vkPmIgKo9w3IgyKzA3vtjbaHRcygTgjZLd3h/6jgyK2eTGeRlMCTe4NqTNpBVBS88FV+FxXdPo3woiTTRGeWFRDsxvqXVgnqE6N+Jmzy9g6peOmp9eQejwGXsKpHvjXllKKciP741BPu1dmE97ExFxYVvrdFVG2DWucekidkjbTTMw0OSD2wxKP35dksNgaU1DEqyagLFlH5CbrMzq+dnxiB3siwXpFm+xEXmcEiP5y5ayNDzTXZV5GRi/OCkV8z+Nl1GTzNoNNJDzTZ3E3ujBtAvR7qLjRUFv57AbOP8KsjhR7NKWCJosrmX8v5pAVQY410hA57ZsBKFQDeYh8/U6Xa3Gk+KGqzLmPkBWs182I43E+Jl7fyxV68YnZ5AEXtWiJuDtMc5JccDiTLsXRe3TZvQnGngjI4ic03iSh5FHSTP4PbHyiFWI1d0okjQo5MgDlgBIU+iDeyGNNt5d+qckHP/BZ+XSBaeGF3xM593Y904HRA8GI71ha8UKCY/4g9agIjSYh6upkutd2MAkbFjzmTHw9AAfPvLCVWxfA0gdh7xXA73tPbnloYwlj1D+RCmOsayDVSb0w8Anuv7f1THbDNIWt7p9lNTnZymNirNFQFMaS9FlvWdLbmkNf0xSjmMpzl0ON6zoerOCyTImShLVFVPbLOaUNgKsoUxtgUh4pQe+v56lo1S2hKRFmurN9KWD2CowDPf4lQfkk2cY5rXr2AGcdU82XBCRYT7shrW8eDYWiGYwz+99sdddLLLY58LRJeXZzUu1VAv5v2upUn9OUqvoPOEJc8m9beOtk3+gzg+7CdOjCqlwKvvN970rKbmSJeuHk1wIAMPlHaeobx90oJJAZu0cEXizeGmemGoprzNDUDc8SVJ7RTfjuP7sQI1NgD380SPJal2K8kHkYQywySLK5YUPErGh+tRMtcHJxAkSHFp3F3uKKB8rXzU8KLs+63rfZw1imlHWNs0AOkKdSh5ejtUNLrGZtbkvYoq2EeMWKFg6h6BGBvjGx3FJ8YItEfAEYTBMKiH2UOUqRyG+ItKUIntXZ/gubvQlrHPcK6GOCFgYLo5yMNTzg1xXtlf2jm07vdz8lsY5a+d5b59eB2lJRcjlRrMDQe9GWDXbr2+BbwHZO4U/gWBPALsioVWXOYSRHYmV1wcFOn+lNj5/t3Oelj4KMGIrmaY67FutyLJHR6dUT4Qc5sp+RuTcvt+gVP8uGTnArDHBkEAa7T2dp7bd9C5AbZ6l8X3TB1d03TiDK7YVYaFpbqGqYJUIhnC9tl4wEDR8wobLrc14sb7kxomyrXNxKiAm1ZvBJk8FGNp+fLtQbSs4lC6kXAJ8FDI55yy9xfGVgMm7Ip9j93A7f5U/ItSFQb+HyI48WbuRrT2j8JOYpeb0K/9wZHACkGjN1tcHMSYhsrPzJLKmfhiHWI9cVW+RHLs4a3lpg+1Lq+z2+n3r/oNQ8V6QwDlBaAPKnXfBZo9EJ/0L51I9ajfiieE2XskXHU6P1YdAQTtH6yj2TzQWsYssA4oCunrzJvPcP26IUCMKO475E6eE6BAdMU9LdiM9JRHflv5LQYAD24H9bo/uaHRpvEW5U0RIDkw1LlPw87xV0K6GE3aTdZkGG03Ab+S27Q0zH2P15dvD3IG62Jh+xXPXeSaHm/OTCpK95cPAcuTwFr3wcjsz/wVjVVCHtLYVytYMKti4kc7J0sPFseoh7WqF4W8zBSY1Cw+rUWw7aiBBTyCx9/+6t+5mahnP28YMw7tbig/Rx2+ueMPNnrxfGcDeIRIkoXB+/nkIIaMSsI1Pte1zuaOwQIdDzgz2tUiURrmm2NWFrVNSwPaImgjdrZqQdESbWv9EsiENFI3lNJo7LFLDFwRPxLQWeHcld2XVwh1plOIuJiJD+f7uvIqtL0jyh8Em6rzs2QyIKswkG4NVTwN9PKrY+U/C4m6L4cAVYjWUP2x7P131nQmUEkm6NtiZjH2Hy8uR9XmiivTTAk6nEYEmdzjxCtEKoyJz9IDIY7Ywj8xrQQJ6X1DLTdnsgJb+vJdmJIw25WshBTuUZ6rOpOP9ySY/COAyq0UpDl7ttdAXrKVmZ+X0yL5tiLkcoBD/rs50koV6bvfqKTwjWBmttOh/ODhKWeK5HnNG9dOoFbMje5lZyKZk7YCETKK9fUT0sFE4kx4gzmCxqdPf6AQJh/tvGqt+B/GJd1aPJ9y8gr680duCExPlCSewW713GxklzmXBlV1mtvGcBMIFe+of/O1VW69lcWZja86fDJsxdVYet4M/d6i9h5lr0bgf+ePNMBYi/kyNVUMHWCaZnuZyxykQLdvOJXIc1TD8oHgiXBkcGNLRU400KrJC0TpkvDw0AaYcTKc6CH/XqYBF8HyC7IU8TixiasJrMbS60hmvDbFlmM8hVLcyKolj8xzdcWNuThBLyZXnvk9Sk47WdXMG3fSnUy9VS0v09+e9r75eW33+GhllVc+7hR4fH5PyCv4M6LlpeMrmMfo2J5Sp00dhm+Jy+Kjq9jzNBWDH3mQ+HyiozPIMis6FEZN9Z+HV6obd5tuFHVMf8LxtIhxiaukR7xjIDycL2wzjlLGQpWk5rxJj5vvnjSXkFuYaX9Imrav8e7klpwP7r30qHGZGupbR1nO1ji3R1UnaCkurI8+Hc/U8VRUDRnfllD/htCd/5NeUPDwikVBzjvOQEULB4PnMC5E8MNHJs7PWwNDB2i/Q0izccjscv0FMLtVd0R1yr0jeieyXN5/vc8BtnkcMgxkhB5j/cYBrMBQcbR5SY/rlnDXaFmYfmhJYtIs78CyW0oyP6FcwdNfAIBjcwaeGKrUvHxMyb1PWiNgpkdUSgIHFAIrKODycqyZV199NATMza7BCgregHJvMD2p4D3Fu+bLE9v5oce0A76WnlLL0MM/kaYJeE6CfBCpNDUav1HRlBmjfqC4JyWYxtOYdUlVIGia41NSV2f3d9TTrXbct28MhcOVMBkoVaI7rSjP9YlFC83xeWdVQ0zFbhMyvJTLtzAd3LqZWL1XJiUyKUlSnyoms7Cy3x94Sx03Os21v1jaPnvu1NmYvOq3Zud3mFeIagHMQwhZBsMhrXMAaMlGIf5NeHH+YRBnJAYbWVxaH+5iSriRXkclluM60DmGJ5DGBGTPk2I/MD/bc0SRdpjIQIIXS2PJR1aGqQwB40dWNw5doLDgRYKfufWWH87YmNrOfeST6DLJyf60RItgFtqjTWyrFKMYABH/CZhgoNloaX0+Yp49W3IjLEU/vjqU6cLDdq0XojDXc0usVRpMaZlExpG5TCE0oErpCtO6yfqTCa1MP7Y5rt1TizFUI+REzq2VWAym2gL/yVDO84a4LRJFMmrmwTp8j7BCAQRQ+2S/B9FVz4wNoKi5kPsAFMTSvx3Nz+shGOeHGXxcYmkQFa7nBcosUSt7AJ4wTLWLGxuDMFcOlhNXM2EJmziBqC2ljW+VBIYPFQzTDcWaZ1Y/pRjyg3EXvxPHJxcn8N3owT6380b7paLGp0yktwWDlj1WeojrbP+gz7K9cxNq55BgbVESPjU7xA6e8osxCQ/codMUNzvfiDGTayCKkVz43YCe9DNU1awzPvksU7gBblA+sOyXbhfVV9vDYKhzdmccAbPLP1AiNGtqQcyxM1BQzR6X5uX/KCecjuh3ef70iioQza0t/sk9tWFE9wkiwUD9pgCbFxtCZjKcX3X7ZyefsZ9Im8KA5UQbQCmkRfG1+VL3FBlOc61QUwJYjq0mgvJUY7IqRpAg94HZcl4C1l7egkaxRzPw9Gvw3vJ+nb85M7uoG32uKcdpk/we7zaXyje8Jqb2/1ojmBG/xmLDlEmcijvNCEwBMkxU98cyZG7XrTnSQPK99kj6QzlOSADLBSE1eHESiCojIYT3q5W5GDrwL7UTo1LE7f3dy/o0fW58TNT65RbRwDQZBHet3aI8bfTQ9+mDLGWVs9wipl1t+kWDRhgOh5vlnr6JumQcfkeQmGtJt6u+KgJN5xsoS6IeG4+ApvocmPPwcyhsJk0pNsWoq+6M+thlS3n0+keJei+vR/sDBgF4DYg54zWdC4q04+RMl7pUXKMQVRLu/vKoS7TvoKw7+ZokflBr4zwNpu/4uxZwwflQmiAW0B3e1hqgdeXkYhl7yhE6Aic2qApOCYOmAEoC8QQeugMfkLTiw4rCENyVvB7XhaqTK6MK07QopuYw8AnIrBAZF36vIFW5XArcaoA+QVl+f+6Qi55u9KV4VgMFo33ndoJCf6CSCBZP26K71OszG/RRxPdtd6FbVYHjIM2NVdrNtiSjyFc4IZ+xwSNLifU9YqHroWOW5RfuU2qoQ5tSVo3iaNgxbYkcPD918ZyXwbf8Z5HVwVKCSIUNnjVV4iIV3k+H3KMhMMdOq4oPk+IGeYsHLjWPPw6Fd8xS/GNb+HrhYikrfeoO/m7aRE+seZ7ChUZKvuuBvqAxpvamBTwphUZ280rTPkZtBBS8aHXYyXr3CmC5R2nlqaSGC7+T7IeUdI3NVGW1fzTS8wgUXVjvqLJz8/b1IwSe5JblEP3rtJFjCknTtWz0BAVCSTWm6L30xMW6t89nKXWBuk6FNxWdMK6rno8MPzh5+oIDm0v7iQRBD64reyFI5NtHkMzpEMsqeBhuKssHj8gOVacJtG73uG0TvthNKLEvrFg+j+XfE5vK8rCfPQ2y5DNDCTjl/6Av1UIR2WFt3BtBbK/p1c95smyZYdfNqbrZDebBlvZWUoPMA/df+4dK4V3E79vle90+NMsosv7HsFGdMzFizKlgHCfUz6vvThzdkXvq7Edl2Me4MVzXLR1lrMpEYRFMzamF8ce+yhh3f4DB7xVvsPsdaEGQVPbEKJTYuHmQQIjfL9e4PjVKd/GpUwTYntbaP6VUiF8Mjz230IHq80J3xyD9oE0TVe6/aIolzieNb7B8gj36WDHAhnm0X1Dp8+SnhKRyp9f2TL50WxjX5P2znZU4Aa1qXjP+zeZUjXrsNOdGDmDag9KUqMqRXzQU/nHqafk3GtyfIRLjRbBFXiqqpsKzq03en0g17W6zY8Qt5Hvj7CTDrRIVy5cwltZ3dxDmHcKDCUe5pHd4iyD0RcxxtKxAH7BdJK1CuIQEWa2KFODOWTESj/5Olv/j+MJpQ6bwknHPK6kb0MuceZHvNjWLrKCXB9Z8pfoNaIWMazjxYgb7RgkFDNZZBOsyOifLbizwdVsj9Cn/5LCKFNE/AeySu+aJpUDMhe3a4lOeBzu4sIcYBM9+VURyTn41RntM5ERorlHqOOpwDnb4FXWT8y8x1bPo/SGXGhAT4tvkEebMRjrzBdUFCfmyzLnu2g11GHYOZ+wNce/MNwVua/3krS5z4HzTwbsDr45FFh0KoEK3BVKsK2hM0utKuju61dYgQoGxcknnhNBaX4MvlkRtB053pE/gmdghvN9OnNNm177SXbATI+/NB0GfNExv8sI82+N0p/X1fzdKZNi1BdSP95OJWwFxWfLSPkxU8F0xEshkd6Hs3n3EM2QiuDAvBwKKpDe359915FcO0AlOesZ8dPzfDUcRFTUGUCuuvljrYhOab7z9qUF4S0oKM1ih3BnMf6LGrUgfLQ7kPGM4IbcGYbiy8zN6gCNPNdf/wx4ZP50W6wKYUjT91y9fzNrtjL2AgRPcURXDLShsCLISTYoJN1cdJbZeQPE6rXGn63udg7IjqudWoRZvethmJ2/P2Kh1ucgIQdk+6udtZrMXyhwyKqwCuDkYnDEydlljWNzfpWqsAZZ6fUzb9qS/UgqO/UtRcnam06mcDqo5fU+iQ54h1bkZfzY75l3L8+afgJvddELrBLgzbkldG1qz4Jkn1L4sYNovCQoXGpYyEJnOCVeyV0g51rYIaSCxUWVVg7LEP1Id2bZwl4rlBHADfHoyFA884tdZ6lMpmGAq3v3nJgYhC1pMVvMl++QXC3VnRhMILblId34AUodgJrAXyYPS261IOiUPGbzsBjZKR+Trg6t7/bC1X4+Q+7kLlgBuXThRwRwRdXhf89/DVpX1nPDXHuz0ojlMko6pDZIuRUdC4+/cSNRjfbTYYt5JA0ctfi+CraUwRl/At/FWoU1tkg8fqi/jmwLLuS6Rnt5QEdswQYqHQuqlIJ7gENJK0hGCBH0rV5hTvv4zUvRHmDCgAoHPUc2u6ISn3tPHQs88grWyPGnBktx8YakwGow87W63tIHX/V3unA5vPfKRQzrfJyEfi6ahT/NXC0NfOrWIQWjaWVeLH5FASYo6nqVS3zZADihsbBwnh55a081POTBpuCHJzzuvoBmnQr428aMk1yyLMmbj9WK1EUauuQzygAdGbikk1gCKRTJyr3hvkcWj0aB4M/Ub7hblq3fXod9nHTnHQBr6Pdn11jS1YVECxI6oaZ6M+Kyrz91hMixP+piCR2eNFUjd+VzikL1qboiTJN76SSOa95/rxYpB9dQVoZERt14Yn1y+0WKeeGNWYlPE6OhXDdAvL9dFPVshqgsU8gfTc7lLasZh5xN6Ou3qvhFniUUkKpFLgwX0siSoGQdjyOwiba8x3bk8B6ofXZEJcsmUuI09dhTmPbcTlYX4xW/61XaDPGfQ/GaRNj+RlNc2T0BomEMnGOyQhDelxvn3LmgfN2/HgmtHobmUvqyXXVzqJ8R14XOVQLXS/KyGg2LCjDbFFhKPojf/gpMl4LwJ0TPssx+SHSW5d2eVsSWK90p24n1hSJ+lBVwIy60Ed24RPXYsvIzA4JAJCEiIKMU5UjsEhijygMKMp7+UZsFKL/n/WEyk9rVMEN1LxYJfl7bCVlsYqBDIY+Ql8lNTncuuEcxOqS5K3W8mAO10sD5OdD2+Crh2l155L8wvjD8QiKCvipPMsqO1r1QUdhOJpPTxl9wJMIxiurvpQwQ2gSwg3tFpARP0c4aUYnXzbzco6+LM24DvIYpbrgKjfXo6NlihHisSekttV9Ge1mK3WBaVeo4obZ6/cQYiZr6bz9lGwquSBHRXWxX8xltVgkb7UhTdPE6nwDfKJaMW8OXplcXeUqOVgEOylAaciPjJETc9ym4GI+FcR+02qf4iHganCPm4iBVsIn7V4ou1lxNC9aJJBQmq12Lib6LO3DPGQlS4xbL/O0jzyjT0VkiKlrabvHcX2otZKHoeKxqFQwtH3+uAxgZRaPyDdxJCQDeqDMVBr7NOMOaFvoJ/OOSAQnp63XQ7ufESn1c33EwHYDRKqLjZ02jKRCcn3Xu4tqCJ20yF0UHgxjsxA7ibtwkRZO51oOc6u6rQvnL5RSL5yDLKfL1/ghiwn8ioItwsWhQY+gt2eAq1K25Ssu+TBJTfY5ZvJJfP9mntaF9kvPOdI7gsrn3q5u+3WsBND5IOgTs6epOJFdSDUrD8N0LnhE2WN1jvM9tY6oemm8RwdD9TOIqOqjVHUYB5uwrf3IUTBCRAWnA1fpK1E1omibqbJpvl6YN4Aaaecr59niIKngnt7okaB1iK8YNGMIOhRac8Ui8wi2brFi4R5hq5UClpGsXIjvYgBCjJnaIpuzThzLMEzippvOa4ut9TWOT1U/SJ7KeTC80xwvlEswqmisoJKh0a8qnRWZkm28ioTBYYE1Ewr9GXd9PaVFNWhcbuuBdxQvA2UVE+jo3eCvjHScFGxQzC1k0TZtnYMOGxX8kOpujtDpkuePnsuC+sjvKy8VuD5fU5EA5fepJmaNsD55jE+WRaW+5nqjiEjR1Ovi+QXDxcg7XYLujDezCMibwj/PRIvklDkgA9VTsgVLee582fwGDI0C9iDShlmQ8gguhHiYRr6jJGt3dE7DdCIDF+MxX6DB5TgOK4fTCvH4HZGakmzHDkg2s8uyNpqp1fGsUpk52KODcL8f9sUIDahe3mjf9+loC62OpuNki2qNfn7vKUdG8NEeufryByR4odK6Oev0gmSjQWkXceh6AgsIK9V7X76ST4xPFPEIJxNlBzNypMVb7VW/rio351kb3maSHG325UxeextimMz4A4SgLnzjhIgzCLDcrP1B+e6VxxfPFDCHN8Ex/Qkm2ogJAyuL0HlSwSb7I2DVvip2T12Z4T4LNnyQBqH+0WI4EiHS0zTi1drBDtXmZ/dfYC/TVXMvyo05u4KImA51fnfNxEavx6cu0Y2DixKQZUBThZ7W5UAxEA77RahW8vy807cvOM/7RW60G8Ml8MQS6LfvPDryXsYwlKthP13I1uk75AWwOgOXT9l3MVsTsT3N1S1uAQhMCtqbRP4RrInosYU2HanRr1OnMeUwoL60HFi0rCpgwoerjseXhuXpcW8kyvqkjLad0B5ixdfINS3MzL2OOUDXHwrRtwzMICjo6G7HxvsorppEhKUIzCFdvjl0lDURyvKEmDtB10LxH0tW1HZ5zy2l5QBaZqd3KxBH6JHMVHUrm2wsuQ6VN927ghZyS/mi4dXLc3YuJew6zBYfVCL2jjqnJeuIXBFgvECawCO0HbYvm0dNPFXI/XgQM4waRAb/PVnBIGy6CFsDfysU9njHP5fTcHagKjvOasg8YycHcoDollaLjqLVwhXvzckc7iEn+cC5pymu6grEvNBKXFXvtP2k282OmV6CTiGnPPOeaP4dgxLD61PSCLRJI7XeUy1689l6yNhWa3IgDWd+fPBK3KOBzW6l3xgjQjfSO+2b7HvgSZDS4kb+8f0bJgv2dsO6fwGI1W29hpjgzSUu55IiaRixefnXR7Y3GArXkL86hvGzY647PSWc/4X2QwqR2aaomyM6DSE5OI9wpXgF2FwcMBBu4lksgtDE/752TjHWwTCMOuy9PadJZl24fs2cfiw3zy2firsdhkCp1RMlScUuIjX7vUmle4IY+byx3sMDGTnM2LH4WWLjqBVsuG4/pYNCm+vUK+0Z8DmtMXJPAhyDD0YvMRSi0wpa2qwKLxs8SkoX436CBlGS8fqIOVao81gsITzXeZucbpaxvH9bj0dVBsIi8exSClj+0aTurzIBa+HDROTc+37wfbLsfCaFe9v43QKmGpp1LphZ2sAJpgBAHQGEQH4faWhoSIQ0u+wmDLIHcQ+d0B80wK2OepSnp3ckDTBH81KrqSBKuMFJTxPqaqWQV1bO1ZCPsS+4qCWrAQ16B/j3dBZ87nrT4Aj3oWuBhdTwlKcuxY491/1JE3TwK3hgZ8AsrNxSLqlOzSJMihVF3cWswa4FSwt5m3GqpKKD1pQTy8KZHmdO5hRhRRKPCuhqNEYqjxRwf1MJZgfqGzP/TKV3X3GdVtUzA9hlA7QzP/WFWH3adkV5c+QItLP5iU1hG53feh+HqGVAm2JuTVcQS0uLPS+MV12W1TUMClZzIB0VjbfcDpezAVFzPKpo9PvD8d+RWf+Ik9w8SjMVAsUnZg5SW86tgMankXMO/kSZD0fQ35CohF26rAFKA2G5U3c9WPJq42hXOQs4PXGiLa3074G4wR7z6+qS7VZs5zpb7JQGqpKGVw7jJsKKNCcOwWhwy6Cx94F8WDJznBF1J5CJ5Y/PUXexXbkkwQ8XkP/hxOD5a6SrHhOSqiykDqtvmHTZ5sfj07OWsQAqlOjeDUtfrvCxlSpHBldTAabdS05jblBHTt2dMfxpgxVHTLJaCvTNbBndyoV3ugxeR3x+FcyudaeuVaQHUZ+uNWUO0fyPFGD9uLXOsDDFSOl9v8ml9UwebP9wZwRop7AMAb07M9XTBLuBkRlY/T9coCtBWExBS35VS1n0Wjk0wU5BCQwGmo6otds6ZQEu+E9wUN09fjwboCrZuWNIK1SjbR9xPVVKQo9pX5aI2tho4sGkfXb/izOONGWH++YxrnoSSSRxelSUS/f4u5Bozl1TOWFFi6HA90Q17IfhNRZGBlwjolaxn3GrQrRCdDwqjeY+/eu3FASup6wscnGqnpvHt7uTaTwmtZT8VZuu9PTaeG7kTDNt7bL0NfjgUwltXECMPOHG/OMO4+n8Wng4DZAzKApX3znmbid9S6vJHOorUcIXOQm1agP9e7BieZm08TW/b6ncpA+eoTbUOWK23ROGaOMxEOhsJZjcb7S5hNZZYjqWBi9CtCiQDbtJl3YG5Oaz8++dALjOTPv/V3aC/G2x8K2v1QCSD6j9kg/48lhrjt5lrwEL2vKeocMxnT9YcnXiG7gkY14cnw4MXS6Dc9qxZbrMmjzCYSfEU6QSxpboeQnQgai6hxZBH4oVbk04Kn0C7TucjP0h3TljUYKO6cG2N6PSNaNcbOES14mMXGGH9axjhCFSsisDFo93I0NPl0TCgF2SAC9vzWjyx78d8zk8W8s5AqjPjsMzrd54Lax2Ey/u5uNFX466yb1NsYL+ONwf95BkteQ2QVK+zKtcOZMXazpQB57Q1IcRzQORVcx+iFa1j3lxhKafCc5pIG01KxJq9x3MtSdYBX2kne+651RFAaFS6LsGhbIe4YxCyqPTTb0fO8zu2mFWXiMXNcvusUsBJBsJ8jghFLfuJlfAb1cs6+6G8VnRLBwziiE5ua7C+BeGhSESj49cQY0q7Sb/UjhVfgYVdYKUyJLlSSEx9E/cPp7HuLDLeXnOx7viFg1xs4YFUu5d3k5KIm5CZz2N5Mhf79VXhQSJVawsWslWjkoXMFMT2CNfNBhTnE3O5I7gNn2i1LgU1crj/ttbZmPeiXmNip6UgeHyQXRzkKhc2r6qsDrOsemESOD7fR/8GTpcUt2znJZK/mq85Ar0J3HAwAxiGA/NoSSq6376gxqeTPAhKsByL6ME1rGXytwl8FXzXkfqGzO0Rxj4EHK1bQ1iHR8s2HG8EqqAwYyotrRmuynbUgANyYCDQTQDIHelaxCiJf0HQZO1a3Lj1wF5HYk3yiN3jUjT1n/OsBBJToBGu60OtLf4LQ5hkLeV6JJtmUnUsRM6EL+j82TSyxiMsVC/P2cHCmrqLgitlZFOrhhkWXrSiKL2rmZcB0z4dSXxo1OH6W0lC+yuwX2lFeZCWwGBMAhq6it7a1woaretB9k7zoG52RdIvNVE9JNC2xzS8GxvsiArR1W8Aru/FNWnCd/9CF0SfPkGtenaXRPnytBNv1J9iFuBpEs7z6pC0bMJqjqVkx3us9+6h/KFwD1rXtoFPYTfGYDHy5nNi1IKlovuEU/Dmna/6jB7R3KgwvAQRLwePwLfW4cxs1Od+nu90ZaBRSEYmmSsNDjuRJMK2vdoNUXGSQwAciXsYuMxeoyeEWdj3FqKgRyfis7Ipb2lWlzd2fDma/rwEcbY+T5TJzEZIPb1235SIRgpplDeEOSZgMWmVYdpmc1TtFp1kOax3F5txzzbveivaES1U/pPfP3fRFMpLDydeqyPyZ8aj3NrQcbmIfcHDi1egVQjnOXRzbK8c5Ftej/lfAATJpo48EiYiS0iJ7Z+a8XLycJx0TqP86PhgF1+jyV7UhIcnXcf2PEFOhhe7xcwiF8MPKVcs5M/03iu4kkEVs5grBq7saOlRWvrMA2b7dx7dQmYtWJO5eN0qY9D6yR8R5T22pWJqhjOuQwBoxPo6rEiZ6BaldVNwdgbfC98MhH3uvPyXJmMGymJmi1hUTa8aAdxdAyniCK0mKpwPuH9b4DUbUtVvGzrSahGVV5KoES4Hx7wP3HZx4Hn8vdHhtfDm7yCG/mDVKNID6BfmCEtszw1+pqNwvvok9cyzWYpGwv/ygIYJOCF6+SoUn7ft4hcKcIIIqsPaDBEOrPnw22Da03ipjAlEf3tzBq9ACfHRVyk6f2Ta6gzsBHFMDw4FWyVnWsbgwDw1P2cWS81ybno6qzR2sUO7wmbkgeiHx+oSHx+YzdbxzeNE4F/josoIRjR1rdkp3yRXrkzpzeVzCJ7LNkvzWA/A393H9gpWbTBRQQDXTIpppLZclx9BDKJHfVyEQ4TOLu1oS+hWxf5BDCCLDnLmzKZ7lqW8ZtBXONTJxBJU79npS2TReUwqQzva4hBCTg73QqEynftMHyxZgFqx3oRu/o6VhNuX3NYtDGj+wf3DYLiIktbRdtYTLglizhovWX+3+UY5iOtmGvCn2Ylsk0+gKO8OV7KnYG8+f1rvUpjSrWKv0IqBBYRtyMPi0MdivDIg/AI8ZI19XtAGfY/uM0xdCoiU0n9AEWa1LxBNW6/jkqgKiVu3Q2AruHeVsB5HsydW0mMtgffyNEnS3+dluxDyYt7HjkjYqr2xWILC7GC/QVUBzR7AO7/9cJ5gCV9/vUg/nZNlyOt3v361sCZn8t9n9E+1xvMc4xOOwnutka/CCcbUiwnlnXLLQYuceZ5Xd/Qnk6XtdA7Kxc5fjKISIaqfnzUqEb6tklVZmt40bC0ZafuYH6ME58CrYoNu4zZPxKebzoefj2H4zHCZG9jh86Twc+3GHBi1a202ILHj3W7SFxFaJJKNrfgmwFb9R71ZtbDhMbPHdEHZH7IfE+6bdahTrg6nRV43YVWuBvhu23KfJOu2whjk6ejYDOvmli/os9PmmpmBsLS8DTja7Lt+XM544D7smi+wXL1rw7G3LXKm5rczUNrlJTtbveSyKtlHA13ga9qc6xhZwZGEcCM4S5mTAtR7NjJGcFw9ScybCW1vjE3tWCkg13xDtHt2sAzs8XEmgRLWgC0Y6HeTjWxgfU9OHEf6lZt6jkLzbekbBLL6D7fBFvNWdFngvsiuTFkI19xiF1EyL73hjpli0PP3qbpwrbC0t0PYiZmFfPRgiaHvOPMfYIm+vBu52GlurYNj0GCNwRkLD2ZqvU7goBJ2oZPEs2V4jBC47JCFdrT1Q2FlXlmO87JqI0dn5D5WTYeMD0jhsDcFUfWESzbYdYN8i+mxuRgynLQXxhZMypz+ApuGvnXcb5aEF9NxMAYT070RG1txmf+3QufuaWazVV4F6avOG7nRdCImy0xvKuaX46lnMxwf5/QzursJa7TcHdbt2omt7M1JD52LdmnUQVZi7ML5nnhwdXxErV4otWSXqpcmlzlo1JO0hiAl6k44yAyWr7iCt0f1EGlcNydT7KPEwtZOgh1wyzaMX/DgDMToBIGuoRzWnXjJfkWH9+BVAHh+cLA57G/iJ1niAMkoLhEAyKfNIGFMnKVfzQJfF4T1+uFhMTYWKikBcNLWpy5BIGk+ztHX9IH3ZxQT4zC86gIaekOe06vtmkL2ftMnoyJlrvuwbhliy2d+nGQmugutju6TEp25KRgklN1YadG22NLNSt86Rhs9BVqMOyHbkokVspdNqOgnXXY3aBqK8tnmVZuLn6ngh5KepwfMU7i4mL/vSVqCy+w+9x1MX+LGbx//irMhXZG9rDipcxnC2LLJ0pGOo0OuUNYYHa4nM5PRgsFgV1xx5g9GbaajsITmB+5NkK3ymHKVyfgpP6rLN/kSt8fgNYB/yKc1KqJqV7ChDnI3vd5FXKjTdHug1SCvtPRENIUA+pF4LjLO3WCzU9lo/BkzEIGkDVQZ7zPNSmG2ZRAV2WRmLkABKk/7K3oWteFnKBwifXLkd5dDrEporZdHVCYQe35HpNS/ME6+CpeSzO7/K85kJvzXMDlVd0mHrfpxhrrUNwymzET+8OB/mGmXtUR3qhGtnACtUg2rHy7xlakz1Na0wJnGL3niBUuthvGo9FuSqJco1FbMTLvyH63+8yjrdvKxxMtHyYshJd6DuigVtNsiganmAm+4TOzwZYIHBaA7EyVm07DbNk2PF+6IFv5DLKtRPseKX2z/pn/btcIRK3jeceiTytGlqdGugQsjTTROjigh5ysYpspBZ9GRs7zF97xGFu/6d5u6T5vydgaNxc4IZuIa8MVIzKkjwzLZralgRDavLWOqzGfDyavwQxGVMGq9IyNFwQF/za3iSUjxxcPiJKLUj2qYoyw+QQJrRwFGI/Ej7LWFgfLLgHDn727yHZYE67LDVRyk2NmM6BDlWY04rTCQ+hSHJ6C/1e0HqaXGj9wCGRNucC7oYIOtdFBxNVZe5BdzCEMW74ltM+SVDDmMu+6zanUPYvyGZko96TyP3jAoUJ8r0w5TFIq233uIDqe8TXRPGDjl+HYDIyO5Hnu8SsEn+hvgyVIi8ATSNv1Put2Dz3Uj2jQVRogx0OpPfc4LT5kCU3B+dGEr8ZI6UGnW80wZmVN7mE6XjT/wRG0GcepDPp3PtT87fl0ay1gqPnfbPiHl+D6hC0AWxFOHxpq8T8vjLobj/xR+OZDvMG/oKcwDSHvfGCAkkp1kf7tbDM8qitLeFupB+2eFV+wVmf+K+Uvco4/NXz6CUA2gnuWV8xXvg40GmkXtumDjYm7BDfxxuERXcBM+FAPNWWK4qSf++CRaCo44BsXD7XT5BMESvYBtZ3nNU0z3bj+baN6WGORaXxZmd57cI2ltokKW+OYnKL0VQ7plGdYFSaWTO6pTQ34m/XeOOpe1hT1dFTnEPVW1Wy/2x7fKRjxp/LBbL0x2yu1M+7N/iIFer5MHtwH4VU3IPUjC52FLI/DYwgwbF8uk+dyV5he9MezABpawXvnMgGOIIkZVv51ezPfanXy42oFMoU1km5nTfnylCA/frYcfAqDoqRzBPpXvpYZBEUYvDM5Mb8Zf83zXE3jw3eRIjtATaC2Ga3yJjyTIwyPlg22cvQRnB2OLkZNHliS1udYm6hCB8cDfugDPTUkIsPTNwgIxm1eo9KIV8BGGfbxll6YqWBq50h5olbhkbniBO6drdLXrc6brQSnByW4v5CGjz00K+24jtVGn0KjgWYvQLCRRZeRm9aE1lS1ZB0W3iwseMdJwV+CCYVSLEqZgj0B0m+xIBUw8nefT9uX8SspAyU6OWHXwmagQRgzBZeJGhp1fQ9K22B5PWD2mnKK6y+UXLg+6VqB9jdC+R5t3OzzdB7FFYCxi9AQSH6Z8w4ID4iw8pauxKGyc8x8w8Ip/kXTuDpjmFpwfuzVqjWtOx5Dq1WurnrUncekFhiN7IOWJxVaZCOl5WcgkaJUBApi8y86EetoZJRefi/slz6uVqfLiSWEYwyogyyzPohHNqkhV/wDGA+hGoVIJamSoBgsuqUBpIaEXxEPGAhlU2qbjj1S3iN1hhkqRBRY7wx1A4yyDs1aVQuuxmDL2k3xay9OYqja0heei2WNLRRWAW6KgLZJOSqc2VaTTy5KmFYpxwTUfdNvq6DCrPPv7lqKE8pZvn0bCbyimkvk7cozmKY7zBcaN2DVbOLtYyRxius7uEjLMZh28fs7QsqgmblVMe8ZWtVi9fhZgXcbASOvisRrr+vsm/cqXX9h8bmakaZHPfMvKxrLfRut3o1toska8z3b2QX7MmJH37FgcjMmuCxHDTXKkeHZ+Q0pvVmm0vFbYS7HWnVYvg8BtoMccDDy5FqvVugoyGEK0OkZDlMzgVxGzyCTlVdmcsyUju0mVPoaeUTa547jq6Cvj0EdJxA/0S5gdTYyR6AI+0GsBqGI48E6NOfpTOrc8w4xOPSaxILFXqRTFHWJpNj5qIv5YyiTD0ZBdIBBkNHpSV33lvOkR1LiYLD5U/3OuCjpWyGz9erE+Ekj7X5iGnmH6XRy9ntCOif0yxEdTO6Fcfh/38JdUS5DcJxvAl8EyCTHYPzGde2EymGJcHdc8isTXvkj+nRQQLCV7qeoh3CJa2mi0SQP+7H1qJFMjrt8Jd5BtDEjcgsd3FKUthA9oVrdzNYErsvLPKCK7wHtkByYhncwLrjme+OK3mKTD4hLF6r0G1Asdgs9YX0PZu+Fj/jQGDdDx15FKTqaVbvL78B+LXl1DT6adXz7a2DHuMIVxvMhO0jryqzp8JqPV2anMVqpdynoo6ed0w+oxRj2NOR8SmILsiHstdXeUMz88jInxhFu2Go/clv1PeubaB7sbyL5WSFoQ3mBIH+U8nSRxV/53qB/XhtV0cO5LgNNufTCyax4V3BHKwQmuFV/dzSrf4XKItn63up2BaK5nItYl5vsEtdfEcr04WNojgi63a34ibXaM/Ne3fXsXBbw3n4aaJEIaHpeqBWpjU7yVGAYtMSfF9uTmwKie7RJpJn42A+JNYo06JKfchPjOYtvI80cQGKKxURJjmTTWSZhuOwW2OhqOyB2uEGDUZ9Omf+imiXnoQ5O9pY6yXz5NQaFQLJh6pChryi+cBifr8FRufjm91ks15sA9YozpgR4flI9gNGj9Fik4RaO3rIcdUKLdRis7S9Pdw1Ul1lxWSa8tUGbD4JKN5hmgcaSqM8nnpqqAirQvhHdS80FqY75/zLaZY5aCMFnUQi9I1xp0w7USNNS36uQmDeQnm+vMmz2lbIXZlAO4WWjZ1QdvI3lzE6eQCDKyykMCcESDMyZyLRi4jpQ5Hk+kZWIFAAJD1wC32kCQioMEaqogJ3Q/nzPKpcri+Z2Q+kiN+FyKaPf13Umop/DEALxR9QWBNT7Nhbis7xVfkb/wKWgYRu5ELIlPT3/ILeCmFpbnC+WZQRVYiwRpLw4T2VPB4EPfhd3yiknb226C2DwGn8PajqWjsf8UvTgFTSSwxEdQFbBQwu3mJo8t2TILrvPdbLbJHsQTdeug7gw6O3/3jU77SuS3rH61KibD3Kv0JFnYKimSmIPfmS1qQB5f4oUzz0oQ3W9VLB3PsYDpH0gFTl6jPzifjtzQst+TaMCk6JjrGoHw5cSMAttsaYPDlGYgEm4tXMxuQnxv4WWhY43bqFI7+KHnlgQAjNGpUD18UZdnNK1iKfLsk/4obyKhYow/hbCmRYftntxbcxSOlyWVqa0+/q/RuNxZPVr9mdoG+H5v9agpmrRSJaD02VKUIuxxg25aXl9z6ZTOAr/GlkjOpugjk5X4cWT+RWQXNN1FLwJUKrBcyPIAE+a0fSkeL5TZYpFuShMYLDc7VIztrnvaV9PkrhopXEJyHh8DbeEnwctcQzHmZMhhq9B7n82FQh8h1Xp7fI1/rOcL4y+TI2MjuzKAJeKKMhGBJ6i0LvWm1wjky2G5Dlv7Y3+pH6J2bFSFOQw/kFYtl7uBp2GIG1+P9CBobSWoZ8UPgFhRLwjLSnOKRxiaVhLEOcVO27bywpc2qfmtPkkdnAbStXCwurr/WV4ZXseV4ZSJHfR63bbJt2fDqFQ9dzzvDb7rGlMOf3Nb57q+yftopzqX9zmT9Tu+IKtza4168rcACByfLZPlJ94ZNAeW4INWYq+VEGIILi/4V2LiWxkzRf0oub9dCrozrZNtF42vpb7TY5IyEw8ZHMZTlZ9iJ8P88Z0cKkhj1NhZJoEjMpsVMCnJza3rPymLVyVfKnA968ZZWh0bv5G6haAS0wTyngCi79Ja2I9J60lOcRb9oLgXZS2QktgKe7ph09C0Br41CN2JdDolq8I9qdtqI95EbSEOxpzJ7+TU5mplcJFP/zegQMv0JD+hoNhy9FWSTmZhN87qUDPB/OReNaqVecn0JLSLLIMS3VGQ9dksS7sf3nZsMxRq1SHYtX6DGdOHf2TMkiT++2xGGTT0WswTccBgj7tEPe/xWWmVjo8tLT3pTnWRAsWTuIR48PoL5POIubFsRORO1HmUEVMBNuRJqzJDRkGn8Y5ac7t/RiOOac65zpRHFa5SCA7AaOYss6+/29kBTACwAW+hJ1OkEbGBrZiPk9jBixTdbOoDHz9u47UcHwqFGduJhxFYuBbbXwGnGBUYgq1ZecuDFBbcL8vlTfa8TkWlYyc1ZfAXh62K6vSloXDVh5sSheWdobQBiAUNLf362uMLTpDviJZkWu5WjbOIFRto8wZ+XvmK6tDvxr3Fq4Z+MJ1OWGBrfsRthfC7DnY7fxuQKat1cey4O9YeCjUCpcEijAb4bjibzRmEO4ZjrZpiT6oYi0D6zoJymHsPk6miW8SK/BiHgc3YVwohqZ5CrYOD0F+3eWoK66ZghC+xTXQHz0/yW9qVQaaSaBR/ufV4al+6Qa1awjFHqzKAem4YPucxcB17F3uN6qMBDiNHKU09goKXGKxyGbItaluiEgJjWdDTC/hHVb3gvl3c3zV/WDWJ7GNKQUEMoyf4KTYUUGGo/iMvz8CbjwJdE5knDjPa2ZgNCW6aUdyCcbN0geDljc2HAWyX+urBfV2b3m+aOU+H9a/Nxq41tHNm2UjuAG3rd/JxftEse4N4IANE1lMibKNfE+PQ4FD82DbwEK8518NmidW5x9rXInc+jzKghZywoSgU348egLEoRxJfP/23FyV7m3hl+tuGdTzNSb5irc4d9KwWELODPSHd2x2cutk2bGio5JmixJry04GepBJipBnjNg6by7hPRh+3RBiOOoy0wdepJVPrBJXQbSp3mFpa1SlqEcS9WpCTXuDOVuNKG05Qhk88aXAXHqM/yp4JCXdtQUsZVGIRWQxLmn4WoEBRFZseftaaZTyrZBfTcNoctHMhRljnoyMW+6pmY3PksRcROtjAv9dUL9OoskmPX5EbsAvZuD3BIzVlLrB7unQdeDvHker8y2kFhVrzCWsB8IbvIwjnW9Ozm4or2pvG4CFDM7H9nrl6YsYQI9RDQ4V73Z/HaMyANH7nFqsZmVkGBrGasLw/9/VNf0Ehj3Rojl70ZREhz6oBFFehAvTeiUuVIQD3Kcb1J5bp+FZzoZ//7ToABhBlYU+q2CjRCfGeh3PoBGa1HJeBwajeIZjA4XAHm+k+52HLACmRWIIWpkH8Ekwzyng8bbQAu9+qlqOe36gk1OqAYIMRMekSLsqxERdeVaHF7wJIT7szQZRPa5JFAckjSSL3JszqvN7yevwAdRx9EFwXzthdJFl38ujyTmMAtsasTDTgaBu/47kjftLoYXZGwR5Ra93KuaLmWrZhxcONCylbVxgiz/qIir26qWQnZULp0cZBO+EWL6CMcum6j+JNGUX6ocI72KILSKRCiIs4289h2FptS5Q5pMYnuxdjL7A5f59myl0WWKX1TiYhuHIrT+wmQ8SxK78awd462MYsfa8u8kVtsemntPX2CkIiybmK1IG4EVtH3Bv4Ey0iDBWxwDHcQPYgDjAHGy1mtBgtL48tSR5eBr6rHjUiYsgH5/cwVgKPu8nbFNlmuzG6pI1jI20xR4p6u/cEPE0QGLTd0Lhd7jPIkrA7KpRBG3vp7PMkBtoQ61gj/j+zHrV6hmCIX9goZxpRGPRwbCDPCkdcnnsL5+U+8oO8VXa9a3o56TlwKmKugqO3U+gZFpW45txWmFVmzT9zIEkZSM+47hWGLSWbz8rmCfFUxDLFFrHX2/8xMEu+9I3tpALgqwXPc6FV5c7j59uv1rbq6fG9YdsBKJsGDAWIuC2sXbHHwTexqBF7GU1uRhwB6pIYaDJ/jHvHjJFGAim9G3hMk6QlBx6CB1vBwvql4p8tiH0yLXJGQB5Js4Gpl2gdA0J9Pdi7bcxNxuCgBfNIFIgo72Sl5jgoLORKlSH8O+x6CgOQweKrZywPxLdheuYjyjtuvJzLA4i2oPKwhSmSr5q/5z8lL56mtGMnjIrU/r+8etH/QGOKyHr8RsrvDarlwKlJDZzBqIGTkySzlYuRAjALCTgTm3n8NCCZwxw18zdGfSYdsQs0YbeZEr5DWhu7ovnm/nmN8wQgrFkRccnRwNgaV5C1SjrDOqviXvr2ymW5vWt4Bla6AqhN8cuU4Z4IBms6aXbxhSm3LNkacAXxOwjq8PfLZeIm+BK3OjVv0yWzp6i8qIY8ri4PXVPYZkaSFwcYgA0QHvqPwQ+eSTxU1IX7/w+UyoxXe0AUXdhwwAk2cRVjzKewAyDicTuC8O6MRUzc46i4OG/tZBrrk21vJUra3F2GeMj4E/qnL22OA4tiIeVt+5SRQL1N8M5+cw0iUFxfpofikeQIT3FwZrQRAhyA8VJ6znhMxr3zrkfma+jOFCWHqh2PrfPT4+eWgoCJapH7JLDNafVXLp6wNI8M+71/dXGj0DQ7NdcsQ+9pNuJIK4p66QlxBal/taH0N+dPRkyuzml+KVeEFfwabUq3tXNvJopkfQn61kkz856+RPfft5LfecRcFPAnvp/hTdYAVFKq6zdpzIInlo5etXOFzonRPjx1Q8pR+/j7SoQrKi8TXnZBLof+ukzTclv2cSS4htyiwiHCh6p/SeYEWj/02G5HtljN2Sczp89ZFcqIbLG60cXGxoo8nTMMi3+PpSUIF77dRO0URng0tR8oLO/NMpfncES6xEDUyEhoCHyNNfG8f0+2jLX+0/vx0e2Elg/9i+9JYXzPwIkrQVtqKDIkMTKCnIAR8um3SLEGrGGXzhTHy+ERFFt82rHqvqHumrXPXUxvzgg/u3p51U/ByfIP6NoUygNzXxvyrwkIvLb+nOkLQD017oRaMDYd6w29x2dBm1372KIK2FQ5HrPryRKe1Gz0bz05nlEU2YlmflODlOe/ZzfOzi2TlpcwvE6UIyEvDlp8xt/CJLHJrOYwPXYhu3aBjn9qcbfM31Q/CdliKBWfVpQBzciHdheqGidmevIyokvvJ3kqupb4eMdlhQ9jtMSgN6yYyedh9y+UTVtQE1DyT/C13xZ8xfUaYkIJ85sqEMx7u553ENQamKmfG1ibtEoKXa+xzV8ziAqn1+NwMKZrvKcqGTd/tTkLOjMe+Yyw6LrX1axQ9ocMxdZSg0bc1OllIYsPckARbXnuF10k7T+4kx6h+RcjdFeItsjut8yKmKnMy5oCL7ZLVmZNaaa12XDG7q4Uezn4YEXLSjn9MjHM5QNoBhX4LrRAISvCLp0DJUid98U75Sg1MnzaFFm6zNVBu5pgya1gJimRxwqSUELAXN6PUlG3bUgVSM61GimZei3YueE2t2jM0h1ho++aSDP++bz+w14Iz8WreX6TmkHD+KtD7+Iz2DpvEhF/hvE/CdrfkAls0bfOlRUY62OSNCS/MsbuPRlXcQCi3vqdX81QfHHm+d0B9l+jFMZtTm8hpnwACpUsBLVm18NY8Ea8GE+3SFfZFL3RI6tJsB6PqZE2booQ4+aVAStE+u9fCKKs20AkkBl1m1A1PQSgKjiVgjMEnaiwR1kRGgK/uEzHBcwEUmWDlhEFchVe+YU/QakVdDfuzeht0RBLeUJRvRLmE6k0up8DqM515aUywTDscyehuOFl10GOitwn3KrxV+ElipOyrwtgdZmYTaiKzJZaSjQhGWtoiwtcxerzMSUpOfK9edOOb2XgHOyO/j+rbiE7eUsP8n8Wmi8LHxGDSmHytXXpp0d6CXRZmpQkbwLiRMVG3MlNeW3q2omXM9H9JWNRpWBZqlko/GkdKBT69hMGDYFDO6qdoJ3Q0pJCmAud5W/+6n6X4mTSGtP/MeVYSVmRbsQgOZJod1YT+JtDetc9V+pahCrBKCjb7wd+vUQnPoF9+mntLOxh/FvdgVoaSK1e0zZjaAuJdolIHXQfBF70KoZ/m63HQ/4nGjJHSZtCd/sxdOUmQxm9U2/6BPe2eK/wrGHD/hKoOxuinM6MzyvaW2OPeJaUK5HBsJABeN6f1s+wDF9VCOqmHtrH2GZ7xEl0hm2PJV4X/b8KMvP4dKAxwV8pa/J4ihunjPWtvRBmBWk302U6+CkUrCFiYrXmRx6T/FHaGRUnJnMPt3sEI4MhjqnZVCYqkVu0rHyCoECwvSoy61k3uMuGP+lohes27u6RounvM1ThIWwLIPdvR8Fsqk3XVoujC2/WxQ+45B8qvdyrxXJMRZZUyBw58QXk3tt+otU209Y+IxgT2sZ1LgQxt/opZqSdNltc3BW/0yJeggTYVnYxq+aodrs/oj+GKP3nliZ2szA1fJAHQENkxuA+dEkprM3uoD46bdC7Lfzkt4mLoBGlGqMnVg+G28uw2Y7fK9acJcX/aDvrZm+ER8Lsz/4DYqtNXLHElQXi9arSJf0dT9VyCe20FVaWo17CjZuRcB1Opcexi6FoePeyCITjEBHjcgMHENVt+3yommIaXJyqZzbIEFE8u0cAHzgm8TxSEvhPqYShOwcLrzxCxS0jmoYrYHeK6BToWZURdO0e5648E+5kmXnIi7UAMeV/N0tja44GsAitVPbYtfeDyQfxbSflrAAuWMJnmA+UlMGmAqMpjNF/xcC67mLWUDxoR4fVrwF4vEJFoF95x/9po3pEdYeqRr14SPNFydajKr2Y3V63+dFOLTZk1bhpIMlFoDAwadgHEwMhnfUsbWcVJvg8bsqMnJT9Sn/1phfBvD1ZahkKlfGnWRTcxk0zlkHtVIL9FnbrrUCdw7P304D61lx8JJwmKk8GR3K1Kw1ogzzqBLOiaG+EvoQMNjw5Fb6pTgW/M0mW3ndMfpliLCORCVcPHsFunO0T+c5WUHjkMXNYiE9RPwKQViQuTJsW1vgVpGuujuvx4Sfsgp23ehmsB8eevcm4ut2ho1JyXaog5ngV7jc9Qm0lfgIiArMekyfiOMCuWx2asWx9oUZO/fkJthcOnFLgMGhqC2a2c5p3vy05nmIrAY+mcdDeQewXfSuGw2fRaEyRaQMX96QRAPO337UxY4BATFktRSQzpckkFyz02F09uQWrjARNmOaLag0fsCh3ny644p66uDqKD1OCyeAfXquSS+696heuP9DLiIc2JzeUmItQrJHKeFLMg89ddYhxbIwbF0K6xfG0xrHuzNBpOpO+57Pw0e1oBTPNcanuN1dZmklP6cVfVS7XbkQYmcltf0R2kPXXaQvxfj6dnwzEg3A722BXwj5QT4S3R4ZVyC+eYhJqTXh3akcc16hOQxYpD5vP9EiPq7ojILHW/8irsFGOKJZIsNpVv6Ky6ZaGXnVY2q8hSNp3s/JP16xUryF2VqkpEm5r89wwDxl0XQia0Orzbp/Cl1Kbz4GSZKddtPp23LEx+ypvB7Hd8O4YfbAgQbv5+Z6oT5qpB9tYYI+ywtDXMBSl/Nv/TgoykUSXxfBO8dYFBVYA35Paqz28COx+Dcz3zynvGS8sylLc2I4Xgs6LGAMEQ4eoBBParb18A11YWETVYNaJpH76SNsvmXkEFQBt66RAqhaUdeWL3fmZfcKvk2uYoF1tmtiUmkYrX0S4QtTkM3YHRA79B6cLPND58keDPMifuW1VgE3KHw8K53VNo89WE95cXpgfo47GuMJt7WhKMLP3nklVrhhIUHpLrgTOmZSAvaxlY2dgrDv8B5dhDAHPRjTK2BaGKcfvOk+TpjWCk7tQZ1LPsny6n+bcMoEKNzKuhxuW1F7xpbtVrxN+QEDYGhk0GwPepELLCK/fdhJzWyoIFxGVYuI6KMizF7ZPwJZlgRdxJ15gzNXipbbEH1yNCXTkFPFVBlTs+rk68dxSrrHxR2M29MMdporlRHMnT/Y7Wn/HHbhuMW5ZCYlry1o0seiff+drRd50/P3PQQzmRib4f6kptJjmPsKOWTwaskL9y57o3J9QqpAbda1lDmIOum72qmyt0vtVHtd5CElp/YBzpHwCLaj0ukT/6aqDsLVHpTVxDo24k5CEh9iJCAxULbmzG0BN86G1gk22mblb9rxsi1zwh/r1p9PpjUnbzRHjXxCa4OVx+4QNFHgTIOcKp4Wf5PaDexW0Kgxe38u4P6L8ltO8IHO2z1Bi0ZeYmICOVljVhrqZW5crWud2RwyrmL+x5WF/++t/u12pJytzfs7AFtR/g7KgYlVhQOV8BpD1K86HcpGtzI1gBTDeYFhodoVCZHKBOBmQR/dyfv07S5UvvEbjzsrfdA/9SbVAuX6/FDGZTVnSciJHDYHoDAJ7nvEO1ZfYDfWwX6YqBtNZiHgJ/koLAzFKVZnnzNvY6xMBM/499YFsYBAxkJiTXaH4w8g3WNGyV7yUAvI+SAYj9biCIjJhz9vFAIyPODjQNuoaV/KBAyn5jdrLNE/ifAwsMtRDayP9fcOQY90xnLZ/l29D3WFtyjPgq0PTRVONGZdDrdvHmJPonoU4ADop01Gzo3dm+PQWVBqemWblvi0HxXUVIeofiuuVg46x77DBX2bwoATSFgflAQ38SPwedyrzQK0BNLoHvnqhWHH/lYc7ZlRJXcD78ghKF1ta+XIjQJdokVYbspFkBN99UCoNPjKqaVff/U07dbwIOK1f4Q5oGllbz/p/4PFPjqwtdMlrgd7nd7Pygac+j0TAwFCT50wRbQEbKH8agH0g78QiMVVD4xq169Svj2rIjxUb5vWtTOzPmddVH914nBaTVQo7syK0PMoVqbFeP9Gr26dFk0GIJnpMATkeUM7jsfWMa0SpzvNdox2fPy/yAiu4iwvtbEzI1Flo5m4PA+Lzp8EPQD8ladu+r/j5pG02Flbp2l95nsCcnsOepA5+FDHsRY0bs1KFgBESC7wxdpRMo+R5eRXZStinKhqNsJc5PqaD/0nJcb3vqS88cmzM14FYKPd9xa7L2fhrNxq/Fv0ijp7O+AmNKkLTypZjzpr1JSy3Zx5+GG1GTHD1aNlBBLT0Bix6+onqK7fMoFMnL/uFPEfPb+xtFGlbhBwKNDSJWmpYHtQJUEUKtbjrObut/P0ADNBjvmcwesfThq7NYpN//Ou0gpOwLkwjDMdmccHAwtGiXEkXEmPJxvGFHgg6scCITjfKzkSxU8jz1KaXlZIDLCJcGz3BfSXnurq0F63IdbIl1TZJ1qEjDvJ9eScI169phwsPhJO1vc94Fl1LGYEU6vfXs2zP6ezsg941xzzqBx1gmJFlk+AhiHv/PwhKisiJvfLDqBCwpvm2FA/2qW+ICII6enwWvBqRA4lyh/rCAJxL/2/k/JDe5vjdu2rJED1CwjKUBEREsFr4JNWadoNi8NmId2iSURqvi9JgmFOzhrOmwCHfTi9tMZP0UmALRUOiAIiP8rTvlk2ntT8oM4Eaw5US09BJXtG/hJeVyNebgmE0OBXT+Q02gd8+Tx+8zRT94PZhV7FU+FEkGCb5q3QK3qKenQW3uMyg9a+2k2hKvhoVveI8UPPTEhvCxaVSk954tRMqb9S9ga1Bz3uON6jcfcbkvQbUFzSbh/ddHUsECslN/dh8vA2Nq+zk0r1DrFVvX0/e5b//83NTO2ORqHiT9bUo3jodhGOGqPDojfBbsb8GUjK93vvjdqofXSr2x8/HgSeTuAirSSVOgcwPOVo+TOu3T3Obm0bMDc/TUTG05tVr/Ka6Ft+PY8ZTicqb5J5ubCzBSIHU8KFRhLIb10wmPuYCP6Znm34x43Zmg1TEm/U7XA9obmT7bgFERjA4t+FygfhwCRxznhnzgebkv2MCrJpMa4zoaHSHcu7xMoFHNFJupWM6RYoLDd7gzOmsOAT4rIDXKCJI1Y0gTGvWe/mkqRspqHilH0RdCiSCi4fekfJK51hsY99ZSkD5j+YcmA6LK1o6jvGIXhZPRJ4JzgXuYULYUI/B5Fl7bBEuVlTS4+vp9liSZTfCgrTngGmJ9zfdGyR2zQwnOfiRT6KvU+elfYPn1d5jIxkmKrIM5IF0vUIEyTiZ+pLPWaYbOGPBxSJeI7+hGORs3jGvmkm5ZOl0+vgDNZaCIkmS6XuBLCJV6lMsWfZ+D4sZXYEzzA/YHTG2y/iqcKYJ/satKN2Yh/PGRauDbiHsz4NlFEVAGz5x268ihVuDJYeuOwoDkelvGe3PDPWEnITRlCeoExGl8HUzUGhkjYoE701u/RP6WCeVIT7hPwLAsqMB8wlYpVqOn9QNfz0TbU4MaWeja+g1n9gA0jlKGrNkg45ixU86bO8P3Rq6xDSTYje1L/XTJrKDVUiy+871ZeyZryyv7f6GajF4RaIM9R70Am68IjdF1DhRAO9HI1nWYeB6esz/3TyviWZi8S4CU4qZrD/KLpqnWN65bNyzFitcddrVC/nxXx8bWOP+pWhOqeD8dwmroLMoY46Rwoi04BG8+OHkMT/ooeJbNz4Nnl4UgOrH9ey+bdnMi+3XqN3QFqch8OwNPM32rM5fAvZn9M8X49erxl9YP+OULZnChySwVAFH45bvIBIYAnhkTYVFzmH2Y0DkX7cggDJwBdQxufSE7d+Q5l8mDd/1AKopEpHRXe0WUoHRGfg6ybFKtItbwr4cPjVsdavCbAwjzsL0lq4LOHdwz+HCChgfd3Cs8yV1fPaScCrwyQb467VXu7dlu94v1TFz91351eepSZc00f3f5DNdNd10VdyMmHcHtDe5THPxRc/z/+ufkq8jmX/0Fcx9OiqiQ71srB9iWb6EIrsmfVEowVMMVTqhRhG7P4DKnVimEqesvQg6wL18fQoewXfhWPiBa5Scxlu3sbaqlS0aYIk45s2Q4w4AwUsJl7qfCKQIwEflo073X4paMwJr7TDJv9vxTgDMpZSonsrr/QoHi7JnRIxT62+kZgtMrC47FyYX6rORQjYLU9gh4bJNSZgKZiTxPu4DvmCSpwcsmoKb8FSR5OoJOJEC00WMb8liz3zba5+Smq6+2kprNUb77NDw9VVxA/VP/hF6SvLGZAilhkg5W3dasra5zzKPXokpsj1/ltqBBq8MvvcsW3/1eADocZkSPkSTT0K/6TH3M5IMzCF2HGG2yh84YrtrVDwgAgZ7VuUZvbGuBXs4XX52yCxYo6pjvHtI7s2Zd6rnro3Hs9WUXgqfQhi5foOg+NS+VJsfjKtu49tUnGSo7MW2tuj3tCWDr1xa96b6A2WMQhE+caxcIEMGNNfU0CzJAZMA3QuoKGBzk//80WN0dQh04UFk4LsVkoMqQP4Yuy/rg8RAgvxLN2UnURU7QskZC+88eGwL8IcuEe/c7RRjmOvWE/oprmKKE72gYaD1eE7wcxVNmEei7WIlSPnk4uXd/o1vz5nxH/zNsN/+RahEFEOQbEAsrb1lB18JJHHxfQwWBbIo0OTGQOWZTs8bw3G4Z4LFus6milSuBD9XnJBOfPXWMQJe/aH/Zb9/ntLmM007N+xc5rf9ay3wmOC+Z+2F4lZ87XGkmTQwYpuiCgfktrZU26ekYSvmLknQt+nNqQZXEImNyNv1n2KZFbfZYCG1TL55lQJ+PZ1/4i7FEbELeXGufrLt6pAGyzjabKyx2A5yyFXBDGUPImXMXEEG1ruI9qLDmbDyfwIc+/l4qWe+0EtxMg7EAzf02tcIj1eLdcoRJIqDbyY2n8mRe6HW5pQsJwDL4hrM5seHy0e9lmwQgkQsmiOZhzLBbEopGi8GvArwmjzrKR7TWou1rkk5PbL9bJUUo2sGPfzsRcyWzmg9/7bml9HTcPa52lONkfoO0DCU+pthJpMAFaX+5Q+uu2pzXSgxzvFA9MQvChN/eENt0YthBA3X6o+c5hCLobyTb5qf4r3SqOCl0JBTdG0jl6zB9ea/vqlARut7h9D7G1CMknUDjoq3HEvJw2zdDrmhNpAImST4tgXPAw2BoXnRjR7OfrxUEBEhLt6avdl3h7Al1H4rel6Hy3Ux8LyVBAp0b/MEnH7cDwWHs95YrLd2cmzY52FfohH3NnkF9AUUCgWQARkwFNFzUuMiAifGtMhAIXSb0I+cUwwvVvYLG/n/YosuwKBBglEPmzC7z/VjeS3lHC6pVVTTLNHnFXKVXW5S+Rlbrw/KSJiEOkOU7/QZdj2Cq0t+nM4rmXUTmbliK/bXKQIM+WNhroeOl06i6pjcN40OXUe3KJ87jVqrrMQTLVTOEx244DKRdzQ7GsdnTlPCsp74HTZM1Kbf+6AlWPkDN8x/nK8CpSfGHiCos0lcjoiYj7sI3/KZtIEiKiDdHcVjlSXVISnSpxrLry8vlMZJdfJ+lbteoKY7D7zi0lMfacf1toTXJDj8NXhYanK5sZg+vnyiHIroAwrdT8rnkR4D1oquNG+5OSBmVrOHJ0RMa8IT7+EU9ryGt4HWI0xTxQwPOCjKpZSDb2vcp4UbxFvwP7a80XLWQB5aqjqIzlvWYX5ksdf9Ub+JCdhsTK0mfxhvIS8jxymhMqyaZ+Lw3CdH8A2WZynb8zOkVC0cr55mPzlZF35qM+jP+N/pD0Ki5rd/B1yxdnZEMdK/DknoVXK+y3TDHGsMbrcfJtmvP9e2irO35yvPYBluGF+bWfenSjNdWdtx/EthFLMA2CQFs5eL7dh3LNpALFYIrp5CVse46ckrhgck9IXyzsy6hwaZpsmE/WLFumPz/QblQtVu+SApGZtWTL16y0wrWf9jVNm7u9OTTxsjO7aYpi1YnJ+VlSj+W3UMvQhIFX9x+esT2BUQVosbSYo72y/2HZiBE0172EbmiEJR+y0otB5nco9ErR88n0uGVX56cB3gi9xiBZCfm/gJMJhz4q09nXimzqrB4BiGHnwkcjDOz0sAJ8qv7t23Pu2qS/WMnJnmSgoC2Z2p+s8ZmrobjFkfzae2SUNjgy2HQCmBQOL2pkf++ltc1Y1XqfObkcSm//Lhf8GK7tEIX0ScADcKVBts7AtQvgw5ouHYBvNr1B97I9CVLBOdZtO6KgEbJSAz7sFtjegiPcuQ5MD3ZPGWJXTYVHbhpM7g3ARV0ePpgRK0Bd+UlFtOnTPBe8Oztkz9u8lHctA3vMAkk/1sbZhqAXJ4RQ4XsGEtQKKhjslIgMtE+md+ymB1q5o70sw3ZVxVCQ7RZv17+FMZgy6QJo6x/JzGmHfWglGoZlKheRY98gQ9LobfAmsRixN+SmLppSmGFfZPZctBpHpfKlKd21+8SQxSPfM6gH+XhRlbBAR2fVnM1YtofHIaovNTyJkiZ+/fJ1qSyKReURGD36mz23BPP3js+xSYd4G2V56vqnGtUKWfuAJdw20FgPt2IBGp7rCIZr6W7Wr6Aaw1W/IqzFZ9hm7h4nP6itAjvgvAKArOUXfhj/WLba96uUkvqV3CZcsqA9nWXo+ct7PloU4wDTZeLU+7NTTJMrYJWpKvB8q8OLYqhtcmQH7XuVvSnqIGrFaAi3GLZKuEBlYkuXWsnHsSrkg62o54OaUuVtQZSJVTGWkpvipD3pw2PTeZZkTi1LWYN5qfTEsCqyVI1AHfFEmwg03jN5ftge5Uzp/olZBFYw6T4tGthghE/CotiXhDFL1v3T7KOOtGoCJw8mZSaMfIAmX1K/JasRV2t6zFFkcuhqLPZK/zkQXLlbqt0lEnFSnhASb2teKJvFpvbZhNL+0q65G1i65J4ZyAg7AR6Htlut/kscTRThQ0U+0WYp5xzwD6RhLpG6L9Pba0lehW621oA2UPy8WOkkrrGR1untOELvFrU2Y0hSaQDxIlgA861Qd0cIHn+XSix5VBbYeRXfB0o6hT2LrDZ8GVYdBVIMmCkT8cPPhFhINMkYjPv7UXXwQ4h0vNAt9D/8sS57yIJayhUgpw3TsP3y9MGi+1G7fDnhVK1J4xiui/N82J7ZfFhOlqA1AVGx5xCQBbnIgp2K1TQvPF2Bqvv5Te6H+jqkllodSFeSSJejAK7qVzDK8SeAGieRvPMKFIxB0TuaD8KWKvBnBVbq/KQ+1VNyHtQsGhCNNMq2wmCvIwUq92x2Yok47BKcgEv+fB4qazl57DBnndsVTlL6OwtKbGxbhyYhG/gPyO/zyanfM82qd4utQ7Z3h2cHFHcCw3TQOmThtMuRUhjFdS1V4KMMlZMezFXUUxsC+S7ITgwlvoeBHUTuzr777jH17hS6tB1EI27D8zgg11WClXsj3uxZCQuvokXkgkVpSWCIz/t5auuQQtOWDznWFCZsaJ900vg/whzRtniskvDuYBWbbHPk3eHfAa3lgr+CpbTPca33vg11YCHkGXgXKEO9rg4z+E91FTMNXm3W51fpbnJkiCzE1nEzlzcvqVwPjC9XHiJs4mnWvnIzgCBPmrI0NNnvoMKV/3llpsyL4+bJKtugISI6lb4TcOp3wRPatwleZ59kWWXrX9mUTbt3QyK4yF2xLsxlLjiB5wz5KDQYoUY66i4ujXACaKrb+TLKHM4/EXxeGTqigMByrKPdnoF8SeSpJNKwRcP00Tg+FwJ4NmSbtMzwJf6GcFBn7ICJui4hF7oTt03GfRidVREFed+QkiBhn+2DI0/1rvgcAlXAxekxyfKoFnxFKynCGMSD3gbx6oI79A3255zIj5sZ6cegBVxkVf8fYlqGJd9trGqYjMGZHvLNLzMyPpqC7VAa2EQ8lJPJ97mQY5P9vKFZdJtd82WtH5AH9CKmwwXkjACTLy7VzJXLc5G6UU2+n+tLCzR6tHMY3l/XzzFM8vMb96zgm+nlT3Uq4Lxlcayrtbg7X2I6KIlhUeVKZU2iWB09eMPJtggadD6roK24+zXVtkVBoohFEM3VL9zicsQtRbuea9bUNZyH/AHNNYWiWKX1as4wc+S5OVdLlq2RRIdglFkju02+MOSuJTWIi3Le8wkAJZyZ/H4slW4vNxvschC88g2JarUT5ofNfazWMk2GYpT1u7gVxQyYudvKJ/yDDf+ukd4ghNjWCRyixGMLT2rg016b26xEZn4TujP2ymN+iUCQNRANAlL/osVd7rvsknTTlaCkjwsebjkhkJ2p3JerAlc080L+6OT1B/3Xq6GTPIyd3EqGqqcRW83Sk0tP7PzuboH0giWWxWGTJ2hoXrlu1DBuvNfhSdar/jATFP7Kf1wGtYgjN6KxQoTYpceg9upA6braPTY7Vz668qolUJGCni34Pi0tgtvLxxmAwo7Alzfx+j/CSqRBpd7wW1XlZVoEqhtBiETv4g1s7CB1FAAz5oqawY6GEbTWQSjDhGuPtuGFeRQc4G2VBHyQFN5+mYsvoD93M2+MMzJss5iiIyQLge4F4UDu+G20ixVG3HciFMYEdqHf3VTpa4xHEucHAf9BLg2LdYlYtBDruJNr0a+J/GF4ymA7IpAFYdC8y3Hk/4F0fmgjZ1drwIwFqK2Z+l+pfOzhxBmluW/O5wxeejJ26AD+YoBnlVMAt1Y5HN/RNiLoto43RcaRWcDWCg00I+G+4iR4HgC/bf7zISYpMET0CB1/vmv0LD++0JG/fPccZ6VD9uBD6iMGhX0WBW4WG+czZamA4zldZn0Cr3XF9xMEEa/uRQIMOlp3mDaM8voEqqtB0KDB2l/gOlpSUiD5KSVko2OgnieFbd1ZVg163ZP4fzen6gQXnwZMd0wsbq7eJVsUEc8Y8dyaQivTgu9J8XIVPAK7pjD7KPmeB/UBQHFf08X/a0+CgfYasBojayuwXBSKPkifz54gA3W2YVme7tYkk/WOCCgVNjXjYZKoLaxsB5TnjleHVUD9DHNE6NW9s1X0W3LmzDnBQZ0ynPuTRiKIT/i00U+4HYjVDLel2j/tUTxQwSTcMK4AFt3ms3Vw38LDUJVUpodOq9CjQrCmbF4OhORoYRGhLD4UjMbEyz7H/y4kGbu2KSkd9Rk8mZnqehNBwbZBkZSRnk9x/cQuXjmwJU0Z/5YPtECcrr4rRJuJPo69mQbrbJcg0dXcJfhZM6zz3dZ1HJDEuL4ZmhQVr6IKSBno8BRYsQDq3075cNDtzUN2lJyP38J4S2UrC90KafWhgSlGHaEQXhkSFrHu3nOkDe5Xyq0u3vxPuJMiNF5mTkNj2MESoY0aXsRLsvt6vz0C5vxutGoRhgaXnazYAdIB3fHOT4uuHklX8qveYhEDUctyhN25/G4sEgAByHBPT81bmYlMdvSxsiRgR6FBLQCXewlZAnTy6ny684u5ZrG93NTs3pRILlsIrhUkZBUFHaVf11rRWJy4qIT+5fYrG45LlN/ytOZF8d1idrPXrFkZimEO3HacMN+F6WjNnc7STZHQXvw8ueJ4wxepdJ6jjnRfvPQ4GTaGorH3lMqXvnXPVbemOOLnW7AvfUzgKHQvEVWFwEBZnSfeiTnsyNo82MP7P997K+XGd14slMbSBwcbrbJ3OZzwe9IhBDSjuDoLooo9BFUd5o6SaRewhQkIx+xMPiSb6+knrrPHQfObVgKT2rJVpUAagvQHnzfJf4yScHWluKi9Di47cfseROWtqaTTsP5qhy1fVlmg0/8iI5vYNhZUKDFCMpRoc/ityoaKVlB+Ehh/UwNzZV12mcCGZINTMl+CRMT+8VK1REIkjEg4IENmfh6yAf13I5SOKgP1/0rPzm5kVM3JmY6OGb213whAO/NLLJptT9Jw6ctJvGIoxpPsCIgUEq6903H9SIWRb5EaSuOc8hm1Eb1xpDZOoBToGk8mpVaJcdw7oaqikJX7FhUd5Uej+UUjtCHZ0FvDUJcXWC16yKPWm5dRXBfGwnSFjdzAkqKK9BBPAuYqJP74zK6OVKemsASRhVRGtbGyjF0bLGU2O719R4m1WqSxDrfTgQzAWPeoUNjWsDkCvd2OuUaoN7bI+KezsiMxGi1upokGFvnTY4nnVVNkbfCShsv0i6bWRoNBSuKkqL5Wzz1VXLMgIizwMzK2J1evSpK3GLzl3TvaHs7x2G4h7tI/Lo0OQMDrKxok0G9cJYEOsE53yqsp0Xcy53xR/GtskIyokqGYkTeHn0/1cad/bEzuLE4qtT+dVQ3SLlQ+1+cgeczvxf71Dc+eFPYmE76CV9uPAbxwjDJ2FYowCsDbAmhxzAicJY+sZvoESyf9EW3aWajprAlsiK7RnYcCL+HSUyjAN9Ce3+5HduGXTsq56DPfJdfd7hu/V67nD5J1F1Ol1/wj41j785lnmbNqXTbBAWiy1s1nu0kBmWT/hGYOl00BQi+ikoB57GNIzMcrZaltK85Ckmyzk238mTuBAFYjBAlDhiDNf3QamCnFaS5RI/fJH/aTUIic0/WLag9BKNKfzUZlf2y7flmmbwVplMYl67noenfNFfMmnpYDgQ2N9P2n5cBnJvhVqPZsa9TQE7opGE5sIe3qq/MiyztCjm4/1qOk83DMppkkwHny22Eq67Gqk+c1qy2g6ZwrBTFaTP/pcOqB4EE/IaAa/D9pkz1d5ZwlyUs/T31dpyczFIIXm5u08Nboy5rJVW0nMRNpBOQcODNtR0JNxJjNsCcNpq1Pq9GVIDU4c+y//qxKGZD1hNxGaJycLxseF4ttMpPZpkTXqWcGT+Jz2MxTJMG2mA5AHQdBxxeEqiJ213JuDb/7X99jVPMlEa2FYgPt5aU6/kOCneWXZUK8oWjRxXBzAFGwf1Gat3Gx6bOMO4FDBB3IQt6crxeyrTY32Sa6lTXqWPVRuFn+ewv+/11qj5bhENho4fmXuMM3AfTzdms9AQVx3L9oP5mG8aJq3go9EN97wk3yMBjTA5Abs8plyU1VbD3qOqUUTohjswtz3TvHNe9ZYzWRxF5kytMTD6i1Vr4sRxfYSoKkk7L2qt1ZPlz2GRZksoSgoVqRdBDKbjVY1kEt/ySTbN2Ev/Ua67yJIfvCkFPHIXl42K7lCWbj9zK8JFRrY0vl3l/al3daKu9X4iBxxf2SEDd9uYHzKYgRiG/8tmMe9Xcjjc6gkUvrE2shSXHckp1vVPCu4ptZxy3rIXvObyIz/n/5zfDjcz787vQPMwuz9QwoXtfPuywAFNt/Nv7WG6LPIhy4E1YvyrhldpkMWBIbvJa9ZUZ0tEr3kTCeMs94XVZhF7RR2UAhO5abeSnOxAM8GC6QwtRz2oz8nP066/t3YLyhrGqr4PNnKzYPXQqzy+sQTh/st/Cer5s5oevMw+2c6Xw+0sRa1Tzv8yonuY8zA3s0VrCBbzBWNG75WNBwCnaRinNjRjnHVKXdYhvrAnuvOSnKsnTNjpPfdmeDcxL+4iJBxKg/0cMIrUkjaCKvZMgl3OUC2HOujcaXDKz4Cyq6uRvsKtzaH+GvqNdw2jJKQr7J+76WU6MLSyF+s0lxvXMGqPX2cLAGs9zz9NauX1AAG+eojbSNkxIiVH+SCTDNvLOgXX7mZFMZLwVY+DC+o69+H6rZg7Oo+7lHxcz+zGPFqsullHIxGKzD6bh2zBpIXwWMHdivmQSvmz+F/EpjIqY8yUl2ijRvyhFFeybmNYmWCk0n0vJPp5gM5Q/GPU6TI2IeK8YRKW/KK/33YOefG5CiT/FqmHLHmsJ+/q5hsHZnggYgoP1UNWhhIZGJewvqEsNb53ww5JfKs7QKP0tADTWZUZ3XhUWgerlnraI4+dd8JBOyJdceeAUyLpZB8lPwvbmzSeDLe4L1ORNZ8vTUIbfytgvOOeLLXMnrDTvcDF179ugRwXt0mgfAfq/KUqrT6LJCe6T57UaRZId7+ieLHwZCNtemjmoK7Ux8tAyWfLFABHGV8ZE+5Gkg9GCscWQ2PVcRLLxROJgiBpPucapHvRNwTB71cOgxnB9/xGOB4LZSGU3Q1FgA+QS17bO7q7C1MHseOaS54puaEQaUj9mNLNRkCYObTtLZYb2u1REfx7oV9Lg2y1UuAf5K+EzDZfyhpMtQ9oqXsEoQDIgeArE/KvFTDu/KIgdltbkyG7aojiDofzHdZ/JFMRL0KEp3m2T+We1Et7ezRv/vhA93rVwSvLQAWUfjB6528bRfeIYfNe0uR0mPrNzExekNkMDe4+9E1wuU4kf98Kb//Z4omJGxzRMZYAcr+OSyWkhr23ELS0Z60O5Ta9Ji1xAlOaRKIyoSRObbBziVdn+rgmxl0azRrFMp5sJDg8BDBXUwneQ23tSpi2EYIWJmFu5QMIr6QPAqeKn+wdRYlejglCt3vYE0gqXPjZqo+04ScgnpJCz5nlQdrEpdM9y8trEOFY6+Fw8S3FiNdBLYX+s+wyrERQiG377MEpRoNZ1+j1t10NiYkmJAp04hU0l7dc+gdUDOJMm6SGM5OR8O+W3zn7uXRl7JjKzj99ZsMQ4PVdgid43ix4bCLkBx8VvN+mqwl5tajJNWElm56s2hpWyFseKzArm36dPjhcO63WujtmhgnaHsHhISSz4uixfE4tfBvRqrhZNg1YrZtU+DlH4l4FvB8e+AlDc3DsmP2CEnpFzoSR5yKwomUauA3WtEoLtFM0zxeNE7fMbu+NA9dHfLOgkcdYJnt1v3QpcC/mNEz5Xxlg3fYkxgU76r5E/xAZ25O8jtS8PSqjP5FS8zk1wBSfgE1JuMcBlWoVD0B8R+7f0z9/nPGAFy0BFYka8iAyprExHNoVTrVMAR0Cc7NX6yKIze+vSBivRizE/QhUjSMHLXLDAAIEE3wUwmC0rtgOILA9BypvtN318IbvMp0R4/gjo83ghpkdaHWO7JgeOwWuZk+3eYlEgsc7chD4u1ZG7JK0MEd7x8G02E6Dy4QL6sPuzIMnHCIjrEuBYJ8sooJjwGMy6u17vcW2IC0x0grbo8SxiaXzbPCD4z5L/LZxnUrEmgvfu+//fThpAuRBLQTzFdxy4IZ05PxXhemYoMvOPxUPwnZGzjEBIUTmxDWtsNVq/BBxP6QxQUH8/dSQPXnSLTkgy18sID3UhsjNxQ5H0OEeIWM68nkKjdo5mQxMBMaK3qrqjg1F+PoBgbxnp69T/UWNBk6Z9OhlRX8EfijELt2ONms2Etzn0mxRFzBZhU090cVatVwTSJ5aeGrvP/bhnvziykrurYeWjcU290YHoiX4EEjeOWOMCGUPIAp8R2+WQXCfCXiKJtx4E349i9SbxFIKco0k8qUzKFVC7UlxxR2kLrGTLTpNNynql1JFNqTnUkpvTlfBw9thQwGIih9OpAbcuyARUs0N3SLAuPgF03h1hRxN+1e9IMPle+OfyK5ooTX5bfYDWflYpgxw9atIiABlSV4aRcAkiit/Fcl/oBmBWmTquKYpctlWINX1VkgS7hpYJrsWiWmRiUZ+drsGme2irWOOmftgKuweLYlRdEsJk4TkmIH9VTsSynWXccY+34NoBsrLEm3JYBJpT7ZBX232dP2sMzg+vjmxOnDm5OYTpBjXMv/i5mIyyDB2LOgjnZxfJlSPEs+9Qk0K+BcYJZp42mZwhv/5fF8afZMuLU8QNE0/BjZc0Myig8g2zqkLGowheYaeCMwRa81fhUvcbjlEeLlshRTqUqlFXkXsd4BS61RzzkQSLds0v0dYKMlpxkIHCs7NjE0O77M+GrKY2jXe8dmCfEveGPjJlrCYsoZBL5qDIx0FMAKEfwth5pYdrD6vM3v9JjoX6GncbCebz2VNEc39ILXfQD0cc0DxRD3Bzw02tpkNTlY6plZk+qsikVgWe9tkQPPBlef3Vxpx9/sz2vcsU4jINTVpkCYO/RCz6KO2zDLKASJollUSlQg+97RdhHZ+ZhCgW7O8Exdm7hGU2J5Ufi5M55lqa2FTFwWu+qbwdZr8jgBhPE/0LEWFCscRnJfWofII2Rrzo1RCxLky56yo4duuAMeHhtbNk/mbGYkGwO/t4iq5VaJf5NdBW5hq53g77T7ZUC6gdxRMMv63T/3+wGtGWK47tkCx5QQPstj0te5wRUvdU9u3RiTL9yV2pTjv8DPG7EEmhU/oP5dQh050uER9EH6kkCWt1SAxO0qlyhFNv7jtvrJtHbaEYVft6+0K39xKKTo5T3RPBefzI+JB48R7vYCdWiF3mEgNhPPv6b7/WWZpMYVBe0LdWd5oxjoyFOlGp2Qv7/0UJtG/BS/adcRvvL225x1tbzyxmLafJxK0xNOFmFSQbWP1tmor2iOD5oIU3SWTex9+Q1+m43vuvvXxeLM/zur6uOYXBVjPIZ/g3bkv6a7w2EorCtKUIjO0dzDKU3fRYZevdmZKQ9pfKWkAc883Ze6B5oQT9tvWeuENWOp+p06q2sPOuYCtkk1fP+CxoBc1qX/8i/IdMmTRMk+LSo+cTaROinjWqGS3fOta9jrhMo/8eMroCy2BwJNWtwOFx2gXzb7RamMaKk31cY7yP6FfDOFMm5frlgiljJx2IDPvrJ2RwSheNOQgsyW+0DeOv/5lPZZSvXmM1qFANFwZs+ZchLB0HAfyOYn75/CdK3DiqDBDT37qjmACBPIwdE/WKqW/SwXXfjx2+bTCsuTVJggWmyU7rZbR1Z8XvbV8ypPbLVxVN3atWynK8YaJWgU6PUYRUMgca9/a0GCHShHEEJCFaCtrc4ayhS34w8wLxyRn4VS9zLWc1U3rYPo8Kcn8qOUK8plhIeLMIrJsSN6J7ClUJR4pzqlR35p/88kIIq4DbC/O9WT2JsjUyIQuwMKc3pq2JGJaVXdD1ti0vr27d/6fj9aJfIdrgZ1QBXn3oh8ZQFZwR5rklnmjdpJ0VRDbGcLfGfQ2OG9NVnqRrQFlnNlI/Q8tRF1q0M37TIKVimo8xMj9xFwY0YKN1ul5hMgLr8n+ymCYnmZO0e/x5OOuhrprj4J1HC4qIFWLhK4UYgO/HJvLkpcDBDCkh+nhNgyvmXJKPCsmfn7Nk/20TG+6v36GapFGa9LCDqMcIfGlYOylZTVBId9gUbo8b9pGLyCUQp7SLmULeILsBY+tbfoiP5EvYO1VHr9KuNorBG8Kh2mz044JGljOXSC82R4u2ngJIOEoUyg+PVGcvbfbgg45xG5W4hAh33rhJ6tSZuyDB22LFEVdGssdv97CRPqjYU6AbfR7dE6xsE0msRxAYMMHvZJ5Df6OJfTKuXNyqdpMZMqTjyViIZYbBrRzFnPexpKjomwWWUwX5QFEcMSLuhn1cD+TU4Kew8ggcpEGjnKqXle+41pd6QJkH9du07JDX0qXiRmJHaRDay/Rss9aDfzpMZrVmRc+qYwjEiYJF83/RqOK6SD0E/PRYT+HCGzirGWf0KYbzfest7L/8TgFHtOvSrX8ThsqaLVQdOamJgJDhr6OlA4jh9LncqttWVMyo2vOpKVq3RvRsXll0UqscYIPuNx31bz00R004dfoJm34EoLiH9BQr95Eze7hSX/RXNYVKfy0iJkWLrU5mpzSFmsjraMl2dUOF34DzfWSBdRlC3St3Eex6v0Nqj90Rli0G2vDW4Lv602cgCvP9XsOqZOkAQxOY0NkX4PrPdlh/HBC+g1QM1e6NUbCF+D9oqZCpZyMnlyXkrGsj3+vuc74QOpIuj2AQQHG4zolNaSEA2s8DbCt9RFCZbRX+Y5vf7sdniivJ7LyLIDyLz3rOQ4TY1W39GeIwkzdIH5kQv5OfNAEyVTHfQ0kX16fDqOUCmMZFLiVCCoFClbegL8DiIKsUXnyO5sYtDAUXjOzEStXu1i2NjMPg438mF6Ma0rtHcqxe0XaqvaXJYgKFt/Al/26oiYFRkjnkArZhZl7+o47W3CVbQxTbPZKlaTPZ0DZRxOpFcSGa/deHbm2gRhZk9N0gosi12yNrxMiIK+OsWv442icP4cHioZSTrxPETbQJbr7rEwpeY+wrJXdT0bgr/53YQplPgWqizPGsoSagF/X4vr7Tjxv8IoETs3i4fy8FKY8KQdqNC3DSjlIRdTaZV2fRyBSquviolBdHMqT3j6dPxEb3CknGgtELjQdYl5KI+hVEpyUZiJSZNa7O4aa/nHDKrpR9onVRgg3a7SKMw4LVMaQ0vCrE60ODkwMqhWtbkylggbgTEukNRzQnRBhonvAG4zEFNGK5mnUK9gRde4IaeK6bDMDXCnx/ZoWIjK5Qq8KtIizB5sMQeRCMCF29aVm8cO2MZ9N4UCn1aMDmB0ybnx1f7WVOAv56AC2MOTq6zcMNxF8L0RnQidmbdDEDoOtsef/QgHCz2QEcNXhwqThl0HL1YnyPreg1cGuo+Im026FRLX6uvvPsmUcHVYzfHWoCTpjmekUf3AeQpnXgJ0MAs2RPytzm0z5KkpFQr69fEA/i+SWl6MAg6NImXrhRm9guaxTVW+6zt9fRk+eFB5Gz3UBxyNiOZJhndEBDv0TYojkd+28nEbWDRAatL0MbTu9bFDSYuBB3Xi31IVTP38KpNOQ5wt19gF0kvlh28lNKZHCvcR5Oe0jjZ71SrIeVjIdRIRGMGP3wVs0LabC80AcQ+Ol454VsV61mt0+5zelVsgM6V34gSZhNqcaF4jJRO3rUGcRFsEVNiCufvrvuVJ5iE7CSt7EtNi7cVUI/HTev+1sSLSsJMQjisrrmw+wI3RtGJvSAyPwJtshql4rVGhI7bFBFgMwIULqCTNA2OO3wY2DgRoeNDwLPY4FmHtCr9SZx+wzpYZcDx6IhZJvbGto22mPFEItJEXC6/IaI6HSi+9uhcEsEmg7l0c4YDQ9REbnGGV64rymjsGosK+viyIN431EOL7JkZLgvKlRSZ2jxe7Bv8rbsd4cy+lYRHCU2JSJA4zwlGz/NQVoCQVmsq01YQ6WKA90zKq7BdTSEK11/wVk7rEvE5fmEGjGBbaoWB0jJWzT2bghpHYQtpFor6+2lv/9S1U/rXbvGxzZhQ89H3zK0iVXuFG9Rxg+6aEjH8/hqcWpgjGrFJpiV4flUQk3Ha5xF/NGMfRSObMCL9a62S6E/gNY/Nqwlfw0fzo3qLK8c//Nf3NVD467TAuf4R6KAZOAqaw7JviAClF1mOKJeO468FEbYHvIpGv1U74Rk8wptnq5SltrGWTlyfFLIae+tKvedjMANYUsfOXRVmUh2RWh+7/VA4bG9mGTpNIWw1/eMY5+Qb4Q5iWZjMZIvPt1SXHnRocsoFxpp0ZpNIjkz72O0l29pTy67WR367d4h9xZONDlrFVurWaO0YFr9+zCxwpNcREkTJp6vflL0TkAoY4v9FrB4xM2qykUZ3YDAnZjaiEv0GFST68Me3dsM73zMmaigTsqRT3/xQcGPlbTk61W1WSHrIP1o6OJBQKnB7OyagKcQHF5toWjSRXN78firu16+0vzDaRdNtHYkSfhAVNK1stfUf0X9HMb5C4OKkd+ImRSihwUtC1RM//qKgaC+WQepEgKg3f/Y2VR6b2dy/eLCyzOyikFEraS/XEannNEOk3QTFvTruwc+5zZB80Sid0rjZCsWQuwf3NqVXRqGM2L0XG6yycwcgyzOk0ix8WlH3JnE/tLv4jqajQA/9Zt8Xewz3tjS6R5LjPsvQ5NwefN7b0krw76Dzd1Up1K78DAPq7kfkY67zEMosalW0S0XhYfvNWkwpGt1X+3CUJubfD+R5aRBi47DapUpQ7uK9UgPhGIFc5Yauo9GP+E+QtwzvMzD0GCxChnK3EUlRkAJJTTPHScVwfpuiksylGldFfudYK0y2KG0ABCziC05kJpfl/6EsMMHjxufSn/p7QDsR9/dqOLnD7aBroGfxXZ4suYkMWVJZkPJ2IxlH6BtMehruQq7zXvsn5nIZM1Q48bbNMxWXpqy3x4G1/5zlzKcmUcyupkmsX3dqSopm2E5Fto82JUghRqVuNI+FIkJ5lCWnmzWL7gAXJtr5mbfBIrDa6HAo+G25b1yf0Thq7MomFGaiDsEukVM6OLOJbw1rLWpy68/uF4mea/AQ9LpiAp1q4AmGOs99I8SCo06dtHVdvnbJxp2wwubsvP+OrjI1FzmQx1TFCZcmgfkdr8PzjH4cW16OMn3mYkxd3NNg2FMX4SLNZ/LBtlvZ9mUvAfUd1IOBtF7d0FjeIsfz/AUKAnLSnV/YGQ79AbeqAQVxo3/oOyQ+YPUzEHxwow8YSN70ZUJi5Gh1whS799QXRoKZJGJ6ZK1xEsWIE6PsHQ2dbIec6Z3Z0ZgDC5d6ZPOncyYGX5H0B8zo5BFACajeLsX2F4VLAY3eDUnt7b9W9QGcPzhR7PDOTSgRQk8rQuGJUpkGPSj8tZ9eYrxzxvM/wzzHSOXQEqNeKf4ZkXjnIblGGDA5Mk5uwNW5a6nnLwq3lxBNpS+yERGBOuxz8mH7OFXDs7GvWLp0Cz1s29O6WPCU32/fak/GQvyp8MLYa9v/C8bqiJq/E9jcSvVuVCoymGEdTdtEgc1UeVL1DXWQoP0pyn1Q448cKLztL5Ok1RUtUat/qGYEEfE4DtHL7XhH2M9ZCeIkreciqjTi3ivHg25pa1TAa0aTnUNT1siOExwQxaEo+7rlW2Ei3cwKvlUM+ukNT2B9lWXvVxmWnl2qZCPCAZerWxeBcH1/dPwcZ4wFuPYBLuIaW194kmH/XpJrxgc05P40GXUM4YjBjLYTOm8hiMDOV97/90cinAmT1VX7GiUOodYhqpE1I9S3+SLDFSLVeDBVfYRKeNQJwRIfLEdZ5Tx/qwyoBr+vKAAdDcFYNmCJ2fpuy2/dSZQ6eqKfmID94/Sb5ZE2dw0ixYFyJXh3kCBb9/5q5KAq9tAnZkfTbdMUMWgHjuIB2Dq2TctgeXgHR9h40o7Xn1OSE3X+RCSto0NsTu+KsZEyHSjlj6DhMsBa8JUpKEZb8T55AbudPCuDT5xRXIXmE9vhtlsboXVWUzMUNI+dv0MrBPopfJtNA/CJXa+AxXsWQXceGXvAcjuvcAk4C+R0rOAfHiTijcv7rd+IsfoRZyhuOQy4RATkTzOP5RR3qSgVF51r2alKF3a3psqIReg7bOjiJoNYWj3XE4CfxHzbJzwuMJTH5LqVEIPGu6y4sFULQM8JvJ90/lmXqka/y3mGSc6wICd7KSnXLsFMqpniQYyaM5cfpOicdbojFhYGIIpZogX9qj9IBDjxKSzX0xbGPLvCRmExfT2P41qbJcAZL18Bvy7kbrWbx7oZuRgG2Xu+DX1BZBIYlGZ5nGTA2G9dIC27OhSB4jmfHQWCpxELEvnEpaGmKb/AFezXzdffDqiMQRw36VDhw8LAygeuYnLSKP1wPLD7f/KvvJ3L1pkEbNZNfo234xeD7xI3Ck5E5nHxGfU+uTDIpmMfsgylwkBWBjDfJCf7Z/KQ028SCGnCTUQYqLCutY39TzLKpgA5H8C8gQrjG73kj8mL58yOERbtCyVTfWovr1mDaxxqLF2hOjIVUX9ngLnp5a2WENLvr6ta7Q9XPRUHM5sqxk9MXoAFFtnpOxd1xHGhmLm/XNITtinDZbuQcpcR7Cl6ZB2CoYyDZt/ncVlqCFekfc7c1AAqe6sx9EQjeN+z5ryxO6lJ6nprhyFKn5uUyLxBLrdCCWX3TaH9TbTrFgff5s/oM61uh0nqPiq8sPq9muwMDVVqtSa6qIKoNuO9hXUbXGiPWJmXsYoc5g8y5zzP0o5DtfXLWO1/U6tadQhxLZ403N8UR54J4xjuFeZhUD/yxtXL2iUJ58Dyo+M3lhVihgenk+LJ2Dco74b+0Y5IOvShoVbCn3lbwcspWftF0/U5vP6T9KeDkPMLalCzWpxw3yPtNdwlQV+j/B9+fGzWZqRFT3eux/j9aKzfDVjnmCWCJ9YPVk0joDu4Mp011uyKwkTzbOpn7JGyErhLtbimcbKje/1p4e1xv33MrJbr706GmHzHIMFwZq2Rzf/F4Wvo7FYn8ZfUTu7Slvpvxunp5LKnH6aBbDBIEbzem/V8DXSvbLv49P+t3VFot2HLw2/h/QgrqD9gYdW6rjplOZFo0bJlTE9Eg3IgqukCQNGdo/hUMo0lPFdF/VqFo1OIzQ63h4N14jLtdSNSIIK8Eykzminp01acnmOGTYkZjbYaYKP/0ssvKah78bGs31Yr+jq0a4/n67hmiJZFFgjd8KdPqF+7AELvSQTrsGHiLHTH4YGpKmm0QRUt296otw4JCv5NQfe4crE1lyUfDUKlioj0rBL5OTsfXIPbp7V3Zw8Ps90+wCV3gKKPCDPOp2l3XzbtvclfBcphVmWV+A5btVIORBoSU8UnMvuplarBSR3XzSgoNkybM74vbndcSzX74bZgMQ1MpYf1wla+WhgJ5tSlpEi/iO7f3qDw/6KaFBRnCkKN3Xwsfipx0JkUFmomRKXHosv/p5Tn/yvtNKSE8qT+0ZArIdk1cefddXTOyk4nUV4I/ggxtn/CEMY2iqdrxeEEBaOAlPwz10GA8RhQ37VPWA8KW71cS8WLAFwN310fqgZJEra7DIbP9+Jy91JdlhVMkkA2glOB6H0sZ9VT1uzh3I1pcDTAqj2THblEV+OWLU2QLqMRf1hxZahGwKqAsI7v62F218WXrbWdGsGqK4cf3Hpxh4iqC8w7E64aXGSfCGYPz+DjPXQZcUBJ200jQuG8yND6IcemTuEEaOqShMbxfdx/rmvbL4qKRGbYs2q/ocmKLyV6vjBI423bEINWefp8N63u6DsFuQ6//+3ywdEBwW0XEwUx7h6hXmtdVRmRpF1gbB0yizF10kJ9AC906CB9yQyWt0yzksSRNRvn6DhEBVHwZckEmpqDomCEZL8BLxlIuCMF5wKsJoeG0MhTTiAITcR2pH5Hb9XojX/1sZwYIFMoBW8LyVNsMrRHcyq2qAGMFFwdwqri4dI4OrRmSWGBxyPoNWjtT32WvokR1NWXxmI2LvNQi8gRZg/dM9fBREkFHLWsD7D3NYxBhN3irWWNCAwHjyCvZbfWKZWMNvCNmUtKijATiAsQLFT4ns7thSV+khZi+gby9Y2oKgxjpW49FaFjZ+3qeR+3vdAFpxl7UpMd9DVS2vXkfttE3TE1XbGip8vr8hg6vCiEVIYq1T1OEKh5thoSPE+p5w4aG8OA2ASP5UY3nHJCQiuiFtZ2CYOhx3UcD4wquzOlhAobah5gZEYBtZnH9i53SdkKtcl8OynVNJtbjMiZ/UHKddAozhH76SzB0Eyc51AQPrRq4FZVzrmzhxKw6a3MoOXgPa3JOqJWGTdmoIdNkd2DbxV7Me4xzrhcInnobZPrcdnr8a/r3r2O7U9C2CZsy2Jjegc1N3LE03wKtgQTv0oCZ7aBVEzvKdOyrFLitEFivNuEcEEpgUZF1ZiuBq3Hg48TWInnwvEbHbLMPf0R06xJvUlXHxvV2AcbFQ/Ssl+YOuNvgfIe+nqJbyewSe3oalv0Q8oossFwp8F94Or0LCyhP5LdyReCqXI2/JyFXwEAR9TErNvU1sRv6LB2lNIKKS1OSMwhcw6jAomJFa+f+Sp17YkPrSceebPm9TfWnjcB1OMlIjy/QpeJdVoLu0DDTEgipRxTuDP4Ws+A/U9UnTO/HIJPJ7E3DQz/Ss7h7w0q8qZtkcid3dHVriX2lcBaAXVT/6tV7wTdBBx27QD636qkagif/I4hsk6ObmZ9zdJdEHSSk0A2EfrdJJRyjCOCDbSzMnKmKNJyitjWK9ElL/Iwdb1NmMrSw2tbmbNnIo2qdOM/ba7yFBN+5YOHvIBRgjzMNCApx0jj7b1m9QmC7dlRTeU5tE0QUm+Vxhi++RwgSVcl68py+UwSekut7rBhDsRzGHNWF6zA9mmLpJQNdesG6NuJaU3SL8OfH49DxV8dJPp0RZ03x0pAtL16cI8Cgh3Eiw470guja82TD4ANZ560WoDSM4Aloav0I9J5Orp5q8DmPHCkyMocjC64sQ3XuSZqo2tXkZCwBgIM98fEa/ElKR9vuanGCtvjhpYnp9Z60WWZw8ArH/d4EwsGBga/X3kKo2Txbve9jzHnPU5FYT7ChbE7wuIhgzBb3762SSrzZEuKNXDHXNA5JeFngDpGJxSntHvs//5Jwfjx+IwIuIK/wZQZJaGcQx5tQrTnl+L/46kDY0AuToTeXQW5X7hBPC2PZASf8ZGckiGDMulnQfyzlmOdi7cDBV9KdhG/yw6Rkr4vc+d+3EIeMJSErhh33AocfltXH2NgEK1K5EZ1XcU/SbAO3TkQ8Ef4FNv1ncfBHB/q2rElUk8LFVBm1x3CNbUQpwpJVuDf78slf8xJi5v9kBoAn8xbosyZxuRO5UcDmpOoRLnGg0i8Q82Wi2bvraY+o6JoA9KZVQebsRpavt4IBxkqYRqDt2Orz/9T1hosJExkmpkId7tiux70yhYG2aaFjycf6GyuVif71QrZLVUyUqPH1k/8AnHo30IHfN+UCrWMmKYKR2mm6TQWBlTIeiam7MdNQNm7UBRZaNGoGxregtjqQS+OAroFWJqBdyww0kX34oQ191DSXyV3Sa/XM9yd6XXTDqdWJfkz/HGpFjnMay5kpJWQpBIayoKWn6nMW1uYGxdcle2yrpq7l7TyJxWbyF051XtLXPs8GIpQr/uMN4+rm/jmX/scDyNx+i+ca9XRBCBtnXSlXNnBcsIIovQudwunyIOrSfinMVKtG1TEhq3YSCmAkAF0quzCP1DNo8VI30wPxJnjdJskAyW+pWhMAnVjAaUVMn37wXNDWGPbOMYqepq6YEqRgxV9qPCUjmxLiW4v3vERHH3hrFWlf2NYGKjygoVW/mzcxylW66QnysLzBc7ns5jQweaIfBnXqTOtEWsRu0ZCJYvDIrIsHMegSuUdZ8j3MYLdV4L95OoXNoxWX5A1NK7gKPSg+9xlm5Pb697bVjubd+TduZ2cVFqDNq19gA/jOmnTCZgTvYdj00IPBgoMcVCOEwjs/K3BhotsJI2bPjxjN00EY/mojzbI45wkIPvFGifDnwE/gq7N92lS8ekgdIZ44hxAUIs/QDZcUF40sfc3xy8UUcMkt7kAXUi8uqmy34dwPCoTF3ZkAPu8KyrzqKG99091YeQ0JmNloHKd1cG3g9n9qKCIIHIdomJi1SgeT2TzxSLmtwYMp7gurJoNclQbqL++8vlAVWebzUdYcrS9kBqnk0kIAtCAGPGoo9wzuSe5WU8tG75f+JnHa0aFiVi4k3nw3uXXVmDcgghL3kngntsEHr55Wy87/XmFoWyzfB8unFRoliHqyZWm1ytrW2R+XddZ8Fbkc7pF4zQ2W0/rDITiGPgRLXQc10vVQxfa/qn7AFQpCGys5/BG4loj2tHhcXTRbNtn9f1ZBDSpTiTP1WUoSCtAtXpOZvyR4VQxyIRq3v+vpyBpQR7/jLvqraDuowksiTh2Cul8og3/BQI8zDoH56/PFHCyqnlsHqENXdYbn8wBoHssUEEX78xDOep11PJpAIHFyyBpKFZz12bEgdIfWaPGhv4m3ZFMAMdX4El8RMwIHvTWrHBkK8lWFDhOSnR77KL18vZ/ZmVvJJBz31NT1V5VSyZmp/qbNw7Nv3ewPCRjpwMUN872Se4GusdHGKjgYPQFSE4Ewf2b5L4ANPL/sEWEoYY4Ic7w7L3kIuwo9W2+jQwy6nIIV06VRbQSM7pPFuiNdc4/TLEa8YiGi0G2aqzr7T19JKiJSMd1CwK03gZ/M9vCoPn+9tjvsPb87Ha90rR+sHmPznQWJeossR9vPohYKNUSuqEdsPtb42VlZlXYqQlNv6T2KRW3R8IExam42YWDCC9RSC+bI/rATL865awIsdWS74ndJHzLZllg2+lfy/Kx0u/ezmQanS16Qc17V13fMMzE6E9wNLG/ACCAZscsX2Q9OlxZwY4Xq0IYX7NpoCvjRxLzh9ex4c44FF4td2yjsCdBfmyHhf7bbgXVPBrpbWuT/L2xD3TQi8GQ80u1xlhc7Om1/yyFENrdxL6HzNg1PZuFpDkrCfOGHryIrHpD3Z79SBHKESkkAIr2FfmAQQVAW4xFIq0OTCqhlDcuVf8jKZFqADcg+8BfcOeVx5ujHMSUwu5i5CmSTRm+uVP3pWJSlnXrcF8E7ocXRHJhSDxFJwxMU4upLh/LrbOmaR7JnwZGDt0vZBfGDj2Bk6koIBLo6+FjNAvYAR1OdsQOaHubGO0pKpOuBc/HzNrdVE5FKaRecYsYi5pXLCfLeVemYTpNGwKzwd5jc99+FDVfVgdBKPNuPrXjuo8s/v68HM3IAWoBOFkocSYV9KyKRyE9EUHHBFj3v6ygGACaV7LU4Ia1oVbrKkSh7bB46KTLrP0uJc9N5Rm1LhYO4HynVJoojywHErh1GK5MPcdk6uZlvKyf1MasGXD1qzTMJYdIRHzYbqEdFehh85jYFmlbGsM2XWntMpC8NpPYGhIgW8X5hoWuqkEjXoq/g4l0AX0BnX+1ckc6nnvkJfVCeUOLA3DYQPBs3Z3KHQ4jyBUmyOeUZNOYZM8RTauXfdbXnaO9yY32r9otLK9M0i7+BzeeRXwxXuTko/XLicLKo0qBniwnV4CdyH/VZuG+Hq5/REEBlngfvt6W6gQlrPdLeNXbtSyC2l25ohUvng6Zhg7wtLVAzjUyyHbycBHWhxQ0MAW5FzqsFC7JvQIQz4+HEYg0QE7bzyaP6EB+y+bw8EjsieA2vBdG1i8ghgIPoFj6RHkfMsIBBYhKfurEI2nAdNJPRpEo7rdzFkGCBoW7BTUaRqQ0YmG70/KSZQxY+Rsl8IsiwF9BPMr4P3s5O5RtuZUCmY6I/UpXv8JsLdxBOyu63okX8eCnXo0RpaeHcxbcpwVU4k/16TmviQcX8p9TDAYq76ip8UFsaCPpooPZGp1eFAUSILgQ9+2x73DVNlEKgS+BfHXUVyCiSpIof33GGmsLJd1EI7PsKcRaEgR1XlU1m/RPvKoshVubq/uDejM5jDAGbOraVT4VQB2kjawK3NUMalZdv5irpyASlMawPyo3RhzcupD8B1KtLfpRzYCYpuhdZgYTcjyyw2PmeqTve32mJ6C/ITRkVuUwHU3PE0Tqtq1VdP96ADnslvd1uCUwkVR7MJm4cj8MR0I+2JayY8/Ab+kev/QffT7xQiIab4HvAvVv11H+TCF31WaQ32o2/ZNovPDJFQMZrYZA+guS5dR9kFfWEeCpQd9fD+/7Vte/jBF0aruVM0DUXL/sfC5abqiaF3maE9bJLdl3KN7r1zvXcppFRDVZs+tJowuIT/I4SzRc8qGQAkWWfsd5V67D0iDg5+1Q9jOhO7Sx7DwOOMRqQglwsWH8ebri56omE2NYAWF+4Xh44rSVs37vjV3cggqkoUm2NkgsEokpy9yUkb950EbrP7s8gbnCsRJccludnWbpqhvnqnoehRCg98C9ueYRKA", ...)
]];

		commEvent:Connect(function(updateType, t)
			----SX_VM_CNONE();
			if (updateType == 1) then
				local newT = {};

				for username, data in next, t do
					local player = Players:FindFirstChild(username);
					if (not player) then continue end;

					newT[player] = data;
				end;

				t = newT;

				playerEntries = t;
			elseif (updateType == 'ready') then
				actorLoaded = true;
			elseif (updateType == 5) then
				currentGun = t;
			elseif (updateType == 8) then
				menuScreenGuiIsEnabled = t;
			end;
		end);

		run_on_actor(actor, code, commId);

		print('Waiting for actor to load');
		--repeat task.wait(); until actorLoaded;

		function Utility:getCharacter(player)
			----SX_VM_CNONE();

			if(player == LocalPlayer) then
				local playerHumanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
				if(not playerHumanoid) then return end;

				return LocalPlayer.Character, playerHumanoid.Health, playerHumanoid.MaxHealth;
			end;

			local playerCharacter = playerEntries[player];
			if(not playerCharacter or not playerCharacter.isAlive) then return end;
			local currentHealth, maxHealth = playerCharacter.currentHealth, playerCharacter.maxHealth;

			playerCharacter = playerCharacter.head;
			return playerCharacter.Parent, maxHealth, (currentHealth / maxHealth ) * 100, currentHealth;
		end;

		function Utility:getRootPart(player)
			----SX_VM_CNONE();

			if(player == LocalPlayer) then
				local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
				if(not rootPart) then return end;

				return rootPart;
			end;

			local playerCharacter = playerEntries[player]
			if(not playerCharacter or not playerCharacter.isAlive) then return end;

			return playerCharacter.torso;
		end;

		local function getAimPart()
			----SX_VM_CNONE();
			local Enabled = library.flags.silentAim and library.flags.silentAimHitChance >= math.random(1, 100)
			if (not Enabled) then return false end;

			local closestPlayer = Utility:getClosestCharacter();
			if (not closestPlayer) then return false end;

			local playerCharacter = playerEntries[closestPlayer.Player];
			if (not playerCharacter) then return false end;

			local body = playerCharacter[library.flags.silentAimHitPart];
			if (not body) then return false end;

			if (currentGun.weaponType == 'Melee') then return end;
			return body;
		end;

		task.spawn(function()
			while task.wait() do
				debug.profilebegin('update all entries 2');
				commEvent:Fire(4, getAimPart());
				debug.profileend();
			end;
		end);

		local camera = workspace.CurrentCamera;

		local materials = {};

		for _, v in next, Enum.Material:GetEnumItems() do
			table.insert(materials, v.Name);
		end;

		local killSayMessages = {
			'You just got destroyed by Aztup Hub',
			'Gonna cry?',
			'It\'s not hacks, just my insane gaming chair',
			'Take the L',
			'aztupscripts.xyz',
			'Git gud',
			'Ur bad',
			'Literal trash'
		};

		local killFeedContainer = LocalPlayer.PlayerGui.HudScreenGui.Main.DisplayKillfeed.Container;

		killFeedContainer.ChildAdded:Connect(function(child)
			if (not library.flags.killSay) then return end;
			task.wait();

			if child.TextKillfeed.ContentText:match('(.-)%s') == LocalPlayer.Name then
				local victim = child.TextKillfeed.ContentText:match('.-%s+.-%s+(.+)');

				if victim ~= LocalPlayer.Name then
					commEvent:Fire(6, 'chatted',  killSayMessages[math.random(1, #killSayMessages)] .. ' ' .. victim);
				end;
			end;
		end);

		local activeControls = {W = false, S = false, A = false, D = false, moving = false}

		RunService.RenderStepped:connect(function(step)
			local weaponColor, weaponMaterial = library.flags.weaponColor, library.flags.weaponMaterial;
			local weaponColorValue, weaponMaterialValue = library.flags.weaponColorValue, library.flags.weaponMaterialValue;

			if (weaponColor or weaponMaterial) and camera:FindFirstChild('Main') then
				for _, v in next, camera.Main:GetChildren() do
					if (weaponColor) then v.Color = weaponColorValue; end;
					if (weaponMaterial) then v.Material = weaponMaterialValue; end;

					if (v:IsA('PartOperation') and weaponColorValue) then
						v.UsePartColor = true;
					end;
				end;
			end;

			if library.flags.fly and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Humanoid') and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
				LocalPlayer.Character.Humanoid.PlatformStand = true
				LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 2, 0)
				local pos = LocalPlayer.Character.HumanoidRootPart.Position
				local CameraCF = camera.CFrame
				local hrp = LocalPlayer.Character.HumanoidRootPart
				hrp.CFrame = CFrame.new(pos) * CFrame.Angles(CameraCF:ToEulerAnglesXYZ())
				if activeControls.moving then
					local ToMove
					local look, right = CameraCF.lookVector * 50, CameraCF.rightVector * 50
					if activeControls.W then
						ToMove = look
						if activeControls.A then
							ToMove = ToMove - right
						elseif activeControls.D then
							ToMove = ToMove + right
						end
					elseif activeControls.S then
						ToMove = -look
						if activeControls.A then
							ToMove = ToMove - right
						elseif activeControls.D then
							ToMove = ToMove + right
						end
					elseif activeControls.A then
						ToMove = -right
					elseif activeControls.D then
						ToMove = right
					end
					LocalPlayer.Character:TranslateBy(ToMove * step)
				end
			end
			if library.flags.knifeAura then
				local cloestCharacter = Utility:getClosestCharacter()
				if (not cloestCharacter) then return end;
				if cloestCharacter then
					local aimPart = getAimPart()
					if aimPart then
						commEvent:Fire(6, 'knifehit', cloestCharacter, tick(), aimPart)
					end
				end
			end
		end)

		UserInputService.InputBegan:Connect(function(input)
			local key = input.KeyCode.Name;

			if activeControls[key] ~= nil then
				activeControls[key] = true;
				activeControls.moving = true;
			end;
		end);

		UserInputService.InputEnded:connect(function(input)
			local key = input.KeyCode.Name;

			if activeControls[key] ~= nil then
				activeControls[key] = false;
			end;

			if activeControls.W or activeControls.A or activeControls.S or activeControls.D then
				activeControls.moving = true;
			else
				activeControls.moving = false;
			end;
		end)

		local function autoDeploy(state)
			if (not state) then
				maid.autoDeploy = nil;
				return;
			end;

			maid.autoDeploy = task.spawn(function()
				while task.wait(0.1) do
					if (menuScreenGuiIsEnabled) then
						print('Attempting to spawn Player...');
						commEvent:Fire(6, 'spawn');
					end;
				end;
			end);
		end;

		library.OnLoad:Connect(function()
			commEvent:Fire(2, library.flags);

			library.OnFlagChanged:Connect(function()
				commEvent:Fire(2, library.flags);
			end);
		end);

		local function applyGunModifications(...)
			return commEvent:Fire(3, ...);
		end;

		_G.event = commEvent;
		-- GUI
		do
			gunModsSection:AddToggle({
				text = 'No Recoil',
				callback = function(value)
					applyGunModifications('NoRecoil', value)
				end
			})

			gunModsSection:AddToggle({
				text = 'No Flash',
				callback = function(value)
					applyGunModifications('NoFlash', value)
				end
			})

			gunModsSection:AddToggle({
				text = 'No Spread',
				callback = function(value)
					applyGunModifications('NoSpread', value)
				end
			})

			gunModsSection:AddToggle({
				text = 'No Sway',
				callback = function(value)
					applyGunModifications('NoSway', value)
				end
			})

			gunModsSection:AddToggle({
				text = 'Full Auto',
				callback = function(value)
					applyGunModifications('FullAuto', value)
				end
			})

			gunModsSection:AddToggle({
				text = 'Instant Reload',
				callback = function(value)
					applyGunModifications('InstantReload', value)
				end
			})

			gunModsSection:AddToggle({
				text = 'Instant Equip',
				callback = function(value)
					applyGunModifications('InstantEquip', value)
				end
			})

			gunModsSection:AddToggle({
				text = 'Weapon Color',
			}):AddColor({
				flag = 'Weapon Color Value',
			})

			gunModsSection:AddToggle({
				text = 'Weapon Material',
			}):AddList({
				values = materials,
				flag = 'Weapon Material Value'
			})

			gunModsSection:AddToggle({
				text = 'Bullet Tracers'
			}):AddColor({
				flag = 'Bullet Tracers Color'
			})

			gunModsSection:AddList({
				text = 'Bullet Tracers Material',
				values = materials,
			})

			gunModsSection:AddSlider({
				text = 'Bullet Tracers Lifetime',
				textpos = 2,
				value = 2,
				min = 1,
				max = 10
			})

			gunModsSection:AddSlider({
				text = 'Bullet Tracers Alpha',
				textpos = 2,
				value = 6,
				min = 1,
				max = 10
			})

			silentAimSection:AddToggle({
				text = 'Silent Aim'
			})

			silentAimSection:AddSlider({
				text = 'Hit Chance',
				flag = 'Silent Aim Hit Chance',
				value = 100,
				min = 0,
				max = 100
			})

			silentAimSection:AddList({
				text = 'Hit Part',
				flag = 'Silent Aim Hit Part',
				values = {'torso', 'head'}
			})

			silentAimSection:AddToggle({
				text = 'Knife Aura'
			})

			silentAimSection:AddToggle({
				text = 'Frag Teleport'
			})

			localSection:AddToggle({text = 'Walkspeed', callback = function(t)
				commEvent:Fire(7, t and library.flags.walkspeedValue or 16, t and library.flags.walkspeedValue or 16)
			end}):AddSlider({
				flag = 'Walkspeed Value',
				value = 16,
				min = 0,
				max = 100,
				callback = function(value)
					if(not library.flags.walkspeed) then return commEvent:Fire(7, 16) end;
					commEvent:Fire(7, value);
				end
			})

			localSection:AddToggle({
				text = 'Fly',
			})

			localSection:AddToggle({
				text = 'No Fall Damage',
			})

			otherSection:AddToggle({
				text = 'Anti Aim'
			})

			otherSection:AddToggle({
				text = 'Auto Deploy',
				callback = autoDeploy
			})

			otherSection:AddToggle({
				text = 'Kill Say'
			})
		end;

	end)()
end

if (gameName == 'Bloxburg') then (function()

		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];
		local prettyPrint = sharedRequires['prettyPrint'];


		local column1, column2 = unpack(library.columns);

		local Players, ReplicatedStorage, HttpService, PathfindingService, RunService, TweenService = Services:Get(
			'Players',
			'ReplicatedStorage',
			'HttpService',
			'PathfindingService',
			'RunService',
			'TweenService'
		);

		local LocalPlayer = Players.LocalPlayer;
		local Heartbeat = RunService.Heartbeat;

		do -- // Functions
			local framework = require(ReplicatedStorage:WaitForChild('Framework'));
			framework = getupvalue(framework, 4)

			local modules;
			local network;

			local jobManager;
			local guiHandler;

			repeat
				task.wait();

				modules = framework.Modules;
				if (not modules) then continue end;

				network = framework.net;
				if (not network) then continue end;

				jobManager = modules.JobHandler;
				if (not jobManager) then continue end;

				guiHandler = modules.GUIHandler;
				if (not guiHandler) then continue end;
			until modules and network and jobManager and guiHandler;

			local saveHouse;
			local loadHouse;

			if (not isfolder('Roniro Hub V3/Bloxburg Houses')) then
				makefolder('Roniro Hub V3/Bloxburg Houses');
			end;

			hookfunction(getfenv(network.FireServer).i, function()
				print('Ban attempt lel');
			end);

			-- if(not debugMode) then
			guiHandler:AlertBox(
				'If you encounter any bugs using the auto farm make sure you post them in the discord #bug-reports channel.In all case to not get banned make sure that you buy a car after you finished your shift and make sure that you dont farm overnight.\n\nWe are not responsible in any shape of form if you get banned!',
				'Warning',
				0.5
			);
			-- end;

			function saveHouse(player)
				local plot = workspace.Plots[string.format("Plot_%s", player.Name)];
				local ground = plot.Ground;

				local saveData = {};
				saveData.Walls = {};
				saveData.Paths = {};
				saveData.Floors = {};
				saveData.Roofs = {};
				saveData.Pools = {};
				saveData.Fences = {};
				saveData.Ground = {};
				saveData.Ground.Counters = {};
				saveData.Ground.Objects = {};
				saveData.Basements = {};

				local objects = {};
				local counters = {};

				local function getRotation(object)
					return tostring(plot.PrimaryPart.CFrame:ToObjectSpace(object));
					--local rot = -math.atan2(object.lookVector.z, object.lookVector.x) - math.pi * 0.5;

					--if(rot < 0) then
					--    rot = 2 * math.pi + rot;
					--end;

					-- return rot;
				end;

				local function getFloor(position)
					local currentFloor, currentFloorDistance = nil, math.huge;

					for i, v in next, plot.House.Floor:GetChildren() do
						if((v.Part.Position - position).Magnitude <= currentFloorDistance) then
							currentFloor = v;
							currentFloorDistance = (v.Part.Position - position).Magnitude;
						end;
					end;

					return currentFloor;
				end;

				local function getPolePosition(pole)
					pole = pole.Value;
					if(pole.Parent:IsA('BasePart')) then
						return pole.Parent.Position;
					else
						return pole.Parent.Value;
					end;

					return error('something went wrong!');
				end;

				for _, object in next, plot.House.Objects:GetChildren() do
					local floor = getFloor(object.Position) or plot;
		
					local objectData = {};
					objectData.Name = object.Name;
					objectData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(object);
					objectData.Rot = getRotation(object.CFrame);
					objectData.Position = tostring(ground.CFrame:PointToObjectSpace(object.Position));
		
					if(not objects[floor]) then
						objects[floor] = {};
					end;
		
					if(object:FindFirstChild('ItemHolder')) then
						for _, item in next, object.ItemHolder:GetChildren() do
							if(item:FindFirstChild('RailingSegment')) then
								if(not objectData.Fences) then
									objectData.Fences = {};
								end;
								local _, from = framework.Shared.FenceService:GetEdgePositions(item);
		
								local offSetFrom = ground.CFrame:PointToObjectSpace(from);
		
								local itemData = {};
								itemData.Name = item.Name;
								itemData.From = tostring(offSetFrom);
								itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item);
								itemData.Segment = item.RailingSegment.Value.Name;
		
								table.insert(objectData.Fences, itemData);
							else
								if(not objectData.Items) then
									objectData.Items = {};
								end;
		
								local itemData = {};
								itemData.Name = item.Name;
								itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item);
								itemData.Rot = getRotation(item.CFrame);
								itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position));
								table.insert(objectData.Items, itemData);
							end;
						end;
					end;
		
					table.insert(objects[floor], objectData);
				end;
		
				for _, counter in next, plot.House.Counters:GetChildren() do
					local floor = getFloor(counter.Position) or plot;
		
					local counterData = {};
					counterData.Name = counter.Name;
					counterData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(counter);
					counterData.Rot = getRotation(counter.CFrame);
					counterData.Position = tostring(ground.CFrame:PointToObjectSpace(counter.Position));
		
					if(not counters[floor]) then
						counters[floor] = {};
					end;
		
					if(counter:FindFirstChild('ItemHolder')) then
						for _, item in next, counter.ItemHolder:GetChildren() do
							if(not counterData.Items) then
								counterData.Items = {};
							end;
		
							local itemData = {};
							itemData.Name = item.Name;
							itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item);
							itemData.Rot = getRotation(item.CFrame);
							itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position));
							table.insert(counterData.Items, itemData);
						end;
					end;
		
					table.insert(counters[floor], counterData);
				end;
		
				for _, wall in next, plot.House.Walls:GetChildren() do
					if(wall.Name ~= 'Poles') then
						local offSetFrom, offSetTo = ground.CFrame:PointToObjectSpace(getPolePosition(wall.BPole)), ground.CFrame:PointToObjectSpace(getPolePosition(wall.FPole));
		
						local wallData = {};
						wallData.From = tostring(offSetFrom);
						wallData.To = tostring(offSetTo);
						wallData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(wall);
						wallData.Items = {};
		
						if(wall:FindFirstChild('ItemHolder')) then
							for _, item in next, wall.ItemHolder:GetChildren() do
								local itemData = {};
		
								itemData.Name = item.Name;
								itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position));
								itemData.Side = item:FindFirstChild("SideValue") and item.SideValue.Value == -1 or nil;
								itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item);
		
								local itemConfig = framework.Items:GetItem(item.Name);
								if(itemConfig.Type ~= 'Windows' and itemConfig.Type ~= 'Doors') then
									itemData.Rot = getRotation(item.CFrame);
								end;
		
		
								if(item:FindFirstChild('ItemHolder')) then
									itemData.Items = {};
									for _, item2 in next, item.ItemHolder:GetChildren() do
										local itemData2 = {};
		
										itemData2.Name = item2.Name;
										itemData2.Rot = getRotation(item2.CFrame);
										itemData2.Position = tostring(ground.CFrame:PointToObjectSpace(item2.Position));
										itemData2.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item2);
		
										table.insert(itemData.Items, itemData2);
									end;
								end;
		
								table.insert(wallData.Items, itemData);
							end;
						end;
		
						table.insert(saveData.Walls, wallData);
					end;
				end;
		
				for _, floor in next, plot.House.Floor:GetChildren() do
					local floorData = {};
					floorData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(floor);
					floorData.Points = {};
					floorData.Objects = objects[floor] or {};
					floorData.Counters = counters[floor] or {};
		
					for i, v in next, floor.PointData:GetChildren() do
						table.insert(floorData.Points, tostring(v.Value));
					end;
		
					table.insert(saveData.Floors, floorData);
				end;
		
				for _, roof in next, plot.House.Roof:GetChildren() do
					local roofData = {};
					roofData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(roof);
					roofData.Name = roof.Name;
					roofData.Points = {};
					roofData.Items = {};
		
					for i, v in next, roof.PointData:GetChildren() do
						table.insert(roofData.Points, tostring(v.Value));
					end;
		
					if(roof:FindFirstChild('ItemHolder')) then
						for _, item in next, roof.ItemHolder:GetChildren() do
							local itemData = {};
							itemData.Name = item.Name;
							itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position));
							itemData.Rot = getRotation(item.CFrame);
							itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item);
		
							table.insert(roofData.Items, itemData);
						end;
					end;
		
					table.insert(saveData.Roofs, roofData);
				end;
		
				for _, path in next, plot.House.Paths:GetChildren() do
					if(path.Name ~= 'Poles') then
						local offSetFrom, offSetTo = ground.CFrame:PointToObjectSpace(getPolePosition(path.BPole)), ground.CFrame:PointToObjectSpace(getPolePosition(path.FPole));
						local floorData = {};
		
						floorData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(path);
						floorData.From = tostring(offSetFrom);
						floorData.To = tostring(offSetTo);
		
						table.insert(saveData.Paths, floorData);
					end;
				end;
		
				for _, pool in next, plot.House.Pools:GetChildren() do
					local poolData = {};
					poolData.Position = tostring(ground.CFrame:ToObjectSpace(pool.HitBox.CFrame));
					poolData.Size = tostring(Vector2.new(pool.HitBox.Size.X, pool.HitBox.Size.Z));
					poolData.Type = pool.Name;
		
					table.insert(saveData.Pools, poolData);
				end;
		
				for _, basement in next, plot.House.Basements:GetChildren() do
					local basementData = {};
					basementData.Position = tostring(ground.CFrame:ToObjectSpace(basement.HitBox.CFrame));
					basementData.Size = tostring(Vector2.new(basement.HitBox.Size.X, basement.HitBox.Size.Z));
					basementData.Type = basement.Name;
		
					table.insert(saveData.Basements, basementData);
				end;
		
				for _, fence in next, plot.House.Fences:GetChildren() do
					if(fence.Name ~= 'Poles') then
						local to, from = framework.Shared.FenceService:GetEdgePositions(fence);
		
						local offSetTo, offSetFrom = ground.CFrame:PointToObjectSpace(to), ground.CFrame:PointToObjectSpace(from);
						local fenceData = {};
		
						fenceData.To = tostring(offSetTo);
						fenceData.From = tostring(offSetFrom);
						fenceData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(fence);
						fenceData.Name = fence.Name;
						fenceData.Items = {};
		
						if(fence:FindFirstChild('ItemHolder')) then
							for _, item in next, fence.ItemHolder:GetChildren() do
								local itemData = {};
								itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item);
								itemData.Name = item.Name;
								itemData.Rot = getRotation(item.CFrame);
								itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position));
		
								table.insert(fenceData.Items, itemData);
							end;
						end;
		
						table.insert(saveData.Fences, fenceData);
					end;
				end;

				if(objects[plot]) then
					saveData.Ground.Objects = objects[plot];
				end;

				if(counters[plot]) then
					saveData.Ground.Counters = counters[plot]
				end;

				local playerHouses = ReplicatedStorage.Stats[player.Name].Houses;
				local playerHouse;

				for _, v in next, ReplicatedStorage.Stats[player.Name].Houses:GetChildren() do
					if(v.Value == playerHouses.Value) then
						playerHouse = v;
					end;
				end;

				saveData.totalValue = playerHouse.TotalValue.Value or 'Unknown';
				saveData.bsValue = playerHouse.BSValue.Value or 'Unknown';

				writefile(string.format('Roniro Hub V3/Bloxburg Houses/%s.json', player.Name), HttpService:JSONEncode(saveData))
			end;

			function loadHouse(houseData)
				local myPlot = workspace.Plots['Plot_' .. Players.LocalPlayer.Name];
				local myGround = myPlot.Ground;

				local placements = 0;
				local oldFramework = framework;

				local streamRefTypes = {
					'PlaceObject',
					'PlaceWall',
					'PlaceFloor',
					'PlacePath',
					'PlaceRoof'
				};

				local framework = {
					net = setmetatable({
						InvokeServer = function(self, data)
							placements = placements + 1;
							if(placements >= 4) then
								placements = 0;
								task.wait(3);
							end;

							local dataType = data.Type;
							local returnData = {oldFramework.net:InvokeServer(data)};

							if (table.find(streamRefTypes, dataType)) then
								returnData[1] = typeof(returnData[1]) == 'Instance' and returnData[1].Value;
							end;

							return unpack(returnData);
						end;
					}, {__index = oldFramework.net});
				};

				local position = framework.net:InvokeServer({
					Type = 'ToPlot',
					Player = LocalPlayer;
				});
				LocalPlayer.Character:SetPrimaryPartCFrame(position);

				framework.net:InvokeServer({
					Type = 'EnterBuild',
					Plot = myPlot
				})

				local function convertToVector3(vectorString)
					return myGround.CFrame:PointToWorldSpace(Vector3.new(unpack(vectorString:split(','))));
				end;

				local function convertPoints(points)
					local newPoints = {};

					for i, v in next, points do
						table.insert(newPoints, convertToVector3(v));
					end;

					return newPoints;
				end;

				local function convertRot(cf)
					if(not cf) then
						return;
					end;

					local newCf = myGround.CFrame:ToWorldSpace(CFrame.new(unpack(cf:split(','))));
					local rot = -math.atan2(newCf.lookVector.z, newCf.lookVector.x) - math.pi * 0.5;

					if(rot < 0) then
						rot = 2 * math.pi + rot;
					end;

					return rot;
				end

				local count = 0;
				local totalCount = 0;
				for i, v in next, houseData do
					if(typeof(v) == 'table') then
						totalCount = totalCount + #v;
					end;
				end;

				print('starting for', count);

				for _, wallData in next, houseData.Walls do
					local offSetFrom, offSetTo = convertToVector3(wallData.From), convertToVector3(wallData.To);
					local wall = framework.net:InvokeServer({
						Type = 'PlaceWall',
						From = offSetFrom,
						To = offSetTo
					})

					for _, itemData in next, wallData.Items do
						local item = framework.net:InvokeServer({
							Type = 'PlaceObject',
							Name = itemData.Name,
							TargetModel = wall,
							Rot = convertRot(itemData.Rot),
							Pos = convertToVector3(itemData.Position),
						});

						if(itemData.Items) then
							for _, itemData2 in next, itemData.Items do
								local item2 = framework.net:InvokeServer({
									Type = 'PlaceObject',
									Name = itemData2.Name,
									TargetModel = item,
									Rot = convertRot(itemData2.Rot),
									Pos = convertToVector3(itemData2.Position),
								});

								framework.net:InvokeServer({
									Type = 'ColorObject',
									Object = item2,
									UseMaterials = true,
									Data = itemData2.AppearanceData
								})
							end;
						end;

						framework.net:InvokeServer({
							Type = 'ColorObject',
							Object = item,
							UseMaterials = true,
							Data = itemData.AppearanceData
						})
					end;

					framework.net:InvokeServer({
						Type = 'ColorObject',
						Object = wall,
						UseMaterials = true,
						Data = {wallData.AppearanceData[1], {}, {}, {}},
						Side = 'R'
					})

					framework.net:InvokeServer({
						Type = 'ColorObject',
						Object = wall,
						UseMaterials = true,
						Data = {wallData.AppearanceData[2], {}, {}, {}},
						Side = 'L'
					})
				end;

				for _, floorData in next, houseData.Floors do
					local floor = framework.net:InvokeServer({
						Type = 'PlaceFloor',
						Points = convertPoints(floorData.Points)
					});

					for _, itemData in next, floorData.Objects or {} do
						local item = framework.net:InvokeServer({
							Type = 'PlaceObject',
							Name = itemData.Name,
							TargetModel = floor,
							Rot = convertRot(itemData.Rot),
							Pos = convertToVector3(itemData.Position),
						});

						framework.net:InvokeServer({
							Type = 'ColorObject',
							Object = item,
							UseMaterials = true,
							Data = itemData.AppearanceData
						})

						if(itemData.Fences and item) then
							for _, fenceData in next, itemData.Fences do
								local fence = framework.net:InvokeServer({
									Type = 'PlaceObject',
									Name = fenceData.Name,
									Pos = convertToVector3(fenceData.From),
									RailingSegment = item.ObjectModel.Railings[fenceData.Segment]
								});

								if(not fence and debugMode) then
									warn(fence);
									error('failed to place fence');
								end;

								framework.net:InvokeServer({
									Type = 'ColorObject',
									Object = fence,
									UseMaterials = true,
									Data = fenceData.AppearanceData
								})
							end;
						end;

						if(itemData.Items) then
							for _, itemData2 in next, itemData.Items do
								local item2 = framework.net:InvokeServer({
									Type = 'PlaceObject',
									Name = itemData2.Name,
									TargetModel = item,
									Rot = convertRot(itemData2.Rot),
									Pos = convertToVector3(itemData2.Position),
								});

								framework.net:InvokeServer({
									Type = 'ColorObject',
									Object = item2,
									UseMaterials = true,
									Data = itemData2.AppearanceData
								})
							end;
						end;
					end;

					for _, counterData in next, floorData.Counters or {} do
						local item = framework.net:InvokeServer({
							Type = 'PlaceObject',
							Name = counterData.Name,
							TargetModel = floor,
							Rot = convertRot(counterData.Rot),
							Pos = convertToVector3(counterData.Position),
						});

						if(counterData.Items) then
							for _, itemData in next, counterData.Items do
								local item2 = framework.net:InvokeServer({
									Type = 'PlaceObject',
									Name = itemData.Name,
									TargetModel = item,
									Rot = convertRot(itemData.Rot),
									Pos = convertToVector3(itemData.Position),
								});

								framework.net:InvokeServer({
									Type = 'ColorObject',
									Object = item2,
									UseMaterials = true,
									Data = itemData.AppearanceData
								})
							end;
						end;

						framework.net:InvokeServer({
							Type = 'ColorObject',
							Object = item,
							UseMaterials = true,
							Data = counterData.AppearanceData
						})
					end;

					framework.net:InvokeServer({
						Type = 'ColorObject',
						Object = floor,
						UseMaterials = true,
						Data = floorData.AppearanceData
					})
				end;

				for _, pathData in next, houseData.Paths do
					local path = framework.net:InvokeServer({
						Type = 'PlacePath',
						To = convertToVector3(pathData.To),
						From = convertToVector3(pathData.From)
					})

					framework.net:InvokeServer({
						Type = 'ColorObject',
						Object = path,
						UseMaterials = true,
						Data = pathData.AppearanceData
					})
				end;

				for _, roofData in next, houseData.Roofs do
					local roof = framework.net:InvokeServer({
						Type = 'PlaceRoof',
						Points = convertPoints(roofData.Points),
						Start = convertToVector3(roofData.Points[1]),
						Settings = {
							IsPreview = true,
							Type = roofData.Name,
							RotateNum = 0
						}
					});

					for _, itemData in next, roofData.Items or {} do
						local item = framework.net:InvokeServer({
							Type = 'PlaceObject',
							Name = itemData.Name,
							TargetModel = roof,
							Rot = convertRot(itemData.Rot),
							Pos = convertToVector3(itemData.Position),
						});

						framework.net:InvokeServer({
							Type = 'ColorObject',
							Object = item,
							UseMaterials = true,
							Data = itemData.AppearanceData
						})
					end;

					framework.net:InvokeServer({
						Type = 'ColorObject',
						Object = roof,
						UseMaterials = true,
						Data = roofData.AppearanceData
					})
				end;

				for _, poolData in next, houseData.Pools do
					framework.net:InvokeServer({
						Type = 'PlacePool',
						Size = Vector2.new(unpack(poolData.Size:split(','))),
						Center = CFrame.new(unpack(poolData.Position:split(','))),
						ItemType = poolData.Type
					});
					count = count + 1;
				end;

				for _, basementData in next, houseData.Basements do
					framework.net:InvokeServer({
						Type = 'PlaceBasement',
						ItemType = 'Basements',
						Size = Vector2.new(unpack(basementData.Size:split(','))),
						Center = CFrame.new(unpack(basementData.Position:split(','))) - Vector3.new(0, -12.49, 0)
					});
				end;

				for _, fenceData in next, houseData.Fences do
					local fence = framework.net:InvokeServer({
						Type = 'PlaceObject',
						Name = fenceData.Name,
						StartPos = convertToVector3(fenceData.From),
						Pos = convertToVector3(fenceData.To),
						ItemType = fenceData.Name
					})

					for _, itemData in next, fenceData.Items do
						local item = framework.net:InvokeServer({
							Type = 'PlaceObject',
							Name = itemData.Name,
							TargetModel = fence,
							Rot = convertRot(itemData.Rot),
							Pos = convertToVector3(itemData.Position),
						});

						framework.net:InvokeServer({
							Type = 'ColorObject',
							Object = item,
							UseMaterials = true,
							Data = itemData.AppearanceData
						})
					end;

					framework.net:InvokeServer({
						Type = 'ColorObject',
						Object = fence,
						UseMaterials = true,
						Data = fenceData.AppearanceData
					})
				end;

				for _, groundItem in next, houseData.Ground.Objects do
					local item = framework.net:InvokeServer({
						Type = 'PlaceObject',
						Name = groundItem.Name,
						TargetModel = myPlot.GroundParts.Ground,
						Rot = convertRot(groundItem.Rot),
						Pos = convertToVector3(groundItem.Position),
					})

					if(groundItem.Fences and item) then
						for _, fenceData in next, groundItem.Fences do
							local fence = framework.net:InvokeServer({
								Type = 'PlaceObject',
								Name = fenceData.Name,
								Pos = convertToVector3(fenceData.From),
								RailingSegment = item.ObjectModel.Railings[fenceData.Segment]
							})

							framework.net:InvokeServer({
								Type = 'ColorObject',
								Object = fence,
								UseMaterials = true,
								Data = fenceData.AppearanceData
							})
						end;
					end;

					if(groundItem.Items) then
						for _, itemData2 in next, groundItem.Items do
							local item2 = framework.net:InvokeServer({
								Type = 'PlaceObject',
								Name = itemData2.Name,
								TargetModel = item,
								Rot = convertRot(itemData2.Rot),
								Pos = convertToVector3(itemData2.Position),
							});

							framework.net:InvokeServer({
								Type = 'ColorObject',
								Object = item2,
								UseMaterials = true,
								Data = itemData2.AppearanceData
							})
						end;
					end;

					framework.net:InvokeServer({
						Type = 'ColorObject',
						Object = item,
						UseMaterials = true,
						Data = groundItem.AppearanceData
					})
				end;

				for _, counterItem in next, houseData.Ground.Counters do
					local item = framework.net:InvokeServer({
						Type = 'PlaceObject',
						Name = counterItem.Name,
						Pos = convertToVector3(counterItem.Position),
						Rot = convertRot(counterItem.Rot),
						TargetModel = myPlot.GroundParts.Ground,
					})

					if(counterItem.Items) then
						for _, itemData in next, counterItem.Items do
							local item2 = framework.net:InvokeServer({
								Type = 'PlaceObject',
								Name = itemData.Name,
								TargetModel = item,
								Rot = convertRot(itemData.Rot),
								Pos = convertToVector3(itemData.Position),
							});

							framework.net:InvokeServer({
								Type = 'ColorObject',
								Object = item2,
								UseMaterials = true,
								Data = itemData.AppearanceData
							})
						end;
					end;

					framework.net:InvokeServer({
						Type = 'ColorObject',
						Object = item,
						UseMaterials = true,
						Data = counterItem.AppearanceData
					})
				end;

				framework.net:FireServer({
					Type = 'ExitBuild'
				});
			end;

			do -- // Remote Spy
				local oldFireServer = network.FireServer;
				local blacklistedTypes = {'LookDir', 'GetServerTime', 'CheckOwnsAsset', 'VehicleUpdate'};

				oldFireServer = hookfunction(network.FireServer, function(self, data, ...)
					if (data.Type == 'EndShift' and library.flags.pizzaDelivery) then return end;

					if (not table.find(blacklistedTypes, data.Type)) then
						print(prettyPrint({
							data = data,
							traceback = debug.traceback()
						}));
					end;

					return pcall(oldFireServer, self, data, ...);
				end);

				local oldInvokeServer = network.InvokeServer;
				oldInvokeServer = hookfunction(network.InvokeServer, function(self, data, ...)
					local fireType = data.Type;
					local returnData = {select(2, pcall(oldInvokeServer, self, data, ...))};

					if (not table.find(blacklistedTypes, fireType)) then
						print(prettyPrint({
							returnData = returnData,
							data = data,
							type = fireType,
							traceback = debug.traceback()
						}))
					end;


					return unpack(returnData);
				end);
			end;

			local function findCurrentWorkstation(workStations, justFindIt)
				local closestDistance, currentWorkstation = math.huge, nil;
				local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;

				if(not rootPart) then
					return
				end;

				for i, v in next, workStations:GetChildren() do
					local distance = (rootPart.Position - v.PrimaryPart.Position).Magnitude;

					if(distance <= closestDistance and (v.InUse.Value == nil or v.InUse.Value == LocalPlayer)) then
						closestDistance, currentWorkstation = distance, v;
					end;
				end;

				return currentWorkstation;
			end;

			local function findCurrentWorkstationBens(workStations)
				for i,v in next, workStations:GetChildren() do
					local customer = v.Occupied.Value;
					if(customer and customer.Order.Value == '') then
						return v;
					end;
				end;
			end

			local function tweenTeleport(position)
				local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
				if(not rootPart) then
					return warn('no root part for tween tp :/');
				end;


				local path = PathfindingService:CreatePath();
				path:ComputeAsync(rootPart.Position, position);

				local waypoints = path:GetWaypoints();
				local cfValue = Instance.new('CFrameValue');
				local connection;

				cfValue.Value = rootPart.CFrame;

				connection = cfValue:GetPropertyChangedSignal('Value'):Connect(function()
					LocalPlayer.Character:SetPrimaryPartCFrame(cfValue.Value);
				end);

				for i, v in next, waypoints do
					local tweenInfo = TweenInfo.new((rootPart.Position - v.Position).Magnitude / 20, Enum.EasingStyle.Linear);
					local tween = TweenService:Create(cfValue, tweenInfo, {Value = CFrame.new(v.Position + Vector3.new(0, 4, 0))});

					tween:Play();
					tween.Completed:Wait();
				end

				connection:Disconnect();
				connection = nil;

				cfValue:Destroy();
				cfValue = nil;

				path.Blocked:Connect(function()
					warn('BLOCKED IN PATH!');
				end);
			end;

			local function getOrder()
				local box = workspace.Environment.Locations.PizzaPlanet.Conveyor.MovingBoxes:WaitForChild('Box_1');
				local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
				if(not rootPart) then
					return print('No root part :/');
				end;

				if((box.Position - rootPart.Position).Magnitude <= 8) then
					local order = framework.net:InvokeServer({
						Type = "TakePizzaBox",
						Box = box
					});

					if(order) then
						return order;
					else
						return getOrder();
					end;
				else
					print('tween teleport');
					tweenTeleport(Vector3.new(1171.3407, 13.6576843, 273.778717));
					return getOrder();
				end;
			end;

			function copyPlayerHousePrompt(targetPlayer)
				task.wait();
				if(not guiHandler:ConfirmBox(string.format('\nThis will copy the house of %s into your executor workspace folder with the name Bloxburg_House.json.\nIf you want to copy this house simply press Yes (Make sure you can see the house you want to copy or use the teleport to player plot otherwise save house won\'t work properly)\n', targetPlayer.Name, targetPlayer.Name), 'House Copier')) then
					return;
				end;

				saveHouse(targetPlayer);
				return guiHandler:MessageBox(string.format('House of %s has been copied', targetPlayer.Name), 'Success')
			end;

			function loadPlayerHousePrompt(house)
				task.wait();
				local success, houseData = pcall(readfile, string.format('Roniro Hub V3/Bloxburg Houses/%s', house));
				if(not success) then
					return guiHandler:AlertBox('There was an error.','Error');
				end;

				houseData = HttpService:JSONDecode(houseData);
				local bsValue = houseData.bsValue;
				local totalValue = houseData.totalValue - (bsValue * 20);

				if(not guiHandler:ConfirmBox(string.format('\nAre you sure? You are about to load an house.\nMoney Required: %s\nBloxBux Required: %s\nIf you clicked on this button by mistake simply press No.\n', totalValue, bsValue), 'House Loader', 5)) then
					return;
				end;

				loadHouse(houseData);
			end

			local oldNamecall;

			oldNamecall = hookmetamethod(game, '__namecall', function(...)
				------SX_VM_CNONE();
				local args = {...};
				local self = args[1];

				if(typeof(self) ~= 'Instance') then return oldNamecall(...) end;

				if (checkcaller() and getnamecallmethod() == 'FireServer' and args[2].Order and args[2].Workstation) then
					if (args[2].Workstation.Parent.Name == 'HairdresserWorkstations' and library.flags.stylezHairDresser) then
						args[2].Order = {
							args[2].Workstation.Occupied.Value.Order.Style.Value,
							args[2].Workstation.Occupied.Value.Order.Color.Value
						}
					elseif (args[2].Workstation.Parent.Name == 'CashierWorkstations' and library.flags.bloxyBurgers) then
						args[2].Order = {
							args[2].Workstation.Occupied.Value.Order.Burger.Value,
							args[2].Workstation.Occupied.Value.Order.Fries.Value,
							args[2].Workstation.Occupied.Value.Order.Cola.Value
						}
					elseif (args[2].Workstation.Parent.Name == 'BakerWorkstations' and library.flags.pizzaBaker) then
						args[2].Order = {
							true,
							true,
							true,
							args[2].Workstation.Order.Value
						};
					end;
				end;

				return oldNamecall(unpack(args));
			end);

			function stylezHairDresser(toggle)
				if(not toggle) then
					return;
				end;

				repeat
					if(jobManager:GetJob() == 'StylezHairdresser') then
						local workstation = findCurrentWorkstation(workspace.Environment.Locations.StylezHairStudio.HairdresserWorkstations);
						if(workstation) then
							if workstation.Mirror:FindFirstChild("HairdresserGUI") then
								workstation.Mirror.HairdresserGUI.Overlay:FindFirstChild("false").ImageRectOffset = Vector2.new(0, 0)
								workstation.Mirror.HairdresserGUI.Overlay:FindFirstChild("false").ImageColor3 = Color3.new(0, 255, 0)

								for i, v in next, getconnections(workstation.Mirror.HairdresserGUI.Frame.Done.Activated) do
									v.Function();
								end

								task.wait(1)
							end
						end;
					end;
					Heartbeat:Wait();
				until not library.flags.stylezHairDresser;
			end;

			local function GetBurgerWorkstations()
				if workspace.Environment.Locations:FindFirstChild("BloxyBurgers") then
					local stations = {}
					for i, v in next, workspace.Environment.Locations.BloxyBurgers.CashierWorkstations:GetChildren() do
						if v.InUse.Value == LocalPlayer and v.Occupied.Value ~= nil then
							table.insert(stations, v)
						end
						if v.InUse.Value == nil and v.Occupied.Value ~= nil then
							table.insert(stations, v)
						end
					end
					return stations
				end
			end;

			function bloxyBurgers(toggle)
				repeat
					if(jobManager:GetJob() == 'BloxyBurgersCashier') then
						for i,workstation in next, GetBurgerWorkstations() do
							if(workstation) then
								if workstation.OrderDisplay.DisplayMain:FindFirstChild("CashierGUI") then
									workstation.OrderDisplay.DisplayMain.CashierGUI.Overlay:FindFirstChild("false").ImageRectOffset = Vector2.new(0, 0)
									workstation.OrderDisplay.DisplayMain.CashierGUI.Overlay:FindFirstChild("false").ImageColor3 = Color3.new(0, 255, 0)
									for i, v in next, getconnections(workstation.OrderDisplay.DisplayMain.CashierGUI.Frame.Done.Activated) do
										v.Function();
									end

									task.wait(1)
								end
							end;
						end
					end;
					Heartbeat:Wait();
				until not library.flags.bloxyBurgers;
			end;

			function FindClosestCrate()
				local closestBlock
				local closestDistance = math.huge

				for i, v in next, workspace.Environment.Locations.Supermarket.Crates:GetChildren() do
					if LocalPlayer:DistanceFromCharacter(v.Position) < closestDistance and v.Name == "Crate" then
						closestDistance = LocalPlayer:DistanceFromCharacter(v.Position)
						closestBlock = v
					end
				end
				if closestBlock == nil then
					task.wait(0.5)
					--FindClosest("Crate")
				end

				return closestBlock
			end

			function FindClosestEmptyShelf()
				local closestBlock
				local closestDistance = math.huge

				for i, v in next, workspace.Environment.Locations.Supermarket.Shelves:GetChildren() do
					if LocalPlayer:DistanceFromCharacter(v.PrimaryPart.Position) < closestDistance and v.IsEmpty.Value == true then
						closestDistance = LocalPlayer:DistanceFromCharacter(v.PrimaryPart.Position)
						closestBlock = v
					end
				end

				if closestBlock == nil then
					task.wait(0.5)
					--FindClosest("EmptyShelf")
				end

				return closestBlock
			end

			local GoToShelf, TakeCrate

			GoToShelf = function()
				if jobManager:GetJob() == "SupermarketStocker" and library.flags.supermarketStocker then
					local shelf = FindClosestEmptyShelf()
					local gotopart = shelf:FindFirstChild("Part")
					tweenTeleport(gotopart.Position)
					network:FireServer({
						Type = "RestockShelf",
						Shelf = shelf
					})
					TakeCrate()
				end
			end;

			TakeCrate = function()
				if jobManager:GetJob() == "SupermarketStocker" and library.flags.supermarketStocker then
					local Crate = FindClosestCrate()
					tweenTeleport(Crate.Position)
					network:FireServer({
						Type = "TakeFoodCrate",
						Object = Crate
					})
					GoToShelf()
				end
			end

			function Stocker(toggle)
				if not toggle then return end

				spawn(function()
					repeat
						if library.flags.supermarketStocker and jobManager:GetJob() == "SupermarketStocker" then
							LocalPlayer.Character.Humanoid:ChangeState(11)
						end

						Heartbeat:Wait()
					until not library.flags.supermarketStocker
				end)

				if jobManager:GetJob() == "SupermarketStocker" and library.flags.supermarketStocker then
					TakeCrate()
				end
			end

			local function Fish()
				repeat
					task.wait()
				until LocalPlayer.Character:FindFirstChild("Fishing Rod") and jobManager:GetJob() == "HutFisherman"
				local start_time = tick()
				network:FireServer({
					Type = "UseFishingRod",
					State = true;
					Pos = LocalPlayer.Character:FindFirstChild("Fishing Rod").Line.Position
				})

				task.wait(2)

				if LocalPlayer.Character:FindFirstChild("Fishing Rod") then

					local originalBobberPosition = LocalPlayer.Character["Fishing Rod"].Bobber.Position.Y
					if LocalPlayer.Character:FindFirstChild("Fishing Rod") then
						local con

						con = LocalPlayer.Character["Fishing Rod"].Bobber:GetPropertyChangedSignal("Position"):Connect(function()
							if LocalPlayer.Character:FindFirstChild("Fishing Rod") then
								if originalBobberPosition - LocalPlayer.Character["Fishing Rod"].Bobber.Position.Y < 3 then
									local time_elapsed = tick() - start_time
									network:FireServer({
										Type = "UseFishingRod",
										State = false,
										Time = time_elapsed
									})

									con:Disconnect()

									if library.flags.fisherman then
										Fish()
									end
								end
							end
						end)
					end
				end
			end

			function fisherMan(toggle)
				if(not toggle) then
					return;
				end;

				Fish()
			end

			function pizzaBaker(toggle)
				if(not toggle) then
					return;
				end;

				repeat
					if(jobManager:GetJob() == 'PizzaPlanetBaker') then
						local workstation = findCurrentWorkstation(workspace.Environment.Locations.PizzaPlanet.BakerWorkstations);
						if(workstation) then
							local order = workstation.Order;
							local oldPosition = LocalPlayer.Character.PrimaryPart.Position;

							if(order.IngredientsLeft.Value == 0) then
								local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;

								rootPart.CFrame =  CFrame.new(1167.14685, 13.6576815, 255.879852);

								task.wait(0.5);

								network:FireServer({
									Type = "TakeIngredientCrate",
									Object = workspace.Environment.Locations.PizzaPlanet.IngredientCrates.Crate
								})

								task.wait(0.5);

								network:FireServer({
									Type = "TakeIngredientCrate",
									Object = workspace.Environment.Locations.PizzaPlanet.IngredientCrates.Crate
								})

								rootPart.CFrame = CFrame.new(oldPosition);

								task.wait(0.5);

								network:FireServer({
									Type = "RestockIngredients",
									Workstation = workstation
								})
							elseif(order.Value ~= 'true') then
								if workstation:FindFirstChild("OrderDisplay") and workstation.OrderDisplay:FindFirstChild("DisplayMain") and workstation.OrderDisplay.DisplayMain:FindFirstChild("BakerGUI") then
									workstation.OrderDisplay.DisplayMain.BakerGUI.Overlay:FindFirstChild("false").ImageRectOffset = Vector2.new(0, 0)
									workstation.OrderDisplay.DisplayMain.BakerGUI.Overlay:FindFirstChild("false").ImageColor3 = Color3.new(0, 255, 0)
									for i, v in next, getconnections(workstation.OrderDisplay.DisplayMain.BakerGUI.Frame.Done.Activated) do
										v.Function();
									end
								end
							end;

							task.wait(1);
						end;
					end;
					Heartbeat:Wait();
				until not library.flags.pizzaBaker;
			end;

			local function DeliveryMovement(character, cf)
				local cfValue = Instance.new('CFrameValue');
				local distance = (character:GetPivot().Position - cf.Position).Magnitude;
				local speed = 35;

				local tween = TweenService:Create(cfValue, TweenInfo.new(distance / speed, Enum.EasingStyle.Linear), {Value = CFrame.new(cf.Position)});
				cfValue.Value = CFrame.new(character.PrimaryPart.Position);

				local maid = Maid.new();

				maid:GiveTask(tween);
				maid:GiveTask(cfValue);
				maid:GiveTask(RunService.Heartbeat:Connect(function()
					character:PivotTo(cfValue.Value);
				end));

				tween:Play();
				tween.Completed:Wait();

				return maid;
			end

			local GroceryCashierFunctions = {
				BagAmount = function(station)
					local amount = 0
					for i, v in next, station.Bags:GetChildren() do
						if v.Transparency == 0 then
							amount = amount + 1
						end
					end
					return amount
				end;
				RestockBags = function(stat)
					local Crate = workspace.Environment.Locations.Supermarket.Crates:FindFirstChild("BagCrate")
					tweenTeleport(Crate.Position + Vector3.new(5, 0, -5), 12)
					network:FireServer({
						Type = "TakeNewBags",
						Object = Crate
					})
					repeat
						task.wait()
					until LocalPlayer.Character:FindFirstChild("BFF Bags")
					tweenTeleport(stat.Scanner.Position - Vector3.new(3, 0, 0), 12)
					network:FireServer({
						Type = "RestockBags",
						Workstation = stat
					})
					repeat
						task.wait()
					until stat.BagsLeft.Value > 0
				end;
				GetFreeCashierStation = function()
					if workspace.Environment.Locations:FindFirstChild("Supermarket") then
						local Station
						local EmptyStations = {}
						for i, v in next, workspace.Environment.Locations.Supermarket.CashierWorkstations:GetChildren() do
							if v:FindFirstChild("InUse") and v.InUse.Value == LocalPlayer then
								Station = v
							end
						end
						for i, v in next, workspace.Environment.Locations.Supermarket.CashierWorkstations:GetChildren() do
							if v:FindFirstChild("InUse") and v.InUse.Value == nil then
								table.insert(EmptyStations, v)
							end
						end
						if Station == nil and #EmptyStations > 0 then
							local closest = nil
							local distance = math.huge
							for i, v in next, EmptyStations do
								if LocalPlayer:DistanceFromCharacter(v.Scanner.Position) < distance then
									distance = LocalPlayer:DistanceFromCharacter(v.Scanner.Position)
									closest = v
								end
							end
							Station = closest
						end
						if Station == nil then
							task.wait()
							--GetFreeCashierStation()
						end
						return Station
					end
				end
			}

			function NextCustomer()
				if jobManager:GetJob() == "SupermarketCashier" and library.flags.supermarketCashier then
					local Station = GroceryCashierFunctions.GetFreeCashierStation()
					count = 0
					CurrentBags = 1
					if Station.BagsLeft.Value == 0 then
						GroceryCashierFunctions.RestockBags(Station)
					end
					repeat
						for i, v in next, Station.DroppedFood:GetChildren() do
							count = count + 1
							if count / CurrentBags == 3 then
								network:FireServer({
									Type = "TakeNewBag",
									Workstation = Station
								})
								CurrentBags = CurrentBags + 1
								if Station.BagsLeft.Value == 0 then
									GroceryCashierFunctions.RestockBags(Station)
									task.wait()
								end
							end
							network:FireServer({
								Type = "ScanDroppedItem",
								Item = v
							})
							task.wait(0.1)
						end
						task.wait()
					until jobManager:GetJob() ~= "SupermarketCashier" or Station.Occupied.Value ~= nil and (Station.Occupied.Value.Head.Position - Station.CustomerTarget_2.Position).magnitude < 3
					network:FireServer({
						Type = "JobCompleted",
						Workstation = Station
					})
					NextCustomer()
				end
			end

			function supermarketCashier(toggle)
				if not toggle then return end

				repeat task.wait() until jobManager:GetJob() == "SupermarketCashier"

				if library.flags.supermarketCashier then
					NextCustomer()
				end
			end

			local interactionHandler = framework.Modules.InteractionHandler;
			local interactionsDatas = getupvalue(interactionHandler.AddInteraction, 2);

			function pizzaDelivery(toggle)
				if(not toggle) then
					if(LocalPlayer.Character.PrimaryPart:FindFirstChild('funny')) then
						LocalPlayer.Character.PrimaryPart.funny:Destroy();
					end;
					return;
				end;

				local hasVehicle = false;

				repeat
					task.wait();

					if(jobManager:GetJob() ~= 'PizzaPlanetDelivery') then
						continue;
					end;

					if(not LocalPlayer.Character.PrimaryPart:FindFirstChild('funny')) then
						local bodyVelocity = Instance.new('BodyVelocity');
						bodyVelocity.Name = 'funny';

						bodyVelocity.Velocity = Vector3.new(0, 0, 0);
						bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);
						bodyVelocity.Parent = LocalPlayer.Character.PrimaryPart;
					end;

					local vehicle, customer;

					if (not hasVehicle) then
						repeat
							for object, interactionData in next, interactionsDatas do
								if (object.Name == 'DeliveryMoped') then
									select(3, interactionData[1][1]())();
									break;
								end;
							end;

							task.wait(0.5);
							vehicle = LocalPlayer.Character:FindFirstChild('Vehicle_Delivery Moped');
						until vehicle;
					end;

					-- hasVehicle = true;

					repeat
						task.wait(0.1);
						LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(1170, 14, 275));

						local box = workspace.Environment.Locations:WaitForChild('PizzaPlanet'):WaitForChild('Conveyor'):WaitForChild('MovingBoxes'):FindFirstChildOfClass('UnionOperation');
						if (not box) then continue end;

						customer = network:InvokeServer({
							Type = 'TakePizzaBox';
							Box = box
						});
					until customer;

					LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(1170, -50, 275));
					task.wait(0.5);

					local maid = DeliveryMovement(LocalPlayer.Character, customer.PrimaryPart.CFrame * CFrame.new(0, -10, 0));
					task.wait(0.5);

					network:FireServer({
						Type = "DeliverPizza",
						Customer = customer
					});

					repeat
						task.wait();
					until not LocalPlayer.Character:FindFirstChild('Pizza Box');

					task.wait(0.5);

					maid:Destroy();
					maid = nil;

					task.wait();
				until not library.flags.pizzaDelivery;
			end;

			local function GetClosestTree()
				local closestDistance = math.huge
				local closestBlock

				for i, v in next, workspace.Environment.Trees:GetChildren() do
					if LocalPlayer:DistanceFromCharacter(v.PrimaryPart.Position) < closestDistance and v.PrimaryPart.Position.Y > 5 then
						closestDistance = LocalPlayer:DistanceFromCharacter(v.PrimaryPart.Position)
						closestBlock = v
					end
				end

				return closestBlock
			end

			function lumber(toggle)
				if not toggle then
					return
				end

				spawn(function()
					repeat
						if library.flags.lumber and jobManager:GetJob() == "LumberWoodcutter" then
							LocalPlayer.Character.Humanoid:ChangeState(11)
						end

						Heartbeat:Wait()
					until not library.flags.lumber
				end)

				repeat
					if jobManager:GetJob() == "LumberWoodcutter" then
						local Tree = GetClosestTree()

						if Tree then
							local tweenInfo = TweenInfo.new((LocalPlayer.Character.HumanoidRootPart.Position - Tree.PrimaryPart.Position).Magnitude / 45, Enum.EasingStyle.Linear);
							local tween = TweenService:Create(LocalPlayer.Character.HumanoidRootPart, tweenInfo, {CFrame = Tree.PrimaryPart.CFrame});

							tween:Play();
							tween.Completed:Wait();

							repeat
								network:FireServer({
									Type = "UseHatchet",
									Tree = Tree
								})

								task.wait()
							until (Tree.PrimaryPart.Position.Y < 0) or (jobManager:GetJob() ~= "LumberWoodcutter") or (library.flags.lumber == false)
						end
					end

					Heartbeat:Wait()
				until not library.flags.lumber
			end

			local ColorsValue = {
				"Dark stone grey";
				"Dark orange";
				"Deep orange";
				"Lime green";
				"Royal purple";
			}

			local function FindClosestStone()
				local closestDistance = math.huge
				local closestBlock
				local closestY = math.huge

				for i, v in next, workspace.Environment.Locations.Static_MinerCave.Folder:GetChildren() do
					if LocalPlayer:DistanceFromCharacter(v.PrimaryPart.Position) < closestDistance and v.PrimaryPart.Position.Y < closestY then
						if (not v:FindFirstChild("B")) or (v:FindFirstChild("B").BrickColor.Name ~= "Bright red") then
							closestDistance = LocalPlayer:DistanceFromCharacter(v.PrimaryPart.Position)
							closestBlock = v
							closestY = v.PrimaryPart.Position.Y
						end
					end
				end

				return closestBlock
			end

			local function FindClosestOre()
				local closestDistance = math.huge
				local closestBlock

				local bestColor = "Dark stone grey"
				for i, v in next, workspace.Environment.Locations.Static_MinerCave.Folder:GetChildren() do
					if v:FindFirstChild("M") then
						if table.find(ColorsValue, bestColor) < table.find(ColorsValue, v:FindFirstChild("M").BrickColor.Name) then
							closestBlock = v
							bestColor = v:FindFirstChild("M").BrickColor.Name
						elseif table.find(ColorsValue, bestColor) == table.find(ColorsValue, v:FindFirstChild("M").BrickColor.Name) then
							if LocalPlayer:DistanceFromCharacter(v.PrimaryPart.Position) < closestDistance then
								closestDistance = LocalPlayer:DistanceFromCharacter(v.PrimaryPart.Position)
								closestBlock = v
							end
						end
					end
				end

				if closestBlock == nil then
					closestBlock = FindClosestStone()
				end

				return closestBlock
			end

			function miner(toggle)
				if not toggle then
					if LocalPlayer.Character.HumanoidRootPart:FindFirstChildOfClass("BodyVelocity") then
						LocalPlayer.Character.HumanoidRootPart:FindFirstChildOfClass("BodyVelocity"):Destroy()
					end

					return
				end

				local bv = Instance.new("BodyVelocity", LocalPlayer.Character.HumanoidRootPart)
				bv.Velocity = Vector3.new(0, 0, 0)

				spawn(function()
					repeat
						if library.flags.miner then
							LocalPlayer.Character.Humanoid:ChangeState(11)
						end

						Heartbeat:Wait()
					until not library.flags.miner
				end)

				repeat
					if library.flags.miner and jobManager:GetJob() == "CaveMiner" and workspace.Environment.Locations:FindFirstChild("Static_MinerCave") then
						local TargetBlock = FindClosestOre()

						TargetBlock.PrimaryPart.CanCollide = false
						if TargetBlock then
							tweenTeleport(TargetBlock.PrimaryPart.Position, 20)

							local TargetX, TargetY, TargetZ = string.match(TargetBlock.Name, "(.+):(.+):(.+)")
							local TargetVector = Vector3.new(TargetX, TargetY, TargetZ)

							network:InvokeServer({
								Type = "MineBlock",
								P = TargetVector
							})
						end
					end
				until not library.flags.miner
			end

			function bensIceCream(toggle)
				if(not toggle) then
					return;
				end;

				repeat
					local workstation = findCurrentWorkstationBens(workspace.Environment.Locations.BensIceCream.CustomerTargets);
					if(jobManager:GetJob() == 'BensIceCreamSeller' and workstation) then
						local customer = workstation.Occupied.Value;
						local iceCup;


						repeat
							framework.net:FireServer({
								Type = 'TakeIceCreamCup'
							})

							iceCup = framework.Shared.EquipmentService:GetEquipped(LocalPlayer);
							task.wait();
						until iceCup or not library.flags.bensIceCream;

						if(not library.flags.bensIceCream) then
							return;
						end;

						for x = 1, 2 do
							framework.net:FireServer({
								Type = 'AddIceCreamScoop',
								Taste = customer.Order['Flavor' .. tostring(x)].Value,
								Ball = iceCup:WaitForChild('Ball' .. tostring(x));
							});
							task.wait(0.1);
						end;

						if(customer.Order.Topping.Value ~= '') then
							framework.net:FireServer({
								Type = 'AddIceCreamTopping',
								Taste = customer.Order.Topping.Value
							});
						end;

						task.wait(0.1);

						framework.net:FireServer({
							Type = "JobCompleted",
							Workstation = workstation
						});
						task.wait(1);
					end;
					task.wait();
				until not library.flags.bensIceCream;
			end;

			local function GetMotorWorkstation()
				if workspace.Environment.Locations:FindFirstChild("MikesMotors") then
					local Station
					for i, v in next, workspace.Environment.Locations.MikesMotors.MechanicWorkstations:GetChildren() do
						if v:FindFirstChild("InUse") and v.InUse.Value == LocalPlayer then
							Station = v
						end
					end
					for i, v in next, workspace.Environment.Locations.MikesMotors.MechanicWorkstations:GetChildren() do
						if v:FindFirstChild("InUse") and v:FindFirstChild("Occupied") and v.InUse.Value == nil and v.Occupied.Value ~= nil then
							Station = v
						end
					end
					if Station == nil then
						task.wait()
						GetMotorWorkstation()
					end
					return Station
				end
			end;

			local WheelPos = {
				["Bloxster"] = Vector3.new(1155.36475, 13.3524084, 411.294983),
				["Classic"] = Vector3.new(1156, 13.3524084, 396.650177),
				["Moped"] = Vector3.new(1154, 13, 402)
			}

			function mechanic(toggle)
				if(not toggle) then
					return;
				end;

				repeat
					if jobManager:GetJob() == "MikesMechanic" then
						local v = GetMotorWorkstation()
						if v then
							local customer = v.Occupied.Value
							if customer then
								local Order = customer:WaitForChild("Order")
								if Order:FindFirstChild("Oil") then
									local Oil = Order.Oil.Value
									if Oil ~= nil then
										repeat
											tweenTeleport(Vector3.new(1194, 13, 389), 12)
											network:FireServer({
												Type = "TakeOil";
												Object = workspace.Environment.Locations.MikesMotors.OilCans:FindFirstChildWhichIsA("Model")
											})
											task.wait()
										until LocalPlayer.Character:FindFirstChild("Oil Can") or not library.flags.mechanic
										tweenTeleport(v.Display.Screen.Position + Vector3.new(0, 0, 5), 12)
										network:FireServer({
											Type = "FixBike";
											Workstation = v
										})
										repeat
											task.wait()
										until (not LocalPlayer.Character:FindFirstChild("Oil Can")) or not library.flags.mechanic
										network:FireServer({
											Type = "JobCompleted";
											Workstation = v
										})
										task.wait(2)
									end
								elseif Order:FindFirstChild("Wheels") then
									local WheelType = Order.Wheels.Value
									for i = 1, 2 do
										repeat
											tweenTeleport(WheelPos[WheelType], 12)
											network:FireServer({
												Type = "TakeWheel";
												Object = workspace.Environment.Locations.MikesMotors.TireRacks:FindFirstChild(WheelType)
											})
											task.wait()
										until LocalPlayer.Character:FindFirstChild(WheelType.." Wheel") or not library.flags.mechanic
										tweenTeleport(v.Display.Screen.Position + Vector3.new(0, 0, 5), 12)
										if i == 1 then
											network:FireServer({
												Type = "FixBike";
												Workstation = v;
												Front = true
											})
										elseif i == 2 then
											network:FireServer({
												Type = "FixBike";
												Workstation = v;
											})
										end
										repeat
											task.wait()
										until (not LocalPlayer.Character:FindFirstChild(WheelType.." Wheel")) or not library.flags.mechanic
										if i == 2 then
											network:FireServer({
												Type = "JobCompleted";
												Workstation = v
											})
										end
										task.wait(2)
									end
								elseif Order:FindFirstChild("Color") then
									local ColorValue = Order.Color.Value
									if ColorValue ~= nil then
										repeat
											tweenTeleport(Vector3.new(1173, 13, 388), 12)
											network:FireServer({
												Type = "TakePainter";
												Object = workspace.Environment.Locations.MikesMotors.PaintingEquipment:FindFirstChild(ColorValue)
											})
											task.wait()
										until LocalPlayer.Character:FindFirstChild("Spray Painter") or not library.flags.mechanic
										tweenTeleport(v.Display.Screen.Position + Vector3.new(0, 0, 5), 12)
										network:FireServer({
											Type = "FixBike";
											Workstation = v
										})
										repeat
											task.wait()
										until (not LocalPlayer.Character:FindFirstChild("Spray Painter")) or not library.flags.mechanic
										network:FireServer({
											Type = "JobCompleted";
											Workstation = v
										})
										task.wait(2)
									end
								end
							end
						end
					end

					Heartbeat:Wait()
				until not library.flags.mechanic
			end

			local function FindClosestTrash()
				local closestDistance = math.huge
				local closestBlock

				for i, v in next, workspace.Environment.Locations.GreenClean.Spawns:GetChildren() do
					if LocalPlayer:DistanceFromCharacter(v.Position) < closestDistance and v:FindFirstChildWhichIsA("Decal", true) then
						closestDistance = LocalPlayer:DistanceFromCharacter(v.Position)
						closestBlock = v
					end
				end

				if closestBlock == nil then
					task.wait()
					FindClosestTrash()
				end

				return closestBlock
			end

			function janitor(toggle)
				if not toggle then
					return
				end

				spawn(function()
					repeat
						if library.flags.janitor then
							LocalPlayer.Character.Humanoid:ChangeState(11)
						end

						Heartbeat:Wait()
					until not library.flags.janitor
				end)

				repeat
					if library.flags.janitor and jobManager:GetJob() == "CleanJanitor" then
						local Trash = FindClosestTrash()

						if Trash then
							if Trash:FindFirstChild("Object") and Trash:FindFirstChild("Object"):IsA("Part") then
								tweenTeleport(Trash.Object.Position)
							else
								tweenTeleport(Trash.Position)
							end

							network:InvokeServer({
								Type = "CleanJanitorObject",
								Spawn = Trash
							})
						end
					end

					Heartbeat:Wait()
				until not library.flags.janitor
			end

			function teleportToPlayerPlot(targetPlayer)
				local position = framework.net:InvokeServer({
					Type = 'ToPlot',
					Player = targetPlayer;
				});

				LocalPlayer.Character:SetPrimaryPartCFrame(position);
			end;

			library.OnLoad:Connect(function()
				while true do
					local loadHouseList = library.options.loadHouse;
					local newList = listfiles('Roniro Hub V3\\Bloxburg Houses')

					for i, file in next, newList do
						file = file:match('Roniro Hub V3\\Bloxburg Houses\\(.+)');
						newList[i] = file;

						if (not table.find(loadHouseList.values, file)) then
							loadHouseList:AddValue(file);
						end;
					end;

					for _, file in next, loadHouseList.values do
						if (not table.find(newList, file)) then
							loadHouseList:RemoveValue(file);
						end;
					end;

					task.wait(1);
				end;
			end);
		end;

		local Autofarm = column1:AddSection('Auto Farm');
		local Autobuild = column2:AddSection('Auto Build');
		local Misc = column1:AddSection('Misc');

		Autofarm:AddToggle({text = 'Pizza Delivery', callback = pizzaDelivery});
		Autofarm:AddToggle({text = 'Bens Ice Cream', callback = bensIceCream});
		Autofarm:AddToggle({text = 'Stylez Hair Dresser', callback = stylezHairDresser});
		Autofarm:AddToggle({text = 'Bloxy Burgers', callback = bloxyBurgers});
		Autofarm:AddToggle({text = 'Pizza Baker', callback = pizzaBaker});
		Autofarm:AddToggle({text = "Fisherman", callback = fisherMan})
		Autofarm:AddToggle({text = "Mechanic", callback = mechanic})
		Autofarm:AddToggle({text = "Lumber", callback = lumber})
		Autofarm:AddToggle({text = "Miner", callback = miner})
		Autofarm:AddToggle({text = "Janitor", callback = janitor})
		Autofarm:AddToggle({text = "Supermarket Cashier", callback = supermarketCashier})
		Autofarm:AddToggle({text = "Supermarket Stocker", callback = Stocker})
		Autobuild:AddList({text = 'Copy House', skipflag = true, noload = true, playerOnly = true, callback = copyPlayerHousePrompt});
		Autobuild:AddList({text = 'Load House', flag = 'Load House', skipflag = true, noload = true, values = {}, callback = loadPlayerHousePrompt});

		Misc:AddList({text = 'Teleport To Player Plot', skipflag = true, noload = true, playerOnly = true, callback = teleportToPlayerPlot});
	end)()
end

if (gameName == 'Bloodlines') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];



		-- Services
		local Players, ReplicatedStorage, RunService, Lighting, MemStorageService, TeleportService = Services:Get('Players', 'ReplicatedStorage', 'RunService', 'Lighting', 'MemStorageService', 'TeleportService');
		local MAIN_PLACE_ID = 10266164381;

		if (game.PlaceId ~= MAIN_PLACE_ID) then
			return ToastNotif.new({text = 'Script will not run in lobby.'});
		end

		-- UI Init
		local column1, column2 = unpack(library.columns);

		local localCheats = column1:AddSection('Local Cheats');
		local visualCheats = column1:AddSection('Visual Cheats');
		local riskyCheats = column2:AddSection('Risky Cheats');
		local teleportCheats = column2:AddSection('Teleport Cheats');
		local miscCheats = column2:AddSection('Misc Cheats');

		-- Utility Functions
		local IsA = game.IsA;

		-- Variables
		local chatLogger = TextLogger.new({
			title = 'Chat Logger',
			-- buttons = {'Spectate', 'Copy Username', 'Copy User Id', 'Copy Text'}
		});

		local localPlayer = Players.LocalPlayer;

		local funcs = {};

		local maid = Maid.new();
		local remotes = ReplicatedStorage.Events;
		local dataEvent, dataFunction = remotes.DataEvent, remotes.DataFunction;

		local gameManager = require(ReplicatedStorage.GameManager);
		local localPlayerData = Utility:getPlayerData();

		local chakraPoints = {};
		local npcs = {};
		local purchasableItems = {};

		local loadSound;
		local inDanger = false;

		-- Functions
		do
			-- Anti Cheat Bypass / No Fall Damage
			do
				local oldNamecall;

				local function fireServerHook(remote, action, ...)
					if (remote == dataEvent and string.lower(action) == 'banme') then
						return warn('No No No');
					end;

					return oldNamecall(remote, action, ...);
				end;

				oldNamecall = hookmetamethod(game, '__namecall', function(self, ...)
					------SX_VM_CNONE();
					local method = getnamecallmethod();

					if ((method == 'fireServer' or method == 'FireServer') and IsA(self, 'RemoteEvent') and self == dataEvent) then
						return fireServerHook(self, ...);
					elseif (method == 'FindFirstChild') then
						local args = {...};
						if (args[1] == 'NegateFall' and library.flags.noFallDamage) then
							print('no fall damage haha');
							return true;
						end;
					end;

					return oldNamecall(self, ...);
				end);
			end;

			-- Remove Kill Bricks
			do
				local KILL_BRICKS_NAMES = {'LavarossaVoid', 'Void'};
				local killBricks = {};

				local function onChildAdded(object)
					if (not table.find(KILL_BRICKS_NAMES, object.Name)) then return end;

					table.insert(killBricks, {
						part = object,
						oldParent = object.Parent
					});

					if (library.flags.noKillBricks) then
						object.Parent = nil;
					end;
				end;

				function funcs.noKillBricks(state)
					for _, killBrick in next, killBricks do
						killBrick.part.Parent = not state and killBrick.oldParent or nil;
					end;
				end;

				library.OnLoad:Connect(function()
					for _, v in next, workspace:GetDescendants() do
						if (table.find(KILL_BRICKS_NAMES, v.Name)) then
							task.spawn(onChildAdded, v);
						end;
					end;

					workspace.DescendantAdded:Connect(onChildAdded);
				end);
			end;

			-- Chat Logger
			do
				local function onPlayerChatted(player, message)
					local timeText = DateTime.now():FormatLocalTime('H:mm:ss', 'en-us');
					local playerName = player.Name;
					local playerIngName = player:GetAttribute('CharacterName') or 'N/A';

					message = ('[%s] [%s] [%s] %s'):format(timeText, playerName, playerIngName, message);

					local textData = chatLogger:AddText({
						text = message,
						player = player
					});
				end;

				ReplicatedStorage.DefaultChatSystemChatEvents.OnMessageDoneFiltering.OnClientEvent:Connect(function(messageData)
					local player, message = Players:FindFirstChild(messageData.FromSpeaker), messageData.Message;
					if (not player or not message) then return end;

					onPlayerChatted(player, message);
				end);

				function funcs.chatLogger(state)
					chatLogger:SetVisible(state);
				end;

				chatLogger.OnUpdate:Connect(function(updateType, vector)
					library.configVars['chatLogger' .. updateType] = tostring(vector);
				end);

				library.OnLoad:Connect(function()
					local chatLoggerSize = library.configVars.chatLoggerSize;
					chatLoggerSize = chatLoggerSize and Vector2.new(unpack(chatLoggerSize:split(',')));

					local chatLoggerPosition = library.configVars.chatLoggerPosition;
					chatLoggerPosition = chatLoggerPosition and Vector2.new(unpack(chatLoggerPosition:split(',')));

					if (chatLoggerSize) then
						chatLogger:SetSize(UDim2.fromOffset(chatLoggerSize.X, chatLoggerSize.Y));
					end;

					if (chatLoggerPosition) then
						chatLogger:SetPosition(UDim2.fromOffset(chatLoggerPosition.X, chatLoggerPosition.Y));
					end;

					chatLogger:UpdateCanvas();
				end);
			end;

			-- Danger Check
			do
				dataEvent.OnClientEvent:Connect(function(eventType, ...)
					if (eventType == 'InDanger') then
						inDanger = true;
					elseif (eventType == 'OutOfDanger') then
						inDanger = false;
					end;
				end);
			end

			-- Danger Checks Features (Reset Character, Instant Log)
			do
				function funcs.resetCharacter()
					local character = localPlayerData.character;
					if (not character) then return end;

					if (library:ShowConfirm('Are you sure you want to reset character?')) then
						character:BreakJoints();
					end;
				end;

				function funcs.instantLog()
					if (inDanger) then return ToastNotif.new({text = 'You can not do this right now. You are in danger.'}) end;

					localPlayer:Kick('');
					task.wait(2.5);
					game:Shutdown();
				end;
			end;

			-- Visuals Features
			do
				function funcs.noRain(state)
					if (not state) then
						return;
					end;

					maid.noRainLoop = task.spawn(function()
						while true do
							ReplicatedStorage.Raining.Value = '';
							task.wait();
						end;
					end);
				end;

				local oldvalue = Lighting.FogEnd;
				local oldBrightness = Lighting.Brightness;

				function funcs.noFog(state)
					if (not state) then
						Lighting.FogEnd = oldvalue;
						maid.noFog = nil;
						return;
					end;

					maid.noFog = RunService.RenderStepped:Connect(function()
						Lighting.FogEnd = 9999999999;
					end);
				end;

				function funcs.fullBright(state)
					if (not state) then
						Lighting.Brightness = oldBrightness;
						maid.fullBright = nil;
						return;
					end;

					maid.fullBright = RunService.RenderStepped:Connect(function()
						Lighting.Brightness = library.flags.brightnessLevel;
					end);
				end;
			end;

			-- Teleports
			do
				local chakaPointsInstances = {};

				for _, chakraPoint in next, workspace.ChakraPoints:GetChildren() do
					table.insert(chakraPoints, chakraPoint.PointName.Value);
					chakaPointsInstances[chakraPoint.PointName.Value] = chakraPoint.Main.Position;
				end;

				function funcs.teleportToChakraPoint()
					local rootPart = localPlayerData.rootPart;
					if (not rootPart) then return end;

					local pos = chakaPointsInstances[library.flags.chakraPoint];

					rootPart.CFrame = CFrame.new(pos - Vector3.new(0, 0, 5), pos);
				end;

				function funcs.teleportToPlayer()
					local player = Utility:getPlayerData(library.flags.playerTeleport);
					if (not player or not player.rootPart) then return end;

					local rootPart = localPlayerData.rootPart;
					if (not rootPart) then return end;

					rootPart.CFrame = player.rootPart.CFrame;
				end;
			end;

			-- NPCs, Mobs features
			do
				local npcsList = {};
				local npcsESP = createBaseESP('npcs', {});
				local mobsESP = createBaseESP('mobs', {});
				local areasESP = createBaseESP('areas', {});

				local function onChildAdded(object)
					if (not IsA(object, 'Model')) then return end;

					local npcValue = object:WaitForChild('NPC', 10);
					if (not npcValue) then return end;

					local rootPart = object:FindFirstChild('HumanoidRootPart') or object:FindFirstChild('Main');

					if (npcValue.Value == 'Dialog') then
						table.insert(npcs, object.Name);
						npcsList[object.Name] = object;

						local npcESP;
						if (rootPart) then
							npcESP = npcsESP.new(rootPart, object.Name);
						end;

						object.Destroying:Connect(function()
							table.remove(npcs, table.find(npcs, object.Name));
							npcsList[object.Name] = nil;
							npcESP:Destroy();
						end);
					elseif (npcValue.Value == 'Combat') then
						local mobESP;

						if (rootPart) then
							mobESP = mobsESP.new(rootPart, object.Name);

							object.Destroying:Connect(function()
								mobESP:Destroy();
							end);
						end;
					end;
				end;

				for _, v in next, workspace:GetChildren() do
					task.spawn(onChildAdded, v);
				end;

				for _, v in next, workspace.Locations:GetChildren() do
					areasESP.new(v, v.Name);
				end;

				workspace.ChildAdded:Connect(onChildAdded);

				function funcs.teleportToNPC()
					local npcName = library.flags.npcTeleport;
					local npc = npcsList[npcName];
					if (not npc) then return end;

					local rootPart = localPlayerData.rootPart;
					if (not rootPart) then return end;

					local main = npc.PrimaryPart or npc:FindFirstChild('Main') or npc:FindFirstChildWhichIsA('BasePart', true);

					rootPart.CFrame = CFrame.new(main.Position + Vector3.new(0, 0, -5), main.Position);
				end;

				function Utility:renderOverload(data)
					local mobsSection = data.column1:AddSection('Mobs');
					local npcsSection = data.column2:AddSection('NPCs');
					local areasSection = data.column2:AddSection('Areas');

					local function makeFor(section, flagName, espObject)
						section:AddToggle({
							text = 'Enable',
							flag = flagName,
							callback = function (state)
								if (not state) then
									maid['update' .. flagName .. 'esp'] = nil;
									espObject:UnloadAll();
									return;
								end;

								maid['update' .. flagName .. 'esp'] = RunService.RenderStepped:Connect(function()
									espObject:UpdateAll();
								end);
							end;
						});

						section:AddToggle({
							text = 'Show Distance',
							flag = flagName .. ' Show Distance'
						});

						section:AddSlider({
							text = 'Max Distance',
							flag = flagName .. ' Max Distance',
							min = 100,
							value = 100000,
							max = 100000,
							float = 100,
							textpos = 2
						});
					end;

					makeFor(npcsSection, 'Npcs', npcsESP);
					makeFor(mobsSection, 'Mobs', mobsESP);
					makeFor(areasSection, 'Areas', areasESP);

					mobsSection:AddToggle({
						text = 'Show Health',
						flag = 'Mobs Show Health'
					});
				end;
			end;

			do -- // Download Assets
				local assetsList = {'ModeratorJoin.mp3', 'ModeratorLeft.mp3'};
				local assets = {};

				local apiEndpoint = USE_INSECURE_ENDPOINT and 'http://test.aztupscripts.xyz' or 'https://aztupscripts.xyz';

				for i, v in next, assetsList do
					if(not isfile(string.format('Roniro Hub V3/%s', v))) then
						print('Downloading', v, '...');
						writefile(string.format('Roniro Hub V3/%s', v), game:HttpGet(string.format('%s/%s', apiEndpoint, v)));
					end;

					assets[v] = getcustomasset(string.format('Roniro Hub V3/%s', v));
				end;

				function loadSound(soundName)
					local sound = Instance.new('Sound');
					sound.SoundId = assets[soundName];
					sound.Volume = 1;
					sound.Parent = game:GetService('CoreGui');

					sound:Play();

					task.delay(4, function()
						sound:Destroy();
					end);
				end;
			end;

			-- Add Purchasable Items
			do
				for itemName, item in next, gameManager.Items do
					if (item.Buyabble) then
						table.insert(purchasableItems, itemName);
					end;
				end;
			end;

			-- Mod Detector
			do
				Utility.onPlayerAdded:Connect(function(player)
					while true do
						local suc, rank = pcall(function() return player:GetRankInGroup(7450839) end);
						if (not suc) then continue end;

						if (rank ~= 0) then
							ToastNotif.new({
								text = string.format('Moderator detected [%s]', player.Name)
							});

							if (library.flags.moderatorSoundAlert) then
								loadSound('ModeratorJoin.mp3');
							end;

							player.Destroying:Connect(function()
								ToastNotif.new({
									text = string.format('Moderator left [%s]', player.Name),
								});

								loadSound('ModeratorLeft.mp3');
							end);
						end;

						break;
					end;
				end);
			end;

			-- Right Click Spectate
			do
				Utility.onLocalCharacterAdded:Connect(function(playerData)
					local clientGui = localPlayer.PlayerGui:WaitForChild('ClientGui', 10);
					if (not clientGui) then return end;

					local playerList = clientGui.Mainframe.PlayerList.List;
					local lastSpectating;
					local lastSpectatingObject;

					local function spectate(player, obj)
						local playerData = Utility:getPlayerData(player);
						if (not playerData) then return end;

						local playerHumanoid = playerData.humanoid;

						if (not player or lastSpectating == player) then
							if (lastSpectatingObject) then
								lastSpectatingObject.PlayerName.TextColor3 = Color3.fromRGB(255, 255, 255);
								lastSpectatingObject = nil;
							end;

							lastSpectating = nil;

							local humanoid = localPlayerData.humanoid;
							if (not humanoid) then return end;

							workspace.CurrentCamera.CameraSubject = humanoid;
							return;
						end;

						if (lastSpectatingObject) then
							lastSpectatingObject.PlayerName.TextColor3 = Color3.fromRGB(255, 255, 255);
						end;

						lastSpectatingObject = obj;
						lastSpectating = player;

						if (player ~= localPlayer) then
							obj.PlayerName.TextColor3 = Color3.fromRGB(255, 0, 0);
						end;

						workspace.CurrentCamera.CameraSubject = playerHumanoid;
					end;

					local function onChildAdded(obj)
						local playerName = obj:WaitForChild('RealName', 10);
						if (not playerName) then return end;

						obj.InputBegan:Connect(function(inputObject)
							if (inputObject.UserInputType == Enum.UserInputType.MouseButton2) then
								local humanoid = localPlayerData.humanoid;
								if (not humanoid) then return spectate() end;

								local player = Players:FindFirstChild(playerName.Value);
								if (not player) then return spectate() end;

								-- Attempt to spectate player
								spectate(player, obj);
							end;
						end);
					end;

					for _, v in next, playerList:GetChildren() do
						task.spawn(onChildAdded, v);
					end;

					playerList.ChildAdded:Connect(onChildAdded);
				end);
			end;

			-- Auto Pickup
			do
				local pickupList = {};

				local function onChildAdded(obj)
					if (not IsA(obj, 'BasePart')) then return end;

					local pickupable = obj:WaitForChild('Pickupable', 10);
					if (not pickupable) then return end;

					local id = obj:WaitForChild('ID', 10);
					if (not id) then return end;

					local pos = obj.Position;
					pickupList[pos] = obj;

					obj.Destroying:Connect(function()
						pickupList[pos] = nil;
					end);
				end;

				for _, child in next, workspace:GetChildren() do
					task.spawn(onChildAdded, child);
				end;

				workspace.ChildAdded:Connect(onChildAdded);

				function funcs.autoPickup(toggle)
					if (not toggle) then
						maid.autoPickup = nil;
						return;
					end;

					local lastRanAt = 0;

					maid.autoPickup = RunService.Heartbeat:Connect(function()
						local rootPart = localPlayerData.rootPart;
						if (not rootPart or tick() - lastRanAt < 0.1) then return end;
						lastRanAt = tick();

						local myPosition = rootPart.Position;

						for pos, obj in next, pickupList do
							local distance = (myPosition - pos).Magnitude;
							if (distance < 50) then
								print('pick it up');
								dataEvent:FireServer('PickUp', obj.ID.Value);
							end;
						end;
					end);
				end;
			end;

			-- Attach To Back
			do
				local entities = {};

				local function onChildAdded(obj)
					task.wait();

					if (not IsA(obj, 'Model')) then return end;
					if (obj == localPlayer.Character) then return end;

					local humanoid = obj:WaitForChild('Humanoid', 10);
					if (not humanoid) then return end;

					local rootPart = obj:WaitForChild('HumanoidRootPart', 10);
					if (not rootPart or not obj.Parent) then return end;

					local connection;

					task.spawn(function()
						local npc = obj:WaitForChild('Npc', 10);

						if (npc and npc.Value == 'Dialog') then
							if (table.find(entities, rootPart)) then
								table.remove(entities, table.find(entities, rootPart));
								connection:Disconnect();
							end;
						end;
					end);

					connection = obj.Destroying:Connect(function()
						table.remove(entities, table.find(entities, rootPart));
					end);

					table.insert(entities, rootPart);
				end;

				for _, child in next, workspace:GetChildren() do
					task.spawn(onChildAdded, child);
				end;

				workspace.ChildAdded:Connect(onChildAdded);

				function funcs.attachToBack()
					local myRootPart = localPlayerData.rootPart;
					if (not myRootPart) then return end;

					local myPosition = myRootPart.Position;
					local last, target = math.huge, nil;

					for _, part in next, entities do
						local dist = (myPosition - part.Position).Magnitude;

						if (dist < last) then
							last = dist;
							target = part;
						end;
					end;

					if (target) then
						myRootPart.CFrame = target.CFrame * CFrame.new(0, 0, 2);
					end;
				end;
			end;

			-- Thunderstorm Server Finder
			do
				function funcs.findThunderstormServer(state)
					if (not state) then return end;

					ToastNotif.new({
						text = 'Thunderstorm Server Finder is running!',
					});

					local thunderStorm = workspace:WaitForChild('Thunderstorm', 5);

					if (thunderStorm) then
						return ToastNotif.new({
							text = 'Found thunderstorm in this server!'
						});
					else
						ToastNotif.new({
							text = 'No thunderstorm was found on this server, finding new server...'
						});
					end;

					local oldServerList = MemStorageService:HasItem('thunderStormServerList') and MemStorageService:GetItem('thunderStormServerList');

					if (oldServerList) then
						oldServerList = HttpService:JSONDecode(oldServerList);
					end;

					if (not oldServerList or #oldServerList == 0) then
						-- Fetch new server if no server of if list is empty

						local serverListData = {};
						local cursor = '';

						while (true) do
							local serverList = request({
								Url = string.format('https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Desc&limit=100&cursor=%s', MAIN_PLACE_ID, cursor)
							});

							table.foreach(serverList, warn);

							if (not serverList.Success) then continue end;
							serverList = HttpService:JSONDecode(serverList.Body);

							for _, server in next, serverList.data or {} do
								-- if (server.playing < server.maxPlayers) then
								table.insert(serverListData, server.id);
								-- end;
							end;

							if (not serverList.nextPageCursor or not serverList.data) then break end;

							cursor = serverList.nextPageCursor;
						end;

						print('Got', #serverListData);
						MemStorageService:SetItem('thunderStormServerList', HttpService:JSONEncode(serverListData));
					end;

					local serverList = HttpService:JSONDecode(MemStorageService:GetItem('thunderStormServerList'));

					while (library.flags.thunderstormServerFinder) do
						local serverId = table.remove(serverList, math.random(1, #serverList));
						dataEvent:FireServer('ServerTeleport', serverId);
						-- TeleportService:TeleportToPlaceInstance(MAIN_PLACE_ID, serverId);
						task.wait(15);
					end;
				end;
			end;

			-- Chakra Sense Alert
			do
				local function onChildAdded(obj)
					local function onChildAdded2(obj2)
						if (obj2.Name == 'Chakra Sense' and library.flags.chakraSenseNotifier) then
							ToastNotif.new({
								text = string.format('%s has chakra sense', obj.Name)
							})
						end;
					end;

					for _, v in next, obj:GetChildren() do
						task.spawn(onChildAdded2, v);
					end;

					obj.ChildAdded:Connect(onChildAdded2);
				end;

				library.OnLoad:Connect(function()
					for _, v in next, ReplicatedStorage.Cooldowns:GetChildren() do
						task.spawn(onChildAdded, v);
					end;

					ReplicatedStorage.Cooldowns.ChildAdded:Connect(onChildAdded);
				end);
			end;

			function funcs.flyHack(state)
				if (not state) then
					maid.flyBodyVelocity = nil;
					maid.flyStepped = nil;
					return;
				end;

				maid.flyBodyVelocity = Instance.new('BodyVelocity');
				maid.flyBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

				maid.flyStepped = RunService.Stepped:Connect(function()
					local camera = workspace.CurrentCamera;
					if (not camera) then return end;

					local rootPart = localPlayerData.rootPart;
					if (not rootPart) then return end;

					local rawMoveVector = ControlModule:GetMoveVector();
					local cameraMoveVector = camera.CFrame:VectorToWorldSpace(rawMoveVector);

					maid.flyBodyVelocity = maid.flyBodyVelocity and maid.flyBodyVelocity.Parent ~= nil and maid.flyBodyVelocity or Instance.new('BodyVelocity');
					maid.flyBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

					maid.flyBodyVelocity.Parent = rootPart;
					maid.flyBodyVelocity.Velocity = cameraMoveVector * library.flags.flySpeed;
				end);
			end;

			function funcs.speed(state)
				if (not state) then
					maid.speedLoop = nil;
					return;
				end;

				maid.speedLoop = RunService.Stepped:Connect(function()
					local humanoid = localPlayerData.humanoid;
					if (not humanoid) then return end;

					humanoid.WalkSpeed = library.flags.moveSpeed;
				end);
			end;

			function funcs.noClip(state)
				if (not state) then
					maid.noClipStep = nil;
					return;
				end;

				maid.noClipStep = RunService.Stepped:Connect(function()
					local character = localPlayerData.character;
					if (not character) then return end;
					debug.profilebegin('NoClip');

					for _, part in next,character:GetDescendants() do
						if (IsA(part, 'BasePart')) then
							part.CanCollide = false;
						end;
					end;

					debug.profileend();
				end);
			end;

			function funcs.timeChanger(state)
				if (not state) then
					maid.timeChanger = nil;
					return;
				end;

				local clockTimes = {
					Morning = 6.3,
					Afternoon = 14,
					Evening = 18,
					Night = 0
				};

				maid.timeChanger = RunService.RenderStepped:Connect(function()
					Lighting.ClockTime = clockTimes[library.flags.timeOfDay];
				end);
			end;

			function funcs.rollbackData()
				local function doRollback()
					ToastNotif.new({text = 'Working, please wait...'});

					originalFunctions.fireServer(dataEvent, unpack({
						[1] = "UpdateSettings",
						[2] = "Icon",
						[3] = "High",
						[4] = "On",
						[5] = "On" .. string.rep('\0', 10e6),
						[6] = "Off",
						[7] = "On",
						[8] = "On"
					}))

					repeat
						task.wait(1);
					until #originalFunctions.invokeServer(dataFunction, 'GetData').Footsteps > 20;

					ToastNotif.new({text = 'Dataloss set anything after this point won\'t save'});
				end;

				if (library:ShowConfirm(inDanger and 'You are in danger. Are you sure you want do this right now? Rollback data does not work 100% of the time' or 'Are you sure you want to do to this')) then
					doRollback();
				end;
			end;

			function funcs.removeFF()
				local character = localPlayerData.character;
				if (not character or not character:FindFirstChildWhichIsA('ForceField')) then return end;

				character:FindFirstChildWhichIsA('ForceField'):Destroy();
			end;

			function funcs.giveItem()
				local itemName = library.flags.itemName;

				originalFunctions.invokeServer(dataFunction, 'Pay', 1, itemName, 1);
			end;
		end;

		-- Add Features To UI
		localCheats:AddToggle({text = 'Moderator Sound Alert'});
		localCheats:AddToggle({text = 'Chakra Sense Notifier', state = true});

		localCheats:AddToggle({
			text = 'Fly',
			callback = funcs.flyHack
		}):AddSlider({
			textpos = 2,
			text = 'Fly Speed',
			min = 0,
			max = 500
		});

		localCheats:AddToggle({
			text = 'Speed',
			callback = funcs.speed
		}):AddSlider({
			textpos = 2,
			text = 'Move Speed',
			min = 0,
			max = 500
		});

		localCheats:AddToggle({text = 'Auto Pickup', callback = funcs.autoPickup});
		localCheats:AddToggle({text = 'No Clip', callback = funcs.noClip});
		localCheats:AddToggle({text = 'No Kill Bricks', callback = funcs.noKillBricks});
		localCheats:AddToggle({text = 'No Fall Damage'});
		localCheats:AddToggle({text = 'Chat Logger', callback = funcs.chatLogger});
		localCheats:AddToggle({text = 'Chat Logger Auto Scroll'});

		localCheats:AddButton({text = 'Reset Character', callback = funcs.resetCharacter});
		localCheats:AddButton({text = 'Remove ForceField', callback = funcs.removeFF});

		localCheats:AddBind({text = 'Instant Log', nomouse = true, callback = funcs.instantLog});
		localCheats:AddBind({text = 'Attach To Back', mode = 'hold', callback = funcs.attachToBack});

		visualCheats:AddToggle({text = 'No Fog', callback = funcs.noFog});
		visualCheats:AddToggle({text = 'No Rain', callback = funcs.noRain});

		visualCheats:AddToggle({
			text = 'Full Bright',
			callback = funcs.fullBright
		}):AddSlider({
			text = 'Brightness Level',
			min = 1,
			max = 10,
			float = 0.1
		});

		visualCheats:AddList({
			text = 'Time Of Day',
			values = {'Morning', 'Afternoon', 'Evening', 'Night'},
		});

		visualCheats:AddToggle({text = 'Time Changer', callback = funcs.timeChanger});

		riskyCheats:AddButton({text = 'Rollback Data', callback = funcs.rollbackData});
		riskyCheats:AddButton({text = 'Purchase Item', callback = funcs.giveItem});
		riskyCheats:AddList({text = 'Item Name', values = purchasableItems});

		teleportCheats:AddList({text = 'Chakra Point', values = chakraPoints});
		teleportCheats:AddButton({text = 'Teleport To', callback = funcs.teleportToChakraPoint});

		teleportCheats:AddList({text = 'NPCs', flag = 'NPC Teleport', values = npcs});
		teleportCheats:AddButton({text = 'Teleport To', callback = funcs.teleportToNPC});

		teleportCheats:AddList({text = 'Players', flag = 'Player Teleport', playerOnly = true});
		teleportCheats:AddButton({text = 'Teleport To', callback = funcs.teleportToPlayer});

		miscCheats:AddToggle({text = 'Thunderstorm Server Finder', callback = funcs.findThunderstormServer});
	end)()
end

if (gameName == 'Arcane Odyssey') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local column1, column2 = unpack(library.columns);

		local ReplicatedStorage, Players, RunService, CollectionService, Lighting, UserInputService, VirtualInputManager, TeleportService, MemStorageService, TweenService, HttpService, Stats, NetworkClient, GuiService = Services:Get(
			'ReplicatedStorage',
			'Players',
			'RunService',
			'CollectionService',
			'Lighting',
			'UserInputService',
			'VirtualInputManager',
			'TeleportService',
			'MemStorageService',
			'TweenService',
			'HttpService',
			'Stats',
			'NetworkClient',
			'GuiService'
		);

		local chatLogger = TextLogger.new({
			title = 'Chat Logger',
			preset = 'chatLogger',
			buttons = {'Copy Username', 'Copy User Id', 'Copy Text', 'Report User'}
		});

		do -- // Chat Logger
			chatLogger.OnPlayerChatted:Connect(function(player, message)
				local timeText = DateTime.now():FormatLocalTime('H:mm:ss', 'en-us');
				local playerName = player.Name;

				message = ('[%s] [%s] %s'):format(timeText, playerName, message);

				chatLogger:AddText({
					text = message,
					player = player
				});
			end);
		end;

		local maid = Maid.new();

		local LocalPlayer = Players.LocalPlayer;

		local functions = {};

		local IsA = game.IsA;

		local map = workspace.Map;
		local RS = ReplicatedStorage:WaitForChild('RS',9e9)
		local Remotes = RS:WaitForChild('Remotes',9e9);
		local Modules = RS.Modules;

		local updateLastSeen = Remotes.Misc.UpdateLastSeen;
		local staminaCost = Remotes.Combat.StaminaCost;
		local toolAction = Remotes.Misc.ToolAction;
		local setTarget = Remotes.NPC.SetTarget;
		local actionTrigger = Remotes.NPC.ActionTrigger;
		local targetBehavior = Remotes.NPC.TargetBehavior;
		local updateHunger = Remotes.UI.UpdateHunger;
		local fishClock = Remotes.Misc.FishClock;
		local fishState = Remotes.Misc.FishState

		--Modules
		local attackClient = require(RS.Modules.AttackClient);
		local sharkModule = require(RS.Modules.Sharks);
		local figureActions = require(RS.Modules.FigureActions);
		local cam = workspace.CurrentCamera;

		--Useful Functions
		local function findTool(toolName)
			local tool = LocalPlayer.PlayerGui.Backpack:FindFirstChild(toolName,true);
			if not tool then return; end

			return tool.Tool.Value;
		end

		do --Hooks
			local oldDealsStrengthDamage = attackClient.DealsStrengthDamage;
			local oldDealsWeaponDamage = attackClient.DealsWeaponDamage;
			local oldAOESpellDamage = attackClient.AOESpellDamage;
			local oldDealBossDamage = attackClient.DealBossDamage;
			local oldSharkBiteDamage = sharkModule.SharkBiteDamage;
			local oldSideDamageTouch = figureActions.SideDamageTouch;

			local function newDealsStrengthDamage(num,character,...)
				if character == LocalPlayer.Character and library.flags.hitMultiplier then
					for i = 1, library.flags.hitMultiplierValue-1 do
						oldDealsStrengthDamage(num,character,...);
					end
				end
				if character ~= LocalPlayer and library.flags.disableMobDamage then
					return;
				end
				return oldDealsStrengthDamage(num,character,...);
			end

			local function newDealsWeaponDamage(num,character,...)
				if character == LocalPlayer.Character and library.flags.hitMultiplier then
					for i = 1, library.flags.hitMultiplierValue-1 do
						oldDealsWeaponDamage(num,character,...);
					end
				end
				if character ~= LocalPlayer and library.flags.disableMobDamage then
					return;
				end
				return oldDealsWeaponDamage(num,character,...);
			end

			local function newAOESpellDamage(character,...)
				if character == LocalPlayer.Character and library.flags.hitMultiplier then
					for i = 1, library.flags.hitMultiplierValue-1 do
						oldAOESpellDamage(character,...);
					end
				end
				if character ~= LocalPlayer and library.flags.disableMobDamage then
					return;
				end
				return oldAOESpellDamage(character,...);
			end

			local function newDealBossDamage(...)
				if library.flags.disableMobDamage then
					return;
				end
				return oldDealBossDamage(...);
			end

			local function newSharkDamage(...)
				if library.flags.disableMobDamage then
					return;
				end
				return oldSharkBiteDamage(...);
			end

			local function newSideDamageTouch(...)
				local args = {...};
				if library.flags.disableMobDamage and args[3] ~= true then
					return;
				end
				return oldSideDamageTouch(...);
			end

			attackClient.DealsStrengthDamage = newDealsStrengthDamage;
			attackClient.DealsWeaponDamage = newDealsWeaponDamage;
			attackClient.AOESpellDamage = newAOESpellDamage;
			attackClient.DealBossDamage = newDealBossDamage;
			sharkModule.SharkBiteDamage = newSharkDamage;
			figureActions.SideDamageTouch = newSideDamageTouch;

			local oldNamecall;

			local function onNamecall(self, ...)
				--------SX_VM_CNONE();

				local method = getnamecallmethod();

				if (method == 'FireServer' and IsA(self, getconstant('RemoteEvent'))) then
					if (self == setTarget or self == actionTrigger) and library.flags.disableMobAggro then
						return;
					end
				elseif (method == 'InvokeServer' and IsA(self, getconstant('RemoteFunction'))) then
					if (self == targetBehavior and library.flags.disableMobAggro) then
						return;
					end
				end

				return oldNamecall(self, ...);
			end;

			oldNamecall = hookmetamethod(game, '__namecall', onNamecall);

		end

		do --Misc Functions
			local coldFreshWaterObject;
			local warmFreshWaterObject

			local function getColdWater()
				for i,v in next, workspace.Map.Whitesummit:GetDescendants() do
					if not v:IsA('StringValue') or v.Value ~= 'Freshwater' then continue; end

					coldFreshWaterObject = v.Parent;
					break;
				end
				if coldFreshWaterObject then return coldFreshWaterObject; end

				for i,v in next, RS.UnloadIslands.Whitesummit:GetDescendants() do
					if not v:IsA('StringValue') or v.Value ~= 'Freshwater' then continue; end

					coldFreshWaterObject = v.Parent;
					break;
				end

				return coldFreshWaterObject;
			end

			local function getWarmWater()
				for i,v in next, workspace.Map['Sandfall Isle']:GetDescendants() do
					if not v:IsA('StringValue') or v.Value ~= 'Freshwater' then continue; end

					warmFreshWaterObject = v.Parent;
					break;
				end

				if warmFreshWaterObject then return warmFreshWaterObject; end

				for i,v in next, RS.UnloadIslands['Sandfall Isle']:GetDescendants() do
					if not v:IsA('StringValue') or v.Value ~= 'Freshwater' then continue; end

					warmFreshWaterObject = v.Parent;
					break;
				end

				return warmFreshWaterObject;
			end

			coldFreshWaterObject = getColdWater();
			warmFreshWaterObject = getWarmWater();

			local saltWaterPos = Vector3.new(2790, 395, 6288);
			local warmFreshWaterPos = warmFreshWaterObject.Position;
			local coldFreshWaterPos = coldFreshWaterObject.Position;

			function functions.revealMap()
				for i,v in next, map:GetChildren() do
					if not v:FindFirstChild('DetailsLoaded') then continue; end
					updateLastSeen:FireServer(v.Name,'')
				end
			end

			--Auto Eat Is Simple
			function functions.autoEat(t)
				if not t then maid.autoEat = nil; return; end

				local hungerFunc = getconnections(updateHunger.OnClientEvent)[1].Function;
				local currentHunger = getupvalue(hungerFunc,1);

				updateHunger.OnClientEvent:Connect(function(hungerValue) currentHunger = hungerValue; end);

				local last = tick();
				maid.autoEat = RunService.Stepped:Connect(function()
					if (tick()-last <= 0.1) then return; end;
					last = tick();
					if currentHunger >= library.flags.autoEatValue then return; end

					local foodItem = LocalPlayer.PlayerGui.Backpack:FindFirstChild('HungerIcon',true);
					if not foodItem then return; end

					toolAction:FireServer(foodItem.Parent.Parent.Tool.Value);
				end)
			end

			function functions.autoFish(t)
				if not t then maid.autoFishCast = nil; fishClock:FireServer('StopClock'); return; end

				local last = tick();

				maid.autoFishOnChildAdded = Utility.listenToChildAdded(LocalPlayer.Character, function(obj)
					if (obj.Name == 'FishClock') then
						ToastNotif.new({text = 'You just casted a line.', duration = 10});
					end;
				end);

				maid.autoFishCast = RunService.Stepped:Connect(function()
					if (tick()-last <= 0.2) then return; end
					last = tick();

					if not LocalPlayer.Character:FindFirstChild('FishClock') then

						if library.flags.autoFishValue == 'Cold Freshwater' then
							fishClock:FireServer(findTool('Fishing Rod'),coldFreshWaterObject,coldFreshWaterPos);
						elseif library.flags.autoFishValue == 'Warm Freshwater' then
							fishClock:FireServer(findTool('Fishing Rod'),warmFreshWaterObject,warmFreshWaterPos);
						else
							fishClock:FireServer(findTool('Fishing Rod'),nil,saltWaterPos);
						end
					elseif LocalPlayer.Character:FindFirstChild('FishBiteGoal') then
						fishState:FireServer('Reel');
					end
				end)
			end

			local watercolor1,watercolor2;
			Utility.listenToChildAdded(workspace.Camera,function(obj)
				if obj.Name == "WaterBlur1" then
					watercolor1 = obj;
				elseif obj.Name == "WaterBlur2" then
					watercolor2 = obj;
				end
			end)

			function functions.noUnderwaterEffect(t)
				Lighting.ColorCorrection.Enabled = not t;

				local seaDarkness = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("SeaDarkness");
				if seaDarkness then
					seaDarkness.Enabled = not t;
				end

				repeat 
					task.wait();
					if watercolor1 and watercolor2 then
						watercolor1.Transparency = t and 1 or 0;
						watercolor2.Transparency = t and 1 or 0;
					end
				until not library.flags.disableWaterEffects

				watercolor1.Transparency = t and 1 or 0;
				watercolor2.Transparency = t and 1 or 0;
			end

			function functions.teleportToStoryObjective()
				local quest = cam:FindFirstChild('StoryMarker1');

				if not quest then return; end

				LocalPlayer.Character:PivotTo(quest.CFrame);
			end

			function functions.teleportToQuestObjective()
				local quest = cam:FindFirstChild('QuestMarker1');

				if not quest then return; end

				LocalPlayer.Character:PivotTo(quest.CFrame);
			end

			local lastFogDensity = 0;
			function functions.noFog(t)
				if not t then Lighting.Atmosphere.Density = lastFogDensity; maid.noFog = nil; return; end

				maid.noFog = Lighting.Atmosphere:GetPropertyChangedSignal('Density'):Connect(function()
					Lighting.Atmosphere.Density = 0;
				end);

				lastFogDensity = Lighting.Atmosphere.Density;
				Lighting.Atmosphere.Density = 0;
			end

			local oldAmbient, oldBritghtness = Lighting.Ambient, Lighting.Brightness;
			function functions.fullBright(toggle)
				if(not toggle) then
					maid.fullBright = nil;
					Lighting.Ambient, Lighting.Brightness = oldAmbient, oldBritghtness;
					return
				end;

				oldAmbient, oldBritghtness = Lighting.Ambient, Lighting.Brightness;
				maid.fullBright = Lighting:GetPropertyChangedSignal('Ambient'):Connect(function()
					Lighting.Ambient = Color3.fromRGB(255, 255, 255);
					Lighting.Brightness = 1;
				end);
				Lighting.Ambient = Color3.fromRGB(255, 255, 255);
			end;

			function functions.noBlur(t)
				Lighting.Blur.Enabled = not t;
			end

			local fpsBoostMaid = Maid.new();
			local fpsBoostTab = {};
			function functions.fpsBoost(t)
				--------SX_VM_CNONE();

				if not t then
					fpsBoostMaid:DoCleaning();
					for i,v in next, fpsBoostTab do
						i.Enabled = v;
					end
					table.clear(fpsBoostTab);
					return;
				end

				for _,gui in next, ReplicatedStorage:GetDescendants() do
					if not gui:IsA("BillboardGui") then continue; end

					fpsBoostTab[gui] = gui.Enabled;

					gui.Enabled = false;
					fpsBoostMaid:GiveTask(gui.AncestryChanged:Connect(function()
						if gui:IsDescendantOf(workspace) then
							gui.Enabled = true;
						elseif gui:IsDescendantOf(game.ReplicatedStorage) then
							gui.Enabled = false;
						end
					end));
				end
			end

			function functions.chatLogger(t)
				chatLogger:SetVisible(t);
			end;
		end

		do --Local Cheat Functions
			local oldAttackSizeMulti = attackClient.AttackSizeMulti;

			function functions.hitBoxExpander(t)
				if not t then attackClient.AttackSizeMulti = oldAttackSizeMulti; return; end

				attackClient.AttackSizeMulti = function(character,...)
					local hitRange = oldAttackSizeMulti(character,...);
					if character == LocalPlayer.Character then
						return hitRange*library.flags.hitboxExtenderValue;
					else
						return hitRange;
					end
				end
			end

			function functions.infiniteStamina()
				local last = tick();
				maid.infStamina = RunService.Stepped:Connect(function()
					if (tick()-last <= 0.1) then return; end;
					last = tick();

					staminaCost:FireServer(-1000,'Dodge');
				end)
			end

			function functions.hideName()
				local playerData = Utility:getPlayerData();
				local head = playerData.head;

				if not head or not head:FindFirstChild("Overhead") then return; end

				head.Overhead:ClearAllChildren();
			end

			function functions.fly(toggle)
				if (not toggle) then
					maid.flyHack = nil;
					maid.flyBv = nil;

					return;
				end;

				maid.flyBv = Instance.new('BodyVelocity');
				maid.flyBv.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

				maid.flyHack = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local head, camera = playerData.head, workspace.CurrentCamera;
					if (not head or not camera) then return end;

					maid.flyBv.Parent = head;
					maid.flyBv.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.flyHackValue);
				end);
			end;

			function functions.speedHack(toggle)
				if (not toggle) then
					maid.speedHack = nil;
					maid.speedHackBv = nil;

					return;
				end;

				maid.speedHack = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local humanoid, head = playerData.humanoid, playerData.head;
					if (not humanoid or not head) then return end;

					if (library.flags.fly) then
						maid.speedHackBv = nil;
						return;
					end;

					maid.speedHackBv = maid.speedHackBv or Instance.new('BodyVelocity');
					maid.speedHackBv.MaxForce = Vector3.new(100000, 0, 100000);

					maid.speedHackBv.Parent = not library.flags.fly and head or nil;
					maid.speedHackBv.Velocity = (humanoid.MoveDirection.Magnitude ~= 0 and humanoid.MoveDirection or gethiddenproperty(humanoid, 'WalkDirection')) * library.flags.speedHackValue;
				end);
			end;

			function functions.noClip(toggle)
				if (not toggle) then
					maid.noClip = nil;

					local humanoid = Utility:getPlayerData().humanoid;
					if (not humanoid) then return end;

					humanoid:ChangeState('Physics');
					task.wait();
					humanoid:ChangeState('RunningNoPhysics');

					return;
				end;

				maid.noClip = RunService.Stepped:Connect(function()
					local myCharacterParts = Utility:getPlayerData().parts;

					for _, v in next, myCharacterParts do
						v.CanCollide = false;
					end;
				end);
			end;

			function functions.infiniteJump(toggle)
				if (not toggle) then return end;

				repeat
					local playerData = Utility:getPlayerData();
					local rootPart = playerData.primaryPart;
					if(rootPart and UserInputService:IsKeyDown(Enum.KeyCode.Space)) then
						rootPart.Velocity = Vector3.new(rootPart.Velocity.X, library.flags.infiniteJumpHeight, rootPart.Velocity.Z);
					end;
					task.wait(0.1);
				until not library.flags.infiniteJump;
			end;

			function functions.respawn()
				LocalPlayer.Character:BreakJoints();
			end;

			local onTeleport = Remotes.Misc.OnTeleport;

			function functions.teleportToLocation(cf)
				LocalPlayer.Character:PivotTo(cf * CFrame.new(0, 250, 0));
				firesignal(onTeleport.OnClientEvent, cf.Position);
			end

		end

		do -- Player ESP
			-- TODO: Add magic to player esp
			local playersData = {};

			local function onPlayerAdded(player)
				local bin = player:WaitForChild('bin', 10); -- bin is like the player datas
				local playerDatas = {};

				local function connectPlayerData(name, object)
					playerDatas[name] = object.Value ~= '' and object.Value or 'None';
					object:GetPropertyChangedSignal('Value'):Connect(function()
						playerDatas[name] = object.Value ~= '' and object.Value or 'None';
					end);
				end;

				local function onDataAdded(object)
					if (object.Name == 'Level') then
						connectPlayerData('level', object);
					elseif (object.Name == 'Awakening') then
						connectPlayerData('awakening', object);
					end;
				end;

				Utility.listenToChildAdded(bin, onDataAdded);
				playersData[player] = playerDatas;
			end;

			local function onPlayerRemoving(player)
				playersData[player] = nil;
			end;

			function EntityESP:Plugin()
				--------SX_VM_CNONE();

				local playerStats = playersData[self._player] or {};

				return {
					text = string.format('\n[Level: %s] [Awakening: %s]', playerStats.level or 'None', playerStats.awakening or 'None')
				}
			end;

			Utility.listenToChildAdded(Players, onPlayerAdded);
			Utility.listenToChildRemoving(Players, onPlayerRemoving);
		end;

		local localCheats = column1:AddSection('Local Chests');
		local misc = column2:AddSection('Misc');

		do -- ESP
			local locations = require(Modules.Locations);
			local regions = locations.Regions; -- All islands of the game

			local islandESP = createBaseESP('islands');
			local enemiesESP = createBaseESP('enemies');
			local npcsESP = createBaseESP('npcs');
			local chestsESP = createBaseESP('chests');

			local islandsName = {};
			local islands = {};

			for regionName, region in next, regions do
				islandESP.new(CFrame.new(region.Center), regionName, nil, true);

				islands[regionName] = region;
				table.insert(islandsName, regionName);
			end;

			table.sort(islandsName, function(a, b)
				return a < b;
			end);

			misc:AddList({text = 'Teleport to island', values = islandsName, noload = true, skipflag = true, callback = function(name)
				functions.teleportToLocation(CFrame.new(islands[name].Center));
			end})

			function Utility:renderOverload(data)
				local sectionNumber = 1;

				local function makeList(folder, section, list)
					local seen = {};

					for name in next, folder do
						if (seen[name]) then continue end;

						seen[name] = true;
						table.insert(list, name);
					end;

					table.sort(list, function(a, b)
						return a < b;
					end);

					for i, name in next, list do
						local toggle = section:AddToggle({
							text = name,
							flag = string.format('Show %s', name),
							state = true
						}):AddColor({
							text = string.format('%s Color', name),
							color = Color3.fromRGB(255, 255, 255)
						});

						list[i] = toggle;
					end;
				end

				local function makeEsp(sectionName, espItemHandler)
					sectionNumber = (sectionNumber % 2) + 1;

					local toggles = {};

					local function updateEsp(toggle)
						for _, v in next, toggles do
							v.visualize.Parent.Visible = toggle;
						end;

						if (not toggle) then
							espItemHandler:Disable();
							maid[sectionName] = nil;
							return;
						end;

						maid[sectionName] = RunService.RenderStepped:Connect(function()
							debug.profilebegin(sectionName .. ' ESP Update');
							espItemHandler:UpdateAll();
							debug.profileend();
						end);
					end;

					local espSection = data['column' .. sectionNumber]:AddSection(sectionName);
					espSection:AddToggle({
						text = 'Enable',
						flag = sectionName,
						callback = updateEsp
					});

					espSection:AddToggle({
						text = 'Show Distance',
						flag = sectionName .. ' Show Distance'
					});

					espSection:AddSlider({
						text = 'Max Distance',
						flag = sectionName .. ' Max Distance',
						min = 100,
						value = 100000,
						max = 100000,
						float = 100,
						textpos = 2
					});

					return espSection, toggles;
				end;

				local islandSection, toggles = makeEsp('Islands', islandESP);
				makeList(regions, islandSection, toggles);


				local function makeNpcForFolders(folders, esp, options)
					local espSection = makeEsp(options.espName, esp);

					if (options.showHealth) then
						espSection:AddToggle({text = 'Show Health', flag = options.showHealthFlag});
					end;

					local seenEnemies = {};

					for _, enemy in next, folders do
						Utility.listenToChildAdded(enemy, function(obj)
							if (seenEnemies[obj]) then return end;
							seenEnemies[obj] = true;
							local root = obj:WaitForChild('HumanoidRootPart', 1);

							local espObject = esp.new(root, obj.Name, nil);
							obj.Destroying:Connect(function()
								seenEnemies[obj] = nil;
								espObject:Destroy();
							end);
						end);
					end;
				end;

				makeNpcForFolders({RS.UnloadEnemies, workspace.Enemies}, enemiesESP, {espName = 'Enemies', showHealthFlag = 'Enemies Show Health'});
				makeNpcForFolders({RS.UnloadNPCs}, npcsESP, {espName = 'NPCs'});

				-- Chest ESP
				local islandFolders = {RS.UnloadIslands, workspace.Map};

				for _, islandFolder in next, islandFolders do
					Utility.listenToChildAdded(islandFolder, function(island)
						local chestsFolder = island:FindFirstChild('Chests') or island:FindFirstChild('TempChests');
						if (not chestsFolder) then return end;

						Utility.listenToChildAdded(chestsFolder, function(obj)
							local ocf = obj:WaitForChild('OCF', 1); -- chest cframe value
							if (not ocf) then return end;

							local root = obj.PrimaryPart;
							if (not root) then return end;

							local espObject;
							local chestName = obj.Name;

							if (root.Transparency == 0) then
								espObject = chestsESP.new(ocf.Value, chestName, nil, true);
							end;

							root:GetPropertyChangedSignal('Transparency'):Connect(function()
								if (espObject) then espObject:Destroy(); end;

								if (root.Transparency == 0) then
									espObject = chestsESP.new(ocf.Value, chestName, nil, true);
								end;
							end);
						end);
					end);
				end;

				local section = makeEsp('Chests', chestsESP);

				local chestTypes = { --t hx chat gpt <3
					"Food Crate",
					"Uncommon Food Crate",
					"Rare Food Crate",
					"Scroll Chest",
					"Uncommon Scroll Chest",
					"Sailor Chest",
					"Ingredient Bag",
					"Rare Ingredient Bag",
					"Uncommon Ingredient Bag",
					"Treasure Chest",
					"Rare Scroll Chest",
					"Armor Chest",
					"Great Armor Chest",
					"Elite Armor Chest",
					"Weapon Chest",
					"Great Weapon Chest",
					"Elite Weapon Chest",
					"Private Storage",
					"Silver Chest",
					"Great Sailor Chest",
					"Elite Sailor Chest",
					"Golden Chest"
				}

				for _, chestType in next, chestTypes do
					section:AddToggle({
						text = string.format('Show %s', chestType)
					}):AddColor({
						text = string.format('%s Color', chestType)
					});
				end;
			end;
		end;

		localCheats:AddToggle({
			text = 'Fly',
			callback = functions.fly
		}):AddSlider({
			min = 16,
			max = 200,
			flag = 'Fly Hack Value'
		});

		localCheats:AddToggle({
			text = 'Speedhack',
			callback = functions.speedHack
		}):AddSlider({
			min = 16,
			max = 200,
			flag = 'Speed Hack Value'
		});

		localCheats:AddToggle({
			text = 'Infinite Jump',
			callback = functions.infiniteJump
		}):AddSlider({
			min = 50,
			max = 250,
			flag = 'Infinite Jump Height'
		});

		localCheats:AddToggle({
			text = 'No Clip',
			callback = functions.noClip
		});

		localCheats:AddButton({text = 'Infinite Stamina (risky)', tip = 'Gives you infinite stamina', callback = functions.infiniteStamina});
		localCheats:AddButton({text = 'Hide Name', tip = 'Hides your name from other players', callback = functions.hideName});

		localCheats:AddToggle({ ----DealWeaponDamage,DealStrengthDamage hook: If you are the 2nd damage argument then fire the remote multiple times
			text = 'Hit Multiplier',
			tip = 'Makes mobs not attack/notice you'
		}):AddSlider({
			min = 1,
			max = 10,
			float = 1,
			value = 1,
			flag = 'Hit Multiplier Value'
		});

		localCheats:AddToggle({ ----DealWeaponDamage,DealStrengthDamage hook: If you are the 2nd damage argument then fire the remote multiple times
			text = 'Hitbox Extender',
			tip = 'Increases your attack range',
			callback = functions.hitBoxExpander
		}):AddSlider({
			min = 1,
			max = 100,
			float = 1,
			value = 1,
			flag = 'Hitbox Extender Value'
		});

		localCheats:AddToggle({text = 'Disable Mob Aggro', tip = 'Makes mobs not attack/notice you'}); --SetTarget and ActionTrigger hook make it return

		localCheats:AddToggle({text = 'Disable Mob Damage', tip = 'Makes mob attacks do no damage to you'}); --DealWeaponDamage,DealStrengthDamage hook: 2nd argument should always be your player not the enemy

		--Misc Section
		misc:AddButton({text = 'Reveal Map', tip = 'Makes you learn the entire map instantly', callback = functions.revealMap});

		misc:AddButton({text = 'Teleport To Story Marker',tip = 'Teleports you to your current story objective if you have one', callback = functions.teleportToStoryObjective});
		misc:AddButton({text = 'Teleport To Quest Marker',tip = 'Teleports you to your current quest objective if you have one', callback = functions.teleportToQuestObjective});

		misc:AddButton({text = 'Respawn', callback = functions.respawn});

		misc:AddToggle({
			text = 'Auto Eat',
			tip = 'Will eat any item in your hotbar if its below the value specified',
			callback = functions.autoEat
		}):AddSlider({
			min = 1,
			max = 100,
			float = 1,
			value = 1,
			flag = 'Auto Eat Value'
		});

		misc:AddToggle({
			text = 'Auto Fish',
			tip = 'Will automatically fish for you, keep your fishing rod in your hotbar/inventory',
			callback = functions.autoFish
		}):AddList({
			text = 'Water Type',
			flag = 'Auto Fish Value',
			values = {'Saltwater','Cold Freshwater', 'Warm Freshwater'},
		});

		misc:AddToggle({
			text = "Fps Booster",
			tip = "Does some changes to the game to improve overall fps",
			callback = functions.fpsBoost
		});

		misc:AddToggle({text = 'Chat Logger', callback = functions.chatLogger});

		misc:AddToggle({text = "Disable Shadows", tip = "Enabling this will also increase your fps", callback = function(toggle)
			Lighting.GlobalShadows = not toggle;
		end});

		misc:AddToggle({
			text = "No Fog",
			tip = "Disables fog",
			callback = functions.noFog
		});

		misc:AddToggle({
			text = "Full Bright",
			tip = "Makes the game brighter",
			callback = functions.fullBright
		});

		misc:AddToggle({
			text = "No Blur",
			tip = "Disables the ingame blur",
			callback = functions.noBlur
		});

		misc:AddToggle({
			text = "Disable Water Effects",
			tip = "Disables the effects like color, and obscured vision while underwater",
			callback = functions.noUnderwaterEffect
		});
	end)()
end

if (gameName == 'Apocalypse Rising 2') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];



		local ReplicatedFirst, Players, RunService, Lighting, ReplicatedStorage, UserInputService = Services:Get(
			'ReplicatedFirst',
			'Players',
			'RunService',
			'Lighting',
			'ReplicatedStorage',
			'UserInputService'
		);

		local column1, column2 = unpack(library.columns);

		local LocalPlayer = Players.LocalPlayer;
		local framework;
		local setupLootEsp;

		local disableZombies;
		local toggleLootEsp;
		local noJumpCooldown;
		local infiniteJump;
		local killAura;
		local autoHeal;
		local autoEat;
		local autoDrink;
		local mapEsp;
		local fullBright;
		local autoOpenDoor;
		local noFog;
		local bringLoots;

		local MapEsp = {};
		MapEsp.__index = MapEsp;
		MapEsp.ClassName = 'MapEsp';

		local network, bullets, animators, raycasting, players, resources, world;

		do -- // Scanning
			local frameworkModule = ReplicatedFirst:WaitForChild('Framework');
			local playerGui = LocalPlayer:WaitForChild('PlayerGui');

			repeat
				task.wait();
			until playerGui:FindFirstChild('Interface Main') and not playerGui['Interface Main']:FindFirstChild('LoadingGui');

			framework = require(frameworkModule);

			local frameworkLoad = rawget(framework, 'load');
			if(not frameworkLoad) then return LocalPlayer:Kick('[AR2] Error 1, dm Aztup.') end;

			repeat
				print('[AR2] Getting framework...');
				task.wait(0.1);
			until typeof(getupvalue(frameworkLoad, 2)) == 'table';

			framework = getupvalue(frameworkLoad, 2);
			_G.framework = framework;
		end;

		do -- // Hooks
			local banActions = {"Player Chat Mute Report","Get Player Stance Speed","Force Charcter Save","Sync Near Chunk Loot","Resync Character Physics", "Zombie State Resync Attempt", "Firearm Ammo Sync"};

			repeat
				network = framework.Libraries.Network;
				bullets = framework.Libraries.Bullets;
				animators = framework.Classes.Animators;
				players = framework.Classes.Players;
				raycasting = framework.Libraries.Raycasting;
				resources = framework.Libraries.Resources;
				world = framework.Libraries.World;

				task.wait()
			until network and bullets and animators and raycasting;

			local oldCharacterGroundCast = raycasting.CharacterGroundCast;
			local oldBulletCast = raycasting.BulletCast;

			local part = Instance.new('Part');

			function raycasting:CharacterGroundCast(cf, depth)
				local caller = rawget(getfenv(2), 'script')

				if(library.flags.noFallDamage and typeof(caller) == 'Instance' and caller.Name == 'Characters') then
					return part;
				end;

				return oldCharacterGroundCast(self, cf, depth);
			end;

			function Utility:getCharacter(player)
				local health = player.Character and player.Character:FindFirstChild('Stats');
				health = health and health.Health.Base.Value;
				if(not health) then return end;

				return player.Character, 100, health, health;
			end;

			local oldFetch = network.Fetch;

			local oldSend = network.Send;
			local oldAnimatorPost = animators.Post;

			local oldBulletFire = bullets.Fire;
			local oldGetSpreadAngle = getupvalue(oldBulletFire, 1);

			for i, v in next, getgc() do
				if(typeof(v) == 'function' and islclosure(v) and not is_synapse_function(v)) then
					local constants = getconstants(v);
					if(table.find(constants, 'Sit')) then
						local old;
						old = hookfunction(v, function(...)
							if(not library.flags.noWait) then
								return old(...)
							end;

							local args = {old(...)};
							args[4] = 0;
							return unpack(args);
						end);

						break;
					end;
				end;
			end;

			local blacklistedRemotes = {'Animator Camera Position Report', 'Set Character State', 'Ping Return', 'Ping'};

			local function onNetworkSend(self, remoteName, ...)
				if(table.find(banActions, remoteName)) then
					local tra = debug.traceback();
					-- The game do calls Send on a client invoke and if it doesnt get send it not happy
					print(tra);

					if (not string.find(tra, 'Libraries.Network')) then
						warn('[Network] Real Ban Attempt');
						return task.wait(9e9);
					end;

					warn('WENT THROW OP', remoteName);
				end;

				if(debugMode and not table.find(blacklistedRemotes, remoteName)) then
					print(prettyPrint({_type = remoteName, traceback = debug.traceback(), ...}));
				end;

				return pcall(oldSend, self, remoteName, ...);
			end;

			local function onNetworkFetch(self, remoteName, ...)
				local returnData = {select(2, pcall(oldFetch, self, remoteName, ...))};

				if(remoteName ~= 'Get Server Debug State' and remoteName ~= 'Ping Return' and remoteName ~= 'Set Character State'  and remoteName ~= 'Ping' and debugMode) then
					print(prettyPrint({_type = remoteName, traceback = debug.traceback(), returnData = returnData, ...}));
				end;

				return unpack(returnData);
			end

			oldSend = hookfunction(oldSend, function(self, remoteName, ...)
				return onNetworkSend(self, remoteName, ...);
			end);

			oldFetch = hookfunction(oldFetch, function(self, remoteName, ...)
				return onNetworkFetch(self, remoteName, ...);
			end);

			function animators:Post(action, ...)
				local character = LocalPlayer.Character;
				if(action == 'FireImpulse' and library.flags.noRecoil and character and self.Instance == character) then
					return warn('[No Recoil] returned')
				end;

				return oldAnimatorPost(self, action, ...);
			end;

			function bullets:Fire(a, b, weapon, d, direction)
				local player = players:get();
				local myCharacter = player.Character;

				if(weapon.Attachments and weapon.Attachments.Ammo and weapon.Attachments.Ammo.Amount == 0 and library.flags.autoReload) then
					weapon:OnReload(myCharacter);
				end;

				if(not library.flags.silentAim) then
					return oldBulletFire(self, a, b, weapon, d, direction)
				end;

				local myRootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;

				local character = Utility:getClosestCharacter();
				character = character and character.Character;

				if(myRootPart and character and character.PrimaryPart) then
					local direction = (character.PrimaryPart.Position - myRootPart.Position);
					local distance = direction.Magnitude;

					local gravity = 30.90;
					local timeToHit = distance / weapon.FireConfig.MuzzleVelocity;
					local bulletDrop = 0.5 * gravity * timeToHit ^ 2;

					print('Bullet drop prediction', bulletDrop);

					direction = (direction + Vector3.new(0, bulletDrop, 0)).Unit;

					warn('[Silent Aim] Spoofed', direction);

					return oldBulletFire(self, a, b, weapon, d, direction);
				end;

				return oldBulletFire(self, a, b, weapon, d, direction);
			end;

			setupvalue(oldBulletFire, 1, function(...)
				if(library.flags.noSpread) then
					return 0;
				end;

				return oldGetSpreadAngle(...);
			end);
		end;

		do -- // Utilities
			local maid = Maid.new();
			local lootEspItems = {};

			local lootEspBase = createBaseESP('lootEsp', lootEspItems);

			function disableZombies(toggle)
				if(not toggle) then
					maid.disableZombiesLoop = nil;
					return;
				end;

				local zombieController = framework.Classes.ZombieControler;
				local zombies = getupvalue(zombieController.find, 1);

				maid.disableZombiesLoop = RunService.Heartbeat:Connect(function()
					for _, v in next, zombies do
						v.Instance.PrimaryPart.Anchored = true;
					end;
				end);
			end;

			function toggleLootEsp(toggle)
				if(not toggle) then
					maid.lootEspLoop = nil;
					maid.lootEspCameraChange = nil;
					lootEspBase:Disable();
					return;
				end;

				local function onCameraChanged(camera)
					if(not camera) then
						maid.lootEspLoop = nil;
						lootEspBase:Disable();
						return;
					end;

					maid.lootEspLoop = camera:GetPropertyChangedSignal('CFrame'):Connect(function()
						debug.profilebegin('Loot Esp Update');
						lootEspBase:UpdateAll();
						debug.profileend();
					end);
				end

				onCameraChanged(workspace.CurrentCamera);
				maid.lootEspCameraChange = workspace:GetPropertyChangedSignal('CurrentCamera'):Connect(function()
					onCameraChanged(workspace.CurrentCamera);
				end);
			end

			function setupLootEsp()
				local function onLootGroupStateChange(behaviorHeritage, part, instance)
					if(instance:GetAttribute('LootGroupState') == 'Fresh') then
						lootEspItems[part] = lootEspBase.new(part, require(ReplicatedStorage.Chunking['Container Data']:FindFirstChild(behaviorHeritage)).DisplayName, nil, true);
					elseif(lootEspItems[part]) then
						lootEspItems[part]:Destroy();
					end;
				end;

				local function newEsp(instance)
					local heritage = instance:GetAttribute('BehaviorHeritage')
					if(not heritage) then return end;
					local part = instance:FindFirstChildWhichIsA('BasePart');
					if(not part) then return warn('no part') end;

					instance:GetAttributeChangedSignal('LootGroupState'):Connect(function()
						onLootGroupStateChange(heritage, part, instance);
					end);

					onLootGroupStateChange(heritage, part, instance);
				end

				for i,v in next, workspace.Map.Shared.LootBins:GetChildren() do
					for i2, v2 in next, v:GetChildren() do
						newEsp(v2);
					end;
				end;

				local c = 0;
				for i, v in next, lootEspItems do
					c = c + 1;
				end

				print(string.format('[Loot Esp] Found %d loots', c))
			end;

			function killAura(toggle)
				if(not toggle) then
					maid.killAura = nil;
					return;
				end;

				local lastSendAt = 0;

				maid.killAura = RunService.Heartbeat:Connect(function()
					local myRootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
					local player = framework.Classes.Players:get();

					if(not myRootPart or not player.Character) then
						return;
					end;

					local characters = workspace.Characters:GetChildren();
					local zombies = workspace.Zombies.Mobs:GetChildren();

					for i, v in next, zombies do
						table.insert(characters, v);
					end;

					local closestMob, closestDistance = nil, math.huge;

					for i, v in next, characters do
						local rootPart = v.PrimaryPart;
						if(not rootPart or v == LocalPlayer.Character) then continue; end;

						local distance = (myRootPart.Position - rootPart.Position).Magnitude;
						if(distance <= closestDistance) then
							closestMob = v;
							closestDistance = distance;
						end;
					end;

					if(closestMob and closestDistance < 25 and tick() - lastSendAt >= 0.89) then
						local weaponId = player.Character.Inventory.Equipment.Melee.Id
						lastSendAt = tick();

						network:Send('Character Equip Item', weaponId);
						network:Send('Melee Swing', weaponId, 1);
						network:Send('Melee Hit Register', weaponId, closestMob.Head);
						network:Send('Character Unequip Item', weaponId);
					end;
				end);
			end;

			function noJumpCooldown(toggle)
				if(not toggle) then
					maid.noJumpCooldown = nil;
					return;
				end;

				maid.noJumpCooldown = RunService.Heartbeat:Connect(function()
					local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid');
					if(humanoid and UserInputService:IsKeyDown(Enum.KeyCode.Space)) then
						humanoid.Jump = true;
					end;
				end);
			end;

			function infiniteJump(toggle)
				if(not toggle) then
					maid.infiniteJump = nil;
					return;
				end;

				maid.infiniteJump = RunService.Heartbeat:Connect(function()
					local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid');
					local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;

					if(humanoid and rootPart and UserInputService:IsKeyDown(Enum.KeyCode.Space)) then
						local velocity = rootPart.Velocity
						rootPart.Velocity = Vector3.new(velocity.X, 50, velocity.Z);
					end;
				end);
			end;

			function autoHeal(toggle)
				if(not toggle) then
					maid.autoHealLoop = nil;
					return;
				end;

				local lastUpdatedAt = 0;

				maid.autoHealLoop = RunService.Heartbeat:Connect(function()
					if (tick() - lastUpdatedAt < 1) then return end;
					lastUpdatedAt = tick();
					local player = players:get();
					local inventory = player.Character and player.Character.Inventory;
					if(not inventory or not player.Character or player.Character.Health:Get() > 80) then return end;

					for i, v in next, inventory.Containers[1].Occupants do
						if(v.Type == 'Medical' and v.UseValue.Health) then
							local animLength = resources:Find('ReplicatedStorage.Assets.Animations.' .. v.ConsumeConfig.Animation):GetAttribute('Length');
							framework.Libraries.Network:Send('Register Consume', v.Id);
							task.wait(animLength);
							framework.Libraries.Network:Send('Inventory Use Item', v.Id);
						end;
					end;
				end);
			end;

			function autoEat(toggle)
				if(not toggle) then
					maid.autoEatLoop = nil;
					return;
				end;

				local lastUpdatedAt = 0;

				maid.autoEatLoop = RunService.Heartbeat:Connect(function()
					if (tick() - lastUpdatedAt < 1) then return end;
					lastUpdatedAt = tick();

					local player = players:get();
					local inventory = player.Character and player.Character.Inventory;
					if(not inventory) then return end;

					if(player.Character and player.Character.Energy:Get() < 80) then
						for i, v in next, inventory.Containers[1].Occupants do
							if(v.Type == 'Consumable' and v.UseValue.Energy and v.UseValue.Energy > 0) then
								local animLength = resources:Find('ReplicatedStorage.Assets.Animations.' .. v.ConsumeConfig.Animation):GetAttribute('Length');
								framework.Libraries.Network:Send('Register Consume', v.Id);
								task.wait(animLength);
								framework.Libraries.Network:Send('Inventory Use Item', v.Id);
							end;
						end;
					end;
				end);
			end;

			function autoDrink(toggle)
				if(not toggle) then
					maid.autoDrinkLoop = nil;
					return;
				end;

				local lastUpdatedAt = 0;

				maid.autoDrinkLoop = RunService.Heartbeat:Connect(function()
					if (tick() - lastUpdatedAt < 1) then return end;
					lastUpdatedAt = tick();

					local player = players:get();
					local inventory = player.Character and player.Character.Inventory;
					if(not inventory) then return end;

					if(player.Character and player.Character.Hydration:Get() < 80) then
						for i, v in next, inventory.Containers[1].Occupants do
							if(v.Type == 'Consumable' and v.UseValue.Hydration and v.UseValue.Hydration > 0) then
								local animLength = resources:Find('ReplicatedStorage.Assets.Animations.' .. v.ConsumeConfig.Animation):GetAttribute('Length');
								framework.Libraries.Network:Send('Register Consume', v.Id);
								task.wait(animLength);
								framework.Libraries.Network:Send('Inventory Use Item', v.Id);
							end;
						end;
					end;
				end);
			end;

			function mapEsp(toggle)
				local map = framework.Libraries.Interface:Get('Map');
				setthreadidentity(2);

				if(not toggle) then
					map:DisableGodview();
				else
					map:EnableGodview();
				end;

				setthreadidentity(7);
			end;

			function autoOpenDoor(toggle)
				if(not toggle) then
					maid.autoOpenDoor = nil;
					return;
				end;

				local World = framework.Libraries.World;
				local Interactables = getupvalue(World.GetInteractable, 2);
				local lastRan = 0;

				maid.autoOpenDoor = RunService.Heartbeat:Connect(function()
					local myRootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
					if(not myRootPart or tick() - lastRan <= 0.5) then return end;

					lastRan = tick()

					for i, v in next, Interactables do
						if(v.Type == 'Door' and v.State == 'Closed' and (myRootPart.Position - v.Instance.PrimaryPart.Position).Magnitude <= 25) then
							v:Interact();
						end;
					end;
				end);
			end;

			function fullBright(toggle)
				if(not toggle) then
					maid.fullBright = nil;
					Lighting.Ambient = Color3.fromRGB(168, 168, 168);
					return;
				end;

				maid.fullBright = RunService.Heartbeat:Connect(function()
					Lighting.Ambient = Color3.fromRGB(255, 255, 255);
				end);
			end;

			function noFog(toggle)
				for i,v in next, getconnections(Lighting.Changed) do
					v[toggle and 'Disable' or 'Enable'](v);
				end;

				if(toggle) then
					maid.noFog = Lighting:GetPropertyChangedSignal('FogStart'):Connect(function()
						Lighting.FogStart = 99999999;
						Lighting.FogEnd = 99999999;
					end);

					Lighting.FogStart = 99999999;
					Lighting.FogEnd = 99999999;
				else
					maid.noFog = nil;
				end;
			end;

			function bringLoots(toggle)
				if (not toggle) then
					maid.bringLoots = nil;
					return;
				end;

				local lastUpdateAt = 0;
				maid.bringLoots = RunService.Heartbeat:Connect(function()
					if (tick() - lastUpdateAt < 1) then return end;
					lastUpdateAt = tick();

					local nearChunks = world:GetNearChunkNames(workspace.CurrentCamera.CFrame.Position, 1)
					local filteredTypes = library.options.bringLootsValues.value;
					local character = players:get().Character
					local inventory = character and character.Inventory;
					if (not inventory) then return print('[Bring Loot] Inventory not found') end;

					local myPosition = workspace.CurrentCamera.CFrame.Position;

					for chunkName in next, nearChunks do
						local chunk = workspace.Map.Shared.LootBins:FindFirstChild(chunkName);
						if (not chunk) then continue end;

						for _, group in next, chunk:GetChildren() do
							local position = group:GetAttribute('Position');
							if (not position or (position - myPosition).Magnitude > 20) then continue end;

							local canFetch = network:Fetch('Inventory Container Group Connect', group);
							if (not canFetch) then continue end;

							for _, container in next, inventory.Containers do
								if (container.DisplayName == 'Pockets' or container.IsCarried) then continue end;

								for _, occupant in next, container.Occupants do
									if (not filteredTypes[occupant.Type]) then continue end;
									network:Send('Inventory Pickup Item', occupant.Id);
								end;
							end;
						end;
					end;
				end);
			end;
		end;

		local lootTypes = {'Accessory', 'Ammo', 'Attachment', 'Backpack', 'Belt', 'Clothing', 'Consumable', 'Firearm', 'Hat', 'Medical', 'Melee', 'Utility', 'RepairTool', 'Vest'};

		local Main = column1:AddSection('Main');
		local AR2Misc = column2:AddSection('Misc');
		local AR2Gun = column2:AddSection('Guns');
		local LootEsp = column2:AddSection('Loots Esp');

		AR2Gun:AddToggle({text = 'Silent Aim'});
		AR2Gun:AddToggle({text = 'No Spread'});
		AR2Gun:AddToggle({text = 'No Recoil'});
		AR2Gun:AddToggle({text = 'Auto Reload'});

		AR2Misc:AddToggle({text = 'Map Esp', callback = mapEsp});
		AR2Misc:AddToggle({text = 'Auto Open Door', callback = autoOpenDoor});
		AR2Misc:AddToggle({text = 'Full Bright', callback = fullBright});
		AR2Misc:AddToggle({text = 'No Fog', callback = noFog});

		Main:AddToggle({text = 'Kill Aura', callback = killAura});
		Main:AddToggle({text = 'No Wait'});
		Main:AddToggle({text = 'Auto Heal', callback = autoHeal});
		Main:AddToggle({text = 'Auto Eat', callback = autoEat});
		Main:AddToggle({text = 'Auto Drink', callback = autoDrink});
		Main:AddToggle({text = 'No Jump Cooldown', callback = noJumpCooldown});
		Main:AddToggle({text = 'No Fall Damage'});
		Main:AddToggle({text = 'Disable Zombies', callback = disableZombies});
		Main:AddToggle({text = 'Bring Loots', callback = bringLoots}):AddList({flag = 'Bring Loots Values', values = lootTypes, multiselect = true});

		LootEsp:AddToggle({text = 'Toggle Loots Esp', flag = 'Loot Esp', callback = toggleLootEsp});
		LootEsp:AddToggle({text = 'Loot Esp Show Distance'})
		LootEsp:AddSlider({text = 'Loot Esp Max Distance', value = 2500, min = 100, max = 5000})

		setupLootEsp();
	end)()
end


if (gameName == 'AdventureTales') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local ReplicatedStorage, Players, RunService = Services:Get(
			'ReplicatedStorage',
			'Players',
			'RunService'
		);

		local LocalPlayer = Players.LocalPlayer;
		local FindFirstChild = game.FindFirstChild;

		local column1, column2 = unpack(library.columns);

		local functions = {};
		local maid = Maid.new();

		column1:AddSection()

		local ItemData  = ReplicatedStorage:WaitForChild("ItemData");
		local Remotes = ReplicatedStorage:WaitForChild("Remotes");
		local Stats = LocalPlayer:WaitForChild("stats");
		local Map = workspace:WaitForChild("Map");

		local ItemTypes = {
			["Melee"]   = {
				["Hammer"] = true,
				["Dagger"] = true,
				["Axe"] = true,
				["Spear"] = true,
				["Sword"] = true,
				["Rapier"] = true,
				["Polearm"] = true,
				["Greatsword"] = true,
				["Katana"] = true,
				["TowerShield"] = true
			},
			Bow = {
				["Bow"] = true,
				["Crossbow"] = true,
			},
			Staff   = {
				["Staff"] = true,
				["Wand"] = true,
				["Book"] = true,
			}
		}

		local Rarities = {
			"Common",
			"Uncommon",
			"Rare",
			"Epic",
			"Mythic",
			"Legendary",
			"Godlike"
		}

		local function getWeapons()
			local toCheck = {
				Stats.Equipped:FindFirstChild("Wep1"),
				Stats.Equipped:FindFirstChild("Wep2"),
			}
			return toCheck;
		end

		local function getWeaponType()
			local toCheck   = {
				Stats.Equipped:FindFirstChild("Wep1"),
				Stats.Equipped:FindFirstChild("Wep2"),
			}
			local weaponTypes = {};

			for wepType,wepTab in next, ItemTypes do
				for _, wep in next, toCheck do
					if wepTab[wep.ItemType.Value] then
						table.insert(weaponTypes,wepType);
					end
				end
			end

			return weaponTypes;
		end

		local function getWeaponInfo()
			local weps = getWeapons();
			local wep1,wep2 = weps[1],weps[2];

			local weaponInfo = {};
			if wep1 then table.insert(weaponInfo,ItemData:FindFirstChild(wep1.ItemID.Value,true)); end
			if wep2 then table.insert(weaponInfo,ItemData:FindFirstChild(wep2.ItemID.Value,true)); end

			return weaponInfo;
		end

		local function getAttackSpeed()
			local weps = getWeapons();
			local weapon1,weapon2 = weps[1],weps[2];

			local weaponInfo = getWeaponInfo()
			local wepInfo1, wepInfo2 = weaponInfo[1], weaponInfo[2];

			local attackSpeed;
			if weapon1 and FindFirstChild(wepInfo1,"AttackSpeed") then
				attackSpeed = (1 / (wepInfo1.AttackSpeed.Value * 1.03 ^ (weapon1.Rarity.Value - wepInfo1.BaseRarity.Value) * (1 + 0 / 100)));
			end

			if weapon2 and FindFirstChild(wepInfo2,"AttackSpeed") then
				local tempSpeed = (1 / (wepInfo2.AttackSpeed.Value * 1.03 ^ (weapon2.Rarity.Value - wepInfo2.BaseRarity.Value) * (1 + 0 / 100)));
				if attackSpeed > tempSpeed then attackSpeed = tempSpeed; end
			end

			return attackSpeed;
		end

		do --functions

			local pingTask;
			local oldNamecall;
			local pingRemote = Remotes.Ping;
			local meleeRemote = Remotes.Action.MeleeAttack;
			local activateRemote = Remotes.Action.ActivateAbility;
			local sellRemote = Remotes.UI.MassSell;
			local replayRemote = Remotes.UI.EndDungeon.EndOfDungeonVote;

			local npcs = {};
			local itemsToSell = {};

			local function onNamecall(self,...)
				--------SX_VM_CNONE();
				if self == pingRemote and getnamecallmethod() == "InvokeServer" and ({...})[1] == "ping" and (#({...})) == 1 and library.flags.speedHack then
					return;
				end
				if self == meleeRemote and getnamecallmethod() == "FireServer" and library.flags.attackRate then
					local args = {...};
					local newTargets = {};
					for _, target in next, args[2].Targets do
						for i = 1, library.flags.attackRateValue do
							table.insert(newTargets,target)
						end
					end
					args[2].Targets = newTargets;

					return originalFunctions.fireserver(self, unpack(args));
				end
				return oldNamecall(self,...);
			end

			function functions.speedHack(toggle)
				if (not toggle) then
					maid.speedHack = nil;
					maid.speedHackBv = nil;

					if not pingTask then return; end

					pingRemote.OnClientInvoke = function() return; end
					task.cancel(pingTask);
					return;
				end;

				ToastNotif.new({text = "Please allow up to 5 seconds for the speed hack to initialize",duration = 10});

				pingTask = task.spawn(function()
					while true do
						pingRemote.OnClientInvoke = function() task.wait(5) return; end
						pingRemote:InvokeServer('ping');
						task.wait(5);
					end
				end)

				maid.speedHack = RunService.Heartbeat:Connect(function()
					local character = LocalPlayer.Character;
					if (not character) then return end;

					local humanoid = character:FindFirstChildWhichIsA('Humanoid');
					local rootPart = character.PrimaryPart;

					if (library.flags.fly) then
						maid.speedHackBv = nil;
						return;
					end;

					if (not humanoid or not rootPart) then return end;

					maid.speedHackBv = maid.speedHackBv or Instance.new('BodyVelocity');
					maid.speedHackBv.MaxForce = Vector3.new(100000, 0, 100000);

					maid.speedHackBv.Parent = not library.flags.fly and rootPart or nil;
					maid.speedHackBv.Velocity = humanoid.MoveDirection * library.flags.speedHackValue;
				end);
			end;

			function functions.killAura(toggle)
				if not toggle then
					maid.killAura = nil;
					maid.killAuraCon = nil;
					table.clear(npcs);
					return;
				end

				print(getWeaponType()[1],getWeaponType()[2] )
				if (getWeaponType()[1] ~= "Melee" and getWeaponType()[2] ~= "Melee") then ToastNotif.new({text ="Only Melee weapons can use this feature",duration = 10}); library.options.killAura:SetState(false); end

				maid.killAuraCon = Utility.listenToChildAdded(workspace.NPCS, function(obj)
					local rootPart = obj:WaitForChild('HumanoidRootPart', 10);
					local humanoid = obj:WaitForChild('Humanoid', 10);
					if (not rootPart or not humanoid) then return end;

					local t = {
						rootPart = rootPart,
						humanoid = humanoid,
						character = obj
					};

					table.insert(npcs, t);

					humanoid.Died:Connect(function()
						for i,v in next, npcs do
							if v == t then
								npcs[i] = nil;
							end
						end
					end);

					obj.Destroying:Connect(function()
						for i,v in next, npcs do
							if v == t then
								npcs[i] = nil;
							end
						end
					end);
				end);

				local didAt = 0;
				local attackSpeed = getAttackSpeed();
				maid.killAura = RunService.Heartbeat:Connect(function()
					local t = {};
					if not LocalPlayer.Character then return; end

					local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart");
					if not rootPart then return; end

					local rootPartPos = rootPart.Position;

					for _, npc in next, npcs do
						if ((npc.rootPart.Position - rootPartPos).Magnitude > library.flags.killAuraDistance or npc.humanoid.Health <= 0) then continue end;
						table.insert(t, {
							TargetCharacter = npc.character,
							KnockbackDirection = Vector3.zero
						})
					end;

					if (#t <= 0 or tick() - didAt < attackSpeed) then return end;
					didAt = tick();

					meleeRemote:FireServer(1, {Targets = t});
				end);
			end

			function functions.attackRate(toggle)
				if not toggle then return; end
				if (getWeaponType()[1] ~= "Melee" and getWeaponType()[2] ~= "Melee") then ToastNotif.new({text ="Only Melee weapons can use this feature",duration = 10}); library.options.attackRate:SetState(false); end
			end

			function functions.autoPotion(toggle)
				if not toggle then maid.autoPotion = nil; return; end

				maid.autoPotion = RunService.Heartbeat:Connect(function()
					local character = LocalPlayer.Character;
					if (not character) then return end;

					local humanoid = character:FindFirstChildWhichIsA('Humanoid');
					if not humanoid then return; end

					if (humanoid.Health/humanoid.MaxHealth*100) <= library.flags.autoPotionValue then
						activateRemote:FireServer(6)
					end
				end)
			end

			function functions.autoSell(toggle)
				if not toggle then maid.autoSell = nil; table.clear(itemsToSell); return; end

				local lastAutoSell = tick();

				maid.autoSell = Utility.listenToChildAdded(Stats.Inventory,function(obj)
					if not obj:FindFirstChild("Rarity") then return; end

					local objRarity = obj.Rarity.Value; --This is a int value need to be compared against Rarities table

					for rarity,bool in next, library.flags.autoSellValue do
						if bool and (rarity == Rarities[objRarity+1]) then
							table.insert(itemsToSell,{Item = obj,Count = 1})
						end
					end
				end)


				maid.autoSellLoop = RunService.Heartbeat:Connect(function()
					if tick() - lastAutoSell <= 1 or #itemsToSell == 0 then return; end --Don't fire remote unnecessarily

					lastAutoSell = tick();
					sellRemote:FireServer(itemsToSell);
					table.clear(itemsToSell);
				end)
			end

			function functions.autoReplay(toggle)
				if not toggle then maid.autoReplay = nil; return; end

				maid.autoReplay = Map.DescendantAdded:Connect(function(child)
					if child.Name == "LootPrompt" then
						replayRemote:FireServer("ReplayDungeon");
					end
				end)

				if Map:FindFirstChild("LootPrompt",true) then
					replayRemote:FireServer("ReplayDungeon");
				end
			end;

			function functions.maxLevelBattlePass()
				for _, v in next, getconnections(ReplicatedStorage.Remotes.UI.Message.OnClientEvent) do
					v:Disable();
				end;

				for i = 1, 30000 do
					ReplicatedStorage.Remotes.UI.VenturePass.PurchaseLevel:FireServer(0.00142)
				end;
			end;

			oldNamecall = hookmetamethod(game,"__namecall",onNamecall);
		end;

		local localCheats = column1:AddSection("Local Cheats");
		local misc = column2:AddSection("Misc");

		do --//Mob ESP
			local function onNewMobAdded(mob, espConstructor)
				local code = [[
			local FindFirstChild = game.FindFirstChild;
			local FindFirstChildWhichIsA = game.FindFirstChildWhichIsA;
			local mob = ...;

			return setmetatable({
				FindFirstChildWhichIsA = function(_, ...)
					return FindFirstChildWhichIsA(mob, ...);
				end,
			}, {
				__index = function(_, p)
					if (p == 'Position') then
						local mobRoot = FindFirstChild(mob, 'HumanoidRootPart');
						return mobRoot and mobRoot.Position;
					end;
				end,
			});
		]];

				local mobEsp = espConstructor.new({code = code, vars = {mob}}, mob.Name);

				local connection;
				connection = mob:GetPropertyChangedSignal('Parent'):Connect(function()
					if (not mob.Parent) then
						connection:Disconnect();
						mobEsp:Destroy();
					end;
				end);
			end;

			makeESP({
				sectionName = 'Mobs',
				type = 'childAdded',
				args = workspace.NPCS,
				callback = onNewMobAdded,
				onLoaded = function(section)
					section:AddToggle({
						text = 'Show Health',
						flag = 'Mobs Show Health'
					});
				end
			});
		end


		do -- // Local Cheats
			localCheats:AddButton({
				text = 'Max Level Battle Pass',
				callback = functions.maxLevelBattlePass
			});

			localCheats:AddToggle({
				text = 'Speedhack',
				callback = functions.speedHack
			}):AddSlider({
				min = 16,
				max = 45,
				flag = 'Speed Hack Value'
			});

			--localCheats:AddToggle({
			--	text = 'Damage Multiplier',
			--	flag = 'Attack Rate',
			--	callback = functions.attackRate
			--}):AddSlider({
			--	min = 0,
			--	max = 100,
			--	flag = 'Attack Rate Value'
			--});

			localCheats:AddToggle({
				text = 'Kill Aura',
				callback = functions.killAura
			}):AddSlider({
				min = 0,
				max = 15,
				flag = 'Kill Aura Distance'
			});

			misc:AddToggle({
				text = "Auto Potion",
				callback = functions.autoPotion
			}):AddSlider({
				min = 0,
				max = 100,
				flag = "Auto Potion Value"
			})

			misc:AddToggle({
				text = "Auto Sell",
				callback = functions.autoSell
			}):AddList({
				text = "Select Rarities",
				flag = "Auto Sell Value",
				multiselect = true,
				values = Rarities
			})

			misc:AddToggle({
				text = "Auto Replay",
				callback = functions.autoReplay
			})


		end

		--Mob ESP
	end)()
end

if (gameName == 'DeepWoken') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local column1, column2 = unpack(library.columns);

		local ReplicatedStorage, Players, RunService, CollectionService, Lighting, UserInputService, VirtualInputManager, TeleportService, MemStorageService, TweenService, HttpService, Stats, NetworkClient, GuiService = Services:Get(
			'ReplicatedStorage',
			'Players',
			'RunService',
			'CollectionService',
			'Lighting',
			'UserInputService',
			"VirtualInputManager",
			'TeleportService',
			'MemStorageService',
			'TweenService',
			'HttpService',
			'Stats',
			'NetworkClient',
			'GuiService'
		);

		local droppedItemsNames = HttpService:JSONDecode( sharedRequires['c83ce6a4e7b2a57431226bcf42132062a87d15e0887c9580ba22afdca872839f'])

		local LocalPlayer = Players.LocalPlayer;
		local playerMouse = LocalPlayer:GetMouse();

		local functions = {};

		local myRootPart;

		local IsA = game.IsA;
		local FindFirstChild = game.FindFirstChild;
		local FindFirstChildWhichIsA = game.FindFirstChildWhichIsA;
		local IsDescendantOf = game.IsDescendantOf;

		local blockRemote;
		local unblockRemote;

		local dodgeRemote;
		local stopDodgeRemote;
		local rightClickRemote;
		local dialogueRemote;
		local leftClickRemote;
		local dropToolRemote;
		local serverSwimRemote;
		local fallRemote;

		local keyhandler = require(game.ReplicatedStorage:WaitForChild("Modules", math.huge):WaitForChild("ClientManager", math.huge):WaitForChild("KeyHandler", math.huge))

		local stack = debug.getupvalue(getrawmetatable(debug.getupvalue(keyhandler, 8)).__index, 1)[1][1]
		local GetKey = stack[89]
		local key = stack[64]
		getupvalue(GetKey, 2)[0][1][2][4] = "HtttpGet"



		local maid = Maid.new();

		-- Player is server hopping

		if (game.PlaceId == 4111023553) then
			if (MemStorageService:HasItem('DataSlot')) then
				ToastNotif.new({
					text = 'Server hopping...'
				});

				ReplicatedStorage.Requests.StartMenu.Start:FireServer(MemStorageService:GetItem('DataSlot'), {
					PrivateTest = false
				});

				task.wait(0.3);

				ReplicatedStorage.Requests.StartMenu.PickServer:FireServer('none');
				MemStorageService:RemoveItem('DataSlot');
			else
				ToastNotif.new({
					text = 'Script will not run in lobby'
				});
			end;

			return task.wait(9e9);
		end;

		local remoteEvent = Instance.new('RemoteEvent');
		local onParryRequest = function() warn('onParryRequest not implemented'); end;

		local inputClient;

		local function logError(msg)

		end;

		local debugWebhook = Webhook.new('');

		do -- // Hooks
			local oldNamecall;
			local oldNewIndex;

			local oldFireserver;
			local oldDestroy;

			local characterHandler;
			local atmosphere;

			task.spawn(function()
				atmosphere = Lighting:WaitForChild('Atmosphere', math.huge);
			end)

			local getMouse = ReplicatedStorage.Requests.GetMouse;
			local getCameraToMouse = ReplicatedStorage.Requests.GetCameraToMouse;

			local GET_KEY_FUNCTION_HASH = 'dfdcd587cdc8368a9afd04160251e5d69caaa1e6eb19504ddbe0d6243322d035e5b408a2ef283e35dab5be48cdee7f98';

			local getKeyFunction = (function(o)


				for _, v in next, getgc() do
					if (typeof(v) == "function" and not is_synapse_function(v) and islclosure(v) and debug.info(v, 'n') == "gk" and debug.info(v, 's'):find('InputClient') and typeof(getupvalues(v)[1]) == 'table' and (isSynapseV3 or Utility.getFunctionHash(v) == GET_KEY_FUNCTION_HASH)) then
						return v;
					end;
				end;
			end);

			local getKey;

			if (not LocalPlayer.Character) then
				if (MemStorageService:HasItem('oresFarm') or MemStorageService:HasItem('doWipe')) then
					ReplicatedStorage.Requests.StartMenu.Start:FireServer();
				end;
			end;

			-- If we are in a dungeon instance we wait for the game to fully load cause some stuff could be missing
			if (game.PlaceId == 8668476218) then
				repeat
					if (workspace:FindFirstChild('One') and workspace.One:FindFirstChild('TrialOfOne')) then break end;
					print('Waiting for get getkey func');
					getKey = getKeyFunction();
					task.wait(1);
				until getKey;
			end;

			local setscriptes = function() end

			local function isRemoteInvalid(remote)


				if (not remote) then return true; end;
				return not IsDescendantOf(remote, game);
			end;

			local sent = false;

			local function onCharacterAdded(character)
				local humanoid = character:WaitForChild('Humanoid');
				local currentHealth = humanoid.Health;

				humanoid.HealthChanged:Connect(function(newHealth)
					if (newHealth < currentHealth) then
						warn('[Player] Took damage!', tick());
					end;

					currentHealth = newHealth;
				end);

				myRootPart = character:WaitForChild('HumanoidRootPart', math.huge);
				characterHandler = character:WaitForChild('CharacterHandler', math.huge);
				inputClient = characterHandler:WaitForChild('InputClient', math.huge);

				if (not getKey) then
					repeat
						print('Waiting for get getkey func');
						getKey = getKeyFunction();
						task.wait(1);
					until getKey;
				end;

				if (debugMode) then
					getgenv().myRootPart = myRootPart;
				end;

				local oldGetKey = getKey;

				local getKey = getKey

				local function safeGetKey(...)
					setscriptes(inputClient);
					setthreadidentity(2);

					-- Call keyhandler

					local remote = getKey(...);
					local hasErrored = false;

					if (not remote or not IsDescendantOf(remote, game)) then
						repeat
							task.wait(0.1);
							if (typeof(getupvalue(getKey, 1)) ~= 'table') then
								if (not hasErrored) then
									hasErrored = true;
									logError('failed to get it', typeof(getupvalue(getKey, 1)));
								end;

								continue;
							end;

							remote = getKey(...);
						until remote and IsDescendantOf(remote, game);
					end;

					if (hasErrored) then
						logError('actually got it omg!');
					end;

					setthreadidentity(7);
					setscriptes();

					print('We returned', remote:GetFullName());
					return remote;
				end;

				fallRemote = safeGetKey('FallDamage', 'plum');
				dialogueRemote = safeGetKey('SendDialogue', 'plum');
				blockRemote = safeGetKey('Block', 'plum');
				unblockRemote = safeGetKey('Unblock', 'plum');
				dodgeRemote = safeGetKey('Dodge', 'plum');
				leftClickRemote = safeGetKey('LeftClick', 'plum');
				rightClickRemote = safeGetKey('RightClick', 'plum');
				stopDodgeRemote = safeGetKey('StopDodge', 'plum');
				dropToolRemote = safeGetKey('DropTool', 'plum');
				serverSwimRemote = safeGetKey('ServerSwim','plum');

				getgenv().remotes = {
					fallRemote = fallRemote,
					dialogueRemote = dialogueRemote,
					leftClickRemote = leftClickRemote,
					blockRemote = blockRemote,
					dodgeRemote = dodgeRemote,
					rightClickRemote = rightClickRemote,
					stopDodgeRemote = stopDodgeRemote,
					unblockRemote = unblockRemote,
					dropToolRemote = dropToolRemote,
					serverSwimRemote = serverSwimRemote
				};

				if ((not blockRemote or not IsDescendantOf(blockRemote, game)) and not sent) then
					sent = true;
					task.spawn(function()
						logError('NO FALLR EMOTE?????')
						print(fallRemote);
					end);
				end;

				-- This is an old check and shouldn't fail because of safeGetKey
				if (isRemoteInvalid(fallRemote) or isRemoteInvalid(dialogueRemote) or isRemoteInvalid(blockRemote) or isRemoteInvalid(dodgeRemote) or isRemoteInvalid(leftClickRemote) or isRemoteInvalid(unblockRemote) or isRemoteInvalid(stopDodgeRemote) or isRemoteInvalid(rightClickRemote)) then
					print('failed to grab remotes!');
					error('oh no 0x01');
					task.delay(1, function()
						print('[Anti Cheat Bypass] Failed to grab remotes!');
					end);
				else
					print('[Anti Cheat Bypass] Got remotes!', dodgeRemote);
				end;
			end;

			if (LocalPlayer.Character) then
				task.spawn(onCharacterAdded, LocalPlayer.Character);
			end;

			LocalPlayer.CharacterAdded:Connect(onCharacterAdded);

			local gestureAnims = {};
			local gestures = ReplicatedStorage.Assets.Anims.Gestures;

			for _, v in next, gestures:GetChildren() do
				if not v:FindFirstChild('Pack1') and not v:FindFirstChild('MetalPromo') then continue; end;
				gestureAnims[v.Name] = v;
			end;

			local function onNamecall(self, ...)


				if (checkcaller()) then return oldNamecall(self, ...) end;

				local method = getnamecallmethod();

				if (method == 'FireServer' and IsA(self, "RemoteEvent")) then
					if (self.Name == "AcidCheck" and library.flags.antiAcid) then
						return;
					elseif (self == fallRemote and library.flags.noFallDamage and not checkcaller()) then
						return;
					elseif (self.Name == 'Gesture' and library.flags.giveAnimGamepass) then
						local args = {...};
						local animName = args[1];

						if (gestureAnims[animName]) then
							args[1] = 'Lean Back';

							task.spawn(function()
								local playerData = Utility:getPlayerData();
								local humanoid = playerData.humanoid;
								local animator = humanoid and humanoid:FindFirstChild('Animator');
								if (not animator) then return end;

								local onAnimationPlayed;
								local timeoutTask;
								local loadedAnim = animator:LoadAnimation(gestureAnims[animName]);

								onAnimationPlayed = animator.AnimationPlayed:Connect(function(animTrack)
									local animId = animTrack.Animation.AnimationId;
									if (animId ~= 'rbxassetid://6380990210') then return end;

									animTrack:Stop();
									loadedAnim:Play();

									humanoid:GetPropertyChangedSignal('MoveDirection'):Once(function()
										loadedAnim:Stop();
										onAnimationPlayed:Disconnect();
										task.cancel(timeoutTask);
									end);
								end);

								timeoutTask = task.delay(5, function()
									print('TIMED OUT!');
									onAnimationPlayed:Disconnect();
								end);
							end);

							return oldNamecall(self, unpack(args));
						end;
					end;
				elseif (method == 'Play' and IsA(self, "Tween") and self.Instance == atmosphere and library.flags.noFog) then
					return;
				end;

				return oldNamecall(self, ...);
			end;

			local function onNewIndex(self, p, v)


				if (self == characterHandler and p == 'Parent') then
					warn('[Anti Cheat Bypass] Got a ban attempt from charHandler.Parent = nil');
					return;
				elseif (self == Lighting and p == 'Ambient' and library.flags.fullBright) then
					local value = library.flags.fullBrightValue * 10;
					value += 100;

					v = Color3.fromRGB(value, value, value);
				elseif (self == atmosphere and p == 'Density' and library.flags.noFog) then
					v = 0;
				elseif (p == 'BackgroundColor3' and IsA(self, 'TextButton') and typeof(v) == 'Color3') then
					local s, l = debug.info(3, 'sl');
					if (l == 25 and s:find('ChoiceClient')) then
						return oldNewIndex(self,"AutoButtonColor", true);
					end;
				end;

				return oldNewIndex(self, p, v);
			end;

			local function onFireserver(self, ...)


				if (leftClickRemote and self == leftClickRemote and library.flags.blockInput and not _G.canAttack) then
					return;
				end;

				if (blockRemote and self == blockRemote) then
					task.spawn(onParryRequest);
				end;

				return oldFireserver(self, ...);
			end;

			local function onDestroy(self)


				if (characterHandler and self == characterHandler) then
					warn('[Anti Cheat Bypass] Got a ban attempt from characterhandler.destroy');
					return;
				end;

				return oldDestroy(self);
			end;

			warn('[Anti Cheat Bypass] Hooking game functions ...');

			oldNamecall = hookmetamethod(game, '__namecall', onNamecall);
			oldNewIndex = hookmetamethod(game, '__newindex', onNewIndex);

			oldFireserver = hookfunction(remoteEvent.FireServer, onFireserver);
			oldDestroy = hookfunction(game.Destroy, onDestroy);

			local stepped = game.RunService.Stepped;

			local function checkName(name)
				if (name and (name:find('InputClient') or name:find('ClientEffects') or name:find('EffectsClient') or name:find('WorldClient'))) then
					return true;
				end;
			end;

			local rayParams = RaycastParams.new();
			rayParams.FilterDescendantsInstances = {
				workspace.NPCs,
				workspace.Thrown,
				workspace.SnowSurfaces
			};

			local worldToViewportPoint = workspace.CurrentCamera.WorldToViewportPoint;
			local wiewportPointToRay = workspace.CurrentCamera.ViewportPointToRay;

			do -- // Silent Aim
				local function onCharacterAdded(character)
					if (not character) then return end;
					local getMouseFunction;

					repeat task.wait(); until character.Parent == workspace.Live or not character.Parent;
					if (not character.Parent) then return end;

					repeat
						--debug.profilebegin('this is slow 2!');
						for _, v in next, getgc() do
							if (typeof(v) == 'function' and not is_synapse_function(v) and islclosure(v) and debug.info(v, 's'):find('InputClient')) then
								local constants = getconstants(v);

								if (table.find(constants, 'MouseTracker')) then
									getMouseFunction = v;
									break;
								end;
							end;
						end;
						--debug.profileend();
						task.wait(1);
					until getMouseFunction;

					print('Got get mouse function!');

					getMouse.OnClientInvoke = function()
						setscriptes(inputClient);
						setthreadidentity(2);

						local mouse, keys = getMouseFunction();

						if (library.flags.silentAim) then
							local target = Utility:getClosestCharacterWithEntityList(workspace.Live:GetChildren(), rayParams, {maxDistance = 500});
							target = target and target.Character;

							local cam = workspace.CurrentCamera;

							if (target and target.PrimaryPart) then
								local pos = worldToViewportPoint(cam, target.PrimaryPart.Position);

								mouse.Hit = target.PrimaryPart.CFrame;
								mouse.Target = target.PrimaryPart;
								mouse.X = pos.X;
								mouse.Y = pos.Y;
								mouse.UnitRay = wiewportPointToRay(cam, pos.X, pos.Y, 1)
								mouse.Hit = target.PrimaryPart.CFrame;
							end;
						end;

						return mouse, keys;
					end;

					getCameraToMouse.OnClientInvoke = function()
						if (library.flags.silentAim) then
							local target = Utility:getClosestCharacterWithEntityList(workspace.Live:GetChildren(), rayParams, {maxDistance = 500});
							target = target and target.Character;

							if (target and target.PrimaryPart) then
								return CFrame.new(workspace.CurrentCamera.CFrame.Position, target.PrimaryPart.Position);
							end;
						end;

						return CFrame.new(workspace.CurrentCamera.CFrame.Position, getMouseFunction().Hit.p);
					end;
				end;

				LocalPlayer.CharacterAdded:Connect(onCharacterAdded);
				task.spawn(onCharacterAdded, LocalPlayer.Character);
			end;

			do -- // Optimize backpack
				local function updateBackpackHook(character)
					if (not character) then return end;

					repeat task.wait(); until character.Parent == workspace.Live or not character.Parent;
					if (not character.Parent) then return end;

					local wasCalled;
					local renderFunction;
					local backpackClient;

					--if (isSynapseV3) then return warn('warning: we do not hook renderbackpack on syn v3!'); end;

					repeat
						--debug.profilebegin('this is slow!');
						for _, v in next, getgc() do
							if (typeof(v) == 'function' and debug.info(v, 'n') == 'render' and debug.info(v, 's'):find('BackpackClient')) then
								local scr = rawget(getfenv(v), 'script');

								if (typeof(scr) == 'Instance' and string.find(scr:GetFullName(), 'BackpackGui.BackpackClient')) then
									backpackClient = scr;
									print('we hooked', scr);
									local originalFunc = hookfunction(v, function() wasCalled = true; end);
									if (not renderFunction) then
										renderFunction = originalFunc;
									end;
								end;
							end;
						end;
						--debug.profileend();
						task.wait(1);
					until renderFunction;

					maid.backpackHookTask = task.spawn(function()
						while task.wait(1 / 20) do
							if (not wasCalled) then continue end;
							wasCalled = false;
							setscriptes(backpackClient);
							setthreadidentity(2);
							-- debug.profilebegin('renderFunction()');
							renderFunction();
							-- debug.profileend();
						end;
					end);
				end;

				LocalPlayer.CharacterAdded:Connect(updateBackpackHook);
				task.spawn(updateBackpackHook, LocalPlayer.Character);
			end;

			do -- // FPS Boost
				local fpsBoostMaid = Maid.new();
				local hooked = {};

				function functions.fpsBoost(t)
					table.clear(hooked);
				end;


			end;

			warn('[Anti Cheat Bypass] game functions hooked and destroyed maid');
		end;

		local myChatLogs = {};

		local chatLogger = TextLogger.new({
			title = 'Chat Logger',
			preset = 'chatLogger',
			buttons = {'Spectate', 'Copy Username', 'Copy User Id', 'Copy Text', 'Report User'}
		});

		local autoParryHelperLogger = TextLogger.new({
			title = 'Auto Parry Helper Logger',
			buttons = {'Copy Animation Id', 'Add To Ignore List', 'Delete Log', 'Clear All'}
		});

		local assetsList = {'ModeratorJoin.mp3', 'ModeratorLeft.mp3'};
		local audios = {};

		local apiEndpoint = USE_INSECURE_ENDPOINT and 'http://test.Roniroscripts.xyz/' or 'https://Roniroscripts.xyz/';

		for i, v in next, assetsList do
			audios[v] = AudioPlayer.new({
				url = string.format('%s%s', apiEndpoint, v),
				volume = 10,
				forcedAudio = true
			});
		end;

		local function loadSound(soundName)
			if ((soundName == 'ModeratorJoin.mp3' or soundName == 'ModeratorLeft.mp3') and not library.flags.modNotifier) then
				return;
			end;

			audios[soundName]:Play();
		end;

		_G.loadSound = loadSound;

		local setCameraSubject;
		local isInDanger;

		local moderators = {};

		do -- // Mod Logs and chat logger
			-- Y am I hardcoding this?




			local function isInGroup(player, groupId)
				local suc, err = pcall(player.IsInGroup, player, groupId);

				if(not suc) then return false end;
				return err;
			end;

			local function onPlayerChatted(player, message)
				local timeText = DateTime.now():FormatLocalTime('H:mm:ss', 'en-us');
				local playerName = player.Name;
				local playerIngName = player:GetAttribute('CharacterName') or 'N/A';

				message = ('[%s] [%s] [%s] %s'):format(timeText, playerName, playerIngName, message);

				local textData = chatLogger:AddText({
					text = message,
					player = player
				});

				if (player == LocalPlayer) then
					table.insert(myChatLogs, textData);
					functions.streamerMode(library.flags.streamerMode);
				end;
			end;

			local function onPlayerAdded(player)
				if (player == LocalPlayer) then return end;

				local userId = player.UserId;

				if library.flags.modNotifier and (table.find(moderatorIds, tostring(userId)) or isInGroup(player, 5212858)) then
					moderators[player] = true;

					loadSound('ModeratorJoin.mp3');
					ToastNotif.new({
						text = ('Moderator Detected [%s]'):format(player.Name),
					});
				end;
			end;

			local function onPlayerRemoving(player)
				if (player == LocalPlayer) then return end;

				if (moderators[player]) then
					ToastNotif.new({
						text = ('Moderator Left [%s]'):format(player.Name),
					});

					loadSound('ModeratorLeft.mp3');
					moderators[player] = nil;
				end;
			end;

			library.OnLoad:Connect(function()
				local chatLoggerSize = library.configVars.chatLoggerSize;
				chatLoggerSize = chatLoggerSize and Vector2.new(unpack(chatLoggerSize:split(',')));

				local chatLoggerPosition = library.configVars.chatLoggerPosition;
				chatLoggerPosition = chatLoggerPosition and Vector2.new(unpack(chatLoggerPosition:split(',')));

				if (chatLoggerSize) then
					chatLogger:SetSize(UDim2.fromOffset(chatLoggerSize.X, chatLoggerSize.Y));
				end;

				if (chatLoggerPosition) then
					chatLogger:SetPosition(UDim2.fromOffset(chatLoggerPosition.X, chatLoggerPosition.Y));
				end;

				chatLogger:UpdateCanvas();
			end);

			library.OnLoad:Connect(function()
				Utility.listenToChildAdded(Players, onPlayerAdded);
				Utility.listenToChildRemoving(Players, onPlayerRemoving);
			end);

			chatLogger.OnPlayerChatted:Connect(onPlayerChatted);
		end;

		local function formatMobName(mobName)
			if (not mobName:match('%.(.-)%d+')) then return mobName end;
			local allMobLetters = mobName:match('%.(.-)%d+'):gsub('_', ' '):split(' ');

			for i, v in next, allMobLetters do
				local partialLetters = v:split('');
				partialLetters[1] = partialLetters[1]:upper();

				allMobLetters[i] = table.concat(partialLetters);
			end;

			return table.concat(allMobLetters, ' ');
		end;

		-- // Entity esp overwrite
		do
			local playersStats = {};
			local seenPerm = {};

			local function getPlayerLevel(character)
				if (not character) then return 0; end;
				local attributes = character:GetAttributes();
				local count = 0;

				for i,v in next, attributes do
					if (not string.match(i, 'Stat_')) then continue; end;
					count += v;
				end;

				return math.clamp(math.floor(count / 315 * 20), 1, 20);
			end;

			local function onBackpackAdded(player, backpack)
				task.wait();

				local seen = {};
				local seenJSON = {};
				local seenObj = {};

				local function onChildAdded(obj)
					local name = obj.Name;

					if (not seenObj[obj]) then
						seenObj[obj] = true;

						if (not seenPerm[player] and name:lower():find('grasp of eylis') and library.flags.voidWalkerNotifier) then
							seenPerm[player] = true;
							local t = ToastNotif.new({text = string.format('%s is a void walker.', player.Name)});
							local con;
							con = player:GetPropertyChangedSignal('Parent'):Connect(function()
								if (player.Parent) then return end;
								seenPerm[player] = nil;
								ToastNotif.new({text = string.format('[Void Walker Notif] %s left the game.', player.Name), duration = 10});
								t:Destroy();
								con:Disconnect();
							end);
						end;
					end;

					local weaponData = obj:FindFirstChild('WeaponData');
					local rarity = obj:FindFirstChild('Rarity');
					local foundWeaponData = weaponData;

					if (library.flags.mythicItemNotifier and weaponData and not seenJSON[weaponData] and rarity.Value == 'Mythic' and rarity) then
						xpcall(function()
							weaponData = seenJSON[weaponData] or HttpService:JSONDecode(weaponData.Value);
						end, function()
							weaponData = crypt.base64decode(weaponData.Value);
							weaponData = weaponData:sub(1, #weaponData - 2);

							weaponData = HttpService:JSONDecode(weaponData);
						end);

						if (foundWeaponData and not weaponData and debugMode) then
							task.spawn(error, 'Invalid Weapon Data');
						end;

						if (weaponData) then
							seenJSON[weaponData] = true;
						end;

						if (typeof(weaponData) == 'table' and not weaponData.Enchant and not (weaponData.SoulBound or weaponData.Soulbound) and not seen[obj]) then
							seen[obj] = true;

							ToastNotif.new({
								text = ('%s has %s'):format(player.Name, obj.Name:match('(.-)%$')),
							});
						end;
					end;

					playersStats[player] = {
						level = getPlayerLevel(player.Character)
					};

					return function()
						playersStats[player] = {
							level = getPlayerLevel(player.Character)
						};
					end;
				end;

				Utility.listenToChildAdded(backpack, onChildAdded, {listenToDestroying = true});
			end;

			local function onPlayerAdded(player)
				if (player == LocalPlayer) then return end;
				player.ChildAdded:Connect(function(obj)
					if (not IsA(obj, 'Backpack')) then return end;

					onBackpackAdded(player, obj);
				end);

				local backpack = player:FindFirstChildWhichIsA('Backpack');

				if (backpack) then
					task.spawn(onBackpackAdded, player, backpack);
				end;
			end;

			local function onPlayerRemoving(player)
				playersStats[player] = nil;
			end;

			library.OnLoad:Connect(function()
				Players.PlayerRemoving:Connect(onPlayerRemoving);
				Utility.listenToChildAdded(Players, onPlayerAdded);
			end);

			function EntityESP:Plugin()


				local playerStats = playersStats[self._player] or {level = 1};
				local shouldSpoofName = library.flags.streamerMode and library.flags.hideEspNames;

				if (shouldSpoofName and not self._fakeName) then
					self._fakeName = string.format('%s %s', BrickColor.random().Name, self._id);
				end;

				local dangerText = '';

				if (library.flags.showDangerTimer) then
					local humanoid = Utility:getPlayerData(self._player).humanoid;
					local expirationTime = humanoid and humanoid:GetAttribute('DangerExpiration')

					if (expirationTime and expirationTime ~= -1) then
						dangerText = string.format(' [%ds]', expirationTime - workspace:GetServerTimeNow());
					end;
				end;

				return {
					text = string.format('\n[Level: %d]%s', playerStats.level, dangerText),
					playerName = shouldSpoofName and self._fakeName or self._playerName,
				}
			end;
		end;

		local markerWorkspace = ReplicatedStorage:WaitForChild('MarkerWorkspace');
		local isLayer2 = ReplicatedStorage:FindFirstChild('LAYER2_DUNGEON');

		do -- // Functions
			function functions.speedHack(toggle)
				if (not toggle) then
					maid.speedHack = nil;
					maid.speedHackBv = nil;

					return;
				end;

				maid.speedHack = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local humanoid, rootPart = playerData.humanoid, playerData.primaryPart;
					if (not humanoid or not rootPart) then return end;

					if (library.flags.fly) then
						maid.speedHackBv = nil;
						return;
					end;

					maid.speedHackBv = maid.speedHackBv or Instance.new('BodyVelocity');
					maid.speedHackBv.MaxForce = Vector3.new(100000, 0, 100000);

					if (not CollectionService:HasTag(maid.speedHackBv, 'AllowedBM')) then
						CollectionService:AddTag(maid.speedHackBv, 'AllowedBM');
					end;

					maid.speedHackBv.Parent = not library.flags.fly and rootPart or nil;
					maid.speedHackBv.Velocity = (humanoid.MoveDirection.Magnitude ~= 0 and humanoid.MoveDirection or gethiddenproperty(humanoid, 'WalkDirection')) * library.flags.speedHackValue;
				end);
			end;

			function functions.BreakMobs(toggle)
				getgenv().BreakMobsRoniro = toggle
			end

			local FixFling = false
			local RunService = game:GetService("RunService")
			local LocalPlayer = game.Players.LocalPlayer
			RunService.Stepped:Connect(function()
				local Character = LocalPlayer.Character
				if Character and getgenv().BreakMobsRoniro then
					local Root = Character:FindFirstChild("HumanoidRootPart")
					local Hum = Character:FindFirstChild("Humanoid")
					if Root and Hum then
						local MoveDirection = Hum.MoveDirection
						if MoveDirection ~= Vector3.new(0,0,0) then
							Root.Velocity = MoveDirection * 20
						else
							Root.Velocity = Vector3.new(0,0,0)
						end
					end
				end
				if Character and (not getgenv().BreakMobsRoniro) and not FixFling then
					for i,v in Character:GetChildren() do
						if v:IsA("BasePart") or v:IsA("Part")  then
							v.Velocity = Vector3.new(0, 0, 0)
						end
					end
					FixFling = true
				end
			end)


			RunService.Heartbeat:Connect(function()
				if getgenv().BreakMobsRoniro then
					local Character = LocalPlayer.Character
					if Character then
						for i,v in Character:GetChildren() do
							if v:IsA("BasePart") or v:IsA("Part")  then
								v.Velocity = Vector3.new(9e9, 9e9, 9e9)
							end
						end
						FixFling = false
					end
				end
			end)



			function functions.fly(toggle)
				if (not toggle) then
					maid.flyHack = nil;
					maid.flyBv = nil;

					return;
				end;

				maid.flyBv = Instance.new('BodyVelocity');
				maid.flyBv.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

				maid.flyHack = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local rootPart, camera = playerData.rootPart, workspace.CurrentCamera;
					if (not rootPart or not camera) then return end;

					if (not CollectionService:HasTag(maid.flyBv, 'AllowedBM')) then
						CollectionService:AddTag(maid.flyBv, 'AllowedBM');
					end;

					maid.flyBv.Parent = rootPart;
					maid.flyBv.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.flyHackValue);
				end);
			end;

			local depthOfField = Lighting:WaitForChild('DepthOfField', math.huge);
			local effectReplicator = require(ReplicatedStorage:WaitForChild('EffectReplicator', math.huge));

			local playerBlindFold;
			local lastBlurValue = 0;

			function functions.noFog(toggle)
				if (not toggle) then
					maid.noFog = nil;
					depthOfField.Enabled = true;

					return;
				end;

				depthOfField.Enabled = false;

				maid.noFog = RunService.RenderStepped:Connect(function()
					Lighting.FogEnd = 1000000;

					local atmosphere = Lighting:FindFirstChild('Atmosphere');
					if (not atmosphere) then return end;

					atmosphere.Density = 0;
				end);
			end;

			function functions.noBlind(toggle)
				if (not toggle) then
					maid.noBlind = nil;

					if (playerBlindFold) then
						playerBlindFold.Parent = LocalPlayer.Backpack;
						playerBlindFold = nil;
					end;

					return;
				end;

				maid.noBlind = RunService.Heartbeat:Connect(function()
					local backpack = LocalPlayer:FindFirstChild('Backpack');
					if (not backpack) then return end;

					local blindFold = backpack:FindFirstChild('Talent:Blinded') or backpack:FindFirstChild('Flaw:Blind');
					if (not blindFold) then return end;

					blindFold.Parent = nil;
					playerBlindFold = blindFold;
				end);
			end;

			function functions.noBlur(toggle)
				if (not toggle) then
					maid.noBlur = nil;
					Lighting.GenericBlur.Size = lastBlurValue;
					lastBlurValue = 0;

					return;
				end;

				lastBlurValue = Lighting.GenericBlur.Size;

				maid.noBlur = RunService.Heartbeat:Connect(function()
					Lighting.GenericBlur.Size = 0;
				end);
			end;

			-- NoClip
			do
				function functions.noClip(toggle)
					if (not toggle) then
						maid.noClip = nil;

						local humanoid = Utility:getPlayerData().humanoid;
						if (not humanoid) then return end;

						humanoid:ChangeState('Physics');
						task.wait();
						humanoid:ChangeState('RunningNoPhysics');

						return;
					end;

					maid.noClip = RunService.Stepped:Connect(function()


						local myCharacterParts = Utility:getPlayerData().parts;
						local isKnocked = effectReplicator:FindEffect('Knocked');
						local disableNoClipWhenKnocked = library.flags.disableNoClipWhenKnocked;

						for _, v in next, myCharacterParts do
							if (disableNoClipWhenKnocked) then
								v.CanCollide = not not isKnocked;
							else
								v.CanCollide = false;
							end;
						end;

					end);
				end;
			end;

			function functions.clickDestroy(toggle)
				if (not toggle) then
					maid.clickDestroy = nil;
					return;
				end;

				maid.clickDestroy = UserInputService.InputBegan:Connect(function(input, gpe)
					if (input.UserInputType ~= Enum.UserInputType.MouseButton1 or gpe) then return end;

					local target = playerMouse.Target;
					if (not target or target:IsA('Terrain')) then return end;

					target:Destroy();
				end)
			end;

			function functions.serverHop(bypass)
				if(bypass or library:ShowConfirm('Are you sure you want to switch server?')) then
					library:UpdateConfig();
					local dataSlot = LocalPlayer:GetAttribute('DataSlot');
					MemStorageService:SetItem('DataSlot', dataSlot);

					BlockUtils:BlockRandomUser();
					TeleportService:Teleport(4111023553);
				end;
			end;

			local function tweenTeleport(rootPart, position, noWait)
				local distance = (rootPart.Position - position).Magnitude;
				local tween = TweenService:Create(rootPart, TweenInfo.new(distance / 120, Enum.EasingStyle.Linear), {
					CFrame = CFrame.new(position)
				});

				tween:Play();

				if (not noWait) then
					tween.Completed:Wait();
				end;

				return tween;
			end;

			do -- // Bots

				local function findFortMeritNPC(rootPart)
					for _, v in next, workspace.Live:GetChildren() do
						local mobRoot = v:FindFirstChild('HumanoidRootPart');
						if (not CollectionService:HasTag(v, 'Mob') or not mobRoot or formatMobName(v.Name) ~= 'Hostage Etrean' or (mobRoot.Position - rootPart.Position).Magnitude > 500) then continue end;

						return v;
					end;
				end

				function functions.fortMeritFarm(toggle)
					if (not toggle) then
						maid.fortMeritBv = nil;
						return
					end;

					-- // Check if player is near fort merit boat
					local fortMeritBoatLocation = Vector3.new(-9725.6982421875, 3.9712052345276, 2617.1892089844);
					local fortMeritPrisonLocation = Vector3.new(-9318.13671875, 423.30514526367, 2772.7346191406);
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');

					if (not rootPart) then return warn('[Fort Merit Bot] HumanoidRootPart not found') end;

					while true do
						if (not library.flags.fortMeritFarm) then return end;
						if (rootPart.Position - fortMeritBoatLocation).Magnitude > 200 then
							ToastNotif.new({
								text = 'You are too far away from fort merit boat.',
								duration = 5
							});
						else
							break;
						end;

						task.wait(1);
					end;

					local bodyVelocity = Instance.new('BodyVelocity');
					bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);
					bodyVelocity.Velocity = Vector3.new();

					maid.fortMeritBv = bodyVelocity;

					CollectionService:AddTag(bodyVelocity, 'AllowedBM');
					bodyVelocity.Parent = LocalPlayer.Character:FindFirstChild('Head');

					while (library.flags.fortMeritFarm) do
						tweenTeleport(rootPart, fortMeritPrisonLocation);

						local fortMeritNPC;
						local startedAt = tick();

						repeat
							fortMeritNPC = findFortMeritNPC(rootPart);
							task.wait(0.5);
						until fortMeritNPC or tick() - startedAt > 30 or not library.flags.fortMeritFarm;

						if (not fortMeritNPC) then
							task.wait(5);
							continue;
						end;

						local mobRoot = fortMeritNPC:FindFirstChild('HumanoidRootPart');

						tweenTeleport(rootPart, mobRoot.Position);
						task.wait(0.5);
						LocalPlayer.Character.CharacterHandler.Requests.Carry:FireServer();

						startedAt = tick();

						repeat
							task.wait();
						until effectReplicator:FindEffect('Carrying') or tick() - startedAt > 2.5;

						task.wait(0.5);
						tweenTeleport(rootPart, fortMeritPrisonLocation);
						task.wait(0.5);
						tweenTeleport(rootPart, fortMeritBoatLocation);
						task.wait(0.5);

						fireproximityprompt(workspace.NPCs['Etrean Guardmaster'].InteractPrompt);
						task.wait(1);

						dialogueRemote:FireServer({exit = true});
						task.wait(1);

						for _, v in next, workspace.Thrown:GetChildren() do
							if (not CollectionService:HasTag(v, 'ClosedChest')) then continue end;
							local chestRoot = v.PrimaryPart;

							if (chestRoot and (chestRoot.Position - rootPart.Position).Magnitude < 25) then
								local interact = v:FindFirstChild('InteractPrompt');
								if (interact) then
									fireproximityprompt(interact);
									task.wait(5);
								end;
							end;
						end;
					end;
				end;

				local ORE_FARM_MAX_RANGE = 500;
				local PLAYER_DIST_CHECK_MAX_RANGE = 200;
				local MOB_DIST_CHECK_MAX_RANGE = 100;

				local wantedOres = {'Astruline', 'Umbrite'};
				local forceKick = false;

				function functions.oresFarm(toggle)
					if (not toggle) then return end;
					MemStorageService:SetItem('oresFarm', 'true');

					if (not library.configVars.oresFarmPosition) then
						ToastNotif.new({text = 'Please set your position first!'});
						library.options.oresFarm:SetState(false);
						return;
					end;

					local notif = Webhook.new(library.flags.oresFarmWebhookNotifier);

					while (library.flags.oresFarm) do
						task.wait();

						local originalPosition = Vector3.new(unpack(library.configVars.oresFarmPosition:split(',')));

						if (not LocalPlayer.Character) then
							print('Attempt to spawn in');
							firesignal(UserInputService.InputBegan, {UserInputType = Enum.UserInputType.Keyboard, KeyCode = Enum.KeyCode.Unknown});
							task.wait(1);
							continue;
						end;

						local rootPart = LocalPlayer.Character:WaitForChild('HumanoidRootPart', 2);
						local humanoid = LocalPlayer.Character:WaitForChild('Humanoid', 2);
						local backpack = LocalPlayer:WaitForChild('Backpack', 2);

						if (not rootPart or not humanoid or not backpack) then
							-- Abort the bot
							warn('no root part / humanoid / backpack');
							continue;
						end;

						-- Wait for game to spawn in character
						repeat task.wait(); until CollectionService:HasTag(backpack, 'Loaded');

						if ((rootPart.Position - originalPosition).Magnitude > 500) then
							forceKick = true;
							LocalPlayer:Kick();
							GuiService:ClearError();
							ToastNotif.new({text = '[Ores Farm] You were too far from your last pos please click on the set location btn to reset your position and then rejoin the server.'});
							return;
						end;

						print('player spawned in!');

						local function isEntityNearby()
							if (Utility:countTable(moderators) > 0) then return true end;
							for _, entity in next, workspace.Live:GetChildren() do
								local root = entity:FindFirstChild('HumanoidRootPart');
								local isMob = CollectionService:HasTag(entity, 'Mob');
								if (not root or root == rootPart) then continue end;
								if ((root.Position - rootPart.Position).Magnitude <= (isMob and MOB_DIST_CHECK_MAX_RANGE or PLAYER_DIST_CHECK_MAX_RANGE)) then
									ToastNotif.new({text = string.format('too close %s %s', entity.Name, (root.Position - rootPart.Position).Magnitude)});
									return true;
								end;
							end;

							return false;
						end;

						task.spawn(function()
							while true do
								if (isEntityNearby()) then
									print('someone is nearby!!!');
									repeat task.wait(); until not effectReplicator:FindEffect('Danger');
									LocalPlayer:Kick('');
									functions.serverHop(true);

									return;
								elseif (not NetworkClient:FindFirstChild('ClientReplicator') and not forceKick) then
									functions.serverHop(true);
								end;

								task.wait();
							end;
						end);

						-- run player checks ere

						if ((rootPart.Position - originalPosition).Magnitude > 10) then
							tweenTeleport(rootPart, originalPosition);
							task.wait(5);
						end;

						local ores = {};
						local myPosition = rootPart.Position;

						local function onIngredientAdded(obj)
							if (table.find(wantedOres, obj.Name) and (obj.Position - myPosition).Magnitude <= ORE_FARM_MAX_RANGE) then
								table.insert(ores, obj);
							end;
						end;

						Utility.listenToChildAdded(workspace.Ingredients, onIngredientAdded);
						local maxCarryLoad = false;

						for _, ore in next, ores do
							if((humanoid:GetAttribute('CarryMax') or 100) * 1.2 <= humanoid:GetAttribute('CarryLoad')) then maxCarryLoad = true; break end;
							if (not library.flags.oresFarm) then break; end;
							tweenTeleport(rootPart, ore.Position);
							local prompt = ore:WaitForChild('InteractPrompt', 5);
							if (not prompt) then continue end;
							task.wait(0.2);

							local miningStartedAt = tick();
							fireproximityprompt(prompt);
							repeat task.wait(); until not ore.Parent or tick() - miningStartedAt > 10;
						end;

						if (maxCarryLoad) then
							ToastNotif.new({text = 'Max carry load!'});
							notif:Send(string.format('@everyone | %s | You are on max carry load', LocalPlayer.Name));
							task.wait(5);
						end;

						tweenTeleport(rootPart, originalPosition);
						task.wait(1);

						local astruline = LocalPlayer.Backpack:FindFirstChild('Astruline');

						if (astruline) then
							dropToolRemote:FireServer(astruline, true);
						end;

						task.wait(1);

						repeat task.wait(); until not effectReplicator:FindEffect('Danger');
						LocalPlayer:Kick('');
						functions.serverHop(true);

						break;
					end;
				end;

				function functions.setOresFarmPosition()
					local rootPart = Utility:getPlayerData().rootPart;
					if (not rootPart) then return end;

					library.configVars.oresFarmPosition = tostring(rootPart.Position);
					ToastNotif.new({text = 'Location set!'});
				end;

				local function isCharacterLoaded()
					local backpack = LocalPlayer:FindFirstChild('Backpack');
					if (not backpack) then return false end;

					return CollectionService:HasTag(backpack, 'Loaded');
				end;

				do -- Temp Farms
					do -- Echoes Farm
						local Requests = ReplicatedStorage:WaitForChild("Requests");
						local modifiers = require(ReplicatedStorage.Info.MetaData).Modifiers;
						local weaponData = require(ReplicatedStorage.Info.WeaponData).weapon_classes;

						local craft = Requests.Craft;
						local finishCreation = Requests.CharacterCreator.FinishCreation;
						local pickSpawn = Requests.CharacterCreator.PickSpawn;
						local modifyRemote = Requests.MetaModifier;
						local updateMeta = Requests.UpdateMeta;
						local increaseAttribute = Requests.IncreaseAttribute;

						local inDepths = game.PlaceId == 5735553160;

						local function startEchoFarm()
							if (not MemStorageService:HasItem('serverHop')) then
								pickSpawn:InvokeServer("Etris");

								for i in next, modifiers do --Enables all modifiers
									local waiting = true;

									local con;
									con = updateMeta.OnClientEvent:Connect(function(tab)
										if not string.find(tab.Modifiers,i) then return; end
										print('go');
										waiting = false;
									end)

									modifyRemote:FireServer(i);

									repeat
										task.wait(0.1);
										if not waiting then break; end;
										modifyRemote:FireServer(i);
									until not waiting;
									con:Disconnect();
								end

								finishCreation:InvokeServer();
							else
								MemStorageService:RemoveItem('serverHop');
							end;

							repeat task.wait(); until LocalPlayer.Character and (LocalPlayer.Character.Parent == workspace.Live);

							local rootPart = LocalPlayer.Character:WaitForChild('HumanoidRootPart', 10);
							local backpack = LocalPlayer:WaitForChild('Backpack', 10);

							repeat task.wait(); until CollectionService:HasTag(backpack, 'Loaded'); --Wait for us to spawn in

							--Make sure that a browncap and dentifilo is near and Y: 401 is below it

							--Toggle Noclip
							library.options.noClip:SetState(true);
							--Toggly Fly
							library.options.fly:SetState(true);

							local function pickupIngredients()
								local closests = {};
								local closestsParts = {};

								if (getgenv().breakPickup) then
									return false;
								end;

								for _, ingredient in next, workspace.Ingredients:GetChildren() do
									-- Make sure ingredient name is valid
									if (ingredient.Name == 'Dentifilo' or ingredient.Name == 'Browncap') then
										local interactPrompt = ingredient:FindFirstChild('InteractPrompt');
										if (not interactPrompt) then continue end;

										if (not closests[ingredient.Name]) then
											closests[ingredient.Name] = math.huge;
										end;

										local distance = (myRootPart.Position - ingredient.Position).Magnitude;

										if (distance < closests[ingredient.Name] and distance <= 250) then
											closests[ingredient.Name] = distance;
											closestsParts[ingredient.Name] = ingredient;
										end;
									end;
								end;

								-- Find closest ingredient and returns them

								if (not closestsParts.Dentifilo or not closestsParts.Browncap) then return false end;

								for _, ingredient in next, closestsParts do
									local ingPos = ingredient.Position;

									LocalPlayer.Character:PivotTo(CFrame.new(rootPart.Position.X,401.5,rootPart.Position.Z)); --Teleporting them below the Inn
									tweenTeleport(myRootPart, Vector3.new(ingPos.X, 401.5, ingPos.Z));

									-- Pickup the ingredient

									local startedAt = tick();
									local interactPrompt = ingredient:FindFirstChild('InteractPrompt');

									repeat
										if (not interactPrompt) then return false end;
										fireproximityprompt(interactPrompt);
										task.wait(1);
									until not ingredient.Parent or tick() - startedAt > 5;

									if (tick() - startedAt > 5) then
										-- We couldn't pick up the ingredient
										return false;
									end;
								end;

								return true;
							end;

							if (not pickupIngredients()) then
								-- If there is no mushroom then we wait to get new mushroom

								local startedAt = tick();

								repeat
									print('no browncap/dentifilo :(');
									task.wait(1);
								until pickupIngredients() or tick() - startedAt > 20;

								if (tick() - startedAt > 20) then
									MemStorageService:SetItem('serverHop', 'true');
									functions.serverHop(true);
									return;
								end;
							end;

							--Tween to the campfire
							tweenTeleport(myRootPart, Vector3.new(2509.039, 401.5, -5562.163));

							repeat
								task.wait(0.1);
							until craft:InvokeServer({Dentifilo = true, Browncap = true}); --Craft the Mushroom Soup

							originalFunctions.fireServer(fallRemote, math.random(900,1000),false);
							MemStorageService:SetItem('doWipe', 'true');
						end;

						local function fireChoices(choices, responseChoices)
							--There might be a debounce on these gotta test later
							for i, v in next, choices do -- Run Through Choices
								local completed = false;

								local con;
								con = dialogueRemote.OnClientEvent:Connect(function(tab)
									local text = tab.text;

									if (text ~= responseChoices[i] and not tab.exit) then
										-- Invalid data?
										return;
									end;

									completed = true;
								end);

								local waitTime = 0.25;

								repeat
									dialogueRemote:FireServer(v);
									task.wait(waitTime);
									waitTime += math.min(waitTime + 0.25, 1); -- Increase wait time for each failed attempts incase of a debounce or idk
								until completed;

								con:Disconnect();
							end;
						end;

						local function doWipe()
							local choices = {{["choice"] = "What do you mean?"}, {["choice"] = "But I don't want to go."}, {["choice"] = "Isn't there something we can do?"}, {["choice"] = "What is all this?"}, {["choice"] = "So, is this really the end?"}, {["exit"] = true}};
							local responseChoices = {
								'You know what I mean. You\'re me, after all. This is where we as a person end.',
								'[i]*Sigh.*[/i] There was so much left for us to do, wasn\'t there?',

								'[i]*You see your face racked with a pained expression.*[/i] No. You know there isn\'t.',
								'This... All of this around us... Is all our mind is able to make sense of right now. It\'s just holding on to all it can still remember.',
								'Yeah, I suppose it is. Come speak to me again when you want to... Well... You know.',
							};

							repeat task.wait(); until fallRemote and isCharacterLoaded(); --Wait for us to spawn in
							LocalPlayer.Character:PivotTo(myRootPart.CFrame * CFrame.new(0, -100, 0));

							--Remove ForceField
							local myChar = LocalPlayer.Character;

							library.options.noKillBricks:SetState(false);

							print('wiating');
							repeat
								local pos = LocalPlayer.Character:GetPivot().Position;
								LocalPlayer.Character:PivotTo(CFrame.new(pos.X, -2871, pos.Z));
								task.wait(0.5);
							until LocalPlayer.Character ~= myChar and LocalPlayer.Character ~= nil;
							print('ok');

							repeat task.wait(); until isCharacterLoaded(); --Wait for us to spawn in
							task.wait(2); -- 2 seem to be the fastest we can

							local dialogueUI = LocalPlayer.PlayerGui:WaitForChild('DialogueGui'):WaitForChild('DialogueFrame');

							local npcSelf = workspace:WaitForChild('NPCs'):WaitForChild('Self');
							local selfInteract = npcSelf.InteractPrompt;

							local npcSelfCF = npcSelf:GetPivot() * CFrame.new(0, -5, 0);
							local lastProximityPromptFire = 0;
							local stages = {};

							local function talkToSelf()
								repeat
									LocalPlayer.Character:PivotTo(npcSelfCF); --Teleport under Self
									if (tick() - lastProximityPromptFire > 0.5) then
										fireproximityprompt(selfInteract);
										lastProximityPromptFire = tick();
									end;
									task.wait();
								until dialogueUI.Visible;
							end;

							task.delay(60, function()
								if (not LocalPlayer.Character or not LocalPlayer.Character.Parent) then return end;
								--debugWebhook:Send('Took more than 60 seconds ' .. table.concat(stages, ', '));

								while true do
									--debugWebhook:Send(LocalPlayer.Character and LocalPlayer.Character.Parent and 'char found' or 'no char');
									task.wait(10);
								end;
							end);

							dialogueRemote.OnClientEvent:Connect(function(tab)
								if (not tab.text) then return; end;
								table.insert(stages,tab.text..'\n');
							end)

							-- Talk to self 1st part
							talkToSelf();
							fireChoices(choices, responseChoices);

							-- Talk to self 2nd part
							task.spawn(function()
								while true do
									talkToSelf();
									fireChoices({
										{choice = '[The End]'},
									}, {});
								end;
							end);

							while true do
								ReplicatedStorage.Requests.GetScore:FireServer();
								task.wait(0.1);
							end;
						end;

						function functions.echoFarm(t)
							if (not t) then return end;
							-- Don't enable echo farm in to1
							if (game.PlaceId == 8668476218) then return end;

							repeat
								ReplicatedStorage.Requests.StartMenu.Start:FireServer();
								task.wait(1);
							until LocalPlayer.Character;

							if (inDepths) then
								if (not MemStorageService:HasItem('doWipe')) then
									return ToastNotif.new({text = 'Echo farm is turned on but echo farm did not pass first stage so it wont wipe you.'});
								end;

								MemStorageService:RemoveItem('doWipe')
								doWipe();
							else
								if (not MemStorageService:HasItem('serverHop')) then
									local ran = false;
									task.delay(5, function()
										if (ran) then return end;
										ToastNotif.new({text = 'You must be in character creation menu to use the echo farm'});
									end);

									repeat task.wait(); until LocalPlayer.PlayerGui:FindFirstChild('CharacterCreator');
									ran = true;
								end;

								startEchoFarm();
							end;
						end;

						local animalKingFarmRan = false;

						function functions.animalKingFarm(t)
							if (not t) then return end;

							repeat
								ReplicatedStorage.Requests.StartMenu.Start:FireServer();
								task.wait(1);
							until LocalPlayer.Character;

							if (inDepths) then
								if (not MemStorageService:HasItem('doWipe')) then return end;
								MemStorageService:RemoveItem('doWipe')
								doWipe();
								return;
							end;

							if (animalKingFarmRan) then return; end;
							animalKingFarmRan = true;

							-- Toggle noclip
							library.options.noClip:SetState(true);
							--Toggly Fly
							library.options.fly:SetState(true);
							-- Disable echof arm
							library.options.echoFarm:SetState(false);

							-- Select minityrsa and spawn
							if (game.PlaceId ~= 8668476218) then
								repeat task.wait(); until LocalPlayer.PlayerGui:FindFirstChild('CharacterCreator');

								local ran = false;
								task.delay(5, function()
									if (ran) then return end;
									ToastNotif.new({text = 'You must be in character creation menu to use the animal king farm'});
								end);

								repeat task.wait(); until LocalPlayer.PlayerGui:FindFirstChild('CharacterCreator');
								ran = true;

								if (not pickSpawn:InvokeServer('Minityrsa')) then
									ToastNotif.new({text = 'You must have lone warrior origin to use the animal king farm'});
									return;
								end;

								finishCreation:InvokeServer();
								return;
							end;

							repeat task.wait(); until isCharacterLoaded();

							local startPosition = myRootPart.Position;
							local dialogueUI = LocalPlayer.PlayerGui:WaitForChild('DialogueGui'):WaitForChild('DialogueFrame');

							local oneModel = workspace:WaitForChild('One');
							local startTrialOfOne = oneModel.OneTrigger;
							local campfire = oneModel.Campfire.CampfirePart;

							-- Do first stage of trial of one (orbs)
							tweenTeleport(myRootPart, startTrialOfOne.Position);
							repeat task.wait() until dialogueUI.Visible;
							tweenTeleport(myRootPart, startPosition);

							-- Wait until campfire goes back down
							repeat task.wait(); until campfire.Position.Y <= 1178;

							-- Tp to campfire
							tweenTeleport(myRootPart, Vector3.new(campfire.Position.X, 1140, campfire.Position.Z));

							-- Spend points
							local weapon = LocalPlayer.Backpack:FindFirstChild('Weapon');
							local weaponType = weaponData[weapon:GetAttribute('DisplayName')] or weapon:GetAttribute('DisplayName');

							if (weaponType == 'Gun') then
								weaponType = 'WeaponLight'
							else
								weaponType = 'Weapon' .. weaponType:match('(.-)Weapon');
							end;

							local sharkoController;
							repeat
								task.wait(0.5);
								increaseAttribute:InvokeServer(weaponType, true, true);
								sharkoController = workspace.Live:FindFirstChild('MegalodauntController', true)
							until sharkoController;
							-- Spend attribute points until sharko spawns

							local sharko = sharkoController.Parent;
							local sharkoTarget = sharko:WaitForChild('Target');

							local startedAt = tick();

							-- Wait until sharko target is us or timeout reached
							repeat
								task.wait();
							until sharkoTarget.Value == LocalPlayer.Character or tick() - startedAt > 20;

							-- If timeout reached then we have animal king otherwsie we wipe
							if (tick() - startedAt > 20 or not sharkoTarget.Value) then
								print('OMG LE ANIMAL KING');
								logError(string.format('%s someone got animal king?', LocalPlayer.Name));
								Webhook.new(library.flags.animalKingWebhookNotifier):Send(string.format('@everyone | %s got animal king', LocalPlayer.Name));
								repeat task.wait(); until not isInDanger();
								LocalPlayer:Kick('Animal King!');
							else
								MemStorageService:SetItem('doWipe', 'true');
								originalFunctions.fireServer(fallRemote, math.random(900,1000),false);
							end;
						end;
					end;
				end;
			end;

			function functions.charismaFarm(toggle)
				if (not toggle) then
					maid.charismaFarm = nil;
					return;
				end;

				local lastFarmRanAt = 0;

				maid.charismaFarm = RunService.Heartbeat:Connect(function()
					if (tick() - lastFarmRanAt < 1) then return end;

					lastFarmRanAt = tick();

					local tool = LocalPlayer.Backpack:FindFirstChild('How to Make Friends') or LocalPlayer.Character:FindFirstChild('How to Make Friends');
					if (not tool) then
						return ToastNotif.new({
							text = 'You need to have How to Make Friends in your inventory for the farm to work',
							duration = 1
						});
					end;

					tool.Parent = LocalPlayer.Character;

					tool:Activate();

					local singlePrompt = LocalPlayer.PlayerGui:FindFirstChild('SimplePrompt');
					if (not singlePrompt) then return end;

					local chatText = singlePrompt.Prompt.Text:match('\'(.+)\'');
					if (not chatText) then return end;

					warn('should say', chatText);

					library.dummyBox:SetTextFromInput(chatText);
					Players:Chat(chatText);
				end);
			end;

			function functions.intelligenceFarm(toggle)
				if (not toggle) then
					maid.intelligenceFarm = nil;
					return;
				end;

				local lastFarmRanAt = 0;

				maid.intelligenceFarm = RunService.Heartbeat:Connect(function()
					if (tick() - lastFarmRanAt < 1) then return end;
					lastFarmRanAt = tick();

					local tool = LocalPlayer.Backpack:FindFirstChild('Math Textbook') or LocalPlayer.Character:FindFirstChild('Math Textbook');
					if (not tool) then
						return ToastNotif.new({
							text = 'You need to have Math Textbook in your inventory for the farm to work',
							duration = 1
						});
					end;

					tool.Parent = LocalPlayer.Character;

					tool:Activate();

					local choicePrompt = LocalPlayer.PlayerGui:FindFirstChild('ChoicePrompt');
					if (not choicePrompt) then return end;

					local question = choicePrompt.ChoiceFrame.DescSheet.Desc.Text:gsub('[^%w%p%s]', '');
					local operationType = question:match('%d+ (.-) ');

					local number1 = question:match('What is (.-) ');
					local number2 = question:match(operationType .. ' (.-)%?');

					number2 = number2:gsub('by', '');
					number1 = tonumber(number1);
					number2 = tonumber(number2);

					local result = 0;

					if (operationType == 'minus') then
						result = number1 - number2;
					elseif (operationType == 'divided') then
						result = number1 / number2;
					elseif (operationType == 'plus') then
						result = number1 + number2;
					elseif (operationType == 'times') then
						result = number1 * number2;
					end;

					for i, v in next, choicePrompt.ChoiceFrame.Options:GetChildren() do
						if (not v:IsA('TextButton')) then continue end;

						print(math.abs(tonumber(v.Name)-result));
						if (math.abs(tonumber(v.Name)-result)<=1) then
							choicePrompt.Choice:FireServer(v.Name);
							break;
						end;
					end;
				end);
			end;

			function functions.fishFarm(toggle)
				if (not toggle) then
					maid.fishFarmAutoClicker = nil;
					maid.fishFarmAutoPull = nil;
					return;
				end;

				if (not LocalPlayer.Character or not LocalPlayer:FindFirstChildWhichIsA('Backpack')) then
					return ToastNotif.new({
						text = 'Error trying to run fish farm, please try again.',
						duration = 1
					});
				end;

				local fishingRod = LocalPlayer.Backpack:FindFirstChild('Fishing Rod') or LocalPlayer.Character:FindFirstChild('Fishing Rod');
				local rootPart = LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
				local humanoid = LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');

				if (not fishingRod or not rootPart) then
					ToastNotif.new({
						text = 'You need a fishing rod to use the fish farm.',
						duration = 5,
					});
					return;
				end;

				fishingRod.Parent = LocalPlayer.Character;
				task.wait(1);

				local reelLongSong = fishingRod.Handle.FishingLoop;
				local fishingRodRemote = fishingRod.FishinScript.RemoteEvent;

				local lastPullDirection;

				local function pullFishingRod(direction)
					if (direction == lastPullDirection) then return warn('same direction, we dont change') end;
					print('pulling', direction);

					if (lastPullDirection) then
						fishingRodRemote:FireServer(lastPullDirection, false);
					end;

					fishingRodRemote:FireServer(direction, true);
					lastPullDirection = direction;
				end;

				local function attachBait()
					local fishFarmBaits = library.flags.fishFarmBait:split(',');
					local bait = fishingRod.Bait.Value;
					local canBait = fishingRod.CanBait.Value;

					for i, v in next, fishFarmBaits do
						for i2, v2 in next, LocalPlayer.Backpack:GetChildren() do
							if (v:lower() == v2.Name:lower() and CollectionService:HasTag(v2, 'Edible') and canBait and not bait) then
								fishingRod.AddBait:FireServer(v2);

								local lastAttachBaitAt = tick();

								repeat
									task.wait();
								until fishingRod.Bait.Value or tick() - lastAttachBaitAt > 5;

								task.wait(0.5);

								return;
							end;
						end;
					end;
				end;

				maid.fishFarmAutoPull = humanoid.AnimationPlayed:Connect(function(anim)
					local animationId = anim.Animation.AnimationId:match('%d+');

					if (animationId == '6415331110') then
						-- Pull left
						pullFishingRod('a');
					elseif (animationId == '6415331617') then
						-- Pull right
						pullFishingRod('d');
					elseif (animationId == '6415330705') then
						-- Pull back
						pullFishingRod('s');
					end;
				end);

				maid.fishFarmAutoClicker = reelLongSong:GetPropertyChangedSignal('Playing'):Connect(function()
					if (reelLongSong.Playing) then
						task.wait(0.2);

						while (reelLongSong.Playing) do
							fishingRod:Activate();
							task.wait(1 / 10);
							-- Clicking 10 time per second
						end;
					end;
				end);

				local fishingStartedAt = tick();

				task.spawn(function()
					while (library.flags.fishFarm) do
						local hook = fishingRod.Handle.Rod.bobby.hook;

						if ((rootPart.Position - hook.Position).Magnitude < 10) then
							-- If the hook is too close it mean the player is not fishing so we start fishing again.

							attachBait();


							fishingRod:Activate();
							task.wait(library.flags.fishFarmHoldTime);
							fishingRod:Deactivate();
							task.wait(1);
							fishingStartedAt = tick();
						elseif (tick() - fishingStartedAt >= 120) then
							-- If player is fishing for more than 120 second without any fish, we stop fishing and retry.
							fishingRod.Parent = LocalPlayer.Backpack;
							task.wait(1);
							fishingRod.Parent = LocalPlayer.Character;
						end;

						task.wait(0.1);
					end;
				end);
			end;

			function functions.autoLoot(toggle)
				if (not toggle) then
					maid.autoLoot = nil;
					return;
				end;

				local colors = {
					['875252'] = 'Rare',
					['a38e64'] = 'Uncommon',
					['40504c'] = 'Common',
					['9057ac'] = 'Epic',
					['e2ffe6'] = 'Enchant',
					['46ccaf'] = 'Legendary'
				};

				local icons = {
					[tostring(Vector2.new(0, 0))] = 'Ring',
					[tostring(Vector2.new(20, 0))] = 'Gloves',
					[tostring(Vector2.new(40, 0))] = 'Shoes',
					[tostring(Vector2.new(60, 0))] = 'Helmets',
					[tostring(Vector2.new(80, 0))] = 'Glasses',
					[tostring(Vector2.new(100, 0))] = 'Earrings',
					[tostring(Vector2.new(120, 0))] = 'Schematics',
					[tostring(Vector2.new(140, 0))] = 'Weapons',
					[tostring(Vector2.new(160, 0))] = 'Daggers',
					[tostring(Vector2.new(180, 0))] = 'Necklace',
					[tostring(Vector2.new(200, 0))] = 'Trinkets'
				};

				local weaponAttributes = {
					'HP',
					'ETH',
					'RES',
					'Posture',
					'SAN',
					'Monster Armor',
					'PHY Armor',
					'Monster DMG',
					'ELM Armor'
				}

				local starIcon = fromHex('E29885');
				local fired = {};

				local function firstToUpper(str) --Totally not somewhat ripped from devforum cuz lazy
					return str:gsub("^%l", string.upper)
				end

				local function checkItemAttributes(weaponType,itemAttributes) --This function could be more efficient if i didn't check the ones at 0 but whatevs
					local foundMatch = false;
					if library.flags['autoLootWhitelistMatchAll'..weaponType] then --All things have to match gte for it to return true
						local attributeAmount = #weaponAttributes;
						local timesMatched = 0;

						for _,statName in next, weaponAttributes do
							statName = firstToUpper(toCamelCase(statName));

							local weaponTypeValue = library.flags['autoLootWhitelist'..statName..weaponType];
							local itemValue = itemAttributes[statName] or 0;

							if weaponTypeValue and itemValue and itemValue >= weaponTypeValue then
								timesMatched = timesMatched+1;
							end

						end
						foundMatch = attributeAmount == timesMatched;
					else --Only one thing has to match to return true

						for statName, itemValue in next, itemAttributes do --This check is annoying because if its greater than 0 but probably nobody gonna want a 0 stat thing so...
							local weaponTypeValue = library.flags['autoLootWhitelist'..statName..weaponType]; --This is incredibly demonic at this point... autoLootWhitelistHPWeapon

							if weaponTypeValue and itemValue >= weaponTypeValue and weaponTypeValue ~= 0 then
								foundMatch = true;
								break;
							end
						end
					end

					return foundMatch;
				end

				local function canGrabItem(starAmount, weaponRarity, weaponType, itemAttributes, itemName)
					if (weaponRarity == 'Enchant' and library.flags.alwaysPickupEnchant) then
						return true;
					end;
					if (itemName == "Kyrsan Medallion" and library.flags.alwaysPickupMedallion) then
						return;
					end

					if (library.flags['autoLootFilter' .. weaponType]) then
						local priority = library.flags['autoLootWhitelistPriorities' .. weaponType];
						local starsFlag = library.flags['autoLootWhitelistStars' .. weaponType];

						if (priority == 'Stars' and starsFlag[starAmount .. ' Stars']) then
							return true;
						elseif priority == 'Stats' and library.flags['autoLootWhitelistUseAttributes' .. weaponType] and checkItemAttributes(weaponType,itemAttributes) then
							return true;
						end

						local hasOneStarSelected = Utility.find(starsFlag, function(v) return v == true end);

						if (not library.flags['autoLootWhitelistRarities' .. weaponType][weaponRarity]) then
							return false;
						end;

						if (not starsFlag[starAmount .. ' Stars'] and hasOneStarSelected) then
							return false;
						end;

						if (library.flags['autoLootWhitelistUseAttributes' .. weaponType] and not checkItemAttributes(weaponType,itemAttributes)) then
							return false;
						end

						return true;
					end;

					return true;
				end;

				_G.canGrabItem = canGrabItem;

				local lastRan = 0;

				maid.autoLoot = RunService.Heartbeat:Connect(function()
					local choicePrompt = LocalPlayer.PlayerGui:FindFirstChild('ChoicePrompt');

					-- Note to myself the description check could break if game add translation in the future.
					if (not choicePrompt or choicePrompt.ChoiceFrame.Title.Text ~= 'Treasure Chest') then return end;

					local remote = choicePrompt:FindFirstChild('Choice');
					if (not remote or tick() - lastRan <= 0.1) then return end;

					for _, v in next, choicePrompt.ChoiceFrame.Options:GetChildren() do
						if (not IsA(v, 'TextButton') or v.Name == 'Nothing') then continue end;

						local canClick = v.AutoButtonColor;
						if (not canClick) then print('NOOOON'); continue end;

						local weaponRarity = colors[v.BackgroundColor3:ToHex()];
						local weaponType = v.Title.Text:find('Ring') and 'Ring' or icons[tostring(v.Icon.ImageRectOffset)];

						local splitText = v.Text:split(starIcon);
						local starAmount = #splitText - 1;
						local itemName = splitText[1];
						local itemAttributes = {};

						if v.Stats.Visible then
							local itemStats = v.Stats.Text;
							local strippedString = string.match(itemStats,"^.*%>; (.*)") or string.match(itemStats,".*");

							string.gsub(strippedString,'[+-]?%d%%?[^;]*',function(x)
								itemAttributes[firstToUpper(toCamelCase(string.match(x,'%A+(.*)')))] = tonumber(string.match(x,'%d+'));
							end)
						end
						-- print(weaponType, weaponRarity);

						if (not canGrabItem(starAmount, weaponRarity, weaponType, itemAttributes, itemName)) then continue end;

						if (not fired[v]) then
							lastRan = tick();
							remote:FireServer(v.Name);
							fired[v] = true;
							task.delay(0.1, function()
								fired[v] = nil;
							end);
						end;

						return;
					end;

					if (not fired[remote] and library.flags.autoCloseChest) then
						fired[remote] = true;
						remote:FireServer('EXIT');

						task.delay(0.1, function()
							fired[remote] = nil;
						end);
					end;
				end);
			end;

			-- Auto Loot Analytics
			task.spawn(function()
				if (true) then return end;
				-- Disable auto loot analytics

				local sentColors = {
					['875252'] = 'Rare',
					['a38e64'] = 'Uncommon',
					['40504c'] = 'Common',
					['9057ac'] = 'Epic',
					['e2ffe6'] = 'Enchant',
					['46ccaf'] = 'Legendary'
				};

				local lastRanAt = 0;

				local icons = {
					[tostring(Vector2.new(0, 0))] = 'Ring',
					[tostring(Vector2.new(20, 0))] = 'Gloves',
					[tostring(Vector2.new(40, 0))] = 'Shoes',
					[tostring(Vector2.new(60, 0))] = 'Helmets',
					[tostring(Vector2.new(80, 0))] = 'Glasses',
					[tostring(Vector2.new(100, 0))] = 'Earrings',
					[tostring(Vector2.new(120, 0))] = 'Coats',
					[tostring(Vector2.new(140, 0))] = 'Weapons',
					[tostring(Vector2.new(160, 0))] = 'Daggers',
					[tostring(Vector2.new(180, 0))] = 'Necklace',
					[tostring(Vector2.new(200, 0))] = 'Trinkets'
				};

				local starIcon = fromHex('E29885');

				RunService.Heartbeat:Connect(function()
					if (tick() - lastRanAt < 0.2) then return end;
					lastRanAt = tick();

					local choicePrompt = LocalPlayer.PlayerGui:FindFirstChild('ChoicePrompt');

					-- Note to myself the description check could break if game add translation in the future.
					if (not choicePrompt or choicePrompt.ChoiceFrame.DescSheet.Desc.Text ~= 'What do you take?') then return end;

					local remote = choicePrompt:FindFirstChild('Choice');
					if (not remote) then return end;

					for _, v in next, choicePrompt.ChoiceFrame.Options:GetChildren() do
						if (not IsA(v, 'TextButton') or v.Name == 'Nothing') then continue end;

						local canClick = v.AutoButtonColor;
						local color = v.BackgroundColor3:ToHex();

						if (not canClick or sentColors[color]) then continue end;

						local icon = icons[tostring(v.Icon.ImageRectOffset)] or tostring(v.Icon.ImageRectOffset);
						sentColors[color] = true;

						local starAmount = #v.Text:split(starIcon) - 1;

						request({
							Url = '',
							Method = 'POST',
							Body = HttpService:JSONEncode({
								content = string.format('v2 | Icon:%s | Color:%s | Name:%s | Stars:%s', icon, color, v.Name, starAmount)
							}),
							Headers = {['Content-Type'] = 'application/json'}
						});
					end;
				end);
			end);

			function functions.autoSprint(toggle)
				if (not toggle) then
					maid.autoSprint = nil;
					return;
				end;

				local moveKeys = {Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D};
				local lastRan = 0;

				maid.autoSprint = UserInputService.InputBegan:Connect(function(input, gpe)
					if (gpe or tick() - lastRan < 0.1) then return end;

					if (table.find(moveKeys, input.KeyCode)) then
						lastRan = tick();
						VirtualInputManager:SendKeyEvent(true, input.KeyCode, false, game);
					end;
				end);
			end;

			function functions.chatLogger(toggle)
				chatLogger:SetVisible(toggle);
			end;

			local autoParryHelperMaid = Maid.new();

			local animTimes = {};
			local allAnimations = {};
			local mobsAnims = {};
			local fetchingNames = {};

			autoParryHelperLogger.ignoreList = {'8174890073', '180435571', '4087826639', '5554732065', '180436148', '9323073748', '5168319343', '180435792'};

			function functions.autoParryHelper(toggle)
				autoParryHelperLogger:SetVisible(toggle);

				if (not toggle) then
					autoParryHelperMaid:Destroy();
					return;
				end;

				local function onNewEntityAdded(entity)
					if (entity == LocalPlayer.Character) then return end;

					local rootPart = entity:WaitForChild('HumanoidRootPart', 10);
					if (not rootPart) then return end;

					local humanoid = entity:WaitForChild('Humanoid', 10);
					if (not humanoid) then return end;

					local entityMaid = Maid.new();

					entityMaid:GiveTask(entity.Destroying:Connect(function()
						entityMaid:Destroy();
					end));

					entityMaid:GiveTask(humanoid.AnimationPlayed:Connect(function(animationTrack)
						local animationId = animationTrack.Animation.AnimationId:match('%d+');
						local maxLoggerRange = library.flags.helperMaxRange;

						if (table.find(autoParryHelperLogger.ignoreList, animationId) or (myRootPart.Position - rootPart.Position).Magnitude > maxLoggerRange) then
							return;
						end;

						local entityName = entity.Name;

						if (CollectionService:HasTag(entity, 'Mob')) then
							entityName = formatMobName(entityName);
						end;

						local animName = allAnimations[animationId];

						if (not animName and not fetchingNames[animationId]) then
							fetchingNames[animationId] = true;

							task.spawn(function()
								allAnimations[animationId] = '?_' .. game:GetService('MarketplaceService'):GetProductInfo(tonumber(animationId), Enum.InfoType.Asset).Name;
							end);
						end;

						autoParryHelperLogger:AddText({
							text = string.format('Animation <font color=\'#2ecc71\'>%s</font> (%s) played from <font color=\'#3498db\'>%s</font>', animationId, animName or 'no_name', entityName),
							animationId = animationId,
						});
					end));

					autoParryHelperMaid:GiveTask(function()
						entityMaid:Destroy();
					end);
				end;

				autoParryHelperMaid:GiveTask(workspace.Live.ChildAdded:Connect(onNewEntityAdded));

				for i, v in next, workspace.Live:GetChildren() do
					task.spawn(onNewEntityAdded, v);
				end;

				autoParryHelperMaid:GiveTask(autoParryHelperLogger.OnClick:Connect(function(actionName, context)
					if (actionName == 'Add To Ignore List' and not table.find(autoParryHelperLogger.ignoreList, context.animationId)) then
						table.insert(autoParryHelperLogger.ignoreList, context.animationId);
					elseif (actionName == 'Delete Log') then
						context:Destroy();
					elseif (actionName == 'Copy Animation Id') then
						setclipboard(context.animationId);
					elseif (actionName == 'Clear All') then
						for i, v in next, autoParryHelperLogger.allLogs do
							v.label:Destroy();
						end;

						table.clear(autoParryHelperLogger.allLogs);
					end;
				end));
			end;

			local function getWorldInfo()
				local playerGui = LocalPlayer:FindFirstChild('PlayerGui');
				if (not playerGui) then return end;

				local worldInfo = playerGui:FindFirstChild('WorldInfo');
				if (not worldInfo) then return end;

				return worldInfo;
			end;

			local function getBackpackGui()
				local playerGui = LocalPlayer:FindFirstChild('PlayerGui');
				if (not playerGui) then return end;

				local backpackGui = playerGui:FindFirstChild('BackpackGui');
				if (not backpackGui) then return end;

				return backpackGui;
			end;

			local function getChoicePrompt()
				local playerGui = LocalPlayer:FindFirstChild('PlayerGui');
				if (not playerGui) then return end;

				local choicePrompt = playerGui:FindFirstChild('ChoicePrompt');
				if (not choicePrompt) then return end;

				return choicePrompt;
			end;

			local oldDisplayName;
			local oldSlotText;

			function functions.streamerMode(toggle)
				local streamerModeType = library.flags.streamerModeType;

				if (not toggle) then
					maid.streamerMode = nil;
					maid.streamerModeIdSpoofer = nil;

					LocalPlayer:SetAttribute('Hidden', false);

					for _, v in next, myChatLogs do
						v.label.Text = v.text;
						v.label.Visible = true;
					end;

					chatLogger:UpdateCanvas();

					local worldInfo = getWorldInfo();
					local backpackGui = getBackpackGui();

					if (backpackGui and oldDisplayName) then
						backpackGui.JournalFrame.CharacterName.Text = oldDisplayName;
						backpackGui.JournalFrame.CharacterName.Visible = true;
					end;

					if (worldInfo and oldSlotText) then
						worldInfo.InfoFrame.CharacterInfo.Visible = true;
						worldInfo.InfoFrame.CharacterInfo.Slot.Text = oldSlotText or worldInfo.InfoFrame.CharacterInfo.Slot.Text;

						worldInfo.InfoFrame.ServerInfo.Visible = true;
						worldInfo.InfoFrame.GameInfo.Visible = true;
						worldInfo.InfoFrame.AgeInfo.Visible = true;
						worldInfo.InfoFrame.WorldInfo.Visible = true;

						oldSlotText = nil;
					end;

					local character = LocalPlayer.Character;
					if (not character) then return end;

					local humanoid = character:FindFirstChildWhichIsA('Humanoid');
					if (not humanoid or not oldDisplayName) then return end;

					humanoid.DisplayName = oldDisplayName;
					oldDisplayName = nil;

					return;
				end;

				LocalPlayer:SetAttribute('Hidden', true);

				local players = {};

				for _, v in next, Players:getPlayers() do
					if (v ~= LocalPlayer and v:GetAttribute('CharacterName')) then
						table.insert(players, v);
					end;
				end;

				local chosenPlayer = library.configVars.streamerModeTarget or #players > 0 and players[math.random(1, #players)];
				if (not chosenPlayer) then
					return ToastNotif.new({
						text = 'For security reasons, you can\'t use streamer mode without any players in your server.',
						duration = 10
					});
				end;

				local chosenPlayerName = typeof(chosenPlayer) == 'table' and chosenPlayer.CharacterName or chosenPlayer:GetAttribute('CharacterName');
				local chosenPlayerId = chosenPlayer.UserId;
				local chosenPlayerAccountAge = math.random(1, 50);

				local chosenPlayerLevel = typeof(chosenPlayer) == 'table' and chosenPlayer.AccountLevelSmaller or math.random(1, 20);

				library.configVars.streamerModeTarget = {
					Name = chosenPlayer.Name,
					UserId = chosenPlayer.UserId,
					AccountAge = chosenPlayer.AccountAge,
					AccountLevelSmaller = chosenPlayerLevel,
					CharacterName = chosenPlayerName
				};

				for _, v in next, myChatLogs do
					if (streamerModeType == 'Hide') then
						v.label.Visible = false;
						continue;
					end;

					local timeText = v.text:match('(%[.-%])');
					local rawText = v.text:match('.-%] .-%] .-%] (.+)');

					v.label.Text = ('%s [%s] [%s] %s'):format(timeText, chosenPlayer.Name, chosenPlayerName, rawText);
					v.label.Visible = true;
				end;

				chatLogger:UpdateCanvas();

				maid.streamerModeIdSpoofer = LocalPlayer.DescendantAdded:Connect(function(obj)
					if (obj.Name == 'DeathID' or obj.Name == 'KillerCharacter' or obj.Name == 'KillerPlayer') then
						repeat
							obj.Text = '';
							task.wait();
						until not obj.Parent;
					end;
				end);

				maid.streamerMode = RunService.Heartbeat:Connect(function()

					local ultraStreamerMode = library.flags.ultraStreamerMode;
					local hideAllServerInfo = library.flags.hideAllServerInfo;

					local myCharacter = LocalPlayer.Character;

					if (ultraStreamerMode) then
						for _, entity in next, workspace.Live:GetChildren() do
							if (entity == myCharacter) then continue end;
							local humanoid = entity:FindFirstChildWhichIsA('Humanoid');
							if (not humanoid) then continue end;

							humanoid.DisplayName = 'BUY Roniro HUB';
						end;
					end;

					local worldInfo = getWorldInfo();
					local backpackGui = getBackpackGui();
					local choicePrompt = getChoicePrompt();

					streamerModeType = library.flags.streamerModeType;

					if (worldInfo) then
						if (not oldSlotText) then
							oldSlotText = worldInfo.InfoFrame.CharacterInfo.Slot.Text;
						end;

						worldInfo.InfoFrame.CharacterInfo.Visible = streamerModeType == 'Spoof';
						worldInfo.InfoFrame.CharacterInfo.Slot.Text = ('%d:A|%d [Lv.%d]'):format(chosenPlayerId, chosenPlayerAccountAge, chosenPlayerLevel);

						worldInfo.InfoFrame.ServerInfo.Visible = not hideAllServerInfo;
						worldInfo.InfoFrame.GameInfo.Visible = not hideAllServerInfo;
						worldInfo.InfoFrame.AgeInfo.Visible = not hideAllServerInfo;
						worldInfo.InfoFrame.WorldInfo.Visible = not hideAllServerInfo;
					end;

					if (backpackGui) then
						backpackGui.JournalFrame.CharacterName.Visible = streamerModeType == 'Spoof';
						backpackGui.JournalFrame.CharacterName.Text = chosenPlayerName;

						if (ultraStreamerMode) then
							backpackGui.JournalFrame.FactSheet.Container.Age.Value.Text = '???';
							backpackGui.JournalFrame.FactSheet.Container.Born.Value.Text = '???';
							backpackGui.JournalFrame.FactSheet.Container.Level.Value.Text = '???';
							backpackGui.JournalFrame.FactSheet.Container.Race.Value.Text = '???';
						end;
					end;

					if (choicePrompt and ultraStreamerMode and choicePrompt.ChoiceFrame.Title.Text ~= 'Treasure Chest') then
						choicePrompt.ChoiceFrame.Title.Text = '???';
					end;

					local character = LocalPlayer.Character;
					if (not character) then return end;

					local humanoid = character:FindFirstChildWhichIsA('Humanoid');
					if (not humanoid) then return end;

					if (not oldDisplayName) then
						oldDisplayName = humanoid.DisplayName;
					end;

					humanoid.DisplayName = chosenPlayerName;

				end);
			end;

			function functions.rebuildStreamerMode()
				library.configVars.streamerModeTarget = nil;
				functions.streamerMode(library.flags.streamerMode);
			end;

			local function pingWait(n)
				if library.flags.useCustomDelay then
					n+=library.flags.customDelay/1000;
				else
					local playerPing = Stats.PerformanceStats.Ping:GetValue()/1000;
					n -= (playerPing*(library.flags.pingAdjustmentPercentage/100));
				end

				return task.wait(n);
			end;

			-- Get all animations for auto parry debug
			do
				local mobsAnimsFolder = ReplicatedStorage.Assets.Anims.Mobs;
				local seenAnims = {};
				local toRemove = {};

				for _, v in next, ReplicatedStorage.Assets.Anims:GetDescendants() do
					if (not IsA(v, 'Animation')) then continue end;
					local animationId = v.AnimationId:match('%d+');
					local isMobsFolder = v:IsDescendantOf(mobsAnimsFolder);

					allAnimations[animationId] = string.format('%s-%s', v.Parent.Name, v.Name);

					if (table.find(seenAnims, animationId)) then
						table.insert(toRemove, animationId);
					end;

					if (not isMobsFolder) then
						table.insert(seenAnims, animationId);
					else
						table.insert(mobsAnims, animationId);
					end;
				end;

				for _, animId in next, toRemove do
					if (not table.find(mobsAnims, animId)) then continue end;
					print('removed', animId);
					table.remove(mobsAnims, table.find(mobsAnims, animId));
				end;
			end;

			local didRoll = false;
			local canDodge = true;

			_G.getCanDodge = function()
				return canDodge;
			end;

			local isBlocking = false;
			local rollOnNextAttacks = {};

			local function checkRange(range, part)
				if (not myRootPart or not part) then
					return false;
				end;

				range += library.flags.distanceAdjustment;

				if (typeof(part) == 'Vector3') then
					part = {Position = part};
				end;

				return (myRootPart.Position - part.Position).Magnitude <= range;
			end;

			local function checkRangeFromPing(obj, rangeCheck, speed)
				if (not myRootPart) then return false end;

				local distance = (obj.Position - myRootPart.Position).Magnitude;
				local playerPing = Stats.PerformanceStats.Ping:GetValue() * 2;

				distance = (obj.Position - myRootPart.Position).Magnitude;
				distance -= speed * (playerPing / 1000);

				return distance <= rangeCheck, distance, playerPing / speed;
			end;

			local function dodgeAttack()
				local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool')
				if (not tool) then return end;

				print('dodge attempt');
				canDodge = false;

				if (library.flags.blatantRoll) then
					dodgeRemote:FireServer('roll', nil, nil, false);

					local humanoid = Utility:getPlayerData().humanoid;
					if (not humanoid) then return end;

					local cancelRight = ReplicatedStorage.Assets.Anims.Movement.Roll.CancelRight
					local track = humanoid:LoadAnimation(cancelRight);
					track:Play();
				else
					if (library.flags.autoFeint and tool and (effectReplicator:FindEffect('MidAttack') or effectReplicator:FindEffect('UsingMove'))) then

						mouse2click();
					end

					for i = 1, 3 do
						VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game);
						task.wait();
						VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game);
						task.wait();

						if (not library.flags.rollCancel) then continue end;
						task.delay(library.flags.rollCancelDelay, function()
							VirtualInputManager:SendMouseButtonEvent(1, 1, 1, true, game, 1);
							task.wait();
							VirtualInputManager:SendMouseButtonEvent(1, 1, 1, false, game, 1);
						end);
					end;
				end;
			end;


			_G.playerFPS = 0;
			task.spawn(function() --beautiful code Roniro always LOVE
				local i = 0;
				local fps = 0;
				while true do
					fps=fps+1;
					i+=task.wait();
					if i >= 1 then --We basically looping for 1 second in frames and count how many frames it took
						_G.playerFPS = fps;
						fps = 0;
						i = 0;
					end
				end

			end)

			local blockingSignal = Signal.new();

			local function blockAttack(bypassDodge)
				if (not blockRemote or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChildWhichIsA('Tool')) then return end;

				if (library.flags.parryChance < Random.new():NextInteger(1,100)) then return; end
				if (not library.flags.parryWhenDodging and (effectReplicator:FindEffect("DodgeFrame") or effectReplicator:FindEffect("iframe"))) then return; end

				if (library.flags.parryRoll and canDodge and not bypassDodge) then
					didRoll = true;
					dodgeAttack();
					return;
				end;

				isBlocking = true;

				local loopAmount = math.floor(_G.playerFPS*0.1)+1;
				loopAmount = loopAmount >= 12 and 12 or loopAmount;

				local callAmount = math.ceil(12/loopAmount);

				for _ = 1,loopAmount do --How many times to call task.wait
					for _ = 1, callAmount do --How many times we fire the remote between frames
						blockRemote.FireServer(blockRemote);
					end
					task.wait();
				end

				isBlocking = false;
				blockingSignal:Fire();
			end;

			local function unblockAttack()
				if (not unblockRemote or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChildWhichIsA('Tool')) then return end;

				-- if (isBlocking) then
				-- 	blockingSignal:Wait();
				-- end;

				repeat
					task.wait();
				until not isBlocking;

				if (didRoll) then
					didRoll = false;
					return;
				end;

				unblockRemote:FireServer();
			end;

			local function makeDelayBlockWithRange(range, time)
				return {
					waitTime = time,
					maxRange = range
				};
			end;

			--New stuff weird nya

			local function calculatePingWait(n)
				if library.flags.useCustomDelay then
					n+=library.flags.customDelay/1000;
				else
					local playerPing = Stats.PerformanceStats.Ping:GetValue()/1000;
					n -= (playerPing*(library.flags.pingAdjustmentPercentage/100));
				end

				return n;
			end;

			local function parry(timing, rootPart, animationTrack, maxRange)
				local start = tick();

				task.delay(timing/2,function()

					if (not checkRange(maxRange, rootPart)) then
						warn('[Auto Parry] Mob too far away ! Will not feint!!!' .. tostring((rootPart.Position - myRootPart.Position).Magnitude), maxRange);
						return;
					end;

					local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
					if (library.flags.autoFeint and tool and (effectReplicator:FindEffect('MidAttack') or effectReplicator:FindEffect('UsingMove'))) then
						if not effectReplicator:FindEffect('UsingSpell') or not library.flags.autoFeintMantra then
							mouse2click();
						end
					end;
				end)

				task.wait(timing);

				local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');

				if (not animationTrack.IsPlaying) then
					_G.canAttack = true;
					warn('[Auto Parry] Will return due to the animation no longer playing!');
					return 0;
				end;

				if (library.flags.checkIfTargetFaceYou) then
					local dotProduct = (myRootPart.Position - rootPart.Position):Dot(rootPart.CFrame.LookVector);
					if (dotProduct <= 0) then
						warn('[Auto Parry] Will return due to dot product!');
						return 0;
					end
				end;

				print('anim state', animationTrack.IsPlaying);

				if (not checkRange(maxRange, rootPart)) then
					warn('[Auto Parry] Mob too far away !' .. tostring((rootPart.Position - myRootPart.Position).Magnitude), maxRange);
					_G.canAttack = true;
					return 0;
				end;

				if (library.flags.autoFeint and tool and (effectReplicator:FindEffect('MidAttack') or effectReplicator:FindEffect('UsingMove'))) then
					if not effectReplicator:FindEffect('UsingSpell') or not library.flags.autoFeintMantra then
						mouse2click();
					end
				end;

				local character = rootPart.Parent;
				local particle = character and character:FindFirstChild('MegalodauntBroken', true);
				if (particle and IsA(particle, 'ParticleEmitter') and particle.Enabled) then return 0; end;

				if (rollOnNextAttacks[character] and effectReplicator:FindEffect('ParryCool')) then
					rollOnNextAttacks[character] = nil;
					dodgeAttack();
					warn('[Auto Parry] Dodged due to parry cooldown!!');
					return (tick() - start);
				end;

				blockAttack();
				unblockAttack();

				return (tick()-start);
			end

			local function parryAttack(timings,rootPart,animationTrack,maxRange,useAnimSpeed)
				warn(" CALLED PARRY ATTACK!!!!!")

				local convertedWait = 0;
				local waited = 0;
				local offset = 0;

				_G.canAttack = false;

				for i,timing in next, timings do
					convertedWait = calculatePingWait(timing/(useAnimSpeed and animationTrack.Speed or 1));

					waited = parry(convertedWait-offset,rootPart,animationTrack,maxRange,i);
					warn("WE WAITED "..waited,"CURRENT TIME|"..convertedWait);
					offset = waited-convertedWait;
				end

				_G.canAttack = true;
			end

			local function getSwingSpeed(mob,ignore)
				local hasHeavyHands = false;
				if not ignore then
					for _,v in next, mob:GetChildren() do
						if v.Name ~= 'Ring' or v:GetAttribute("EquipmentRef") ~= "Heavy Hands Ring" then continue; end

						hasHeavyHands = true;
						break;
					end
				end

				local handWeapon = mob:FindFirstChild('HandWeapon', true);
				if (not handWeapon) then return end;

				local swingSpeed = handWeapon:FindFirstChild('SwingSpeed', true);
				if (not swingSpeed) then return end;

				swingSpeed = swingSpeed.Value;

				if hasHeavyHands then
					swingSpeed = swingSpeed - 0.08;
				end

				return swingSpeed+1;
			end

			getgenv().getSwingSpeed = getSwingSpeed;
			getgenv().parryAttack = parryAttack;

			--Resonance Mantra

			animTimes['9236066780'] = function(_, mob) -- Shard Bow
				local distance = (mob.HumanoidRootPart.Position - myRootPart.Position).Magnitude;
				if (distance > 200) then return end;

				pingWait(0.5);

				if (distance > 15) then
					for _, v in next, workspace.Thrown:GetChildren() do
						if (v.Name ~= 'Clip') then continue; end
						if not IsA(v,'BasePart') then continue; end
						task.spawn(function()
							repeat
								task.wait();
							until not v.Parent or checkRange(15,v);

							if not v.Parent then return; end
							blockAttack();
							unblockAttack();
						end)
					end;
				else
					blockAttack();
					unblockAttack();
				end;
			end;

			-- Physical Mantras

			animTimes['8066909599'] = 0.47; -- Revenge
			animTimes['7608490737'] = 0.6; -- HeavenlyWind (Need to be checked)
			animTimes['12706574441'] = 0.45; -- Prominence Draw
			animTimes['6510127521'] = 0.6; -- Prominence Draw 2nd part

			animTimes['8085349676'] = 0.37; -- Strong Left
			animTimes['8198492537'] = 0.3; --Exhaustion Strike

			animTimes['8375086403'] = makeDelayBlockWithRange(40, 0.24); -- Masters Flourish
			animTimes['8379406836'] = makeDelayBlockWithRange(35,0.4); --Rapid Slashes (timing is a big wrong)

			animTimes['8150828674'] = function(_, mob) -- Rapid Punches
				local mobRoot = mob:FindFirstChild('HumanoidRootPart');
				if (not mobRoot and not checkRange(100, mobRoot)) then return end;
				pingWait(0.4);

				if (checkRange(10, mobRoot)) then
					blockAttack();
					unblockAttack();
					return;
				end;

				local didAt, lastParryAt = tick(), 0;

				repeat
					RunService.Stepped:Wait();

					if (checkRange(20, mobRoot) and tick() - lastParryAt > 0.2) then
						lastParryAt = tick();
						blockAttack();
						unblockAttack();
					end;
				until tick() - didAt > 1.1;
				if (tick() - didAt > 1.1) then return print('timed out') end;
			end;

			--Flame Mantra
			animTimes['8378263543'] = 0.3; --Fire Eruption
			animTimes['5953326460'] = 0.35; --Rising Flame

			animTimes['8199600822'] = function(_, mob) --Ash Slam
				parryAttack({0.3,0.3},mob.PrimaryPart,_,30)
			end

			animTimes['5963021481'] =  function(_, mob) --Meteor Slam (Rising Flame Pt2)
				if (not checkRange(10, mob.PrimaryPart)) then return end;

				pingWait(0.3);
				blockAttack();
				unblockAttack();
			end

			animTimes['7693947084'] = makeDelayBlockWithRange(10,0.3); --Flame Grab Close
			animTimes['5750353585'] = function(animationTrack, mob) -- Flame Grab Further
				repeat
					task.wait();
				until not animationTrack.IsPlaying or checkRange(15, mob.PrimaryPart);
				blockAttack();
				unblockAttack();
			end;

			animTimes['7608480718'] = function(_, mob) --Fire Forge
				if (not checkRange(30, mob.PrimaryPart) or not myRootPart) then return end;
				local mobRoot = mob:FindFirstChild('HumanoidRootPart');
				if (not mobRoot) then return end;

				local distance = (myRootPart.Position - mobRoot.Position).Magnitude;
				pingWait(0.05*distance-0.05);

				blockAttack();
				unblockAttack();
			end;

			animTimes['7542502881'] = function(_, mob) --Flame Leap
				if (not checkRange(15, mob.PrimaryPart) or not myRootPart) then return end;

				local mobRoot = mob:FindFirstChild('HumanoidRootPart');
				if (not mobRoot) then return end;
				pingWait(0.3);
				dodgeAttack();
			end;

			animTimes['5769343416'] = function(_, mob) --Burning Servants
				if (not checkRange(10, mob.PrimaryPart) or not myRootPart) then return end;
				local originalPos = mob.PrimaryPart.Position;
				local distance;
				pingWait(0.3);
				task.spawn(function()
					distance = (originalPos - myRootPart.Position).Magnitude;
					if distance > 10 then return; end

					blockAttack();
					unblockAttack();
				end)
				pingWait(1.8);
				distance = (originalPos - myRootPart.Position).Magnitude;
				if distance > 10 then return; end

				blockAttack();
				unblockAttack();
			end;

			animTimes['7585268054'] = function(_, mob) -- Flame Blind
				if (not checkRange(30, mob.PrimaryPart)) then return end;

				pingWait(0.7);
				dodgeAttack();
			end;

			--Thunder Mantra
			animTimes['7599168630'] = 0.2; --Lightning Blade
			animTimes['8183996606'] = makeDelayBlockWithRange(35, 0.4); -- Grand Javelin Small Range
			animTimes['7617742471'] = makeDelayBlockWithRange(60,0.2); --Lightning Beam

			animTimes['5750296638'] = function(_, mob) -- Jolt Grab
				pingWait(0.3);
				if (not checkRange(35, mob.PrimaryPart)) then return end;

				table.foreach(mob:GetChildren(), warn);

				if (not mob:FindFirstChild('ShadowHand')) then
					print('we use other');
					pingWait(0.2);
				end;

				blockAttack();
				unblockAttack();
			end;

			animTimes['5968282214'] = function(_, mob) -- Lightning Assault (The tp move)
				local target = mob:FindFirstChild('Target');
				if (target or not checkRange(85, mob.PrimaryPart)) then return end;

				pingWait(0.4);
				blockAttack();
				unblockAttack();
			end;

			animTimes['7861127585'] = 0.45; -- Thunder Kick
			animTimes['12333753799'] = 0.3; -- Thunder Rising windup

			animTimes['12333759044'] = function(_, mob) -- Thunder Rising Cast
				pingWait(0.3);

				repeat
					task.wait();
				until checkRange(30, mob.PrimaryPart) or not _.IsPlaying;
				if (not _.IsPlaying and not checkRange(30, mob.PrimaryPart)) then return print('stopped'); end;
				print('he close');

				blockAttack();
				unblockAttack();
			end;

			animTimes['5968796999'] = function(_, mob) -- Lightning Stream
				local distance = (mob.HumanoidRootPart.Position - myRootPart.Position).Magnitude;
				if (distance > 200) then return end;

				pingWait(0.4);
				local ranAt = tick();

				if (distance > 15) then
					repeat
						for _, v in next, workspace.Thrown:GetChildren() do
							if (v.Name == 'STREAMPART' and IsA(v, 'BasePart')) then
								local rocket = v:FindFirstChild('RocketPropulsion');
								local rocketTarget = rocket and rocket.Target;
								if (rocketTarget ~= myRootPart) then continue end;
								if(not checkRangeFromPing(v, 20, 30)) then continue end;

								blockAttack();
								unblockAttack();
								break;
							end;
						end;

						task.wait();
					until tick() - ranAt > 3.5;
				else
					blockAttack();
					unblockAttack();
				end;
			end;

			-- Silent Heart
			animTimes['12564120372'] = 0.3; -- Silent heart slide m1

			-- Dawn Walker
			animTimes['10622235550'] = function(anim,mob) -- Blinding Dawn
				pingWait(0.5);
				local start = tick();
				repeat
					if checkRange(37,mob.PrimaryPart) then
						blockAttack();
						unblockAttack();
					end
					task.wait(0.1);
				until not anim.IsPlaying or tick()-start >= 2;
				print("FINISHED")
			end

			-- Link Strider
			animTimes['10104294736'] = 0.3; -- Symbiotic Link

			-- Arc Warder
			animTimes['9481400792'] = makeDelayBlockWithRange(20,0.3); -- Arc Beam
			animTimes['9536688585'] = makeDelayBlockWithRange(30,0.4); -- Arc Wave

			-- Star Kindered (No element)
			animTimes['9941118927'] = 0.3; -- Celestial Assault

			animTimes['9461513613'] = function(anim,mob) -- Ascension
				repeat task.wait() until checkRange(25,mob.HumanoidRootPart) or not anim.IsPlaying
				if not anim.IsPlaying then return; end

				dodgeAttack();
			end;

			-- Star Kindered Fire
			animTimes['9717753391'] = function(anim,mob) -- Celestial Fireblade
				pingWait(1);
				local start = tick();
				repeat
					if (checkRange(50, mob.PrimaryPart)) then
						blockAttack();
						unblockAttack();
					end;
					task.wait(0.1);
				until not anim.IsPlaying or tick() - start >= 2;
			end

			animTimes['9919986614'] = function(anim,mob) -- Sinister Halo
				pingWait(0.4);

				if not checkRange(25,mob.PrimaryPart) or not anim.IsPlaying then return; end
				blockAttack();
				unblockAttack();
				pingWait(0.6);
				if not checkRange(25,mob.PrimaryPart) then return; end;

				for i = 1,5 do
					blockAttack();
					unblockAttack();
				end;
			end;

			-- Contractor
			animTimes['9726608174'] = makeDelayBlockWithRange(50, 0.5); -- Contractor Judgement
			animTimes['11862841821'] = 0.3; -- Contractor Equalizer
			animTimes['11328614766'] = function(_, mob) -- Contractor Pull
				pingWait(0.4);
				repeat task.wait(); until checkRange(20, mob.PrimaryPart) or not _.IsPlaying;
				if (not _.IsPlaying) then return print('timed out'); end;
				blockAttack();
				unblockAttack();
			end;

			--Monster Mantra
			animTimes['11219902982'] = function(anim,mob) -- Dread Breath
				pingWait(0.5);
				local start = tick();
				repeat
					if checkRange(40,mob.PrimaryPart) then
						blockAttack();
						unblockAttack();
					end
					task.wait(0.1);
				until not anim.IsPlaying or tick()-start >= 2;
			end

			--Ice Mantra
			animTimes['7598898608'] = 0.45; --Ice Smash
			animTimes['6396523003'] = 0.3; -- Crystal Knee
			animTimes['7616100008'] = function(animTrack, mob) -- Ice Beam
				if (not checkRange(85, mob.PrimaryPart)) then return end;

				local t = 0.00142*(mob.PrimaryPart.Position - myRootPart.Position).Magnitude + 0.58;
				parryAttack({t}, mob.PrimaryPart, animTrack, 85);
			end;

			animTimes['5786525661'] = function(_,mob) -- Warden Blades
				local elapsedAt = tick();
				pingWait(0.45);

				if (checkRange(25, mob.PrimaryPart)) then
					blockAttack();
					unblockAttack();
				end;

				repeat
					if (not checkRange(25, mob.PrimaryPart)) then task.wait() continue end;
					pingWait(0.8);
					task.spawn(function()
						blockAttack();
						unblockAttack();
					end);
				until tick() - elapsedAt > 3;
			end;

			animTimes['8018953639'] = function() -- Ice Chains
				pingWait(1.1);
				local chainPortalIce = workspace.Thrown:FindFirstChild('ChainPortalIce');
				if (not checkRange(20, chainPortalIce)) then return end;
				dodgeAttack();
			end;

			animTimes['8265980703'] = function(_, mob) --Ice Lance
				if (not checkRange(50, mob.PrimaryPart) or not myRootPart) then return end;
				local mobRoot = mob:FindFirstChild('HumanoidRootPart');
				if (not mobRoot) then return end;

				local distance = (myRootPart.Position - mobRoot.Position).Magnitude;

				if (distance < 15) then
					print('melee');
					pingWait(0.3);
				elseif (distance < 20) then
					print('far melee');
					pingWait(0.8);
				elseif (distance < 30) then
					print('far');
					pingWait(0.9);
				elseif (distance < 40) then
					print('rly far');
					pingWait(1);
				end;

				blockAttack();
				unblockAttack();
			end;

			-- Wind Mantra
			animTimes['7618754583'] = makeDelayBlockWithRange(40, 0.3); -- Gale Punch/Flame Palm
			animTimes['6470684331'] = makeDelayBlockWithRange(40, 0.45); -- Astral Wind
			animTimes['8310877920'] = makeDelayBlockWithRange(20, 0.4) -- Wind Gun
			animTimes['5828315760'] = makeDelayBlockWithRange(50, 0.3); -- Air Force

			animTimes['6466993564'] = 0.38; -- Wind Carve
			animTimes['9629695751'] = 0.35; --Champions Whirl Throw
			animTimes['10357806593'] = makeDelayBlockWithRange(15, 0.3); -- Tornado Kick

			animTimes['6030770341'] = function(_, mob) --Heavenly Wind
				pingWait(0.2);
				if (not checkRange(50, mob.PrimaryPart)) then return end;
				blockAttack();
				unblockAttack();
			end;

			animTimes['7794260173'] = function(_, mob) -- Wind Rising
				if (not checkRange(15, mob.PrimaryPart)) then return end;
				pingWait(0.4);
				blockAttack();
				unblockAttack();
			end;

			animTimes['9400896040'] = function(_, mob) -- Shoulder Bash
				local startedAt = tick();
				pingWait(0.3);

				repeat
					task.wait();
				until tick() - startedAt >= 5 or checkRange(20, mob.PrimaryPart);
				blockAttack();
				unblockAttack();
			end;

			animTimes['6017393708'] = makeDelayBlockWithRange(15, 0.3); -- Gale Lunge
			animTimes['6017418456'] = function(_, mob) -- Gale Lunge Launch Anim
				local mobRoot = mob:FindFirstChild('HumanoidRootPart');
				if (not mobRoot or not checkRange(35, mobRoot)) then return end;
				local distance = (mobRoot.Position - myRootPart.Position).Magnitude;
				pingWait(0.01*distance + 0.25);

				blockAttack();
				unblockAttack();
			end;

			animTimes['8375571405'] = function(animationTrack, mob) -- Pressure Blast
				if (not checkRange(40, mob.PrimaryPart)) then return end;
				pingWait(0.5);
				blockAttack();
				repeat
					task.wait();
				until not animationTrack.IsPlaying or not checkRange(40, mob.PrimaryPart);
				unblockAttack();
			end;

			-- Uppercut
			animTimes['11887898774'] = 0.3;
			animTimes['11887938902'] = 0.3;
			animTimes['11887876811'] = 0.3;
			animTimes['11887887621'] = 0.3;
			animTimes['11887892548'] = 0.3;
			animTimes['11887901212'] = 0.3;
			animTimes['11887874227'] = 0.3;

			-- Scythe
			animTimes['11493920418'] = 0.3; -- Slash 1
			animTimes['11493923277'] = 0.3; -- Slash 2
			animTimes['9597289518'] = 0.3; -- Slash 3
			animTimes['11493924588'] = 0.4; -- Running Attack

			do -- Great Axe
				local function getSpeed(x)
					return -1*x+2.05;
				end;

				local function f(animTrack, mob)

					local ignoreHeavyHand = false;
					for i,v in next, mob.Humanoid:GetPlayingAnimationTracks() do
						if v.Animation.AnimationId ~= 'rbxassetid://5971953898' or not v.IsPlaying then continue; end

						ignoreHeavyHand = true;
					end
					local swingSpeed = getSwingSpeed(mob,ignoreHeavyHand) or 1;

					parryAttack({getSpeed(swingSpeed)},mob.PrimaryPart,animTrack,15);
				end;

				animTimes['5064195992'] = f; -- Slash1
				animTimes['5067105317'] = f; -- Slash2
				animTimes['5067090007'] = f; -- Slash3 Also running attack
				animTimes['9484850093'] = 0.3; -- Slash4 (Kick)

				animTimes['7388133473'] = 0.65; -- Critical
				animTimes['10768748584'] = 0.6; -- Enforcer Axe Critical

				animTimes['11363599835'] = function(_, mob) -- Heavy Aerial
					pingWait(0.4);

					repeat
						task.wait();
					until checkRange(20, mob.PrimaryPart) or not _.IsPlaying;
					if (not _.IsPlaying) then return end;

					blockAttack();
					unblockAttack();
				end;
			end;

			animTimes['5805138186'] = 0.38;
			animTimes['4880830128'] = 0.35;
			animTimes['4880833465'] = 0.35;

			-- Railblade
			animTimes['9832721746'] = 0.4; -- Slash1
			animTimes['9832724876'] = 0.4; -- Slash2
			animTimes['9832727905'] = 0.4; -- Slash3
			animTimes['9597289518'] = 0.3; -- Slash4
			animTimes['9893133020'] = 0.4; -- Air Critical
			animTimes['9863424290'] = function(_, mob) -- Ground Critical
				task.spawn(function()
					pingWait(1.1);
					if (not _.IsPlaying or not checkRange(40, mob.PrimaryPart)) then return print('hi') end;
					dodgeAttack();
				end);

				pingWait(0.5);
				repeat
					task.wait();
				until not _.IsPlaying or checkRange(20, mob.PrimaryPart);
				if (not _.IsPlaying) then return print('timed out not playing') end;
				blockAttack();
				unblockAttack();
			end;

			-- Dagger
			do
				local function getSpeed(x)
					return -0.5*x + 1.275;
				end;

				local function f(animTrack, mob)
					local swingSpeed = getSwingSpeed(mob) or 1;

					parryAttack({getSpeed(swingSpeed)},mob.PrimaryPart,animTrack,15);
				end;

				animTimes['7627854272'] = f; -- Slash1
				animTimes['7627889074'] = f; -- Slash2
				animTimes['5950080662'] = 0.3; -- Slash4 (Kick)
				animTimes['5063313656'] = 0.39; -- Running Attack
				animTimes['7576614609'] = 0.39; -- Aerial Stab
			end;

			do --Spear Timings
				local function getSpeed(x)
					return -1*x+2.07;
				end;

				local function f(animTrack, mob)
					local swingSpeed = getSwingSpeed(mob) or 1;

					parryAttack({getSpeed(swingSpeed)},mob.PrimaryPart,animTrack,15);
				end;

				animTimes['7626771915'] = f; -- One Hand Slash 3
				animTimes['7627049402'] = f; -- One Hand Slash 4

				animTimes['7627558238'] = f; -- Two Hand Slash 2
				animTimes['7627372304'] = f; -- Two Hand Slash 3
			end;

			animTimes['5827250000'] = 0.35; -- Running Attack One Handed
			animTimes['5827423063'] = 0.35; -- Slash1

			animTimes['7576748728'] = 0.35; -- Aerial Stab

			-- Crazy Slot
			animTimes['7004327185'] = 0.3; --Crazy Slot Sword Mantra
			animTimes['7003448248'] = 0.6; --Crazy Slot Greatsword Mantra
			animTimes['7007372121'] = 1.8; --Crazy Slot Greataxe Mantra

			animTimes['7007974914'] = function(_,mob)--Crazy Slot Gun Mantra
				parryAttack({0.2,0.4,0.4},mob.PrimaryPart,_,20)
			end;
			animTimes['7005236296'] = makeDelayBlockWithRange(35,0.5); --Crazy Slot Dagger Mantra

			do -- Greatsword
				local function getSpeed(x)
					return -1*x+2.05;
				end;

				local function f(animTrack, mob)
					local swingSpeed = getSwingSpeed(mob) or 1;

					parryAttack({getSpeed(swingSpeed)},mob.PrimaryPart,animTrack,15);
				end;

				animTimes['12071495751'] = makeDelayBlockWithRange(10,0.5); --Petra Crit Start

				animTimes['12071557016'] = function(_, mob) -- Petra Critical
					repeat
						task.wait();
					until not _.IsPlaying or checkRange(20, mob.PrimaryPart);
					if (not _.IsPlaying) then return print('timed out not playing') end;
					blockAttack();
					unblockAttack();
				end;

				animTimes['12071942369'] = 0.6; -- Petra Critical (Pt2)

				animTimes['6675698010'] = f;
				animTimes['6675703249'] = f;

				animTimes['10258479464'] = 0.65; -- DarkSteel Critical
				animTimes['10053070573'] = function(animTrack, mob) --Crescent Cleaver (Timing is a little bit better but still inaccurate due to range)
					local root = mob:FindFirstChild('HumanoidRootPart');
					if (not root) then return end;

					local distance = (myRootPart.Position - root.Position).Magnitude;
					local t = math.max(0.7, 0.03*distance + 0.5);

					pingWait(t);
					if (not checkRange(20, root)) then return end;

					blockAttack();
					unblockAttack();
				end;

				-- Firstlight

				animTimes['13241958217'] = f;
				animTimes['13242083070'] = f;
			end;

			-- Sword
			do
				local function getSpeed(x)
					return -1*x+2.1;
				end;

				local function f(animTrack, mob)
					local swingSpeed = getSwingSpeed(mob) or 1;

					parryAttack({getSpeed(swingSpeed)},mob.PrimaryPart,animTrack,15);
				end;

				animTimes['7600450739'] = f; -- Slash1
				animTimes['7600485223'] = f; -- Slash2
				animTimes['7600160919'] = f; -- Slash3
				animTimes['7600224169'] = f; -- Slash4
			end;

			animTimes['8095864854'] = 0.55; -- Special Critical (Serpent's Edge)

			-- Curve Blade Of Winds
			animTimes['12106091136'] = 0.3; -- Slash1
			animTimes['12106093579'] = 0.3; -- Slash2
			animTimes['12106095892'] = 0.3; -- Slash3

			-- running attack (we use db)
			animTimes['4699358112'] = 0.36;

			animTimes['7827886914'] = 0.47; -- Katana critical
			animTimes['7351158603'] = 0.35; -- Spear critical
			animTimes['7318254065'] = 0.67; -- Sword critical
			animTimes['7350770431'] = 0.45; -- Dagger critical
			animTimes['7367818208'] = 0.73; -- Hammer critical
			animTimes['12921226261'] = 0.5; -- Sacred Hammer Crit
			animTimes['9209255758'] = 0.3; -- Whailing Knife Critical

			-- Karate (Way of Navae)
			do
				local function f(animTrack, mob)
					parryAttack({0.225}, mob.PrimaryPart, animTrack, 15, true);
				end;

				animTimes['6063188218'] = f; -- Slash 1
				animTimes['7616407967'] = f; -- Slash 2
				animTimes['6063195211'] = f; -- Slash 3
			end;

			-- Jus Karita
			animTimes['8278926990'] = 0.25; -- Slash1
			animTimes['8278929677'] = 0.25; -- Slash2
			animTimes['8278931393'] = 0.25; -- Slash3
			animTimes['9597289518'] = 0.3; -- Slash4 (Kick)
			animTimes['8278933540'] = 0.25; -- Slash4 (Kick)

			animTimes['7391446645'] = 0.5; -- Kick
			animTimes['8295145565'] = 0.4; -- Kick Ground?
			animTimes['8367730650'] = 0.3; -- Running Attack
			animTimes['8194213529'] = 0.3; -- Aerial Stab
			animTimes['10168663111'] = function(animationTrack,mob) --Tacet Drop Kick
				parryAttack({0.3},mob.PrimaryPart,animationTrack,30);
			end

			-- Legion Kata
			do
				local function f(animTrack, mob)
					parryAttack({0.2}, mob.PrimaryPart, animTrack, 20, true);
				end;

				animTimes['8161039359'] = f; -- Slash 1
				animTimes['8161043368'] = f; -- Slash 2
				animTimes['8161044711'] = f; -- Slash 3
				animTimes['8161094751'] = 0.3; -- Slash4 (Kick)
				animTimes['8169914770'] = 0.25; --This timing is prob wrong prob ius 0.3 but idk for duke
			end;

			-- Lantern Kata
			animTimes['11186652658'] = 0.3; -- Slash 1
			animTimes['11186654931'] = 0.3; -- Slash 2
			animTimes['11186656574'] = 0.3; -- Slash 3
			animTimes['9597289518'] = 0.3; -- Slash 4

			-- Mace/Club (we use db)
			animTimes['5805183957'] = 0.36; -- Slash1
			animTimes['5805191624'] = 0.41; -- Slash2
			animTimes['5805194816'] = 0.4; -- Slash3
			animTimes['7599410106'] = 0.52; -- Club critical

			-- Rapier
			animTimes['8249175106'] = 0.32; -- Slash
			animTimes['8249177669'] = 0.32; -- Slash
			animTimes['8249271040'] = 0.32; -- Critical

			-- Enforcer Blade (we use db)
			animTimes['6607519294'] = 0.45;
			animTimes['6607538047'] = 0.49;
			animTimes['6669352471'] = 0.39;

			-- Widow
			animTimes['6428519131'] = function(anim, mob) -- Widow Left Swing
				parryAttack({0.43}, mob.PrimaryPart, anim, 100, true);
			end;

			animTimes['6428525211'] = function(anim, mob) -- Widow Doublestab
				parryAttack({0.3}, mob.PrimaryPart, anim, 100);
			end;

			animTimes['6428514850'] = function(anim, mob) -- Widow RightSwing
				parryAttack({0.43}, mob.PrimaryPart, anim, 100, true);
			end;

			animTimes['6428530032'] = function(_, mob) -- Widow Spit
				if (not checkRange(100, mob.PrimaryPart)) then return end;
				pingWait(0.6);
				dodgeAttack();
			end;

			animTimes['6428533082'] = function(_, mob) -- Widow Bite
				if (not checkRange(100, mob.PrimaryPart)) then return end;
				pingWait(0.4);
				dodgeAttack();
			end;

			-- Primadon
			animTimes['8940731625'] = function(_, mob) --Scream
				if (not checkRange(100, mob.PrimaryPart)) then return end;
				pingWait(0.75);
				dodgeAttack();
			end;

			animTimes['8365199156'] = function(_, mob) -- Mid Swipe (Punch)
				if (not checkRange(100, mob.PrimaryPart)) then return end
				pingWait(0.5/_.Speed);

				blockAttack();
				task.wait();
				unblockAttack();
			end;

			animTimes['9225081967']  = function(_, mob) -- Swipe
				if (not checkRange(100, mob.PrimaryPart)) then return end
				pingWait(0.6 / _.Speed)

				blockAttack();
				task.wait();
				unblockAttack();
			end;

			animTimes['9225086332'] = function(_, mob) -- Grab
				if (not checkRange(100, mob.PrimaryPart)) then return end
				pingWait(0.6 / _.Speed);
				print('we dodge', _.TimePosition, _.Speed);

				dodgeAttack(true);
			end;

			animTimes['6438111139'] = function(_, mob) -- Punt
				if (not checkRange(100, mob.PrimaryPart)) then return end
				pingWait(0.75 / _.Speed);
				dodgeAttack();
			end;

			animTimes['9225098544'] = function(_, mob) --Stomp
				parryAttack({0.75}, mob.PrimaryPart, _, 100, true);
			end;

			animTimes['6432260013'] = function(anim, mob) -- Triple Stomp
				parryAttack({0.8, 0.775, 0.75}, mob.PrimaryPart, anim, 100, true);
			end;

			-- Avatar (Ethiron)
			animTimes['11508725111'] = function(_, mob)
				parryAttack({1.5}, mob.PrimaryPart, _, 400, true);
			end;

			-- crabbo
			animTimes['8176091986'] = makeDelayBlockWithRange(50, 1); --Double slam
			animTimes['7942002115'] = makeDelayBlockWithRange(50, 0.4); --Probably double swipe

			animTimes['7938093143'] = function(_, mob) -- grab
				if (not checkRange(50, mob.PrimaryPart)) then return end;

				pingWait(0.5);
				dodgeAttack();
			end;

			animTimes['7961600084'] = function(_,mob) --Jump attack
				if not checkRange(150,mob.PrimaryPart) then return; end
				repeat
					task.wait();
				until not _.IsPlaying or checkRange(15,mob.PrimaryPart)
				if not _.IsPlaying then return; end
				dodgeAttack();
			end;

			--Guns
			do
				local function getSpeed(x)
					return -0.5*x + 1.275; --Should be -0.5*x + 1.05
				end;

				local function f(animTrack, mob)
					local swingSpeed = getSwingSpeed(mob) or 1;

					parryAttack({getSpeed(swingSpeed)},mob.PrimaryPart,animTrack,15);
				end;

				animTimes['6437665734'] = f; -- Primary Shot
				animTimes['6432920452'] = f; -- Offhand shot
				animTimes['7565307809'] = f; -- Aerial Shot
				animTimes['8172871094'] = makeDelayBlockWithRange(20, 0.3); -- Rifle Spear Crit
			end;

			animTimes['9928429385'] = 0.3; -- Rifle
			animTimes['9928485641'] = 0.3; -- Rifle
			animTimes['9930447958'] = 0.3; -- Rifle
			animTimes['9928485641'] = 0.3; -- Rifle
			animTimes['9930618934'] = 0.3; -- Rifle

			animTimes['11468287607'] = 0.4; -- Shadow Hero Blade Critical
			animTimes['11312302005'] = 0.4; -- Wind Hero Blade Critical
			animTimes['11308969885'] = 0.4; --Flame Hero Blade Critical
			animTimes['10904625331'] = 0.4; --Thunder Hero Blade Critical
			animTimes['11183196198'] = makeDelayBlockWithRange(28,0.4); --Frost Hero Blade Critical

			animTimes['12108376249'] = 0.3; -- Eclipse kick
			animTimes['9212883524'] = 0.6; -- Halberd Critical

			animTimes['6415074870'] = function(_, mob) -- Shadow Gun
				if (not checkRange(60, mob.PrimaryPart)) then return end;

				pingWait(0.5);
				blockAttack();
				task.wait(0.3);
				unblockAttack();
			end;

			-- Golem
			animTimes['6500704554'] = function(_, mob) -- Upsmash (Dodge)
				if (not checkRange(50, mob.PrimaryPart)) then return end;

				pingWait(0.4);
				dodgeAttack();
			end;

			animTimes['6501497627'] = function(animationTrack, mob) -- Cyclone
				if (not mob.PrimaryPart) then return end;
				pingWait(3.3);

				repeat
					task.wait(0.1);

					if (not checkRange(50, mob.PrimaryPart)) then
						print('mob too far away :(');
						_G.canAttack = true;
						continue;
					end;

					_G.canAttack = false;
					print(animationTrack.IsPlaying, animationTrack.Parent);
					blockAttack();
					unblockAttack();
				until not animationTrack.IsPlaying or not mob.Parent;
				_G.canAttack = true;
			end;

			animTimes['6499077558'] = makeDelayBlockWithRange(50, 0.4); -- Double Smash
			animTimes['6501044846'] = makeDelayBlockWithRange(50, 0.5); -- Stomp

			-- Ice Mantra
			animTimes['5808939025'] = function(_, mob) -- Ice Eruption
				if (not checkRange(40, mob.PrimaryPart)) then return end;

				pingWait(0.35);
				dodgeAttack();
			end;

			animTimes['5865907089'] = function(_, mob) -- Glacial Arc
				if (not checkRange(40, mob.PrimaryPart)) then return end;

				pingWait(0.6);
				blockAttack();
				unblockAttack();
			end;

			animTimes['7612017515'] = makeDelayBlockWithRange(50, 0.3); -- Ice Blade
			animTimes['7543723607'] = 0.7; -- Ice Spike
			animTimes['7599113567'] = 0.6; -- Ice Dagger
			animTimes['6054920207'] = 0.3; -- Crystal Impale

			-- Shadow
			animTimes['9470857690'] = makeDelayBlockWithRange(40, 0.2); -- Shade Bringer
			animTimes['9359697890'] = 0.3; -- Shadow Devour
			animTimes['11959603858'] = 0.9; -- Shadow Stomp
			animTimes['11468287607'] = 0.4; -- Shadow Sword

			animTimes['9149348937'] = function(_, mob) -- Rising Shadow
				local distance = (mob.HumanoidRootPart.Position - myRootPart.Position).Magnitude;
				if (distance > 200) then return end;

				pingWait(0.4);
				local ranAt = tick();

				print(distance);
				if (distance > 8) then
					repeat
						for _, v in next, workspace.Thrown:GetChildren() do
							if (v.Name == 'TRACKER' and IsA(v, 'BasePart')) then
								if(not checkRangeFromPing(v, 5, 10)) then continue end;

								print('block');
								blockAttack();
								unblockAttack();
								break;
							end;
						end;

						task.wait();
					until tick() - ranAt > 3.5;
				else
					blockAttack();
					unblockAttack();
				end;
			end;

			animTimes['6318273143'] = function(_, mob) -- Shadow Assault
				if (not checkRange(80, mob.PrimaryPart) or not myRootPart) then return end;

				local mobRoot = mob:FindFirstChild('HumanoidRootPart');
				if (not mobRoot) then return end;

				local distance = (mobRoot.Position - myRootPart.Position).Magnitude;
				pingWait(0.3);
				pingWait(distance/60);
				blockAttack();
				unblockAttack();
			end;

			animTimes['8018881257'] = function(_, mob) -- Shadow eruption
				for i = 1, 2 do
					task.spawn(function()
						pingWait(i*0.33);
						if (not checkRange(30, mob.PrimaryPart)) then return end;
						blockAttack();
						unblockAttack();
					end);
				end;
			end;

			animTimes['7620630583'] = function(_, mob) -- Shadow Roar
				repeat
					pingWait(0.2);
					if (not checkRange(40, mob.PrimaryPart)) then continue end;
					task.spawn(function()
						blockAttack();
						unblockAttack();
					end);
				until not _.IsPlaying;
			end;

			animTimes['6038858570'] = function(animationTrack,mob) -- Darkblade
				if (not checkRange(80, mob.PrimaryPart)) then return end
				local distance = (myRootPart.Position - mob.PrimaryPart.Position).Magnitude;
				if distance < 5 then
					pingWait(0.37);
					blockAttack();
					unblockAttack();
					return;
				end
				repeat
					task.wait();
				until not animationTrack.IsPlaying or checkRange(15,mob.PrimaryPart);
				if not animationTrack.IsPlaying then return; end
				blockAttack();
				unblockAttack();
			end

			-- snow golem
			animTimes['8131612979'] = function(_, mob) -- groundPunch
				if (not checkRange(60, mob.PrimaryPart)) then return end

				pingWait(0.7);
				dodgeAttack();
			end;

			animTimes['8131156119'] = function(_, mob) -- Punt
				if (not checkRange(60, mob.PrimaryPart)) then return end

				pingWait(0.2)
				dodgeAttack();
			end;

			animTimes['8130745441'] = makeDelayBlockWithRange(40, 0.3); -- Swing1
			animTimes['8130778356'] = makeDelayBlockWithRange(40, 0.3); -- Swing2

			animTimes['8131374542'] = makeDelayBlockWithRange(100, 0.7); -- Air cutter

			-- squiddo (we use db)
			animTimes['6916513795'] = 0.225;
			animTimes['6916546485'] = 0.225;
			animTimes['6916545890'] = 0.225;

			-- enforcer (we use db)
			animTimes['7018046790'] = makeDelayBlockWithRange(50, 0.45); -- slash 1
			animTimes['7018083796'] = makeDelayBlockWithRange(50, 0.45); -- slash 2
			animTimes['7019686291'] = makeDelayBlockWithRange(50, 0.45); -- kick

			animTimes['7019018522'] = function(animationTrack, mob) -- spin
				print('got spin to win');

				repeat
					pingWait(0.1);

					if (not checkRange(30, mob.PrimaryPart)) then
						print('mob too far away :(');
						continue;
					end;

					blockAttack();
					unblockAttack();
				until not animationTrack.IsPlaying;
			end;

			-- Hive Mech
			animTimes['11834551880'] = function(_,mob)  --Roguemech upsmash
				if not checkRange(40,mob.PrimaryPart) then return; end
				pingWait(0.8);
				dodgeAttack();
			end;

			animTimes['11834549387'] = 0.5; --Roguemech Stomp
			animTimes['11834545925'] = 0.3; --Roguemech  Baragge Stomp
			animTimes['11867360757'] = makeDelayBlockWithRange(40,0.7); --Roguemech GroundPound

			-- crocco (we use db)
			animTimes['8226933122'] = function(_, mob) -- Triple bite
				parryAttack({0.44, 0.44, 0.44}, mob.PrimaryPart, _,  30);
			end;

			animTimes['10976633163'] = function(_, mob) -- Crocco Dig Move
				pingWait(0.7);

				local ranAt = tick();

				repeat
					task.wait();
					print(mob.HumanoidRootPart.Transparency);
				until checkRange(10, mob.HumanoidRootPart) or mob.HumanoidRootPart.Transparency == 0;
				if (tick() - ranAt > 8) then return print('not playing') end;

				print('parry!');

				blockAttack();
				unblockAttack();
			end;

			animTimes['8227583745'] = function(_, mob) --Double shlash Crocco
				parryAttack({0.3, 0.8}, mob.PrimaryPart, _, 30);
			end;

			animTimes['8228293862'] = function(_, mob) -- Breath
				if (not checkRange(75, mob.PrimaryPart)) then return end;

				pingWait(0.35);
				dodgeAttack();
			end;

			animTimes['8229868275'] = function(_, mob) -- Dig
				if (not checkRange(30, mob.PrimaryPart)) then return end;

				pingWait(2);
				dodgeAttack();
			end;

			animTimes['8227878518'] = function(_, mob) -- Tail
				parryAttack({0.65}, mob.PrimaryPart, _, 30);
			end;

			-- Black Tresher
			animTimes['11095471496'] = 0.4; -- Crocco Flip
			animTimes['9474995715'] = function(_,mob)-- CRocco Breath
				if not checkRange(20,mob.PrimaryPart) then return; end
				task.wait(0.2);
				dodgeAttack();
			end;

			-- sharko (we use db)
			animTimes['5117879514'] = function(animTrack, mob) -- Swipe
				parryAttack({0.37}, mob.PrimaryPart, animTrack, 40);
			end;

			animTimes['11710417615'] = function(animationTrack, mob) --Coral Attack
				-- sharko could do aoe attack if lots of player check that

				local target = mob:FindFirstChild('Target');
				target = target and target.Value;
				if (target ~= LocalPlayer.Character) then return end;

				pingWait(0.4);
				blockAttack();

				repeat
					task.wait();
				until not animationTrack.IsPlaying;

				unblockAttack();
			end;

			animTimes['10739102450'] = function(_, mob) -- Cortal Attack But for Player
				parryAttack({0.4}, mob.PrimaryPart, _, 35);
			end;

			animTimes['5121733951'] = function(_, mob) -- sharko double swipe
				parryAttack({0.43,0.58},mob.PrimaryPart,_,40);
			end;

			animTimes['11710290503'] = function(_, mob) -- sharko punt
				if (not checkRange(40, mob.PrimaryPart)) then return end;

				pingWait(0.35)
				dodgeAttack();
			end;

			animTimes['9357410713'] = function(_,mob) -- Mechalodant Beam
				pingWait(1.6);
				if not checkRange(80,mob.PrimaryPart) then return; end
				blockAttack();
				unblockAttack();
			end

			animTimes['9356892933'] = function(animationTrack, mob) -- Mechalodant GunFire
				local target = mob:FindFirstChild('Target');
				target = target and target.Value;
				if (target ~= LocalPlayer.Character) then return end;

				pingWait(0.4);
				blockAttack();

				repeat
					task.wait();
				until not animationTrack.IsPlaying;

				unblockAttack();
			end;

			animTimes['11710316011'] = function(_,mob) -- Sharko Water bite
				pingWait(0.5);
				if not checkRange(50,mob.PrimaryPart) then return; end
				dodgeAttack();
			end;

			animTimes['9903304018'] = function(_, mob) --Teleport Move
				pingWait(0.5);
				if (not checkRange(20, mob.PrimaryPart)) then return print('too far away') end;
				warn('block');
				dodgeAttack();
			end;

			--Ferryman
			local teleportedAt = tick();
			local firstAnim = tick();
			animTimes['5968288116'] = function(_, mob) -- Ferryman Teleport Attack (Doesn't work in second phase...)
				local target = mob:FindFirstChild('Target');
				if (not target or target.Value ~= LocalPlayer.Character) then return  warn('Ferryman Dash: Target is not LocalPlaye') end;

				if (mob.Humanoid.Health/mob.Humanoid.MaxHealth)*100 >= 50 then
					if tick()-teleportedAt > 2 then
						if tick() - firstAnim > 3 then
							firstAnim = tick();
							return;
						end
						teleportedAt = tick();
						parryAttack({0.8},mob.PrimaryPart,_,1000,true)
					else
						teleportedAt = tick();
						parryAttack({0.2},mob.PrimaryPart,_,1000,true)
					end
				else
					if tick()-teleportedAt > 2 then
						if tick() - firstAnim > 3 then
							firstAnim = tick();
							return;
						end
						teleportedAt = tick();
						parryAttack({0.8},mob.PrimaryPart,_,1000,true)
					else
						teleportedAt = tick();
						parryAttack({0.1},mob.PrimaryPart,_,1000,true)
					end
				end
			end;


			-- Owl
			animTimes['7639648215'] = makeDelayBlockWithRange(40, 0.3); -- Swipe (Idk)
			animTimes['7639988883'] = makeDelayBlockWithRange(40, 0.6); -- Slow Swipe (Ok)
			animTimes['7675544287'] = function(_, mob) -- Grab
				local target = mob:FindFirstChild('Target');
				target = target and target.Value;

				if (target ~= LocalPlayer.Character) then return warn('owl grab: target is not localplayer') end;

				pingWait(0.35);
				dodgeAttack();
			end;

			animTimes['7673097597'] = function(_, mob) -- Owl rush (spinning attack)
				local target = mob:FindFirstChild('Target');
				target = target and target.Value;

				if (target ~= LocalPlayer.Character) then return print('owl spin target is not localplayer') end;

				pingWait(0.37);
				dodgeAttack();
			end;

			-- Mud Skipper
			animTimes['11573034823'] = 0.22;
			animTimes['11572468462'] = 0.22;

			-- Lion Fish

			animTimes['5680585677'] = function(_, mob)
				if (not checkRange(70, mob.PrimaryPart)) then return print('lion fish beam triple bite too far away') end;

				task.spawn(function()
					pingWait(0.4);
					blockAttack();
					unblockAttack();
				end);

				task.spawn(function()
					pingWait(1.1);
					blockAttack();
					unblockAttack();
				end);

				task.spawn(function()
					pingWait(1.8);
					blockAttack();
					unblockAttack();
				end);
			end;

			animTimes['6372560712'] = function(animTrack, mob) -- FishBeam
				local target = mob:FindFirstChild('Target');
				target = target and target.Value;

				if (target ~= LocalPlayer.Character) then return print('lion fish beam target not set to player') end;

				local wasUp = false;

				repeat
					local _, _, z = mob:GetPivot():ToOrientation();

					if (z < -1.7 and not wasUp) then
						wasUp = true;
						warn('rised up');
					elseif (z > -1.5 and wasUp) then
						warn('rised down', animTrack.TimePosition, animTrack.Speed);
						dodgeAttack();
						break;
					end;

					task.wait();
				until not animTrack.IsPlaying or not mob.Parent;
			end;

			-- Duke
			animTimes['8285321158'] = function(_, mob)
				parryAttack({0.87},mob.PrimaryPart,_,34)
				print("---------------WIND BALL SHOT----------------")
			end;

			animTimes['8285534401'] = function(_, mob) --Wind Stomp thing
				pingWait(0.5);
				if (not checkRange(28, mob.PrimaryPart)) then return end;
				dodgeAttack();
				print("---------------Wind stomp")
			end;

			animTimes['8290626574'] = function(_, mob) --Wind Stomp 2
				pingWait(0.7);
				if (not checkRange(118, mob.PrimaryPart)) then return end;
				dodgeAttack();
				print("---------------Wind Stomp 2",tick());
			end;


			animTimes['8285638571'] = function(_, mob) --Downward punch?
				pingWait(0.1);
				if (not checkRange(47, mob.PrimaryPart)) then return end;
				dodgeAttack();
				print("---------------Downward Punch")
			end;

			animTimes['8286153000'] = function(_, mob) --Wind Arrow
				parryAttack({0.4},mob.PrimaryPart,_,34)
				print("---------------Wind Arrow")

			end;

			animTimes['8290899374'] = function(_, mob) --Levitate
				pingWait(0.8);
				if (not checkRange(28, mob.PrimaryPart)) then return end;
				dodgeAttack();
				print("---------------Levitate")
			end;

			animTimes['8294560344'] = function(_, mob) --Spirit Bomb?
				pingWait(2.1);
				if (not checkRange(47, mob.PrimaryPart)) then return end;
				dodgeAttack();
				print("---------------Spirint Bomb")
			end;

			-- Car Buncle
			animTimes['9422296675'] = 0.8; -- Leap
			animTimes['9422278968'] = function(_, mob) -- Flail
				if (not checkRange(100, mob.PrimaryPart)) then return end;

				pingWait(0.9);

				repeat
					task.wait();
					if (not checkRange(40, mob.PrimaryPart)) then continue end;

					blockAttack();
					unblockAttack();
					pingWait(0.4);
				until not _.IsPlaying or not mob.Parent;
			end;

			-- Boneboy (Bonekeeper)
			animTimes['9681905891'] = function(_, mob) -- Charge Prep
				print('charge anim star!t');
				pingWait(0.8);

				repeat task.wait(); until checkRange(30, mob.PrimaryPart) or not _.IsPlaying;

				print('charge!');
				dodgeAttack();
			end;

			animTimes['9681421310'] = function(_, mob)
				print('sweep1');
				parryAttack({0.6}, mob.PrimaryPart, _, 30);
			end;

			animTimes['9710538334'] = function(_, mob)
				print('choke start');
				if (not checkRange(30, mob.PrimaryPart)) then return end;
				pingWait(0.3);
				dodgeAttack();
				unblockAttack();
			end;

			-- Chaser
			animTimes['10099861170'] = makeDelayBlockWithRange(70, 0.8); -- The Slam (end part)

			local effectsList = {};

			-- Silent heart uppercut
			effectsList.Mani = function(effectData)
				if (effectData.target ~= myRootPart.Parent) then return end;

				blockAttack();
				unblockAttack();
			end;

			effectsList.ManiWindup = function(effectData)
				if((effectData.pos - myRootPart.Position).Magnitude >= 45) then return print('too far'); end;

				pingWait(0.3);
				blockAttack();
				unblockAttack();
			end;

			effectsList.EthironPointSpikes = function(effectData)
				pingWait(0.5);
				for _, point in next, effectData.points do
					if(checkRange(20, point.pos)) then
						dodgeAttack();
						break;
					end;
				end;
			end;

			effectsList.EnforcerPull = function(effectData)
				if (string.find(effectData.char.Name, '.enforcer')) then return end;
				if (effectData.targ ~= LocalPlayer.Character) then return end;
				blockAttack();
				unblockAttack();
			end;

			effectsList.Perilous = function(effectData)
				if (not string.find(effectData.char.Name, '.chaser')) then return end;
				pingWait(0.5);
				dodgeAttack();
			end;

			effectsList.DisplayThornsRed = function(effectData) -- Umbral Knight
				if (effectData.Character ~= LocalPlayer.Character) then return print('Umbral Knight wasnt on me')  end;
				blockAttack();
				unblockAttack();
			end;

			effectsList.DisplayThorns = function(effectData) --Providence Thorns
				if effectData.Character ~= LocalPlayer.Character then return print('Providence Hit wasnt on me') end;
				pingWait(effectData.Time-effectData.Window);
				blockAttack();
				unblockAttack();
			end;

			effectsList.FireHit2 = function(effectData)
				if effectData.echar ~= LocalPlayer.Character then return print('Fire Hit wasnt on me'); end
				pingWait(1);
				blockAttack();
				unblockAttack();
			end

			effectsList.GolemLaserFire = function(effectData)
				if (not checkRange(15, effectData.aimPos)) then return print('Golem laser: Too far away') end;
				print('DA DODGIES');
				dodgeAttack();
			end;

			effectsList.WindCarve = function(effectData)
				if (effectData.char == LocalPlayer.Character) then return; end
				if (effectData.command ~= 'startAttack' or not checkRange(17, effectData.char.PrimaryPart)) then return end;
				local startedAt = tick();

				repeat
					task.spawn(function()
						blockAttack();
						unblockAttack();
					end);
					task.wait(0.2);
				until tick() - startedAt > effectData.dur+0.5;
				table.foreach(effectData, warn);
			end;

			-- Fire SongSeeker

			effectsList.FireSword = function(effectData)
				if (not checkRange(25, effectData.Character.PrimaryPart)) then return print('Fire Sword: Too far away') end;
				if (effectData.Character == LocalPlayer.Character) then return end;
				if (effectData.BlueFlame) then return; end
				pingWait(0.55);
				print('we parry it!');
				blockAttack();
				unblockAttack();
			end;

			effectsList.FireSwordBlue = function(effectData)
				if (not checkRange(25, effectData.Character.PrimaryPart)) then return print('Fire Sword: Too far away') end;
				if (effectData.Character == LocalPlayer.Character) then return end;

				pingWait(0.6);
				print('we parry it!');
				blockAttack();
				unblockAttack();
			end;

			effectsList.FireDash = function(effectData)
				if (not checkRange(50, effectData.Character.PrimaryPart)) then return print('Fire Dash: Too far away') end;
				if (effectData.Character == LocalPlayer.Character) then return end;

				table.foreach(effectData, warn);
				print('OOOOMG EPICO');
				blockAttack();
				unblockAttack();
			end;

			effectsList.fireRepulseWindup = function(effectData)
				if (not checkRange(50, effectData.char.PrimaryPart)) then return print('Fire Repulse Wind Up: Too far away') end;
				if (effectData.char == LocalPlayer.Character) then return end;

				pingWait(0.8);
				blockAttack();
				pingWait(1);
				unblockAttack();
			end;

			effectsList.FireSlashSpin = function(effectData)
				-- RisingFlame
				if (not checkRange(20, effectData.Character.PrimaryPart)) then return print('Fire Slash Spin: Too far away') end;
				if not (effectData.pos) then return print("Ignoring Fire Spin"); end
				if (effectData.Character == LocalPlayer.Character) then return end;

				blockAttack();
				unblockAttack();
			end;

			-- Wind Song Seeker

			effectsList.WindSword = function(effectData)
				if (not checkRange(25, effectData.Character.PrimaryPart)) then return print('Wind Sword: Too far away') end;
				if (effectData.Character == LocalPlayer.Character) then return end;
				if (effectData.Time == 1.1) then return end; -- Gale Lunge wind sword (hopefully dont break anything)

				pingWait(0.4);
				blockAttack();
				unblockAttack();
			end;

			effectsList.OwlDisperse = function(effectData)
				local target = effectData.Character and effectData.Character:FindFirstChild('Target');
				if (not target or target.Value ~= LocalPlayer.Character) then return end;

				print('owl disperse!');

				local startedAt = tick();
				local duration = effectData.Duration;

				task.wait(duration/3);

				while (tick() - startedAt <= duration+0.3) do
					task.spawn(function()
						blockAttack();
						unblockAttack();
					end);
					task.wait(0.2);
				end;
				print('owl disperse finished');
			end;

			effectsList.ThrowWeaponLocal = function(data) --Stormbreaker Recall
				local obj = data.Primary;
				if (not obj) then return end;

				repeat task.wait() until obj.Anchored;

				repeat
					task.wait();
				until not obj.Parent or checkRange(20, obj);
				if not obj.Parent then return; end

				blockAttack();
				unblockAttack();
			end;

			-- Vent
			effectsList.BlueStun = function(effectData)
				if (effectData.CH == LocalPlayer.Character) then return; end
				if (not checkRange(20,effectData.CH.PrimaryPart)) then return; end
				if (not library.flags.parryVent) then return end;

				blockAttack();
				unblockAttack();
			end;

			--if (debugMode) then
			--	getgenv().effectsList = effectsList;
			--	getgenv().pingWait = pingWait;
			--end;

			animTimes['11889580367'] = function(_, mob) --Stormbreaker Close Range
				if (not checkRange(20, mob.PrimaryPart)) then return end;

				pingWait(0.6);
				blockAttack();
				task.wait(0.2);
				unblockAttack();
			end;

			_G.blacklistedNames = {'chest', 'ReducedDamage','MoveStack','BallShake','IceEruption','DigHide','FadeModel','GaleLeap4','SetModelCFrame','FallingBoulder','waterdash','WallCollisionKnockdown','KickTrail','MovementLines','WallCollisionBigSmall','GroundSmash', 'BigBlockParry', 'minisplash', 'roll', 'DamageBody', 'BlueEffect', 'Parry', 'ClearDamageBody', 'NoStun', 'StopDodge', 'WindTrails', 'RedParry', 'WallCollision', 'BlockParry', 'RedEffect', 'NPCGesture', 'CancelGesture', 'LightningDodger2', 'newLightningEruptionBoss'};

			local function getCaster(data)
				if not data then return; end
				local caster;
				for _,obj in next, data do
					if typeof(obj) ~= "Instance" or obj.Parent ~= workspace.Live or obj == LocalPlayer.Character then continue; end

					return obj;
				end
				return caster;
			end

			ReplicatedStorage.Requests.ClientEffect.OnClientEvent:Connect(function(effectName, effectData)
				if (not library.flags.autoParry or table.find(_G.blacklistedNames, effectName)) then return end;

				local caster = getCaster(effectData);

				if (caster) then
					local autoParryMode = library.flags.autoParryMode;
					local isPlayer = Players:FindFirstChild(caster.Name)

					if (not autoParryMode.All) then
						--If not Parry Guild and its a player and hes in your guild do nothing
						if (not autoParryMode.Guild and isPlayer and Utility:isTeamMate(isPlayer)) then
							return;
						end
						--If Parry Mobs and its a player and they dont parry players then do nothing
						if (autoParryMode.Mobs and isPlayer and not autoParryMode.Players) then
							return
						end;
						--If Parry Player and its not a player and don't parry mobs then do nothing
						if (autoParryMode.Players and not isPlayer and not autoParryMode.Mobs) then
							return;
						end;
						--If Parry Guild And Its a Player and its not guild member then do nothing
						if (autoParryMode.Guild and isPlayer and not Utility:isTeamMate(isPlayer)) then
							return;
						end
					end;
				end;

				local f = effectsList[effectName];

				if (f) then
					warn('Using custom effectFunc for', effectName);
					f(effectData, effectName);
				elseif (getgenv().UNKNOWN_EFFECT_LOG) then
					print('Unknown effect', effectName);
				end;
			end);

			local parryMaid = Maid.new();
			local autoParryProxy = 0;

			_G.canAttack = true;

			-- Get Chaser
			do
				local chaser;

				function functions.getChaser()
					if (not chaser) then
						for _, npc in next, workspace.Live:GetChildren() do
							if (npc.Name:find('.chaser')) then
								chaser = npc;
								break;
							end;
						end;
					end;

					return chaser;
				end;
			end;

			function functions.autoParry(toggle)
				autoParryProxy += 1;

				if (not toggle) then
					maid.autoParryOnNewCharacter = nil;
					maid.autoParryInputDebug = nil;
					maid.autoParryOrb = nil;
					maid.autoParrySlotBall = nil;
					maid.autoParryLayer2DescAdded = nil;
					maid.autoParryOnEffectAddd = nil;

					parryMaid:DoCleaning();

					return;
				end;

				if (debugMode) then
					getgenv().animTimes = animTimes;
					getgenv().blockAttack = blockAttack;
					getgenv().unblockAttack = unblockAttack;

					getgenv().makeDelayBlockWithRange = makeDelayBlockWithRange;
					getgenv().checkRange = checkRange;
					getgenv().dodgeRemote = dodgeRemote;
					getgenv().dodgeAttack = dodgeAttack;
				end;

				local lastUsedMantraAt = 0;
				local lastUsedMantra;

				-- Trial of one orb auto parry
				if (game.PlaceId == 8668476218) then
					if (isLayer2) then
						local chaserBeamDebounce = true;

						maid.autoParryLayer2DescAdded = workspace.DescendantAdded:Connect(function(obj)
							if (obj.Name == 'BloodTendrilBeam') then -- Chaser Beam
								if (not chaserBeamDebounce) then return end;
								chaserBeamDebounce = false;
								_G.canAttack = false;

								task.delay(0.1, function() chaserBeamDebounce = true; end);
								pingWait(0.55);
								blockAttack();
								unblockAttack();
								_G.canAttack = true;
							elseif (obj.Name == 'SpikeStabEff') then -- Chaser Explosion
								_G.canAttack = false;
								pingWait(0.6);
								if (not checkRange(20, obj)) then _G.canAttack = true; return end;
								print(obj, 'got added', obj:GetFullName());
								blockAttack();
								unblockAttack();
								_G.canAttack = true;
							elseif (obj.Name == 'ParticleEmitter3' and string.find(obj:GetFullName(), 'avatar')) then -- Avatar Beam
								pingWait(0.75);

								local avatar = obj.Parent.Parent.Parent;
								local target = avatar and avatar:FindFirstChild('Target');

								if (target and target.Value ~= LocalPlayer.Character) then return end;

								_G.canAttack = false;
								warn('AVATAR BEAM: now we parry');
								repeat
									blockAttack();
									unblockAttack();
									task.wait(0.1);
								until not obj.Parent or not obj.Enabled;
								_G.canAttack = true;
							elseif (obj.Name == 'GrabPart') then -- Avatar Blind Ball
								repeat
									task.wait();
								until not obj.Parent or checkRange(20, obj);
								if (not obj.Parent) then return end;
								dodgeAttack();
							end
						end);
					else
						local lastParryAt = 0;
						local spawnedAt;

						maid.autoParryOrb = RunService.RenderStepped:Connect(function(dt)
							if (not myRootPart) then return end;
							local myPosition = myRootPart.Position;

							for _, v in next, workspace.Thrown:GetChildren() do
								if (not spawnedAt) then
									spawnedAt = tick();
								end;

								if (v.Name == 'ArdourBall2' and tick() - spawnedAt >= 3) then
									local distance = (myPosition - v.Position).Magnitude;

									if (distance <= 15 and tick() - lastParryAt >= 0.1) then
										lastParryAt = tick();
										blockAttack(true);
										unblockAttack();
										break;
									end;
								end;
							end;
						end);
					end;
				end;

				-- firstlight = firesworda
				-- Lesser Angel Air Spear Attack
				maid.autoParrySlotBall = workspace.Thrown.ChildAdded:Connect(function(obj)
					task.wait();
					if (not myRootPart) then return end;

					if (obj.Name == 'SlotBall') then
						repeat
							task.wait();
						until (obj.Position - myRootPart.Position).Magnitude <= 20 or not obj.Parent;

						if (not obj.Parent) then
							return warn('Object got destroyed');
						end;

						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'BoulderProjectile' and (myRootPart.Position - obj.Position).Magnitude < 500) then
						repeat
							task.wait()
						until (obj.Position - myRootPart.Position).Magnitude <= 30 or not obj.Parent;
						if (not obj.Parent) then return end;
						dodgeAttack();
					elseif (obj.Name == 'SpearPart' and (myRootPart.Position - obj.Position).Magnitude < 600) then
						-- Grand Javelin Long Range
						if (myRootPart.Position - obj.Position).Magnitude <= 35 then return; end
						repeat
							task.wait()
						until (obj.Position - myRootPart.Position).Magnitude <= 80 or not obj.Parent;
						if (not obj.Parent) then return end;
						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'StrikeIndicator' and (myRootPart.Position - obj.Position).Magnitude < 10) then
						pingWait(0.2);
						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'WindSlashProjectile' and (myRootPart.Position - obj.Position).Magnitude < 200) then
						if (myRootPart.Position - obj.Position).Magnitude <= 10 then return; end
						repeat
							task.wait()
						until checkRange(30, obj) or not obj.Parent;
						if (not obj.Parent) then return end;
						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'IceShuriken' and checkRange(300, obj) and not (lastUsedMantra == 'ForgeIce' and tick() - lastUsedMantraAt < 1)) then
						print(tick() - lastUsedMantraAt, lastUsedMantra);
						repeat
							task.wait();
						until not obj.Parent or checkRange(20, obj);
						if (not obj.Parent) then return end;
						print('parry');
						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'IceDagger' and not checkRange(20, obj)) then
						local rocketPropulsion = obj:WaitForChild('RocketPropulsion', 10);
						if (not rocketPropulsion or rocketPropulsion.Target ~= myRootPart) then return end;

						repeat
							task.wait();
						until not obj.Parent or checkRange(20, obj);
						if (not obj.Parent) then return end;

						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'WindProjectile' and not checkRange(20, obj)) then
						repeat
							task.wait();
						until checkRange(80, obj) or not obj.Parent;
						if (not obj.Parent) then return end;

						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'WindKickBrick' and not checkRange(15, obj)) then
						-- Tornado Kick

						repeat
							task.wait();
						until checkRange(40, obj) or not obj.Parent;
						if (not obj.Parent) then return end;
						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'SeekerOrb') then
						-- Shadow Seeker
						local rocketPropulsion = obj:WaitForChild('RocketPropulsion', 10);
						if (not rocketPropulsion or rocketPropulsion.Target ~= myRootPart) then return end;
						repeat
							task.wait();
						until not obj.Parent or checkRange(2, obj);
						if (checkRange(2, obj)) then
							blockAttack();
							unblockAttack();
						end;
					elseif (obj.Name == 'Beam') then
						-- Arc Beam
						local endPart = obj:WaitForChild('End', 10);
						if (not endPart) then return; end;

						repeat task.wait(); until checkRange(30, endPart) or not obj.Parent;
						if (not obj.Parent) then print('Despawned') return; end;

						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'DiskPart' and checkRange(100, obj)) then
						-- Sinister Halo
						repeat task.wait(); until checkRange(20, obj) or not obj.Parent;
						if (not obj.Parent) then print('Despawned') return; end;

						pingWait(0.3);
						blockAttack();
						unblockAttack();
						task.wait(0.3);
						if (not checkRange(15, obj)) then return end;
						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'BoneSpear') then -- Avatar Bone Throw
						pingWait(0.5);

						if (isLayer2) then
							repeat
								task.wait();
							until not obj.Parent or checkRangeFromPing(obj, 30, 175);
						else
							repeat
								task.wait();
							until not obj.Parent or checkRange(30, obj);
						end;

						if (not obj.Parent) then return end;
						blockAttack();
						unblockAttack();
					elseif (obj.Name == 'Bullet' and not checkRange(10, obj)) then
						repeat
							task.wait();
						until checkRangeFromPing(obj, 20, 20) or not obj.Parent;
						if (not obj.Parent) then return end;

						blockAttack();
						unblockAttack();
					end;
				end);

				_G.canAttack = true;

				local blacklistedLoggedAnims = {'5808247302', '180435792', '10380978324', '5554732065', '6010566363'};
				local blacklistedLoggedAnimsFind = {}; -- 'walk', 'idle', 'movement-', 'roll-', 'draw', '-block', '-parry', '-shakeblock'};

				local AutoParryEntity = {};
				AutoParryEntity.__index = AutoParryEntity;

				function AutoParryEntity.new(character)
					if (character == LocalPlayer.Character) then return end;

					local self = setmetatable({
						_character = character,
						_name = character.Name,
						_maid = Maid.new(),
						_isPlayer = Players:FindFirstChild(character.Name)
					}, AutoParryEntity);

					self._maid:GiveTask(character:GetPropertyChangedSignal('Parent'):Connect(function()
						local newParent = character.Parent;
						if (newParent == nil) then return self:Destroy() end;
					end));

					self._maid:GiveTask(Utility.listenToChildAdded(character, function(obj)
						if (obj.Name == 'HumanoidRootPart') then
							self._rootPart = obj;
							self:_onHumanoidAdded(); -- We call it here cause we want AnimationPlayed to be listened if there is rootPart

							local feintSound = obj:FindFirstChild('Feint', true);
							if (not feintSound) then return end;

							print('Got feint found!');

							self._maid.feintSoundPlayed = feintSound.Played:Connect(function()
								if (not library.flags.rollAfterFeint) then return end;
								print('feeint', (self._rootPart.Position - myRootPart.Position).Magnitude);
								rollOnNextAttacks[character] = true;

								local con;
								con = effectReplicator.EffectRemoving:connect(function(effect)
									if (effect.Class == 'ParryCool') then
										rollOnNextAttacks[character] = nil;
									end;
								end);

								task.delay(3, function()
									if (not character.Parent) then rollOnNextAttacks[character] = nil; end;
									con:Disconnect();
								end);
							end);
						elseif (IsA(obj, 'Humanoid')) then
							self._humanoid = obj;
							self:_onHumanoidAdded();
						end;
					end));

					self._maid:GiveTask(Utility.listenToChildRemoving(character, function(obj)
						if (obj.Name == 'HumanoidRootPart') then
							self._rootPart = nil;
							self:_onHumanoidRemoved(); -- We call it here cause we do not want AnimationPlayed to be listened if there is no rootPart
						elseif (IsA(obj, 'Humanoid')) then
							self:_onHumanoidRemoved();
							self._humanoid = nil;
						end;
					end));

					parryMaid:GiveTask(function()
						self._maid:Destroy();
					end);

					return self;
				end;

				local blacklistedLogs = {'6500704554', '6501497627'};
				local pastSent = {};

				function AutoParryEntity:_onHumanoidAdded()
					if (not self._rootPart or not self._humanoid) then return end;
					local humanoid = self._humanoid;

					self._maid[humanoid] = humanoid.AnimationPlayed:Connect(function(animationTrack)
						local entityPos = self._rootPart and self._rootPart.Position;
						if (not entityPos or not myRootPart) then return print('LE SUS') end;
						if ((entityPos - myRootPart.Position).Magnitude >= 300) then return end;
						if (library.flags.autoParryWhitelist[self._name]) then return end;

						if (self._isPlayer and (animationTrack.WeightTarget == 0 or animationTrack.Priority == Enum.AnimationPriority.Core)) then
							return -- print('dont do', animationTrack.Animation.AnimationId, animationTrack.Priority, animationTrack.WeightTarget, animationTrack.Speed);
						end;

						local animId = animationTrack.Animation.AnimationId:match('%d+');

						if (self._isPlayer and table.find(mobsAnims, animId)) then
							local msg = string.format('%s - %s', animId, self._character.Name);
							if (not table.find(blacklistedLogs, animId) and not table.find(pastSent, msg)) then
								-- this technically memory leaks but oh well
								table.insert(pastSent, msg);
								--debugWebhook:Send(msg);
							end;
							return; -- Anti auto parry trying to play mob anims so that it don't show cause of invalid rig
						end;

						local autoParryMode = library.flags.autoParryMode;

						if (not autoParryMode.All) then

							--If not Parry Guild and its a player and hes in your guild do nothing
							if (not autoParryMode.Guild and self._isPlayer and Utility:isTeamMate(self._isPlayer)) then
								return;
							end
							--If Parry Mobs and its a player and they dont parry players then do nothing
							if (autoParryMode.Mobs and self._isPlayer and not autoParryMode.Players) then
								return
							end;
							--If Parry Player and its not a player and don't parry mobs then do nothing
							if (autoParryMode.Players and not self._isPlayer and not autoParryMode.Mobs) then
								return;
							end;
							--If Parry Guild And Its a Player and its not guild member then do nothing
							if (autoParryMode.Guild and self._isPlayer and not Utility:isTeamMate(self._isPlayer)) then
								return;
							end
						end;

						if (library.flags.checkIfFacingTarget) then
							local dotProduct = (entityPos - myRootPart.Position):Dot(myRootPart.CFrame.LookVector);
							if (dotProduct <= 0) then return print('Not parrying player is not facing target') end;
						end;

						local animName = allAnimations[animId];

						local waitTime = animTimes[animId];
						local maxRange = getgenv().defaultRange or 20;

						if (typeof(waitTime) == 'table') then
							local waitTimeObject = animTimes[animId];

							maxRange = waitTimeObject.maxRange or 20;
							waitTime = waitTimeObject.waitTime;
						end;

						if (typeof(waitTime) == 'function') then
							warn('[Auto Parry] Using custom function for', animId, animName or 'no animation name');
							waitTime(animationTrack, self._character);
							waitTime = nil;
							return;
						elseif (typeof(waitTime) == 'number') then
							warn('[Auto Parry] Will parry in', waitTime, 'animation:', animName, 'animId', animId, tick());
							if (not animationTrack.IsPlaying) then return print('feeint 2') end;

							print('anim state', animationTrack.IsPlaying);
							--Parry Attack
							parryAttack({waitTime},self._rootPart,animationTrack,maxRange);

							_G.canAttack = true;
							return;
						end;

						if (debugMode) then return end;
						animName = animName and animName:lower();

						if (not table.find(blacklistedLoggedAnims, animId)) then
							for _, v in next, blacklistedLoggedAnimsFind do
								if (animName and animName:find(v)) then
									return;
								end;
							end;

							print('[Auto Parry] Unknown Animation Played', animId, animName and animName or 'NO_ANIM_NAME ');
						end;
					end);
				end;

				function AutoParryEntity:_onHumanoidRemoved()
					local humanoid = self._humanoid;
					if (not humanoid) then return end;
					self._maid[humanoid] = nil;
				end;

				function AutoParryEntity:Destroy()
					self._maid:Destroy();
				end;

				maid.autoParryOnNewCharacter = Utility.listenToChildAdded(workspace.Live, AutoParryEntity);

				maid.autoParryOnEffectAddd = effectReplicator.EffectAdded:connect(function(effect)
					if (effect.Class == 'UsingMove') then
						lastUsedMantraAt = tick();
						lastUsedMantra = effect.Value.Name:match('Mantra%:(.-)%p');
					end;
				end);
			end;

			local killBricks = {};
			local killBricksObjects = {};

			local killBricksNames = {'KillPlane', 'ChasmBrick', 'ThronePart', 'KillBrick', 'SuperWall'};

			local function onNoDebrisAdded(object)
				local name = object.Name;
				local isSpikeTrap = name == 'SpikeTrap';

				if (table.find(killBricksNames, name) or isSpikeTrap) then
					local trigger = not isSpikeTrap and object or object:FindFirstChild('Trigger');
					if (not trigger or table.find(killBricksObjects, trigger)) then return end;
					table.insert(killBricksObjects, trigger);

					table.insert(killBricks, {
						part = trigger,
						oldParent = trigger.Parent
					});

					if (library.flags.noKillBricks) then
						task.defer(function() trigger.Parent = nil; end);
					end;
				end;
			end;

			library.OnLoad:Connect(function()
				if (isLayer2) then
					Utility.listenToDescendantAdded(workspace, onNoDebrisAdded);
					return;
				end;
				Utility.listenToTagAdded('NoDebris', onNoDebrisAdded);
			end);

			function functions.noWind(t)
				if (not t) then
					maid.noWind = nil;
					return;
				end;

				maid.noWind = RunService.Heartbeat:Connect(function()
					local rootPart = Utility:getPlayerData().rootPart;
					if (not rootPart) then return end;

					local windPusher = rootPart:FindFirstChild('WindPusher');
					if (windPusher) then
						windPusher.Parent = Lighting;
					end;
				end);
			end;

			function functions.noKillBricks(toggle)
				for i, v in next, killBricks do
					v.part.Parent = not toggle and v.oldParent or nil;
				end;
			end;

			function functions.infiniteJump(toggle)
				if(not toggle) then return end;

				repeat
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if(rootPart and UserInputService:IsKeyDown(Enum.KeyCode.Space)) then
						rootPart.Velocity = Vector3.new(rootPart.Velocity.X, library.flags.infiniteJumpHeight, rootPart.Velocity.Z);
					end;
					task.wait(0.1);
				until not library.flags.infiniteJump;
			end;

			function functions.goToGround()
				local params = RaycastParams.new();
				params.FilterDescendantsInstances = {workspace.Live, workspace.NPCs};
				params.FilterType = Enum.RaycastFilterType.Blacklist;

				if (not myRootPart or not myRootPart.Parent) then return end;

				local floor = workspace:Raycast(myRootPart.Position, Vector3.new(0, -1000, 0), params);
				if(not floor or not floor.Instance) then return end;

				local isKillBrick = false;

				for _, v in next, killBricks do
					if (floor.Instance == v.part) then
						isKillBrick = true;
						break;
					end;
				end;

				if (isKillBrick) then return end;

				myRootPart.CFrame *= CFrame.new(0, -(myRootPart.Position.Y - floor.Position.Y) + 3, 0);
				myRootPart.Velocity *= Vector3.new(1, 0, 1);
			end;

			local allChests = {};

			function functions.autoOpenChest(toggle)
				if (not toggle) then
					maid.autoOpenChest = nil;
					return;
				end;

				maid.autoOpenChest = task.spawn(function()
					while task.wait() do
						if (not myRootPart) then continue end;
						local pos = myRootPart.Position;
						local closestDistance, chest = math.huge;

						for _, v in next, allChests do
							if (not v.chest:FindFirstChild('Lid') or not v.chest:FindFirstChild('InteractPrompt')) then continue end;

							local dist = (v.chest.Lid.Position - pos).Magnitude;

							if (dist <= closestDistance and dist <= 14 and not v.checked) then
								closestDistance = dist;
								chest = v;
							end;
						end;

						if (not chest) then continue end;
						if (LocalPlayer.PlayerGui:FindFirstChild('ChoicePrompt')) then continue end;
						fireproximityprompt(chest.chest.InteractPrompt);

						if (LocalPlayer.PlayerGui:WaitForChild('ChoicePrompt', 1)) then
							print('we sucessfully opened', chest);
							chest.checked = true;
							task.wait(0.1);
						end;
					end;
				end);
			end;

			do -- // Auto Parry Helper
				if (not isfolder('Roniro Hub V3/Block Points')) then
					makefolder('Roniro Hub V3/Block Points');
				end;

				local autoparryConfigsLoaded = 0;
				local cryptoKey, cryptoIv = fromHex('e5f137adf2983b4273d9dd708ea9bde4'), fromHex('6ec1049ef63e7780db40b825ab605658');

				local function makeParryFunction(parryConfigData)
					local blockPoints = parryConfigData.points;
					local maxRange = parryConfigData.maxRange;

					return function(_, mob)
						if (not checkRange(maxRange, mob.PrimaryPart) or not myRootPart) then return end;

						for _, blockPoint in next, blockPoints do
							if (blockPoint.type == 'waitPoint' and blockPoint.waitTime ~= 0) then
								pingWait(blockPoint.waitTime);
							elseif (blockPoint.type == 'blockPoint') then
								if (blockPoint.parryMode == 'Parry') then
									blockAttack();
									unblockAttack();
								elseif (blockPoint.parryMode == 'Dodge') then
									dodgeAttack();
								elseif (blockPoint.parryMode == 'Block') then
									blockAttack();
								elseif (blockPoint.parryMode == 'Unblock') then
									unblockAttack();
								end;
							end;
						end;
					end;
				end

				local showedNotif = false;


				if (autoparryConfigsLoaded > 0) then
					ToastNotif.new({
						text = string.format('[Auto Parry] %s config(s) loaded', autoparryConfigsLoaded),
						duration = 5,
					})
				end;

				local blockPoints = {};
				local lastAnimationId = library.flags.animationId;

				local function updateAutoParryFunction()
					local animationId = library.flags.animationId;

					if (animTimes[lastAnimationId]) then
						animTimes[lastAnimationId] = nil;
					end;

					animTimes[animationId] = makeParryFunction({points = blockPoints, maxRange = library.flags.blockPointMaxRange});
					lastAnimationId = animationId;
				end;

				local function clearUiObjects(uiObjects, blockPoint)
					table.remove(blockPoints, table.find(blockPoints, blockPoint));

					for _, v in next, uiObjects do
						v.main:Destroy();
					end;

					table.clear(uiObjects);
				end;

				function functions.addBlockPoint(autoParryMaker)
					local blockPoint = {};
					blockPoint.type = 'blockPoint';
					blockPoint.parryMode = 'Parry';

					local uiObjects = {};

					table.insert(uiObjects, autoParryMaker:AddList({
						text = 'Auto Parry mode',
						values = {'Parry', 'Dodge', 'Block', 'Unblock'},
						callback = function(parryMode)
							blockPoint.parryMode = parryMode;
							updateAutoParryFunction();
						end
					}));

					table.insert(uiObjects, autoParryMaker:AddButton({
						text = 'Delete Point',
						callback = function()
							clearUiObjects(uiObjects, blockPoint);
						end,
					}));

					table.insert(blockPoints, blockPoint);
				end;

				function functions.addWaitPoint(autoParryMaker)
					local blockPoint = {};
					blockPoint.type = 'waitPoint';
					blockPoint.waitTime = 0;

					local uiObjects = {};

					table.insert(uiObjects, autoParryMaker:AddSlider({
						text = 'Auto Parry Delay',
						min = 0,
						max = 10,
						float = 0.1,
						textpos = 2,
						callback = function(value)
							blockPoint.waitTime = value;
							updateAutoParryFunction();
						end,
					}));

					table.insert(uiObjects, autoParryMaker:AddButton({
						text = 'Delete Point',
						callback = function()
							clearUiObjects(uiObjects, blockPoint);
						end,
					}));

					table.insert(blockPoints, blockPoint);
				end;

				function functions.exportBlockPoints()

				end;
			end;

			local effectReplicatorEnv = getfenv(effectReplicator.CreateEffect);
			local stunEffects = {'NoMove', 'NoJump', 'NoJumpAlt', 'Action', 'Unconscious', 'Knocked', 'Carried', 'Stun', 'Knocked'};
			local fastSwingEffects = {'OffhandAttack', 'HeavyAttack', 'MediumAttack', 'LightAttack', 'UsingSpell'};

			local oldClearEffect = effectReplicatorEnv.clearEffects;

			-- Todo get bindableevent upvalue and base cleareffect of the remote onclientevent
			local function setupNoStun()
				effectReplicator.EffectAdded:connect(function(effect)
					if (effect.Class == 'Knocked' and LocalPlayer.Character) then
						local humanoid = LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
						local handle = LocalPlayer.Backpack:FindFirstChild('Handle', true) and LocalPlayer.Backpack:FindFirstChild('Handle', true).Parent;
						local weapon = LocalPlayer.Backpack:FindFirstChild('Weapon') or LocalPlayer.Character:FindFirstChild('Weapon');

						local tool = not library.flags.useWeaponForKnockedOwnership and handle or weapon;

						if (not humanoid) then return end;

						local bone = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Head') and LocalPlayer.Character.Head:WaitForChild('Bone', 5);
						while bone and bone.Parent do
							if (not library.flags.knockedOwnership) then task.wait(); continue; end;

							tool.Parent = LocalPlayer.Character;
							task.wait(tool == weapon and 0.15 or 0.05);
							tool.Parent = LocalPlayer.Backpack;
							task.wait(tool == weapon and 0.15 or 0.05);
						end;

						task.wait(0.1);

						if (library.flags.knockedOwnership) then
							if (weapon.Parent ~= LocalPlayer.Character) then
								weapon.Parent = LocalPlayer.Character;
							end;

							handle.Parent = LocalPlayer.Backpack;
						end;
					end;


					if (effect.Class == 'Dodge') then
						task.wait(3);
						canDodge = true;
					end;

					if (library.flags.noStun and table.find(stunEffects, effect.Class)) then
						task.defer(function()
							effect:Remove(true);
						end);
					end;

					if (library.flags.noJumpCooldown and effect.Class == "OverrideJumpPower") then
						task.defer(function()
							effect:Remove(true);
						end);
					end;

					if (library.flags.noStunLessBlatant and table.find(fastSwingEffects, effect.Class)) then
						task.defer(function()
							effect:Remove(true);
						end);
					end;
				end);
			end;

			function effectReplicatorEnv.clearEffects()
				oldClearEffect();
				setupNoStun();
			end;

			setupNoStun();

			do -- // Load ESP
				local function onNewIngredient(instance, espConstructor)
					if (not IsA(instance, 'BasePart') and not IsA(instance, 'MeshPart')) then return end;
					local esp = espConstructor.new(instance, instance.Name, nil, true);

					local connection;
					connection = instance:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not instance.Parent) then
							esp:Destroy();
							connection:Disconnect();
						end;
					end);
				end;

				local function onNewMobAdded(mob, espConstructor)
					if (not CollectionService:HasTag(mob, 'Mob')) then return end;

					local code = [[
		local mob = ...;
		local FindFirstChild = game.FindFirstChild;
		local FindFirstChildWhichIsA = game.FindFirstChildWhichIsA;

		return setmetatable({
			FindFirstChildWhichIsA = function(_, ...)
				return FindFirstChildWhichIsA(mob, ...);
			end,
		}, {
			__index = function(_, p)
				if (p == 'Position') then
					local mobRoot = FindFirstChild(mob, 'HumanoidRootPart');
					return mobRoot and mobRoot.Position;
				end;
			end,
		})
	]];

					local formattedName = formatMobName(mob.Name);
					local mobEsp = espConstructor.new({code = code, vars = {mob}}, formattedName);

					if (formattedName == 'Megalodaunt Legendary' and library.flags.artifactNotifier) then
						ToastNotif.new({text = 'A red sharko has spawned, go check songseeker!'});
					end;

					local connection;
					connection = mob:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not mob.Parent) then
							connection:Disconnect();
							mobEsp:Destroy();
						end;
					end);
				end;

				local function onNewNpcAdded(npc, espConstructor)
					local npcObj;
					if (IsA(npc, 'BasePart') or IsA(npc, 'MeshPart')) then
						npcObj = espConstructor.new(npc, npc.Name);
					else
						local code = [[
			local npc = ...;
			return setmetatable({}, {
				__index = function(_, p)
					if (p == 'Position') then
						return npc.PrimaryPart and npc.PrimaryPart.Position or npc.WorldPivot.Position
					end;
				end,
			});
		]]

						npcObj = espConstructor.new({code = code, vars = {npc}}, npc.Name);
					end;

					local connection;
					connection = npc:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not npc.Parent) then
							npcObj:Destroy();
							connection:Disconnect();
						end;
					end);
				end;

				local function onNewAreaAdded(area, espConstructor)
					repeat
						task.wait();
					until area:FindFirstChildWhichIsA('BasePart');
					espConstructor.new(area:FindFirstChildWhichIsA('BasePart'), area.Name, nil, true);
				end;

				local function onNewChestAdded(item, espConstructor)
					if (not CollectionService:HasTag(item, 'Chest')) then return; end;

					local code = [[
		local CollectionService = game:GetService('CollectionService');
		local item = ...;
		return setmetatable({}, {
			__index = function(_, p)
				if (p == 'Position') then
					if (library.flags.onlyShowClosedChest and not CollectionService:HasTag(item, 'ClosedChest')) then
						return;
					end;

					return item.PrimaryPart and item.PrimaryPart.Position or item.WorldPivot.Position;
				end;
			end
		});
	]];

					local espItem = espConstructor.new({code = code, vars = {item}}, 'Chest');
					local data = {chest = item};

					local connection;
					connection = item:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not item.Parent) then
							table.remove(allChests, table.find(allChests, data));
							espItem:Destroy();
							connection:Disconnect();
						end;
					end);

					table.insert(allChests, data);
				end;

				local function onNewExplodeCrateAdded(item, espConstructor)
					if(item.Name ~= 'ExplodeCrate') then return; end;
					local espItem = espConstructor.new(item, 'Crate');
					item.Destroying:Once(function()
						espItem:Destroy();
					end);
				end;

				local function onNewBagAdded(item, espConstructor)
					if (item.Name ~= 'BagDrop') then return; end;

					local esp = espConstructor.new(item, 'Bag');
					local connection;
					connection = item:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not item.Parent) then
							esp:Destroy();
							connection:Disconnect();
						end;
					end);
				end;

				local function onNewObjectAdded(object, espConstructor)
					local artifactName;

					if (object.Name == 'PieceofForge') then
						artifactName = 'Artifact';
					elseif (object.Name == 'EventFeatherRef') then
						artifactName = 'Owl';
					end;

					if (not artifactName) then return end;

					if (library.flags.artifactNotifier) then
						ToastNotif.new({
							text = string.format('%s spawned. You can see it by turning on Artifact ESP.', artifactName);
						});
					end;

					local code = [[
		local object = ...;

		return setmetatable({}, {
			__index = function(_, p)
				if (p == 'Position') then
					return object.PrimaryPart and object.PrimaryPart.Position or object.WorldPivot.Position
				end;
			end,
		});
	]];

					local isModel = IsA(object, 'Model');
					local espObject = espConstructor.new(isModel and {code = code, vars = {object}} or object, artifactName);

					local connection;
					connection = object:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not object.Parent) then
							espObject:Destroy();
							connection:Disconnect();
						end;
					end);
				end;

				local function onNewBlackBellAdded(object, espConstructor)
					if (object.Name ~= 'DarkBell') then return end;
					print('found', object.Name);

					local blackBell = espConstructor.new(object, 'BlackBell');

					local connection;
					connection = object:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not object.Parent) then
							blackBell:Destroy();
							connection:Disconnect();
						end;
					end);
				end;

				local function onNewGuildDoorAdded(object, espConstructor)
					if (object.Name:sub(1, 10) ~= 'GuildDoor_') then return end;
					print('found', object.Name);

					local guildDoor = espConstructor.new(object, 'GuildDoor');

					local connection;
					connection = object:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not object.Parent) then
							guildDoor:Destroy();
							connection:Disconnect();
						end;
					end);
				end;

				local function onLampAdded(object, espConstructor)
					if (object.Name ~= 'BurnOff') then return end;

					local lamp = espConstructor.new(object, 'Lamp');

					local connection;
					connection = object:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not object.Parent) then
							lamp:Destroy();
							connection:Disconnect();
						end;
					end);
				end;

				local function onNewWhirlPoolAdded(object, espConstructor)
					if (object.Name ~= 'DepthsWhirlpool') then return end;

					local code = [[
		local object = ...;
		return setmetatable({}, {
			__index = function(_, p)
				if (p == 'Position') then
					return object.PrimaryPart and object.PrimaryPart.Position or object.WorldPivot.Position
				end;
			end,
		});
	]];

					espConstructor.new({code = code, vars = {object}}, 'Whirlpool');
				end;

				local itemsToNotify = {'Curved Blade Of Winds', 'Crypt Blade'};

				local function onDroppedItemAdded(object, espConstructor)
					if (IsA(object, 'MeshPart')) then
						local itemName = droppedItemsNames[object.MeshId:match('%d+') or ''];
						local esp = espConstructor.new(object, itemName);

						if (table.find(itemsToNotify, itemName) and library.flags.mythicItemNotifier) then
							ToastNotif.new({
								text = string.format('%s has been dropped turn on dropped items to see it.', itemName)
							});
						end;

						object.Destroying:Once(function()
							esp:Destroy();
						end);
					end;
				end;

				local function makeList(folder, section)
					local seen = {};
					local list = {};

					for _, instance in next, folder:GetChildren() do
						if (seen[instance.Name]) then continue end;

						seen[instance.Name] = true;
						table.insert(list, instance.Name);
					end;

					table.sort(list, function(a, b)
						return a < b;
					end);

					return Utility.map(list, function(name)
						local t =  section:AddToggle({
							text = name,
							flag = string.format('Show %s', name),
							state = true
						});

						t:AddColor({
							text = string.format('%s Color', name),
							color = Color3.fromRGB(255, 255, 255)
						});

						return t;
					end);
				end;

				function functions.playerProximityCheck(toggle)
					if (not toggle) then
						maid.proximityCheck = nil;
						return;
					end;

					local notifSend = setmetatable({}, {
						__mode = 'k';
					});

					maid.proximityCheck = RunService.Heartbeat:Connect(function()
						if (not myRootPart) then return end;

						for _, v in next, Players:GetPlayers() do
							local rootPart = v.Character and v.Character.PrimaryPart;
							if (not rootPart or v == LocalPlayer) then continue end;

							local distance = (myRootPart.Position - rootPart.Position).Magnitude;

							if (distance < 300 and not table.find(notifSend, rootPart)) then
								table.insert(notifSend, rootPart);
								ToastNotif.new({
									text = string.format('%s is nearby [%d]', v.Name, distance),
									duration = 30
								});
							elseif (distance > 500 and table.find(notifSend, rootPart)) then
								table.remove(notifSend, table.find(notifSend, rootPart))
								ToastNotif.new({
									text = string.format('%s is no longer nearby [%d]', v.Name, distance),
									duration = 30
								});
							end;
						end;
					end);
				end;

				do -- No Anims
					function functions.noAnims(t)
						if (not t) then
							if (not maid.noAnimsLoop) then return end;
							maid.noAnimsOnCharAdded = nil;
							maid.noAnimsLoop = nil;

							local humanoid = Utility:getPlayerData().humanoid;
							if (not humanoid) then return end;

							for _, track in next, humanoid.Animator:GetPlayingAnimationTracks() do
								if (track.Animation.AnimationId ~= 'http://www.roblox.com/asset/?id=109212722752') then continue end;
								track:Stop();
								track:Destroy();
							end;

							return;
						end;

						local function onCharacterAdded(char)
							local humanoid = char:WaitForChild('Humanoid', 10);
							humanoid = humanoid and humanoid:WaitForChild('Animator', 10);

							if (not humanoid or not library.flags.noAnims) then return end;

							for _, animTrack in next, humanoid:GetPlayingAnimationTracks() do
								animTrack:Stop();
								animTrack:Destroy();
							end;

							local anim = Instance.new('Animation');
							anim.AnimationId = 'http://www.roblox.com/asset/?id=109212722752';

							for i = 1, 257 do
								local track = humanoid:LoadAnimation(anim)
								track.Priority = 1000;
								track:AdjustSpeed(0);
								track:Play();
							end;

							maid.noAnimsLoop = task.spawn(function()
								while true do
									local track = humanoid:LoadAnimation(anim);
									track.Priority = 1000;
									track:AdjustSpeed(0);
									track:Play();
									task.wait(0.1);
								end;
							end);
						end;

						if (LocalPlayer.Character) then task.spawn(onCharacterAdded, LocalPlayer.Character) end;
						maid.noAnimsOnCharAdded = LocalPlayer.CharacterAdded:Connect(onCharacterAdded);
					end;
				end;

				do --GetJar
					local function closestJar(isLayer2Pt2)
						local last = math.huge;
						local closest;

						local rootPart = Utility:getPlayerData().rootPart;
						if (not rootPart) then return end;

						local findBone = false;
						local findObelisk = false;

						if (isLayer2Pt2 and LocalPlayer.Character and not LocalPlayer.Character:FindFirstChild('BoneSpear')) then
							-- We are not carrying bone, we want to find a bone
							findBone = true;
						end;

						local tagName = findBone and 'Interactible' or isLayer2Pt2 and 'BoneAltar' or 'BloodJar';
						local myPos = myRootPart.Position;

						local obelisks = CollectionService:GetTagged('BuzzObelisk');
						local t = CollectionService:GetTagged(tagName);

						if (isLayer2Pt2 and #obelisks > 0) then
							t = obelisks;
							findObelisk = true;
						end;

						for _, v in next, t do
							local thing;

							if (findObelisk) then
								if (v.Name ~= 'BuzzPart') then continue end;
								thing = v;
							elseif (findBone) then
								if (v.Name ~= 'BoneSpear') then continue end;
								thing = v;
							elseif (isLayer2Pt2) then
								if (v.Name ~= 'Altar') then continue end;
								thing = not v:FindFirstChild('BoneSpear');
							else
								thing = v:FindFirstChild('ActivatedJar')
							end;

							local pos = IsA(v, 'BasePart') and v.Position or v:GetPivot().Position;

							if (thing and (pos - myPos).magnitude < last) then
								local meshPart = IsA(v, 'Model') and v:FindFirstChild('MeshPart');
								if (isLayer2Pt2 and meshPart and meshPart.Transparency ~= 0) then continue end;
								closest = v;
								last = (pos - myPos).magnitude;
							end;
						end;

						return closest;
					end;

					function functions.autoBloodjar(ended)
						if (ended) then
							maid.autoJar = nil;
							maid.jarTween = nil;
							maid.autoJarVelocity = nil;
							return;
						end;

						local running = false;

						maid.autoJar = RunService.Heartbeat:Connect(function()
							if (running) then return; end;

							local chaser = functions.getChaser();
							local damagePhase = chaser and chaser.HumanoidRootPart and chaser.HumanoidRootPart:FindFirstChild('DamagePhase');

							local rootPart = Utility:getPlayerData().rootPart;
							if (not rootPart) then return; end;

							local jar = damagePhase and chaser or closestJar(workspace:FindFirstChild('Layer2Floor2'));
							if (not jar) then return; end

							running = true;

							maid.autoJarVelocity = RunService.Stepped:Connect(function()
								LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.zero;
							end)

							local tween = tweenTeleport(rootPart, jar:GetPivot().Position, true);

							maid.jarTween = function()
								tween:Cancel();
							end;

							task.wait(0.2);
							running = false;
						end);
					end;
				end

				do -- Anti AP
					local randomAnims = {};

					for _, v in next, ReplicatedStorage.Assets.Anims.Weapon:GetDescendants() do
						if (v.Name:lower():find('slash')) then
							table.insert(randomAnims, v);
						end;
					end;

					for i = #randomAnims, 2, -1 do
						local j = math.random(i);
						randomAnims[i], randomAnims[j] = randomAnims[j], randomAnims[i];
					end;

					randomAnims = randomAnims[1];

					function functions.antiAutoParry(t)
						if (not t) then
							maid.antiAutoParry = nil;
							return;
						end;

						maid.antiAutoParry = task.spawn(function()
							while true do
								task.wait();

								local humanoid = Utility:getPlayerData().humanoid;
								if (not humanoid) then continue end;

								pcall(function()
									local animTrack = humanoid:LoadAnimation(randomAnims);

									task.delay(1, function()
										animTrack:Stop();
										animTrack:Destroy();
									end);

									animTrack:play(9999, 0, 0);
								end);
							end;
						end);
					end;
				end;

				function Utility:renderOverload(data)
					data.espSettings:AddToggle({
						text = 'Show Danger Timer'
					});

					makeESP({
						sectionName = 'Ingredients',
						type = 'childAdded',
						args = workspace.Ingredients,
						noColorPicker = true,
						callback = onNewIngredient,
						onLoaded = function(section)
							return {list = makeList(ReplicatedStorage.Assets.Ingredients, section)};
						end
					});

					makeESP({
						sectionName = 'Dropped Items',
						type = 'tagAdded',
						args = 'LootDrop',
						callback = onDroppedItemAdded
					});

					makeESP({
						sectionName = 'Mobs',
						type = 'childAdded',
						args = workspace.Live,
						callback = onNewMobAdded,
						onLoaded = function(section)
							section:AddToggle({
								text = 'Show Health',
								flag = 'Mobs Show Health'
							});
						end
					});

					makeESP({
						sectionName = 'Npcs',
						type = 'childAdded',
						args = workspace.NPCs,
						callback = onNewNpcAdded
					});

					makeESP({
						sectionName = 'Chests',
						type = 'childAdded',
						args = workspace.Thrown,
						callback = onNewChestAdded,
						onLoaded = function(section)
							section:AddToggle({text = 'Only Show Closed Chest'});
						end
					});

					makeESP({
						sectionName = 'Artifacts',
						type = 'childAdded',
						args = {workspace, workspace.Thrown},
						callback = onNewObjectAdded
					});

					makeESP({
						sectionName = 'Crates',
						type = 'childAdded',
						args = workspace.Thrown,
						callback = onNewExplodeCrateAdded
					});

					makeESP({
						sectionName = 'Whirlpools',
						type = 'childAdded',
						args = workspace,
						callback = onNewWhirlPoolAdded
					});

					makeESP({
						sectionName = 'Guild Dors',
						type = 'childAdded',
						args = workspace,
						callback = onNewGuildDoorAdded
					});

					makeESP({
						sectionName = 'Bags',
						type = 'childAdded',
						args = workspace.Thrown,
						callback = onNewBagAdded
					});

					makeESP({
						sectionName = 'Areas',
						type = 'childAdded',
						args = markerWorkspace.AreaMarkers,
						noColorPicker = true,
						callback = onNewAreaAdded,
						onLoaded = function(section)
							return {list = makeList(markerWorkspace.AreaMarkers, section)};
						end
					});

					if (game.PlaceId == 5735553160) then
						-- // Depths

						makeESP({
							sectionName = 'Black Bells',
							type = 'childAdded',
							args = workspace,
							callback = onNewBlackBellAdded
						})
					elseif (game.PlaceId == 8668476218) then
						-- // Layer Two

						makeESP({
							sectionName = 'Lamps',
							type = 'descendantAdded',
							args = workspace,
							callback = onLampAdded
						});
					end;
				end;

				function Utility:isTeamMate(player)
					local myGuild = LocalPlayer:GetAttribute('Guild') or '';
					local playerGuild = player:GetAttribute('Guild') or '';
					if myGuild == '' then return; end

					return myGuild == playerGuild;
				end

				library.OnKeyPress:Connect(function(input, gpe)


					if (gpe) then return end;

					local key = library.options.attachToBack.key;
					if (input.KeyCode.Name == key or input.UserInputType.Name == key) then
						local myRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
						local closest, closestDistance = nil, math.huge;

						if (not myRootPart) then return end;

						repeat
							for _, entity in next, workspace.Live:GetChildren() do
								local rootPart = entity:FindFirstChild('HumanoidRootPart');
								if (not rootPart or rootPart == myRootPart) then continue end;

								local distance = (rootPart.Position - myRootPart.Position).magnitude;

								if (distance < 300 and distance < closestDistance) then
									closest, closestDistance = rootPart, distance;
								end;
							end;

							task.wait();
						until closest or input.UserInputState == Enum.UserInputState.End;
						if (input.UserInputState == Enum.UserInputState.End) then return end;

						maid.attachToBack = RunService.Heartbeat:Connect(function()
							local goalCF = closest.CFrame * CFrame.new(0, library.flags.attachToBackHeight, library.flags.attachToBackSpace);

							local distance = (goalCF.Position - myRootPart.Position).Magnitude;
							local tweenInfo = TweenInfo.new(distance / 100, Enum.EasingStyle.Linear);

							local tween = TweenService:Create(myRootPart, tweenInfo, {
								CFrame = goalCF
							});

							tween:Play();

							maid.attachToBackTween = function()
								tween:Cancel();
							end;
						end);
					end;
				end);

				library.OnKeyRelease:Connect(function(input)


					local key = library.options.attachToBack.key;
					if (input.KeyCode.Name == key or input.UserInputType.Name == key) then
						maid.attachToBack = nil;
						maid.attachToBackTween = nil;
					end;
				end);
			end;

			local playerSpectating;
			local playerSpectatingLabel;

			do -- // Setup Leaderboard Spectate
				local lastUpdateAt = 0;

				function setCameraSubject(subject)
					if (subject == LocalPlayer.Character) then
						playerSpectating = nil;
						CollectionService:RemoveTag(LocalPlayer, 'ForcedSubject');

						if (playerSpectatingLabel) then
							playerSpectatingLabel.TextColor3 = Color3.fromRGB(255, 255, 255);
							playerSpectatingLabel = nil;
						end;

						maid.spectateUpdate = nil;
						return;
					end;

					CollectionService:AddTag(LocalPlayer, 'ForcedSubject');
					workspace.CurrentCamera.CameraSubject = subject;

					maid.spectateUpdate = task.spawn(function()
						while task.wait() do
							if (tick() - lastUpdateAt < 5) then continue end;
							lastUpdateAt = tick();
							task.spawn(function()
								LocalPlayer:RequestStreamAroundAsync(workspace.CurrentCamera.CFrame.Position);
							end);
						end;
					end);
				end;

				UserInputService.InputBegan:Connect(function(inputObject)
					if (inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 or not LocalPlayer:FindFirstChild('PlayerGui') or not LocalPlayer.PlayerGui:FindFirstChild('LeaderboardGui')) then return end;

					local newPlayerSpectating;
					local newPlayerSpectatingLabel;

					for _, v in next, LocalPlayer.PlayerGui.LeaderboardGui.MainFrame.ScrollingFrame:GetChildren() do
						if (v:IsA('Frame') and v:FindFirstChild('Player') and v.Player.TextTransparency ~= 0) then
							newPlayerSpectating = v.Player.Text;
							newPlayerSpectatingLabel = v.Player;
							break;
						end;
					end;

					if (not newPlayerSpectating) then return end;

					if (playerSpectatingLabel) then
						playerSpectatingLabel.TextColor3 = Color3.fromRGB(255, 255, 255);
					end;

					playerSpectatingLabel = newPlayerSpectatingLabel;
					playerSpectatingLabel.TextColor3 = Color3.fromRGB(255, 0, 0);

					if (newPlayerSpectating == playerSpectating or newPlayerSpectating == LocalPlayer.Name) then
						setCameraSubject(LocalPlayer.Character);
					else
						print('spectating new player');
						playerSpectating = newPlayerSpectating;

						local player = Players:FindFirstChild(playerSpectating);

						if (not player or not player.Character or not player.Character.PrimaryPart) then
							print('player not found', player);
							setCameraSubject(LocalPlayer.Character);
							return;
						end;

						setCameraSubject(player.Character);
					end;
				end);

				TextLogger.setCameraSubject = setCameraSubject;
			end;

			do -- // Auto Parry Analytics
				local dataset, dataSetTemp = {}, {};
				local allCombatAnims = {};

				local blacklistedNames = {'Walk', 'Idle', 'Execute', 'Stunned', 'Scream', 'Deactivated', 'Block'};


				for _, v in next, ReplicatedStorage.Assets.Anims.Mobs:GetDescendants() do
					if (IsA(v, 'Animation')) then
						if (table.find(blacklistedNames, v.Name)) then continue end;
						local animationId = v.AnimationId:match('%d+');
						allCombatAnims[animationId] = string.format('%s-%s', v.Parent.Name, v.Name);
					end;
				end;

				for _, v in next, ReplicatedStorage.Assets.Anims.Weapon:GetDescendants() do
					if (IsA(v, 'Animation')) then
						if (table.find(blacklistedNames, v.Name)) then continue end;
						local animationId = v.AnimationId:match('%d+');
						allCombatAnims[animationId] = string.format('%s-%s', v.Parent.Name, v.Name);
					end;
				end;


				allCombatAnims['5773120368'] = 'FiregunRight'; -- Not enough data
				allCombatAnims['7666455222'] = 'WindSlashSlashSlash'; -- Not enough data (client effect?)

				-- Just added to db need to be added to timings

				allCombatAnims['10357806593'] = 'WindKick';
				allCombatAnims['9400896040'] = "ShoulderBash";

				local animLogger = {};
				animLogger.__index = animLogger;

				local listening = {};

				function animLogger.new(character)
					local self = setmetatable({},animLogger);

					self._maid = Maid.new();
					self:AddCharacter(character);

					return self;
				end

				function animLogger:AddCharacter(character)
					if (character == LocalPlayer.Character or listening[character]) then return end;

					self._maid:GiveTask(character.Destroying:Connect(function()
						self:Destroy();
					end));

					local humanoid = character:WaitForChild('Humanoid', 30);
					if (not humanoid) then return end;

					self._maid:GiveTask(humanoid.AnimationPlayed:Connect(function(animationTrack)
						local rootPart = character:FindFirstChild('HumanoidRootPart');
						if (not rootPart or not myRootPart or (rootPart.Position - myRootPart.Position).Magnitude >= 1000) then return end;

						local animId = animationTrack.Animation.AnimationId:match('%d+');
						local animName = allCombatAnims[animId] or 'No Anim Name';

						if (not allCombatAnims[animId] and not animTimes[animId]) then return end;

						local t = {
							animId = animId,
							playedAt = tick(),
							position = rootPart.Position,
							animName = animName,
							animTrack = animationTrack
						};

						table.insert(dataSetTemp, t);

						task.delay(1.5, function()
							local i = table.find(dataSetTemp, t);
							if (not i) then return end;

							table.remove(dataSetTemp, i);
						end);
					end));
				end

				function animLogger:Destroy()
					self._maid:Destroy();
				end;

				local lastParryAt = 0;
				local canParry = true;

				-- effectReplicator.EffectAdded:connect(function(effect)
				-- 	if (effect.Class == 'ParrySuccess') then
				-- 		local playerPing = Stats.PerformanceStats.Ping:GetValue();

				-- 		for _, v in next, dataSetTemp do
				-- 			local t= lastParryAt - v.playedAt;
				-- 			if (t < 0) then continue end;

				-- 			--print('Timing could be', lastParryAt - (v.playedAt-playerPing/2));
				-- 			table.insert(dataset, {
				-- 				ping = playerPing,
				-- 				animId = v.animId,
				-- 				timing = lastParryAt-v.playedAt,
				-- 				blockedAt = lastParryAt,
				-- 				version = 1.02,
				-- 				parriedAt = tick(),
				-- 				autoParryType = library.flags.autoParry and 'normal' or 'no-ap',
				-- 				distance = (myRootPart.Position-v.position).Magnitude,
				-- 				animName = v.animName,
				-- 				animLength = v.animTrack.Length,
				-- 				animSpeed = v.animTrack.Speed,
				-- 				timePosition = v.animTrack.TimePosition
				-- 			})
				-- 		end;

				-- 		table.clear(dataSetTemp);
				-- 	end;
				-- end);

				effectReplicator.EffectRemoving:connect(function(effect)
					if (effect.Class == 'ParryCool') then
						canParry = true;
					end;
				end);

				function onParryRequest()
					if (not effectReplicator:FindEffect('ParryCool') and not effectReplicator:FindEffect('Action') and not effectReplicator:FindEffect('LightAttack') and canParry and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Weapon')) then
						lastParryAt = tick();
						canParry = false;
						warn('Client read', lastParryAt);
					end;
				end;

				task.spawn(function()
					while (true) do
						task.wait(10);
						if (#dataset == 0) then continue end;
						if (debugMode) then continue end;

						task.spawn(function()
							local requestData = request({
								Url = 'https://Roniroscripts.xyz/api/v1/misc/submit-parry-timing',
								Method = 'POST',
								Headers = {['Content-Type'] = 'application/json', Authorization = websiteKey},
								Body = HttpService:JSONEncode(dataset)
							});

							if (requestData.Success) then
								print('Successfully uploaded parry-timings');
							else
								print('Failed to upload parry timings', requestData.Body);
							end;
						end);

						table.clear(dataset);
					end;
				end);

				-- Utility.listenToChildAdded(workspace.Live, animLogger, {listenToDestroying = true});
			end;

			do -- // Auto Wisp
				local spellRemote = ReplicatedStorage.Requests.Spell;
				local func = require(ReplicatedStorage.Modules.Ram);

				local keyIndexes = {
					'Z',
					'X',
					'C',
					'V'
				};

				local currentKeys = {};
				maid.autoWisp = spellRemote.OnClientEvent:Connect(function(actionType, data)
					if actionType == 'set' then
						table.foreach(func(data),function(_, v) table.insert(currentKeys,keyIndexes[v]) end);
						functions.autoWisp(library.flags.autoWisp);
					elseif actionType == 'close' then
						table.clear(currentKeys);
					end
				end)

				function functions.autoWisp(t)
					if (not t) then return end;

					for _, key in next, currentKeys do
						library.disableKeyBind = true;
						VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[key], false, game);
						task.wait();
						VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[key], false, game);
						task.wait();
						library.disableKeyBind = false;
						task.wait(0.2);
					end;
				end;
			end;

			library.OnKeyPress:Connect(function(inputObject, gpe)
				if (not library.flags.easyMantraFeint or inputObject.UserInputType.Name ~= 'MouseButton2' or not effectReplicator:FindEffect('UsingSpell')) then return end;

				VirtualInputManager:SendMouseButtonEvent(0, 50, 0, true, game, 0);
				task.wait();
				VirtualInputManager:SendMouseButtonEvent(0, 50, 0, false, game, 0);
			end);

			effectReplicator.EffectAdded:connect(function(effect)
				if (effect.Class == 'UsingSpell' and library.flags.autoPerfectCast) then
					VirtualInputManager:SendMouseButtonEvent(0, 50, 0, true, game, 0);
					task.wait();
					VirtualInputManager:SendMouseButtonEvent(0, 50, 0, false, game, 0);
				end;
			end);

			function isInDanger()
				return effectReplicator:FindEffect('Danger');
			end;

			function functions.setupAutoLoot(autoLoot)
				local autoLootTypes = {'Ring', 'Gloves', 'Shoes', 'Helmets', 'Glasses', 'Earrings', 'Schematics', 'Weapons', 'Daggers', 'Necklace', 'Trinkets'};
				local weaponAttributes = {'HP','ETH','RES','Posture','SAN','Monster Armor','PHY Armor','Monster DMG','ELM Armor'};
				local autoLootObjects = {};
				local autoLootAttributeObjects = {};

				local oldObjectAttributes;
				local function autoLootShowAttributes(typeName) --I could make this use the flag 1000x the smart but whatevs u can fix it if u want
					local autoLootObject = autoLootAttributeObjects[typeName];
					local showAttribute = library.flags['autoLootWhitelistUseAttributes'..typeName];
					for _, v in next, autoLootObject do
						v.main.Visible = showAttribute;
					end;

					oldObjectAttributes = autoLootObject;
				end;

				local oldObject;
				local function autoLootShowType(typeName) --Kind of messy now thx to awesome code
					if (oldObject) then
						for _, v in next, oldObject do
							v.main.Visible = false;
						end;
					end;

					if (oldObjectAttributes) then
						for _, v in next, oldObjectAttributes do
							v.main.Visible = false;
						end;
					end;

					local autoLootObject = autoLootObjects[typeName];

					for _, v in next, autoLootObject do
						v.main.Visible = true;
					end;

					if library.flags['autoLootWhitelistUseAttributes'..typeName] then
						autoLootShowAttributes(typeName);
					end

					oldObject = autoLootObject;
				end;


				autoLoot:AddDivider('Auto Loot Settings');
				autoLoot:AddToggle({
					text = 'Always Pickup Enchant',
					tip = 'This will make the auto loot pickup always pickup enchants no matter what'
				});

				autoLoot:AddToggle({
					text = 'Always Pickup Medallion',
					tip = 'This will make the auto loot pickup the medallion no matter what'
				});

				autoLoot:AddList({
					text = 'Types',
					flag = 'Auto Loot Whitelist Types',
					tip = 'This allows you to customize the settings for each item type selected',
					values = autoLootTypes,
					callback = autoLootShowType
				});

				for _, v in next, autoLootTypes do
					local autoLootObject = {};
					local autoLootAttributesObject = {};

					autoLootObjects[v] = autoLootObject;
					autoLootAttributeObjects[v] = autoLootAttributesObject;

					table.insert(autoLootObject, autoLoot:AddToggle({
						text = string.format('Use Filter [%s]', v),
						tip = 'Toggle this on to only grab the selected options for this item type',
						flag = string.format('Auto Loot Filter %s', v)
					}))

					table.insert(autoLootObject, autoLoot:AddList({
						text = string.format('Rarities [%s]', v),
						flag = string.format('Auto Loot Whitelist Rarities %s', v),
						tip = 'This tells the autoloot what rarities to pickup for the selected item type',
						multiselect = true,
						values = {'Uncommon', 'Common', 'Rare', 'Epic', 'Legendary', 'Enchant'}
					}))

					table.insert(autoLootObject, autoLoot:AddList({
						text = string.format('Stars [%s]', v),
						flag = string.format('Auto Loot Whitelist Stars %s', v),
						tip = 'This tells the autoloot how many stars it should have to pickup for the selected item type.',
						multiselect = true,
						values = {'0 Stars', '1 Stars', '2 Stars', '3 Stars'}
					}));

					table.insert(autoLootObject, autoLoot:AddList({
						text = string.format('Priority [%s]', v),
						flag = string.format('Auto Loot Whitelist Priorities %s', v),
						tip = 'This tells it what to prioritize over the other for the selected item type',
						values = {'None', 'Stars', 'Stats'}
					}));

					table.insert(autoLootObject, autoLoot:AddToggle({
						text = string.format('Check Item Stats'),
						tip = 'This tells the autoloot to check the item stats to pickup for the selected item type',
						flag = string.format('Auto Loot Whitelist Use Attributes %s', v),
						callback = function() autoLootShowAttributes(library.flags.autoLootWhitelistTypes); end
					}))

					table.insert(autoLootObject, autoLoot:AddToggle({
						text = string.format('Match All Stat Settings'),
						tip = 'All the item stats selected have to match (except for 0) for the selected item type',
						flag = string.format('Auto Loot Whitelist Match All %s', v),
					}))

					for _,valueName in next, weaponAttributes do --Id like for you to hide this but im 2 lazy to figure ur dumb dum UI shit (no comments bozo)
						table.insert(autoLootAttributesObject, autoLoot:AddSlider({
							text = string.format('[%s] Value', valueName),
							min = 0,
							max = 50,
							float = 1,
							flag = string.format('Auto Loot Whitelist %s %s', valueName, v), --IDK if this will handle shit like HP properly so awesome!!!
						}))
					end
				end;

				library.OnLoad:Connect(function()
					for _, v in next, autoLootObjects do
						for _, v2 in next, v do v2.main.Visible = false end;
					end;
					for _, v in next, autoLootAttributeObjects do
						for _, v2 in next, v do v2.main.Visible = false end;
					end;
				end);
			end;

			function functions.holdM1(t)
				if (not t) then
					maid.holdM1 = nil;
					return;
				end;

				local function canAttack()
					return _G.canAttack and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) and leftClickRemote;
				end;

				maid.holdM1 = task.spawn(function()
					while task.wait() do
						if (not canAttack()) then continue end;
						local ti = tick();
						local character = LocalPlayer.Character;
						if (not character) then continue end;
						local shouldUpperCut = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl);

						local ctrl = {
							A = false,
							S = false,
							D = false,
							W = false,
							Space = false,
							G = false,
							Left = true,
							Right = false,
							ctrl = shouldUpperCut
						}

						-- If we have both guns then
						if (character and character:FindFirstChild('RightHand') and character:FindFirstChild('LeftHand') and character.RightHand:FindFirstChild('Gun', true) and character.LeftHand:FindFirstChild('Gun', true)) then
							repeat task.wait() until not effectReplicator:FindEffect('LightAttack');

							repeat task.wait();
								originalFunctions.fireServer(leftClickRemote, false, playerMouse.Hit, nil, shouldUpperCut or nil, {ti - math.random() / 100, ti}, ctrl)
								if (not canAttack()) then break; end;
							until effectReplicator:FindEffect("LightAttack");

							if (not canAttack()) then continue end;
							repeat task.wait() until not effectReplicator:FindEffect('LightAttack');
							if (not canAttack()) then continue end;

							repeat
								task.wait();
								originalFunctions.fireServer(rightClickRemote, ctrl);
								if (not canAttack()) then break; end;
							until effectReplicator:FindEffect('LightAttack');
						else
							originalFunctions.fireServer(leftClickRemote, false, playerMouse.Hit, nil, shouldUpperCut or nil, {ti - math.random() / 100, ti}, ctrl)
						end
					end;
				end);
			end;

			function functions.autoUnragdoll(t)
				if (not t) then
					maid.autoUnragdoll = nil;
					return;
				end;

				local ctrl = {
					A = false,
					S = false,
					D = false,
					W = false,
					Space = false,
					G = false,
					Left = false,
					Right = true
				}

				maid.autoUnragdoll = effectReplicator.EffectAdded:connect(function(obj)
					--warn(obj);
					if (obj.Class == 'Knocked') then
						originalFunctions.fireServer(rightClickRemote, ctrl);
					end;
				end);
			end;

			local oldAgilityValue;

			function functions.agilitySpoofer(t)
				if (not t) then
					maid.agilitySpoofer = nil;

					if (oldAgilityValue) then
						local agility = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Agility');
						if (not agility) then return end;

						agility.Value = oldAgilityValue;
						oldAgilityValue = nil;
					end;
					return;
				end;

				maid.agilitySpoofer = RunService.Heartbeat:Connect(function()
					local value = library.flags.agilitySpooferValue;

					local agility = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Agility');
					if (not agility) then return end;

					if (not oldAgilityValue) then
						oldAgilityValue = agility.Value;
					end;

					agility.Value = value;
				end);
			end;

			function functions.autoRes(t)

				if (not t) then
					maid.autoRes = nil;
					return;
				end;

				local resDebounce = false;
				maid.autoRes = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local humanoid, rootPart = playerData.humanoid, playerData.rootPart;
					if (not humanoid or not rootPart) then return end;

					local isUsingRes = rootPart:FindFirstChild('Core',true);
					print(isUsingRes);
					if not isUsingRes or resDebounce then return; end
					print("Pass1")
					if (library.flags.resHpPercent < humanoid.Health/humanoid.MaxHealth*100) then return; end
					print("Pass2")

					resDebounce = true;
					task.delay(10,function() resDebounce = false; end);

					task.wait(2);
					fallRemote:FireServer(humanoid.Health*1.3,false);
				end);
			end;

			do -- Chunk Loader

				local largeParts = Instance.new('Folder');
				largeParts.Name = "Large Parts";

				local activeChunks = Instance.new('Folder');
				activeChunks.Name = 'ActiveChunks';

				local chunkFolders = Instance.new('Folder');
				chunkFolders.Name = 'Chunks';

				local chunkLoaderMaid = Maid.new();

				local allChunks = {};
				local loadedChunks = {};
				local lastChunk;
				local lastRenderDistance;
				local rootPart;

				local floor = math.floor;
				local newVector3 = Vector3.new;

				local tableInsert = table.insert;
				local tableRemove = table.remove;
				local staticVector = newVector3(1, 0, 1);

				local function getChunk(position)
					local x, z = position.X, position.Z;

					return math.floor(x / 100) .. ':' .. math.floor(z / 100);
				end;

				local function createChunkFolder(chunkId)
					local folder = Instance.new('Folder');
					folder.Name = chunkId;
					folder.Parent = activeChunks;

					local x, z = unpack(folder.Name:split(':'));
					x, z = tonumber(x), tonumber(z);

					if (not allChunks[x]) then
						allChunks[x] = {};
					end;

					if (not allChunks[x][z]) then
						allChunks[x][z] = {};
					end;

					allChunks[x][z] = folder;

					local position = (rootPart or workspace.CurrentCamera).CFrame.Position / 100;
					local floatPosition = newVector3(floor(position.X), 0, floor(position.Z))
					local chunkPosition = floatPosition + newVector3(x, 0, z);

					tableInsert(loadedChunks, {
						chunk = folder,
						p = chunkPosition * staticVector,
						x = x,
						z = z
					});

					return folder;
				end;

				local function chunkFunction(v)
					local position;

					if (IsA(v, 'Model') and FindFirstChildWhichIsA(v,"BasePart")) then
						position = v:GetModelCFrame().Position;
					elseif (IsA(v, 'BasePart') and not IsA(v, 'Terrain')) then
						position = v.Position;
					end;

					if (position and not IsDescendantOf(v.Parent, chunkFolders)) then
						local chunkId = getChunk(position);
						local chunk = (FindFirstChild(activeChunks, chunkId) or FindFirstChild(chunkFolders, chunkId))  or createChunkFolder(chunkId);

						v.Parent = chunk;
					end;
				end

				function functions.disableShadows(t)
					Lighting.GlobalShadows = not t;
				end;

				local ran = false;

				--Stuff that needs to run on toggle
				function functions.chunkLoaderToggle(state)


					if not state then
						if (not ran) then return end;
						chunkLoaderMaid:DoCleaning();

						for _,v in next, allChunks do
							for _,v2 in next, v do
								for _,v3 in next, v2:GetChildren() do
									v3.Parent = workspace.Map;
								end
							end
						end

						for _,v in next, activeChunks:GetChildren() do
							for _,k in next, v:GetChildren() do
								k.Parent = workspace.Map;
							end
						end

						for _,v in next, largeParts:GetChildren() do
							v.Parent = workspace.Map;
						end

						for _, v in next, chunkFolders:GetChildren() do
							for _, v2 in next, v:GetChildren() do
								v2.Parent = workspace.Map;
							end;
						end;

						lastChunk = nil;
						lastRenderDistance = nil;
						rootPart = nil;
						largeParts.Parent = nil;
						activeChunks.Parent = nil;

						return;
					end

					ran = true;

					largeParts.Parent = workspace;
					activeChunks.Parent = workspace;

					for _,v in next, workspace:GetDescendants() do
						if not v:IsA("BasePart") or v.ClassName == "Terrain" then continue; end
						if v.Size.Magnitude >= 500 then v.Parent = largeParts end
					end

					for _, v in next, game:GetService("Workspace").Map:GetChildren() do
						if IsA(v,"Folder") then
							for _,k in next, v:GetChildren() do
								chunkFunction(k);
							end
						end
						chunkFunction(v);
					end;

					chunkLoaderMaid:GiveTask(workspace.Map.DescendantAdded:Connect(function(v)

						task.wait();
						if not v:IsA("BasePart") then return; end
						if v.Size.Magnitude >= 500 then v.Parent = largeParts; return; end
						chunkFunction(v);
					end));

					chunkLoaderMaid:GiveTask(LocalPlayer.CharacterAdded:Connect(function()

						rootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart",10);

						chunkLoaderMaid:GiveTask(rootPart.AncestryChanged:Connect(function()
							if not rootPart.Parent then
								rootPart = nil;
							end
						end));
					end))

					rootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart",5);

					chunkLoaderMaid:GiveTask(RunService.Stepped:Connect(function()

						rootPart = rootPart or workspace.CurrentCamera;

						local position = rootPart.CFrame.Position / 100;
						local chunkRenderDistance = library.flags.renderDistance;

						local floatPosition = newVector3(floor(position.X), 0, floor(position.Z))

						if (floatPosition == lastChunk and lastRenderDistance==chunkRenderDistance) then
							return;
						end;

						local chunkUnloadDistance = chunkRenderDistance * 2;

						lastChunk = floatPosition;
						lastRenderDistance = library.flags.renderDistance;

						local unloadedChunks = {};

						for i, chunkData in next, loadedChunks do
							local chunkDistance = (floatPosition - chunkData.p).Magnitude;

							if (chunkDistance > chunkUnloadDistance * 2) then
								chunkData.chunk.Parent = chunkFolders;
								allChunks[chunkData.x][chunkData.z] = chunkData.chunk;

								tableInsert(unloadedChunks, chunkData);
							end;
						end;

						for _, v in next, unloadedChunks do
							tableRemove(loadedChunks, table.find(loadedChunks, v))
						end;

						for x = -chunkRenderDistance, chunkRenderDistance do
							for z = -chunkRenderDistance, chunkRenderDistance do
								local chunkPosition = floatPosition + newVector3(x, 0, z);
								local x, z = chunkPosition.X, chunkPosition.Z;

								local xChunk = allChunks[x];

								local currentChunk = xChunk and xChunk[z];

								if (not currentChunk) then
									continue
								end;

								currentChunk.Parent = activeChunks;
								xChunk[z] = nil;

								tableInsert(loadedChunks, {
									chunk = currentChunk,
									p = chunkPosition * staticVector,
									x = x,
									z = z
								});
							end;
						end;
					end));
				end
			end;

			do -- One Shot NPCs
				local mobs = {};

				local NetworkOneShot = {};
				NetworkOneShot.__index = NetworkOneShot;

				function NetworkOneShot.new(mob)
					local self = setmetatable({},NetworkOneShot);

					self._maid = Maid.new();
					self.char = mob;

					self._maid:GiveTask(mob.Destroying:Connect(function()
						self:Destroy();
					end));

					self._maid:GiveTask(Utility.listenToChildAdded(mob, function(obj)
						if (obj.Name == 'HumanoidRootPart') then
							self.hrp = obj;
						end;
					end));

					mobs[mob] = self;
					return self;
				end;

				function NetworkOneShot:Update()
					if (not self.hrp or not isnetworkowner(self.hrp) or not self.hrp.Parent or self.hrp.Parent.Parent ~= workspace.Live) then return end;
					self.char:PivotTo(CFrame.new(self.hrp.Position.X, workspace.FallenPartsDestroyHeight - 100000, self.hrp.Position.Z));
				end;

				function NetworkOneShot:Destroy()
					self._maid:DoCleaning();

					for i,v in next, mobs do
						if (v ~= self) then continue; end
						mobs[i] = nil;
					end;
				end;

				function NetworkOneShot:ClearAll()
					for _, v in next, mobs do
						v:Destroy();
					end;

					table.clear(mobs);
				end;

				Utility.listenToChildAdded(workspace.Live, function(obj)
					task.wait(0.2);
					if (obj == LocalPlayer.Character) then return; end
					NetworkOneShot.new(obj);
				end);

				function functions.networkOneShot(t)
					if (not t) then
						maid.networkOneShot = nil;
						maid.networkOneShot2 = nil;
						return;
					end;

					maid.networkOneShot2 = RunService.Heartbeat:Connect(function()
						sethiddenproperty(LocalPlayer, 'MaxSimulationRadius', math.huge);
						sethiddenproperty(LocalPlayer, 'SimulationRadius', math.huge);
					end);

					maid.networkOneShot = task.spawn(function()
						while task.wait() do
							for _, mob in next, mobs do
								mob:Update();
							end;
						end;
					end);
				end;
			end;

			do -- Give Anim Gamepass
				function functions.giveAnimGamepass(t)
					if (not t) then return end;

					-- Add emote pack gamepass
					CollectionService:AddTag(LocalPlayer, 'EmotePack1');
					CollectionService:AddTag(LocalPlayer, 'MetalBadge');
					local gestureGui = LocalPlayer:WaitForChild('PlayerGui', 10):WaitForChild('GestureGui');

					-- Clear all emotes cause we rerun the script

					for _, child in next, gestureGui.MainFrame.GestureScroll:GetChildren() do
						if (child:IsA('TextLabel')) then
							child:Destroy();
						end;
					end;

					gestureGui.GestureClient.Enabled = false;
					gestureGui.GestureClient.Enabled = true;
				end;
			end;
		end;

		local localCheats = column1:AddSection('Local Cheats');
		local notifier = column1:AddSection('Notifier');
		local playerMods = column1:AddSection('Player Mods');
		local autoParry = column2:AddSection('Auto Parry');
		local autoParryMaker = column1:AddSection('Auto Parry Maker');
		local misc = column1:AddSection('Misc');
		local autoLoot = column2:AddSection('Auto Loot');
		local visuals = column2:AddSection('Visuals');
		local farms = column2:AddSection('Farms');
		local inventoryViewer = column2:AddSection('Inventory Viewer');

		do -- // Inventory Viewer (SMH)
			local inventoryLabels = {};
			local itemColors = {};

			itemColors[100] = Color3.new(0.76862699999999995, 1, 0);
			itemColors[9] = Color3.new(1, 0.90000000000000002, 0.10000000000000001);
			itemColors[10] = Color3.new(0, 1, 0);
			itemColors[11] = Color3.new(0.90000000000000002, 0, 1);
			itemColors[3] = Color3.new(0, 0.80000000000000004, 1);
			itemColors[8] = Color3.new(0.17254900000000001, 0.80000000000000004, 0.64313699999999996);
			itemColors[7] = Color3.new(1, 0.61568599999999996, 0);
			itemColors[6] = Color3.new(1, 0, 0);
			itemColors[4] = Color3.new(0.82745100000000005, 0.466667, 0.207843);
			itemColors[0] = Color3.new(1, 1, 1);
			itemColors[5] = Color3.new(0.33333299999999999, 0, 1);
			itemColors[999] = Color3.new(0.792156, 0.792156, 0.792156);

			local function getToolType(tool)
				if (tool:FindFirstChild("Weapon")) then
					return 0;
				elseif (tool:FindFirstChild("Mantra") or tool:FindFirstChild("Spec")) then
					return 3;
				elseif (tool:FindFirstChild("Talent")) then
					return 100;
				elseif (tool:FindFirstChild("Equipment")) then
					return 7;
				elseif (tool:FindFirstChild("WeaponTool")) then
					return 6;
				elseif (tool:FindFirstChild("Training")) then
					return 4;
				elseif (tool:FindFirstChild("Potion")) then
					return 5;
				elseif (tool:FindFirstChild("Schematic")) then
					return 8;
				elseif (tool:FindFirstChild("Ingredient")) then
					return 10;
				elseif (tool:FindFirstChild("SpellIngredient")) then
					return 11;
				elseif (tool:FindFirstChild("Item")) then
					return 9;
				end

				return 999;
			end;

			local function showPlayerInventory(player)
				if (typeof(player) ~= 'Instance') then return end;

				for _, v in next, inventoryLabels do
					v.main:Destroy();
				end;

				inventoryLabels = {};

				local playerItems = {};
				local seen = {};
				local seenJSON = {};

				local function onBackpackChildAdded(tool)

					local toolName = tool:GetAttribute('DisplayName') or tool.Name:gsub('[^:]*:', ''):gsub('%$[^%$]*', '');
					local toolType = getToolType(tool);
					local weaponData = tool:FindFirstChild('WeaponData');

					xpcall(function()
						weaponData = seenJSON[weaponData] or HttpService:JSONDecode(weaponData.Value);
					end, function()
						weaponData = crypt.base64decode(weaponData.Value);
						weaponData = weaponData:sub(1, #weaponData - 2);

						weaponData = HttpService:JSONDecode(weaponData);
					end);

					if (typeof(weaponData) == 'table') then
						table.foreach(weaponData, warn);
						toolName = string.format('%s%s', toolName, (weaponData.Soulbound or weaponData.SoulBound) and ' [Soulbound]' or '');
					end;

					local exitingPlayerItem = seen[toolName];

					if (exitingPlayerItem) then
						exitingPlayerItem.quantity += 1;
						return;
					end;

					local playerItem =  {
						type = toolType,
						toolName = toolName,
						quantity = 1
					};

					table.insert(playerItems, playerItem);
					seen[toolName] = playerItem;
				end;

				for _, tool in next, player.Backpack:GetChildren() do
					task.spawn(onBackpackChildAdded, tool);
				end;

				table.sort(playerItems, function(a, b)
					return a.type < b.type;
				end);

				for _, v in next, playerItems do
					v.text = ('<font color="#%s">%s [x%d]</font>'):format(itemColors[v.type]:ToHex(), v.toolName, v.quantity);
					table.insert(inventoryLabels, inventoryViewer:AddLabel(v.text));
				end;
			end;

			inventoryViewer:AddList({
				text = 'Player',
				tip = 'Player to watch inventory for',
				playerOnly = true,
				skipflag = true,
				callback = showPlayerInventory
			});
		end;

		do -- // Removals
			playerMods:AddToggle({
				text = 'No Fall Damage',
				tip = 'Removes fall damage for you'
			});

			playerMods:AddToggle({
				text = 'No Stun',
				tip = 'Makes it so you will not get stunned in combat',
			});

			playerMods:AddToggle({
				text = 'No Wind',
				tip = 'Disables the slow during wind in Layer 2',
				callback = functions.noWind
			});

			playerMods:AddToggle({
				text = 'No Kill Bricks',
				tip = 'Removes all the kill bricks',
				callback = functions.noKillBricks
			});

			playerMods:AddToggle({
				text = 'No Acid Damage',
				flag = 'Anti Acid',
				tip = 'Prevent you from taking damage from acid water.'
			});

			playerMods:AddToggle({
				text = 'No Anims (Risky)',
				flag = 'No Anims',
				tip = 'Disable all your anims',
				callback = functions.noAnims
			});

			playerMods:AddToggle({
				text = 'No Jump Cooldown',
				tip = 'Makes it so you can jump even when on cooldown.'
			})

			playerMods:AddToggle({
				text = 'No Stun Less Blatant',
				tip = 'Like no stun but it\'s less blatant'
			});

			playerMods:AddToggle({
				text = 'Give Anim Gamepass',
				tip = 'Allows you to use all the animations ingame for free without the gamepass.',
				callback = functions.giveAnimGamepass
			});
		end;

		do -- // Local Cheats
			localCheats:AddDivider("Movement");

			localCheats:AddToggle({
				text = 'Fly',
				callback = functions.fly
			}):AddSlider({
				min = 16,
				max = 200,
				flag = 'Fly Hack Value'
			});

			localCheats:AddToggle({
				text = 'Speedhack',
				callback = functions.speedHack
			}):AddSlider({
				min = 16,
				max = 200,
				flag = 'Speed Hack Value'
			});

			localCheats:AddToggle({
				text = 'Infinite Jump',
				callback = functions.infiniteJump
			}):AddSlider({
				min = 50,
				max = 250,
				flag = 'Infinite Jump Height'
			});

			localCheats:AddToggle({
				text = 'Agility Spoofer',
				callback = functions.agilitySpoofer,
				tip = 'This sets your ingame agility to x amount, allowing you to slide further and climb higher.'
			}):AddSlider({
				flag = 'Agility Spoofer Value',
				min = 0,
				max = 250
			});

			localCheats:AddToggle({
				text = 'No Clip',
				callback = functions.noClip
			});

			localCheats:AddToggle({
				text = 'Break Mobs',
				callback = functions.BreakMobs
			})

			localCheats:AddToggle({
				text = 'Disable When Knocked',
				tip = 'Disables noclip when you get ragdolled',
				flag = 'Disable No Clip When Knocked'
			});


			localCheats:AddToggle({
				text = 'Knocked Ownership',
				tip = 'Allow you to fly/move while being knocked.'
			})




			localCheats:AddToggle({
				text = 'Use Weapon',
				tip = 'Uses your weapon to make knocked ownership work',
				flag = 'Use Weapon For Knocked Ownership'
			});

			localCheats:AddToggle({
				text = 'Click Destroy',
				tip = 'Everything you click on will be destroyed (client sided)',
				callback = functions.clickDestroy
			});

			localCheats:AddBind({text = 'Go To Ground', callback = functions.goToGround, mode = 'hold', nomouse = true});

			localCheats:AddBind({
				text = 'Tween to Objectives',
				tip = 'This will automatically go to bloodjars, bones and the obelisks in layer 2 when held down.',
				mode = 'hold',
				callback = functions.autoBloodjar
			});

			localCheats:AddDivider("Gameplay-Assist");

			localCheats:AddToggle({
				text = 'M1 Hold',
				tip = 'Automatically spams m1, when you hold it down',
				callback = functions.holdM1
			});

			localCheats:AddToggle({
				text = 'Auto Wisp',
				tip = 'Automatically solve the wisp puzzles by pressing keys for you',
				callback = functions.autoWisp
			});

			localCheats:AddToggle({
				text = 'Auto Perfect Cast',
				tip = 'Automatically perfect cast your mantra'
			});

			localCheats:AddToggle({
				text = 'Easy Mantra Feint',
				tip = 'Allows you to right click to feint your mantra'
			});

			localCheats:AddToggle({
				text = 'Auto Unragdoll',
				tip = 'Automatically right click when you get ragdolled',
				callback = functions.autoUnragdoll
			});

			localCheats:AddToggle({
				text = 'Auto Sprint',
				tip = 'Whenever you want to walk you sprint instead',
				callback = functions.autoSprint
			});

			localCheats:AddToggle({
				text = 'Silent Aim',
				tip = 'If toggled with FOV check in aimbot section, your attacks aimed attacks will automatically go towards towards them if in the FOV circle'
			});

			localCheats:AddToggle({
				text = 'Auto Ressurect',
				tip = '(WARNING: CAN WIPE YOU): This function will trigger when the ressurect bell is used and will knock you so that you resurrect up with more HP',
				callback = functions.autoRes
			}):AddSlider({
				suffix = '% HP',
				min = 0,
				max = 40,
				flag = "Res Hp Percent"
			});

			localCheats:AddDivider("Combat Tweaks");

			localCheats:AddToggle({
				text = 'One Shot Mobs',
				tip = 'This feature randomly works sometimes and causes them to die, but it makes AP have issues',
				callback = functions.networkOneShot
			});

			localCheats:AddToggle({
				text = 'Anti Auto Parry',
				tip = 'Breaks all auto parry other than users who are also using Roniro hub.',
				callback = functions.antiAutoParry
			});

			localCheats:AddBind({
				text = 'Instant Log',
				nomouse = true,
				callback = function()
					ReplicatedStorage.Requests.ReturnToMenu:FireServer();

					local playerGui = LocalPlayer:FindFirstChild('PlayerGui');
					if (not playerGui) then return end;

					local choicePrompt = playerGui:WaitForChild('ChoicePrompt', 25);
					if (not choicePrompt) then return end;

					choicePrompt.Choice:FireServer(true);
				end
			});

			localCheats:AddButton({
				text = 'Server Hop',
				tip = 'Jumps to any other server, non region dependant',
				callback = functions.serverHop
			});

			localCheats:AddBind({
				text = 'Attach To Back',
				tip = 'This attaches to the nearest entities back based on settings',
				callback = functions.attachToBack,
			});

			localCheats:AddSlider({
				text = 'Attach To Back Height',
				value = 0,
				min = -100,
				max = 100,
				textpos = 2
			});

			localCheats:AddSlider({
				text = 'Attach To Back Space',
				value = 2,
				min = -100,
				max = 100,
				textpos = 2
			});
		end;

		do --// Notifier
			notifier:AddToggle({
				text = 'Mod Notifier',
				state = true
			});

			notifier:AddToggle({
				text = 'Moderator Sound Alert',
				tip = 'Makes a sound when the mod joins',
				state = true
			});

			notifier:AddToggle({
				text = 'Void Walker Notifier',
				state = true
			});

			notifier:AddToggle({
				text = 'Mythic Item Notifier',
			});

			notifier:AddToggle({
				text = 'Artifact/Owl Notifier',
				flag = 'Artifact Notifier'
			});

			notifier:AddToggle({
				text = 'Player Proximity Check',
				tip = 'Gives you a warning when a player is close to you',
				callback = functions.playerProximityCheck
			});
		end

		do -- // Auto Parry
			autoParry:AddToggle({
				text = 'Enable',
				flag = 'Auto Parry',
				tip = 'Automatically parry when you are attacked.',
				callback = functions.autoParry
			}):AddSlider({
				text = 'Ping Adjustment %',
				flag = 'Ping Adjustment Percentage',
				min = 0,
				value = 75,
				step = 0.05,
				max = 100,
				textpos = 2,
				tip = 'Play with this slider to find what is best for you, we recommend 75%-50%'
			});

			autoParry:AddSlider({
				text = 'Parry Chance',
				tip = 'Determines the chance of you parrying an attack',
				suffix = '%',
				textpos = 2,
				min = 0,
				max = 100,
				float = 1,
				value = 100
			});

			autoParry:AddToggle({
				text = 'Parry When Dodging',
				state = true,
				tip = 'The auto parry will parry when you have dodge frames, it is recommended you turn this on if you have issues with AP'
			});

			autoParry:AddToggle({
				text = 'Parry Vent',
				tip = 'This determines whether or not you will attempt to parry vents from other players',
				state = true
			});

			autoParry:AddToggle({
				text = 'Use Custom Delay',
				tip = 'Disables ping adjust in favor of the timing you specify',
			}):AddSlider({
				text = 'Custom Delay',
				suffix = 'ms',
				flag = "Custom Delay",
				min = -500,
				value = 0,
				max = 500,
				textpos = 2,
				tip = 'Adjust all the parry timings by this number.'
			})

			autoParry:AddSlider({
				text = 'Distance Adjustment',
				min = -25,
				value = 0,
				max = 25,
				textpos = 2,
				tip = 'Adjust all the parry max distances.'
			});

			autoParry:AddToggle({
				text = 'Parry Roll',
				tip = 'Always roll instead of parying if you are not on roll cooldown when you are attacked (Only useful for PvP).'
			});

			autoParry:AddToggle({
				text = 'Roll After Feint',
				tip = 'Automatically roll on the next attack after a feint, only if you on parry cooldown.'
			});

			autoParry:AddToggle({
				text = 'Roll Cancel',
				tip = 'Automatically cancel roll after the autoparry dodges.'
			}):AddSlider({
				text = 'Roll Cancel Delay',
				min = 0,
				max = 1,
				value = 0,
				float = 0.1,
				textpos = 2,
				tip = 'How long the autoparry will wait before cancelling their dodge'
			});

			autoParry:AddToggle({
				text = 'Blatant Roll',
				tip = 'Instantly roll cancels without moving, recommended for use with AP'
			});

			autoParry:AddToggle({
				text = 'Check If Facing Target',
				tip = 'Only parry if you are facing the target.'
			});

			autoParry:AddToggle({
				text = 'Check If Target Face You',
				tip = 'Only parry if you the target is facing you.'
			});

			autoParry:AddToggle({
				text = 'Auto Feint',
				tip = 'This will feint for you if you are mid attack but need to parry, which allows you to parry their attack'
			});

			autoParry:AddToggle({
				text = 'Auto Feint Mantra',
				tip = 'Automatically feint your cast if you are using a mantra and auto parry wants to parry.'
			});

			autoParry:AddToggle({
				text = 'Block Input',
				tip = 'This will prevent you from attacking whenever the opponent is attacking, essentially allowing you to hold M1 with less punishment.'
			});

			autoParry:AddList({
				text = 'Auto Parry Mode',
				values = {'Guild', 'Players', 'Mobs', 'All'},
				tip = 'This will make it so the autoparry will only parry this group of entities, such as mobs, player or guild members.',
				multiselect = true
			});

			autoParry:AddList({
				text = 'Auto Parry Whitelist',
				noload = true,
				skipflag = true,
				playerOnly = true,
				multiselect = true
			});
		end;

		do -- // Auto Parry Maker
			autoParryMaker:AddToggle({
				text = 'Auto Parry Helper',
				tip = 'Shows the auto parry maker helper.',
				callback = functions.autoParryHelper
			}):AddSlider({
				text = 'Helper Max Range',
				min = 10,
				max = 10000,
				textpos = 2,
			});

			autoParryMaker:AddSlider({
				text = 'Block Point Max Range',
				min = 0,
				max = 1000,
				textpos = 2
			});

			autoParryMaker:AddBox({
				text = 'Animation Id',
				tip = 'Put the animation id you want auto parry helper to parry.',
			});

			autoParryMaker:AddButton({
				text = 'Add Block Point',
				callback = function()
					functions.addBlockPoint(autoParryMaker);
				end,
			});

			autoParryMaker:AddButton({
				text = 'Add Wait Point',
				callback = function()
					functions.addWaitPoint(autoParryMaker);
				end,
			});

			autoParryMaker:AddButton({
				text = 'Export Config',
				callback = functions.exportBlockPoints,
			});

			-- autoParryMaker:AddList({
			-- 	text = 'Confidantiality Level',
			-- 	values = {'Public', 'Private', 'Unlisted'},
			-- 	tip = 'Visibility level for this config.',
			-- });

			autoParryMaker:AddDivider('Block Points');
		end;

		do -- // Auto Loot
			autoLoot:AddToggle({
				text = 'Auto Loot',
				tip = 'Automatically loot all items from a chest.',
				callback = functions.autoLoot
			});

			autoLoot:AddToggle({
				text = 'Auto Close Chest',
				tip = 'Automatically close chest once auto loot is done.'
			});

			autoLoot:AddToggle({
				text = 'Auto Open Chest',
				tip = 'Automatically open all chest near you.',
				callback = functions.autoOpenChest
			});

			functions.setupAutoLoot(autoLoot);
		end;

		do -- // Misc
			local realmInfo = require(ReplicatedStorage.Info.RealmInfo);
			local isLuminant = rawget(realmInfo, 'IsLuminant') or false;
			local names = rawget(realmInfo, 'Names') or {};
			local currentWorld = rawget(realmInfo, 'CurrentWorld') or '';

			local oppositeWorld = currentWorld == 'EastLuminant' and 'EtreanLuminant' or 'EastLuminant';

			misc:AddDivider('Perfomance Improvements');

			misc:AddToggle({
				text = 'FPS Boost',
				tip = 'Improves FPS by making game functions faster',
				callback = functions.fpsBoost
			});

			misc:AddToggle({
				text = 'Disable Shadows',
				tip = 'Disabling all shadows adds a large bump to your FPS',
				callback = functions.disableShadows
			});

			misc:AddToggle({
				text = 'Chunk Loader',
				tip = 'Loading multiple locations of the map lags you, the chunk loader will mitigate this',
				callback = functions.chunkLoaderToggle
			}):AddSlider({
				text = 'Render Distance',
				min = 5,
				value = 10,
				max = 25,
				float = 1
			})

			misc:AddDivider("Streamer Tools");

			misc:AddToggle({
				text = 'Streamer Mode',
				tip = 'Locally modify/hide your name so you can record without worying about getting banned.',
				callback = functions.streamerMode
			})

			misc:AddToggle({
				text = 'Ultra Streamer Mode',
				tip = 'Enable that with streamer mode if you are streaming and want nobody to find/join you'
			});

			misc:AddList({
				flag = 'Streamer Mode Type',
				tip = 'Spoof = modifies character info to fake one. Hide = Hide character info',
				values = {'Spoof', 'Hide'},
				callback = function()
					functions.streamerMode(library.flags.streamerMode);
				end
			});

			misc:AddToggle({
				text = 'Hide All Server Info',
				tip = 'Enable that with streamer mode if dont want any server info on top bar'
			});

			misc:AddToggle({
				text = 'Hide Esp Names'
			});

			misc:AddButton({
				text = 'Rebuild Streamer Mode',
				callback = functions.rebuildStreamerMode,
				noload = true,
				skipflag = true,
				tip = 'Rebuild streamer mode fake info.',
			})

			misc:AddDivider('Chat Logger', 'You can right click the chatlogger to report infractions.');

			misc:AddToggle({
				text = 'Chat Logger',
				tip = 'You can right click users on the chat logger to report them for infractions to the TOS',
				callback = functions.chatLogger
			});

			misc:AddToggle({
				text = 'Chat Logger Auto Scroll'
			});

			misc:AddToggle({
				text = 'Use Alt Manager To Block'
			});

			misc:AddDivider('Race Changer');

			-- Setup race changer
			local raceChanger = sharedRequires['86ff59a72aa0134033a45a2517ab434d34ec44d886554adb2efc1b5600868d9b'];
			raceChanger(misc);
		end;

		do -- // Visuals
			visuals:AddToggle({
				text = 'No Fog',
				callback = functions.noFog
			});

			visuals:AddToggle({
				text = 'No Blur',
				callback = functions.noBlur
			});

			visuals:AddToggle({
				text = 'No Blind',
				callback = functions.noBlind
			});

			visuals:AddToggle({
				text = 'Full Bright'
			}):AddSlider({
				flag = 'Full Bright Value',
				min = 0,
				max = 10,
				value = 1,
			});
		end;

		do -- // Farms
			farms:AddToggle({
				text = 'Fort Merit Farm',
				callback = functions.fortMeritFarm
			});

			farms:AddToggle({
				text = 'Echo Farm',
				tip = 'This will automatically farm cooked meals for echoes, you need to have echoes unlocked to use this.',
				callback = functions.echoFarm
			});

			farms:AddToggle({
				text = 'Animal King Farm',
				tip = 'This will automatically farm for AK, requires you to have Trial Of One spawn unlocked, you can wipe with animal king and keep it before level 3',
				callback = functions.animalKingFarm
			});

			farms:AddToggle({
				text = 'Ores Farm',
				tip = 'This will only farm Astruline, use near a section of astruline for it to work',
				callback = functions.oresFarm
			});

			farms:AddButton({
				text = 'Set Ores Farm Position',
				tip = 'Use this before using Ores Farm to set the position that you will farm at',
				callback = functions.setOresFarmPosition
			});

			farms:AddBox({
				text = 'Ores Farm Webhook Notifier'
			});

			farms:AddBox({
				text = 'Animal King Webhook Notifier'
			});

			farms:AddToggle({
				text = 'Charisma Farm',
				callback = functions.charismaFarm
			});

			farms:AddToggle({
				text = 'Intelligence Farm',
				callback = functions.intelligenceFarm
			});

			farms:AddToggle({
				text = 'Auto Fish',
				flag = 'Fish Farm',
				callback = functions.fishFarm
			}):AddSlider({
				text = 'Auto Fish Hold Time',
				flag = 'Fish Farm Hold Time',
				min = 0.1,
				max = 2,
				float = 0.1,
				value = 0.5,
				textpos = 2
			});

			farms:AddBox({
				text = 'Fish Farm Bait',
				tip = 'Set the bait for the fish farm, you can leave this box empty if you dont want to use any you can also add multiple bait with ,.',
			});
		end;

		-- do -- // Analytics
		-- 	local lootDropAnalytics = AnalyticsAPI.new('');

		-- 	local function getProperties(obj, t)
		-- 		local propertiesToLog = t;
		-- 		local properties = {};

		-- 		for _, v in next, propertiesToLog do
		-- 			table.insert(properties, string.format('%s = %s', v, tostring(obj[v])));
		-- 		end;

		-- 		return table.concat(properties, '|');
		-- 	end;

		-- 	library.unloadMaid:GiveTask(Utility.listenToTagAdded('LootDrop', function(obj)
		-- 		local isMesh = IsA(obj, 'MeshPart');

		-- 		if (IsA(obj, 'Part') or isMesh) then
		-- 			local properties = getProperties(obj, {'Size', 'Material', 'Color', isMesh and 'MeshId' or nil});
		-- 			lootDropAnalytics:Report(isMesh and 'MeshPart' or 'Part', properties, 1);
		-- 		elseif (IsA(obj, 'UnionOperation')) then
		-- 			local id = getproperties(obj).AssetId;

		-- 			local properties = getProperties(obj, {'Size', 'Material', 'Color'});
		-- 			table.insert(properties, 'AssetId = ' .. tostring(id));

		-- 			lootDropAnalytics:Report('UnionOperation', tostring(id), 1);
		-- 		end;
		-- 	end));
		-- end;
	end)() end


if (gameName == 'KAT') then (function()

		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local column1 = unpack(library.columns);

		do -- // Functions
			local whitelistedScripts = {'KnifeClient', 'RevolverClient'};
			local oldNamecall;

			oldNamecall = hookmetamethod(game, '__namecall', function(self, ...)
				--------SX_VM_CNONE();
				if(checkcaller()) then return oldNamecall(self, ...) end;

				if(getnamecallmethod() == 'FindPartOnRayWithIgnoreList' and library.flags.silentAim) then
					local caller = getcallingscript();
					local scriptName = typeof(caller) == 'Instance' and caller.Name;
					local method = getnamecallmethod();

					if(table.find(whitelistedScripts, scriptName)) then
						local args = {...};

						local target = Utility:getClosestCharacter();
						local myRoot = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
						local targetRoot = target and target.Character and target.Character.PrimaryPart;

						if(targetRoot and myRoot) then
							args[1] = Ray.new(myRoot.Position, (targetRoot.Position - myRoot.Position).Unit * 2000);
							return oldNamecall(self, unpack(args));
						end;

						setnamecallmethod(method);
					end;
				end;

				return oldNamecall(self, ...);
			end);
		end;

		local Combat = column1:AddSection('Combat')
		Combat:AddToggle({text = 'Silent Aim'});
	end)() 
end

if (gameName == 'Balthazar') then (function()
		local stamina = false;
		local autoload = false;
		local autosave = false;
		local autoheal = false;
		local godmode = false;
		local nofall = false;
		local noSelf = false;
		local noFallDamage = false;
		local jesusS = false;
		local explodetarget = '';
		local fov = '';
		local Multiplier = '';
		local healstart = '';
		local oldNamecall;
		local map = workspace:WaitForChild('Main'):FindFirstChildWhichIsA('Folder');
		local CurrentMap;
		local terrain;
		local waterTexture;
		local assets = ReplicatedStorage.Assets;
		local soundremote = ReplicatedStorage.Remotes.ToServer.Sound;
		local menu = ReplicatedStorage.Remotes.ToServer.Menu;
		local interaction = ReplicatedStorage.Remotes.ToServer.CharacterInteraction;
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];


		local column1, column2 = unpack(library.columns);
		local maid = Maid.new()

		local ReplicatedStorage, RunService, Players, VirtualInputManager, CollectionService, MarketplaceService, Stats, UserInputService = Services:Get('ReplicatedStorage', 'RunService', 'Players', 'VirtualInputManager', 'CollectionService', 'MarketplaceService', 'Stats', 'UserInputService');

		-- Tables
		local functions = {};
		local healtools = {'Health Potion', 'Bandage'}
		--Setup
		SafePart = Instance.new("Part")
		SafePart.Size = Vector3.new(6, 1, 6)
		SafePart.Anchored = true
		SafePart.CanCollide = true
		SafePart.Parent = workspace
		SafePart.Position = Vector3.new(0,500,0)
		--Functions
		local function Load()
			game:GetService("ReplicatedStorage").Remotes.ToServer.Menu:InvokeServer("Load", {})
		end

		local function InstantRespawn()
			LocalPlayer.Character:MoveTo(Vector3.new(0,-550,0))
		end

		function getPlayer(ok)
			local player = {}
			if ok:lower() == "all" then
				for i ,v in pairs(game.Players:GetPlayers()) do
					if v.Name ~= LocalPlayer.Name then
						table.insert(player, v)
					end
				end
			elseif ok:lower() == "me" then
				for i ,v in pairs(game.Players:GetPlayers()) do
					if v.Name == LocalPlayer.Name then
						table.insert(player, v)
					end
				end
			else
				for i ,v in pairs(game.Players:GetPlayers()) do
					if v.Name:lower():sub(1, #ok) == ok:lower() then
						table.insert(player, v)
					end
				end
			end
			return player
		end

		local function mapcheck(set)
			while wait(set) do
				if map.Name == 'Map_Legacy' then
					CurrentMap = 'Legacy';
				elseif map.Name == 'Map_Bloxy Island' then
					CurrentMap = 'BloxyIsland';
				elseif map.Name == 'Map_Testing' then
					CurrentMap = 'Test';
				end
			end
		end

		do 	

			task.spawn(function()
				mapcheck(0.1);
				while wait(1) do
					print(CurrentMap)
				end
			end)

			function functions.infinitestamina(toggle)
				if toggle then
					stamina = true
					task.spawn(function()
						while stamina do
							if LocalPlayer:GetAttribute("IsInMenu") == false then
								LocalPlayer.Character:SetAttribute("Stamina", 100)
							end
							task.wait(0.1)
						end
					end)
				else
					stamina = false
				end
			end


			local noragdolla;
			noragdolla = hookmetamethod(game,"__namecall",function(self,...)
				local args = {...}
				local method = getnamecallmethod():lower()
				if not checkcaller() and self == interaction and method == "fireserver" and library.flags.noRagdoll then
					if args[1] == 'Ragdoll' then
						args[2] = {}
						return noragdolla(self,unpack(args))
					end
				end
				return noragdolla(self,...)
			end)

			local nofira;
			nofira = hookmetamethod(game,"__namecall",function(self,...)
				local args = {...}
				local method = getnamecallmethod():lower()
				if not checkcaller() and self == interaction and method == "fireserver" and library.flags.noSelfDamage then
					if args[1] == 'SetOnFire' then
						args[2] = {}
						return nofira(self,unpack(args))
					end
				end
				return nofira(self,...)
			end)

			local namecall;
			namecall = hookmetamethod(game,"__namecall",function(self,...)
				local args = {...}
				local method = getnamecallmethod():lower()
				if not checkcaller() and self == interaction and method == "fireserver" and library.flags.noFallDamage then
					if args[1] == 'Fell' then
						args[2] = {}
						return namecall(self,unpack(args))
					end
				end
				return namecall(self,...)
			end)

			function functions.fly(toggle)
				if (not toggle) then
					maid.flyHack = nil;
					maid.flyBv = nil;

					return;
				end;

				maid.flyBv = Instance.new('BodyVelocity');
				maid.flyBv.MaxForce = Vector3.new(math.huge, math.huge, math.huge);

				maid.flyHack = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local rootPart, camera = playerData.rootPart, workspace.CurrentCamera;
					if (not rootPart or not camera) then return end;

					if (not CollectionService:HasTag(maid.flyBv, 'AllowedBM')) then
						CollectionService:AddTag(maid.flyBv, 'AllowedBM');
					end;

					maid.flyBv.Parent = rootPart;
					maid.flyBv.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.flyHackValue);
				end);
			end;
			
			
			function functions.speedHack(toggle)
				if (not toggle) then
					maid.speedHack = nil;
					maid.speedHackBv = nil;

					return;
				end;

				maid.speedHack = RunService.Heartbeat:Connect(function()
					local playerData = Utility:getPlayerData();
					local humanoid, rootPart = playerData.humanoid, playerData.primaryPart;
					if (not humanoid or not rootPart) then return end;

					if (library.flags.fly) then
						maid.speedHackBv = nil;
						return;
					end;

					maid.speedHackBv = maid.speedHackBv or Instance.new('BodyVelocity');
					maid.speedHackBv.MaxForce = Vector3.new(100000, 0, 100000);

					if (not CollectionService:HasTag(maid.speedHackBv, 'AllowedBM')) then
						CollectionService:AddTag(maid.speedHackBv, 'AllowedBM');
					end;

					maid.speedHackBv.Parent = not library.flags.fly and rootPart or nil;
					maid.speedHackBv.Velocity = (humanoid.MoveDirection.Magnitude ~= 0 and humanoid.MoveDirection or gethiddenproperty(humanoid, 'WalkDirection')) * library.flags.speedHackValue;
				end);
			end;
			
			function functions.infiniteJump(toggle)
				if(not toggle) then return end;

				repeat
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if(rootPart and UserInputService:IsKeyDown(Enum.KeyCode.Space)) then
						rootPart.Velocity = Vector3.new(rootPart.Velocity.X, library.flags.infiniteJumpHeight, rootPart.Velocity.Z);
					end;
					task.wait(0.1);
				until not library.flags.infiniteJump;
			end;

			function functions.autoload(toggle)
				if toggle then
					autoload = true
					task.spawn(function()
						while autoload do
							if LocalPlayer:GetAttribute("IsInMenu") == true then
								Load()
							end
							task.wait(0.1)
						end
					end)
				else
					autoload = false
				end
			end

			function functions.autosave(toggle)
				local wasDowned = false

				if toggle then
					autosave = true
					task.spawn(function()
						if not LocalPlayer.Character then
							repeat task.wait();
							until LocalPlayer.Character
						end;
						local last = LocalPlayer.Character.HumanoidRootPart.Position
						while autosave do
							if not LocalPlayer.Character then 
								repeat task.wait()
								until LocalPlayer.Character
							end;
							local isDowned = LocalPlayer.Character:GetAttribute("IsDowned")

							if isDowned == true then
								LocalPlayer.Character:MoveTo(SafePart.Position)
							elseif isDowned == false and wasDowned == true then
								LocalPlayer.Character:MoveTo(last)
								wasDowned = false
							end

							if isDowned == true then
								wasDowned = true
							end

							task.wait(0.1)
						end
					end)
				else
					autosave = false
				end
			end

			function functions.jesus(toggle)
				if toggle then
					jesusS = true
					task.spawn(function()
						while jesusS do
							if LocalPlayer:GetAttribute('IsInMenu') == true then
								repeat task.wait(0.1) print('is in menu');
								until LocalPlayer:GetAttribute('IsInMenu') == false
								print('not in menu')
							end
							if CurrentMap == 'BloxyIsland' then
							map.Terrain:WaitForChild('WaterTexture').CanCollide = true
							print(CurrentMap)
							elseif CurrentMap == 'Legacy' then
							for i,v in pairs(map.Water_:GetChildren()) do
								v.CanCollide = true
							end
							elseif CurrentMap == 'Test' then
								print(CurrentMap)
							end
							task.wait(0.1)
						end
						if CurrentMap == 'BloxyIsland' then
							map.Terrain:WaitForChild('WaterTexture').CanCollide = false
							print(CurrentMap)
						elseif CurrentMap == 'Legacy' then
							for i,v in pairs(map.Water_:GetChildren()) do
								v.CanCollide = false
							end
						elseif CurrentMap == 'Test' then
							print(CurrentMap)
						end
					end)
				else
					jesusS = false
					if CurrentMap == 'BloxyIsland' then
						map.Terrain:WaitForChild('WaterTexture').CanCollide = false
						print(CurrentMap)
					elseif CurrentMap == 'Legacy' then
						for i,v in pairs(map.Water_:GetChildren()) do
							v.CanCollide = false
						end
					elseif CurrentMap == 'Test' then
						print(CurrentMap)
					end
				end
			end
			
			--[[function functions.godmode(toggle)
				if toggle then
					godmode = true
					task.spawn(function()
						while godmode do
							if LocalPlayer:GetAttribute("IsInMenu") == false then
								interaction:FireServer(unpack({
									[1] = "Fell",
									[2] = {
										["Damage"] = -500
									}
								}))
							end
							task.wait(0.1)
						end
					end)
				else
					godmode = false
				end
			end]]--


			function functions.instarespawn()
				InstantRespawn()
				while wait() do
					if LocalPlayer:GetAttribute("IsInMenu") == true then
						Load()
						break
					end
				end
			end

			function functions.fov(Value)
				while wait() do
					if LocalPlayer:GetAttribute("IsInMenu") == false then
						LocalPlayer.Character:SetAttribute("ConstFOV", Value)
						fov = Value
						break
					end
				end
			end

			function functions.fovstate(toggle)
				if toggle then
					functions.fov(fov)
				else
					functions.fov(70)
				end

				LocalPlayer.CharacterAdded:Connect(function()
					if toggle then
						functions.fov(fov)
					end
				end)
			end

			function functions.annoyingsound()
				for i,v in pairs(assets:GetDescendants()) do
					if v:IsA("Sound") and v.Parent  then
						spawn(function()
							soundremote:FireServer(unpack({
								[1] = "Play",
								[2] = {
									["Parent"] = LocalPlayer.Character.Torso,
									["SubInfo"] = {
										["RandomSpeed"] = false
									},
									["Sound"] = v
								}
							}))
						end)
					end
				end
			end

			function functions.redeemcodes()
				for i,v in pairs(ReplicatedStorage.Values.Codes:GetChildren()) do
					menu:InvokeServer(unpack({
						[1] = "RedeemCode",
						[2] = {
							["Code"] = v.Name
						}
					}))
				end
				ToastNotif.new({
					text = 'Successfully redeemed all available game codes',
					duration = 3
				});
			end

			function functions.settarget(target)
				for i, v in pairs(getPlayer(target)) do
					explodetarget = v.Name
				end
			end

			function functions.magicgrenade()
				local target = explodetarget
				local grenadename = 'M67 Grenade'
				if game.Players[target] and game.Players[target].Character and game.Players[target].Character:FindFirstChild("Head") and LocalPlayer.Backpack:FindFirstChild(grenadename) then

					local TargetCharacter = game.Players[target].Character
					local TargetHead = TargetCharacter:FindFirstChild("Head")
					local TargetPosition = TargetHead.Position
					local Grenade = LocalPlayer.Backpack:FindFirstChild(grenadename)
					Grenade.Parent = LocalPlayer.Character
					wait(1)
					mouse1press()
					task.wait(0.1)
					mouse1release()

					task.delay(0.3,function()
						local Launcher = workspace:WaitForChild("Ignore").Bullets:WaitForChild("Bullet")
						Launcher.Anchored = false
						Launcher.Name = "1"

						local BP = Instance.new("BodyPosition")
						BP.Name = "N/A_S"
						BP.Parent = Launcher
						BP.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
						BP.P = 1500
						BP.D = 35
						BP.Position = TargetHead.Position

						game.RunService.RenderStepped:Connect(function()
							BP.Position = TargetHead.Position
						end)
						print("cool yo")
						task.wait(1)
						game.Workspace.Camera.CameraSubject = TargetCharacter.Humanoid
						task.wait(4)
						game.Workspace.Camera.CameraSubject = LocalPlayer.Character.Humanoid
					end)
				end
			end
		end


		local Player = column1:AddSection('Player')
		local Exploits = column2:AddSection('Exploits')


		Player:AddDivider('Combat')

		Player:AddToggle({
			text = 'Fly',
			callback = functions.fly
		}):AddSlider({
			min = 16,
			max = 200,
			flag = 'Fly Hack Value'
		});

		Player:AddToggle({
			text = 'Speedhack',
			callback = functions.speedHack
		}):AddSlider({
			min = 16,
			max = 200,
			flag = 'Speed Hack Value'
		});

		Player:AddToggle({
			text = 'Infinite Jump',
			callback = functions.infiniteJump
		}):AddSlider({
			min = 50,
			max = 250,
			flag = 'Infinite Jump Height'
		});

		Player:AddToggle({
			text = 'Infinite Stamina',
			tip = "Makes your stamina not run out",
			callback = functions.infinitestamina
		})

		Player:AddToggle({
			text = 'No Ragdoll',
			tip = 'Prevents you from Ragdolling.'
		})

		Player:AddToggle({
			text = 'No Fall Damage',
			tip = 'Prevents you from taking fall damage.'
		})

		Player:AddToggle({
			text = 'No Self Damage',
			tip = 'Makes u immune to fire.'
		})

		Player:AddToggle({
			text = "Auto Load",
			tip = "Automatically loads u in after dying",
			callback = functions.autoload
		})

		Player:AddToggle({
			text = "Auto Safe",
			tip = "Automatically tp's u to a safe place when knocked / low health",
			callback = functions.autosave
		})


		Player:AddButton({
			text = "Instant Respawn",
			tip = "Instant respawns you",
			callback = functions.instarespawn
		})

		Exploits:AddDivider('Misc')

		Exploits:AddToggle({
			text = 'Jesus Mode',
			tip = 'Be able to walk on water (Bloxy Island)',
			callback = functions.jesus
		})

		Exploits:AddToggle({
			text = 'Field of View',
			callback = functions.fovstate
		}):AddSlider({
			text = 'FOV',
			value = defaultFOV,
			min = 70,
			max = 120,
			callback = functions.fov
		})

		Exploits:AddButton({
			text = 'Redeem codes',
			tip = 'Redeems all available game codes',
			callback = functions.redeemcodes
		})


		Exploits:AddDivider('Fun')
		Exploits:AddBox({
			text = 'Target Username',
			tip = "Sets the target to explode",
			callback = functions.settarget
		})

		Exploits:AddButton({
			text = 'Explode',
			tip = '50/50 Chance of working',
			callback = functions.magicgrenade
		})

		Exploits:AddButton({
			text = 'Play Sound',
			tip = 'Plays weird annoying sound (Server Side)',
			callback = functions.annoyingsound
		})
	end)()
end

if (gameName == 'Bad Business') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local RunService, ReplicatedStorage, Players = Services:Get('RunService', 'ReplicatedStorage', 'Players');
		local LocalPlayer = Players.LocalPlayer;

		local column1, column2 = unpack(library.columns);
		local combat = column1:AddSection('Combat');
		local utils = column1:AddSection('Utils');

		local makeUnlockSkins;
		local unlockAllSkins;

		local autoReload;
		local gameModules;
		do -- // Functions
			local hookRecoilFunction;
			local playerData = ReplicatedStorage.PlayerData:WaitForChild(LocalPlayer.Name);

			local TS = require(ReplicatedStorage.TS);

			for _, v in next, getupvalues(TS) do
				if (typeof(v) == 'table' and getrawmetatable(v) and typeof(rawget(getrawmetatable(v), '__index')) == 'function') then
					gameModules = getupvalue(getrawmetatable(v).__index, 1);
				end;
			end;

			assert(gameModules);

			local lastShootAt = 0;

			function makeUnlockSkins(name)
				local folder = name == 'Charms' and getupvalue(gameModules.Charms.GetConfig, 1) or ReplicatedStorage:FindFirstChild(name, true);

				for _, v in next, folder:GetDescendants() do
					if (v:IsA('ModuleScript')) then
						local folder = Instance.new('Folder');
						local skinName = name == 'Charms' and v.Parent.Name or v.Name;

						folder.Name = skinName;
						folder.Parent = playerData[name];
					end;
				end;
			end;

			do -- // ESP Override
				local characters = getupvalue(gameModules.Characters.GetCharacter, 1);
				local teams = getupvalue(gameModules.Teams.GetPlayerTeam, 1);

				local function getPlayerTeam(player)
					for i, v in next, teams:GetChildren() do
						if v.Players:FindFirstChild(player.Name) then
							return v.Name;
						end;
					end;
				end;

				function Utility:getCharacter(player)
					local character = characters[player];
					if(not character or not character.Parent) then return end;

					local characterBody = character:FindFirstChild('Body');
					if(not characterBody) then return end;

					local health = character:FindFirstChild('Health');
					if(not health or (player ~= LocalPlayer and health:FindFirstChild('Shield'))) then return end;

					local maxHealth = health:FindFirstChild('MaxHealth');
					if(not maxHealth) then return end;

					return characterBody, maxHealth.Value, (health.Value / maxHealth.Value) * 100, health.Value;
				end;

				function Utility:isTeamMate(player)
					return getPlayerTeam(player) == getPlayerTeam(LocalPlayer);
				end;

				function Utility:getRootPart(player)
					local character = characters[player];
					if(not character) then return end;

					return character.PrimaryPart;
				end;
			end;

			do -- // Utility
				local Network = gameModules.Network;

				local equipSkinsNames = {'EquipWeapon', 'EquipSkin', 'EquipCharm', 'EquipSticker', 'EquipTracer'};
				local upvalues = {};

				upvalues.library = library;
				upvalues.playerData = playerData;

				upvalues.oldFireserver = hookfunction(Network.Fire, function(self, actionName, ...)
					local args = {...};
					local actionType = args[1];

					if (actionName == 'Inventory' and upvalues.library.flags.unlockAllSkins) then
						if(table.find(equipSkinsNames, actionType)) then
							local skinType = args[1]:match('Equip(%w+)');
							local gunName, skin = args[2], args[3];

							if (skinType == 'Sticker') then
								skinType = skinType .. args[3];
								skin = args[4];
							end;

							upvalues.playerData.Weapons[gunName].Customization[skinType].Value = skin;
							return;
						elseif (actionType == 'EquipClothing') then
							local loadout = 'Outfit' .. upvalues.playerData.Equipped.Loadout.Value:match('%d');
							local playerOutfit = upvalues.playerData.Outfits[loadout];
							local skin, clothType = args[2], args[3];

							playerOutfit[clothType].Value = skin;
							return;
						end;
					end;

					return upvalues.oldFireserver(self, actionName, ...);
				end);

				local controllersStats = getupvalue(gameModules.Projectiles.InitProjectile, 1);

				for i, v in next, getconnections(gameModules.Characters.CharacterAdded) do
					if (debug.info(v.Function, 's'):match('ItemAnimateScript')) then
						local characterAddedFunction = getupvalue(v.Function, 2);
						local oldEquippedFunction = getupvalue(characterAddedFunction, 17);

						setupvalue(characterAddedFunction, 17, function(gun)
							if (library.flags.unlockAllSkins and gun) then
								local playerGunData = playerData.Weapons:FindFirstChild(gun.Name);
								if (playerGunData) then
									for _, v2 in next, playerGunData.Customization:GetChildren() do
										gun:WaitForChild(v2.Name).Value = v2.Value;
									end;
								end;
							end;

							return oldEquippedFunction(gun);
						end);

						break;
					end;
				end;

				function hookRecoilFunction(f, flagName, newFunction)
					newFunction = newFunction or function() end;

					local upvalues = {};
					upvalues.library = library;
					upvalues.newFunction = newFunction;
					upvalues.flagName = flagName;

					upvalues.oldFunction = hookfunction(f, function(...)
						if(upvalues.library.flags[upvalues.flagName]) then
							return upvalues.newFunction();
						end;

						return upvalues.oldFunction(...);
					end);
				end;

				local function getBulletStats()
					for i, v in next, gameModules.Items:GetControllers() do
						if(v.Equipped) then
							local gunConfig = require(i.Config);
							if (gunConfig and gunConfig.Projectile and gunConfig.Projectile.Template) then
								return controllersStats[gunConfig.Projectile.Template];
							end;
						end;
					end;
				end;

				local function getBulletDirectionForSilentAim()
					if(not library.flags.silentAim) then return end;

					local target = Utility:getClosestCharacter();
					local targetHead = target.Character and target.Character:FindFirstChild('Head');

					if(not targetHead) then return end;

					local bulletStats = getBulletStats();
					if (not bulletStats or not bulletStats.Speed) then return end;

					local targetPosition = (targetHead.Position - workspace.CurrentCamera.CFrame.Position);

					local timeToShoot = targetPosition.Magnitude / bulletStats.Speed;
					local bulletDropPrediction = library.flags.bulletDropPrediction and Vector3.new(0, 0.5 * bulletStats.Gravity * timeToShoot ^ 2, 0) or Vector3.new();

					local playerMovePrediction = library.flags.playerMovePrediction and (Utility:roundVector(targetHead.Velocity) * timeToShoot) or Vector3.new();

					print(playerMovePrediction);

					return (targetPosition + bulletDropPrediction + playerMovePrediction).Unit
				end;

				local upvalues = {};
				upvalues.library = library;
				upvalues.runService = RunService;

				upvalues.oldTimerWait = hookfunction(gameModules.Timer.Wait, function(self, waitTime, ...)
					if(upvalues.library.flags.fireRateModifier and waitTime <= 1) then
						waitTime = upvalues.library.flags.fireRateModifierValue / 1000;
					end;

					return upvalues.oldTimerWait(self, waitTime, ...)
				end);

				hookRecoilFunction(gameModules.Items.FirstPerson.WeaponMovementSpring.Shove, 'noRecoil');
				hookRecoilFunction(gameModules.Items.FirstPerson.WeaponRotationSpring.Shove, 'noRecoil');
				hookRecoilFunction(gameModules.Items.FirstPerson.CameraSpring.Shove, 'noRecoil');

				local oldNamecall;
				local FindFirstChild = game.FindFirstChild;

				oldNamecall = hookmetamethod(game, '__namecall', function(self, ...)
					local method = getnamecallmethod();
					if (method == 'FindPartOnRayWithWhitelist') then
						local n = debug.info(isSynapseV3 and 2 or 3, 'n');

						if (n == 'CastGeometryAndEnemies' and library.flags.wallBang) then
							local args = {...};
							local geometry = workspace:FindFirstChild('Geometry');

							if (args[2][1] == geometry) then
								table.remove(args[2], table.find(args[2], geometry));
							end;

							return oldNamecall(self, unpack(args));
						end;
					end;

					return oldNamecall(self, ...);
				end);

				local upvalues = {};
				upvalues.library = library;

				upvalues.oldRecoilFire = hookfunction(gameModules.Camera.Recoil.Update, function(self, ...)
					lastShootAt = self.Init;

					if(upvalues.library.flags.noRecoil) then
						return Vector2.zero;
					end;

					return upvalues.oldRecoilFire(self, ...);
				end);

				hookfunction(gameModules.Input.Reticle.LookVector, function(...)
					return getBulletDirectionForSilentAim() or workspace.CurrentCamera.CFrame.LookVector;
				end);

				function unlockAllSkins()
					makeUnlockSkins('Skins');
					makeUnlockSkins('Charms');
					makeUnlockSkins('Stickers');
					makeUnlockSkins('Attachments');
					makeUnlockSkins('Tracers');
					makeUnlockSkins('Weapons');

					for _, v in next, playerData.Clothes:GetChildren() do
						v.Parent = nil;
					end;

					local clothingFolder = getupvalue(gameModules.Clothing.GetConfig, 2);

					for _, v in next, clothingFolder:GetDescendants() do
						if (v:IsA('ModuleScript')) then
							local folder = Instance.new('Folder');

							folder.Name = v.Parent.Name;
							folder.Parent = playerData.Clothes;
						end;
					end;
				end;

				(function()
					for i, v in next, getgc() do
						if(typeof(v) == 'function' and islclosure(v) and not is_synapse_function(v)) then
							for i2, v2 in next, getupvalues(v) do
								if(typeof(v2) == 'function' and debug.info(v2, 'n') == 'GetSpeedDebuff') then
									setupvalue(v, i2, function()
										return library.flags.speedhack and -2.5 or 0;
									end);

									return;
								end;
							end;
						end;
					end;
				end)();
			end;

			function autoReload()
				repeat
					if(tick() - lastShootAt >= 0.8) then
						gameModules.Input:AutomateBegan('Reload');
					end;

					task.wait();
				until not library.flags.autoReload;
			end;
		end;

		combat:AddToggle({
			text = 'No Recoil'
		});

		combat:AddToggle({
			text = 'No Spread'
		});

		combat:AddToggle({
			text = 'Auto Reload',
			callback = autoReload
		});

		combat:AddToggle({
			text = 'Silent Aim'
		});

		combat:AddToggle({
			text = 'Bullet Drop Prediction'
		});

		combat:AddToggle({
			text = 'Player Move Prediction'
		});

		combat:AddToggle({
			text = 'Wall Bang'
		});

		combat:AddToggle({
			text = 'Speedhack'
		});

		combat:AddToggle({
			text = 'Fire Rate Modifier'
		}):AddSlider({
			min = 1, max = 1000,
			flag = 'Fire Rate Modifier Value'
		});

		utils:AddButton({
			text = 'Unlock All Skins',
			callback = unlockAllSkins
		});
	end)()
end

if (gameName == 'Arsenal') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local FindFirstChild, FindFirstChildWhichIsA = game.FindFirstChild, game.FindFirstChildWhichIsA;
		local IsA = game.IsA;

		local column1, column2 = unpack(library.columns);

		local RunService = Services:Get('RunService');
		local LocalPlayer = Services:Get('Players').LocalPlayer;
		local Heartbeat = RunService.Heartbeat;

		local toggleFly;
		local toggleNoClip;
		local jumpPower;

		do --//GC Scan
			function Utility:getCharacter(player)
				local character = player.Character;
				if (not character or not FindFirstChild(character, 'Spawned')) then return end;

				local humanoid = FindFirstChildWhichIsA(character, 'Humanoid');

				local maxHealth = humanoid and humanoid.MaxHealth or 100;
				local health = humanoid and humanoid.Health or 100;
				local floatHealth = (health / maxHealth) * 100;

				return player.Character, maxHealth, floatHealth, math.floor(health);
			end;

			do --//Bypass anti cheat
				local oldSpawn;

				oldSpawn = hookfunction(spawn, newcclosure(function(f)
					local Constants = getconstants(f)
					if(table.find(Constants, 'BeanBoozled')) then
						return wait(9e9)
					end

					return oldSpawn(f)
				end))

				local clientEnv;
				local clientEnvTwo;

				for i,v in next, getgc(true) do
					if(clientEnv and clientEnvTwo) then
						break;
					end;

					if(typeof(v) == 'function' and islclosure(v) and not is_synapse_function(v)) then
						local Env = getfenv(v);

						if(rawget(Env, 'ammocount')) then
							clientEnv = Env;
						end;
					elseif(typeof(v) == 'table' and rawget(v, 'firebullet')) then
						clientEnvTwo = v;
					end;
				end;

				local oldFireBullet = clientEnvTwo.firebullet;
				clientEnvTwo.firebullet = function(...)
					if(library.flags.infiniteAmmo) then
						clientEnv.ammocount.Value = 100;
					end;

					return oldFireBullet(...);
				end;
			end

			local maid = Maid.new();
			local BodyVelocity;

			function toggleFly(toggle)
				if(not toggle) then
					if(BodyVelocity) then
						BodyVelocity:Destroy();
						BodyVelocity = nil;
					end;
					return;
				end;

				local BodyVelocity = Instance.new('BodyVelocity');

				repeat
					local RootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('Head');
					local Camera = workspace.CurrentCamera;
					local moveVector = ControlModule:GetMoveVector();

					if(RootPart and Camera) then
						BodyVelocity.Parent = RootPart;
						BodyVelocity.Velocity = Camera.CFrame:VectorToWorldSpace(moveVector * library.flags.flySpeed);
						BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge);
					end;

					Heartbeat:Wait();
				until not library.flags.fly;

				BodyVelocity.Parent = nil;
			end;

			function toggleNoClip(toggle)
				if(not toggle) then return end;

				repeat
					local Character = LocalPlayer.Character;
					if(Character) then
						for i, v in next, Character:GetDescendants() do
							if(v:IsA("BasePart")) then
								v.CanCollide = false;
							end;
						end;
					end;
					RunService.Stepped:Wait();
				until not library.flags.noClip;
			end;

			function jumpPower(toggle)
				if (not toggle) then
					maid.jumpPower = nil;
					return;
				end;

				maid.jumpPower = RunService.Heartbeat:Connect(function()
					local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
					if (not humanoid) then return end;

					warn('woo', library.flags.jumpPowerValue);

					humanoid.JumpPower = library.flags.jumpPowerValue;
				end);
			end;

			local oldNamecall;
			local oldIndex;
			local oldNewIndex;

			local rayCastSpoofs = 0;

			oldNamecall = hookmetamethod(game, '__namecall', function(self, ...)
				--------SX_VM_CNONE();
				if(checkcaller()) then return oldNamecall(self, ...) end;

				local method = getnamecallmethod();
				local caller = getcallingscript();

				if(method == 'FindPartOnRayWithIgnoreList' and library.flags.silentAim and caller and caller.Name == 'Client' and rayCastSpoofs < 250) then
					rayCastSpoofs = rayCastSpoofs + 1;
					local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart;
					local character = Utility:getClosestCharacter();

					character = character and character.Character;
					local head = character and character.FindFirstChild(character, 'Head');

					if(character and head) then
						return head, (head.Position - rootPart.Position).Unit;
					end;
				end;

				return oldNamecall(self, ...);
			end);

			oldIndex = hookmetamethod(game, '__index', function(self, p)
				--------SX_VM_CNONE();
				if(checkcaller()) then return oldIndex(self, p) end;

				if(p == 'Touched' and IsA(self, 'BasePart') and library.flags.silentAim) then
					local function ConnectTouched(self, f)
						local Character = Utility:getClosestCharacter();
						Character = Character and Character.Character;
						local Head = Character and Character.FindFirstChild(Character, 'Head');

						if(Character and Head) then
							return f(Head);
						end;
					end;

					return {
						Connect = ConnectTouched;
						connect = ConnectTouched;
					};
				end;

				return oldIndex(self, p);
			end);

			oldNewIndex = hookmetamethod(game, '__newindex', function(self, p, v)
				--------SX_VM_CNONE();
				if(checkcaller() or not IsA(self, 'Humanoid')) then return oldNewIndex(self, p, v) end;

				if(p == 'WalkSpeed' and library.flags.walkspeed) then
					v = library.flags.walkspeedValue;
				elseif (p == 'JumpPower' and library.flags.jumpPower) then
					v = library.flags.jumpPowerValue;
				end;

				return oldNewIndex(self, p, v);
			end);

			task.spawn(function()
				while task.wait(2) do
					rayCastSpoofs = 0;
				end;
			end);
		end;

		local Character = column1:AddSection('Character')
		local Gun = column2:AddSection('Gun');

		Character:AddToggle({
			text = 'Walkspeed'
		}):AddSlider({flag = 'Walkspeed Value', min = 16, max = 500});

		Character:AddToggle({
			text = 'Jump Power',
			callback = jumpPower
		}):AddSlider({flag = 'Jump Power Value', min = 50, max = 500});

		Character:AddToggle({
			text = 'Fly',
			callback = toggleFly
		}):AddSlider({flag = 'Fly Speed', min = 16, max = 500});

		Character:AddToggle({
			text = 'No Clip',
			callback = toggleNoClip
		});

		Gun:AddToggle({
			text = 'Infinite Ammo'
		});

		Gun:AddToggle({
			text = 'Silent Aim'
		});
	end)()
end

if (gameName == "RoBeats") then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];


		local column1, column2 = unpack(library.columns);
		local RunService = Services:Get('RunService');




		
		
		local EVENT_STRINGS = {};
		local SCORE_CONVERTER;

		local Helding = {};
		local grabVars;
		local tracks;
		local tracksSystem;
		local generateNote;
		local collectNpcsRewards;

		do -- Scan
			local hooked = {};

			local LocalMain;
			local songDatabase;
			local curveUtil;
			local vipModule;

			local Applying = {};

			for i, v in next, getgc(true) do
				if(type(v) == 'table' and type(rawget(v, '_game_join')) == 'table') then
					LocalMain = v;
				elseif(type(v) == 'table' and rawget(v, 'DeltaTimeToTimescale')) then
					curveUtil = v;
				elseif(type(v) == 'table' and rawget(v, 'key_has_combineinfo')) then
					songDatabase = v;
				elseif(type(v) == 'table' and rawget(v, 'playerblob_has_vip_for_current_day')) then
					vipModule = v;
				end;
			end;

			local oldDeltaTimeToTimescale = curveUtil.DeltaTimeToTimescale;
			local currentTime = 0;

			function curveUtil:DeltaTimeToTimescale(n)
				currentTime = n;
				return oldDeltaTimeToTimescale(self, n);
			end;

			function grabVars()
				local gamelocal = getupvalue(LocalMain._game_join.is_game_finished, 1);
				if(not gamelocal) then
					print("nope")
					return;
				end;

				if(not hooked[gamelocal]) then
					local blKeys = {0, 1, 2, 3};

					hooked[gamelocal] = true;
					local oldGameLocalUpdate = gamelocal.update;
					function gamelocal:update(n)
						if(library.flags.songSpeed) then
							n = currentTime / (1/60) * library.flags.songSpeedValue;
						end;

						return oldGameLocalUpdate(self, n);
					end;

					local old_control_just_pressed = gamelocal._input.control_just_pressed;
					function gamelocal._input:control_just_pressed(keyCode)
						if(library.flags.toggleAutoPlayer and table.find(blKeys, keyCode)) then
							return;
						end;

						return old_control_just_pressed(self, keyCode);
					end;

					local old_control_just_released = gamelocal._input.control_just_released;
					function gamelocal._input:control_just_released(keyCode)
						if(library.flags.toggleAutoPlayer and table.find(blKeys, keyCode)) then
							return;
						end;

						return old_control_just_released(self, keyCode);
					end;
				end;

				tracksSystem = getupvalue(gamelocal.set_local_game_slot, 1)

				local tracksystems = getupvalue(gamelocal.post_update, 2);
				setupvalue(gamelocal.post_update, 1, tracksystems);

				if(not tracksSystem) then
					return;
				end;

				for i, v in next, tracksSystem do
					if(typeof(v) == "function" and i:sub(1, 1) == "_") then
						local constants = getconstants(v);
						local isPress = table.find(constants, "press");
						local isRelease = table.find(constants, "release");

						if(isPress) then
							EVENT_STRINGS.PRESS_TRACK = i;
						elseif(isRelease) then
							EVENT_STRINGS.RELEASE_TRACK = i;
						end;
					end;
				end;

				if(tracksSystem[EVENT_STRINGS.PRESS_TRACK]) then
					tracks = getupvalue(tracksSystem[EVENT_STRINGS.PRESS_TRACK], 4); -- // notes lol
				end;

				local function tableFind(t, v)
					for i, v2 in next, t do
						if(v2 == v) then
							return v2;
						end;
					end;
				end;

				for i,v in next, tracks._table do
					if(not EVENT_STRINGS.CAN_PRESS_NOTE or not EVENT_STRINGS.CAN_RELEASE_NOTE) then
						for i2, v2 in next, v do
							if(typeof(v2) == "function") then
								local constants = getconstants(v2);
								if(tableFind(constants, "get_delta_time_from_hit_time")) then
									EVENT_STRINGS.CAN_PRESS_NOTE = i2;
									EVENT_STRINGS.SCORE_FUNCTION = constants[2] == 'Pre' and constants[4] or constants[2];

									_G.CAN_PRESS_NOTE = constants;

									local SpUtil;
									local upvalues = getupvalues(v2);

									for i, v in next, upvalues do
										if(typeof(v) == "table" and rawget(v, "color3")) then
											SpUtil = v;
											break;
										end;
									end;

									local SCORE_FUNCTION = SpUtil[getconstant(SpUtil[EVENT_STRINGS.SCORE_FUNCTION], 1)];

									local ScoreResult = getupvalue(SCORE_FUNCTION, 1);

									local Meaning = {-1, 3, 2, 1};
									-- -1 Miss
									-- 3 Okay
									-- 2 Great
									-- 1 Perfect

									for i, v in next, getconstants(SCORE_FUNCTION) do
										Meaning[v] = Meaning[i];
										Meaning[i] = nil;
									end;

									for i, v in next, ScoreResult do
										Meaning[v] = Meaning[i];
										Meaning[i] = nil;
									end;

									if (isUserTrolled) then
										Meaning = {};
									end;

									SCORE_CONVERTER = Meaning;
								elseif(tableFind(constants, "get_delta_time_from_release_time")) then
									EVENT_STRINGS.CAN_RELEASE_NOTE = i2;
								end;
							end;
						end;
					end;
				end;
			end;

			local random = Random.new();

			function generateNote()
				if(library.flags.random) then
					return random:NextInteger(1, 3);
				end;

				local perfect = library.flags.perfect;
				local great = library.flags.great;
				local okay = library.flags.okay;
				local miss = library.flags.miss;

				local randomTable = {};

				for i = 1, perfect do
					table.insert(randomTable, 1);
				end;

				for i = 1, great do
					table.insert(randomTable, 2);
				end;

				for i = 1, okay do
					table.insert(randomTable, 3);
				end;

				for i = 1, miss do
					table.insert(randomTable, -1);
				end;

				if(#randomTable == 0) then return 0 end;
				return randomTable[random:NextInteger(1, #randomTable)] or 3;
			end;

			coroutine.wrap(function()
				while true do
					RunService.Heartbeat:Wait();
					grabVars();

					if(not library.flags.toggleAutoPlayer) then continue end;
					if(EVENT_STRINGS.CAN_PRESS_NOTE or SCORE_CONVERTER) then
						warn('[RoBeats] [AutoPlayer]', EVENT_STRINGS.CAN_PRESS_NOTE, SCORE_CONVERTER);
						continue;
					end;

					debug.profilebegin('Auto Player');
					local t = tracks._table;
					local chosedNote = generateNote();

					for i = 1, #t do
						local v = t[i];

						local CanHit, NoteScore = v[EVENT_STRINGS.CAN_PRESS_NOTE]();
						local isHeld = v.get_delta_time_from_release_time;
						local index = v:get_track_index();

						NoteScore = SCORE_CONVERTER[NoteScore];

						if(CanHit and NoteScore == chosedNote and not Helding[v] and EVENT_STRINGS.PRESS_TRACK) then
							print('press');
							chosedNote = generateNote();
							tracksSystem[EVENT_STRINGS.PRESS_TRACK](nil, nil, index);
							if(isHeld) then
								Helding[v] = true;
							elseif(EVENT_STRINGS.RELEASE_TRACK) then
								print('release');
								-- delay(0.06, function()
								tracksSystem[EVENT_STRINGS.RELEASE_TRACK](nil, nil, index);
								-- end);
							end;
						elseif(Helding[v] and EVENT_STRINGS.CAN_RELEASE_NOTE) then
							local index = v:get_track_index();
							local CanHit, NoteScore = v[EVENT_STRINGS.CAN_RELEASE_NOTE]();
							NoteScore = SCORE_CONVERTER[NoteScore];
							if(CanHit and NoteScore == chosedNote and EVENT_STRINGS.RELEASE_TRACK) then
								-- delay(0.05, function()
								tracksSystem[EVENT_STRINGS.RELEASE_TRACK](nil, nil, index);
								-- end);

								Helding[v] = nil;
							end;
						end;
					end;
					debug.profileend();
				end;
			end)();
		end;

		local AutoPlayer = column1:AddSection("Auto Player");
		local Misc = column2:AddSection("Misc");

		AutoPlayer:AddToggle({text = 'Enable', flag = 'Toggle Auto Player'});
		AutoPlayer:AddToggle({text = 'Random'});
		AutoPlayer:AddSlider({text = 'Perfect', value = 65, min = 0, max = 100});
		AutoPlayer:AddSlider({text = 'Great', value = 35, min = 0, max = 100});
		AutoPlayer:AddSlider({text = 'Okay', min = 0, max = 100});
		AutoPlayer:AddSlider({text = 'Miss', min = 0, max = 100});

		Misc:AddToggle({text = 'Song Speed'}):AddSlider({flag = 'Song Speed Value', min = 0, max = 10, float = 0.1})
		Misc:AddToggle({text = 'Collect Npcs Rewards', callback = collectNpcsRewards});
		-- Misc:AddToggle({text = 'Unlock All Songs (Freeze Score)', flag = 'Unlock All Songs'});
	end)()
end

if (gameName == "RoBeats CS") then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local column1, column2 = unpack(library.columns);
		local ReplicatedStorage = Services:Get('ReplicatedStorage');

		local gameLocal = require(ReplicatedStorage.RobeatsGameCore.RobeatsGame);
		local oldGameLocal = gameLocal.new;

		local noteResult = require(ReplicatedStorage.RobeatsGameCore.Enums.NoteResult);

		local AutoPlayer = column1:AddSection("Auto Player");

		AutoPlayer:AddToggle({text = 'Enable', flag = 'Toggle Auto Player'});
		AutoPlayer:AddToggle({text = 'Random'});
		AutoPlayer:AddSlider({text = 'Marvelous', min = 0, max = 100});
		AutoPlayer:AddSlider({text = 'Perfect', value = 65, min = 0, max = 100});
		AutoPlayer:AddSlider({text = 'Great', value = 35, min = 0, max = 100});
		AutoPlayer:AddSlider({text = 'Good', min = 0, max = 100});
		AutoPlayer:AddSlider({text = 'Miss', min = 0, max = 100});

		local randomiser = Random.new();

		local function generateRandomScore()
			if (library.flags.random) then
				return math.random(1, 5);
			else
				local chances = {
					[noteResult.Marvelous] = library.flags.marvelous,
					[noteResult.Perfect] = library.flags.perfect,
					[noteResult.Great] = library.flags.great,
					[noteResult.Good] = library.flags.good,
					[noteResult.Bad] = library.flags.bad
				};

				local randomTable = {};

				for i, v in next, chances do
					for i2 = 1, v do
						table.insert(randomTable, i);
					end;
				end;

				return randomTable[randomiser:NextInteger(1, #randomTable)];
			end;
		end;

		_G.test = generateRandomScore;

		local function performGameLocalHook(gameLocal)
			local oldUpdate = gameLocal.update;

			function gameLocal:update(delta)
				local trackSystem = self:get_local_tracksystem();
				if (trackSystem and library.flags.toggleAutoPlayer) then
					local notes = trackSystem:get_notes();


					for noteIndex, note in next, notes._table do
						local canHit, noteScore = note:test_hit();
						local canHit2, noteScore2 = note:test_release();
						local wantedScore = generateRandomScore();

						if (note.ClassName == 'SingleNote') then
							canHit2 = true;
							noteScore2 = wantedScore;
						end;

						local trackIndex = note:get_track_index();

						if (canHit and noteScore == wantedScore) then
							trackSystem:press_track_index(trackIndex);
						end;

						if (canHit2 and noteScore2 == wantedScore) then
							trackSystem:release_track_index(trackIndex);
						end;
					end;
				end;

				return oldUpdate(self, delta);
			end;
		end

		gameLocal.new = function(...)
			local newGameLocal = oldGameLocal(...);
			performGameLocalHook(newGameLocal);

			return newGameLocal;
		end;

		for i, v in next, getgc(true) do
			if (typeof(v) == 'table' and rawget(v, '_game')) then
				performGameLocalHook(v._game);
				break;
			end;
		end;
	end)() end

if (gameName == 'Combat Warriors') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local ReplicatedStorage, RunService, Players, VirtualInputManager, CollectionService, MarketplaceService, Stats = Services:Get('ReplicatedStorage', 'RunService', 'Players', 'VirtualInputManager', 'CollectionService', 'MarketplaceService', 'Stats');
		local column1, column2 = unpack(library.columns);

		local LocalPlayer = Players.LocalPlayer;

		local main = column1:AddSection('Main Cheats');
		local rangedMods = column2:AddSection("Ranged Mods");

		local gameRequire;

		local functions = {};
		local maid = Maid.new();

		local IsA = game.IsA;

		-- Functions
		do
			local Nevermore = require(ReplicatedStorage.Framework.Nevermore);

			function gameRequire(moduleName)
				local modules = getupvalue(rawget(Nevermore, '_require'), 2);
				assert(typeof(modules) == 'table');
				assert(not getmetatable(modules));

				while true do
					for currentModuleName, module in next, modules do
						if (typeof(module) == 'Instance' and currentModuleName == moduleName) then
							setthreadidentity(2);
							local result = {getrenv().require(module)};
							setthreadidentity(7);

							return unpack(result);
						end;
					end;

					task.wait();
				end
			end;

			_G.gameRequire = gameRequire;

			local AirConstants = gameRequire('AirConstants');
			local Network = gameRequire('Network');
			local RoduxStore = gameRequire('RoduxStore');
			local DefaultStaminaHandler = gameRequire('DefaultStaminaHandlerClient');
			local DashConstants = gameRequire('DashConstants');
			local CharacterHandler = gameRequire('CharacterHandler');
			local JumpHandlerClient = gameRequire('JumpHandlerClient');
			local AntiCheatHandlerClient = gameRequire('AntiCheatHandlerClient');
			local UtilityMetadata = gameRequire('UtilityMetadata');
			local WeaponMetadata = gameRequire('WeaponMetadata');
			local RangedWeaponClient = gameRequire('RangedWeaponClient');
			local SpawnhandlerClient = gameRequire('SpawnHandlerClient');
			local RaycastUtilClient = gameRequire('RaycastUtilClient');
			local RangedWeaponHandler = gameRequire('RangedWeaponHandler');


			--Network = getrawmetatable(Network)

			-- Hooks
			do
				local oldNamecall;
				local oldIndex;

				local oldUnequipTools;
				local oldGetCanJump;
				local oldRecoilCamera;
				local oldGetMouseHitPosition;

				function fireServerWrapper(self, name, ...)
					if (name == 'TakeFallDamage' and library.flags.noFallDamage) then
						return;
					elseif (name == 'MeleeDamage') then
						local args = {...};

						if (typeof(args[2]) == 'Instance' and library.flags.antiParry) then
							local shield = args[2].Parent:FindFirstChild('FlareParticles', true);
							if (shield and shield.Enabled) then return print('no dmg?'); end;
						end;
					elseif (name == 'GotHitRE' and library.flags.noFireDamage) then
						return;
					elseif (name == 'BAC') then
						return print('brrrrr', ...);
					elseif (name == "RangedFire" and library.flags.magicBullet) then
						local args = {...};
						local shotId;

						table.foreach(args[3], function(i) shotId = i; end)

						local targetChar = Utility:getClosestCharacter().Character;
						if not targetChar then return; end


						local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
						local metaData = tool and WeaponMetadata[tool:GetAttribute('ItemId')];

						local rootPart = Utility:getPlayerData().rootPart;
						local targetHead = targetChar and targetChar:FindFirstChild('Head');

						if (targetHead and tool and rootPart) then
							local timeToShoot = (rootPart.Position - targetHead.Position).Magnitude / metaData.speed;

							task.delay(timeToShoot, function()
								Network:FireServer("RangedHit",unpack({
									tool,
									targetChar.Head,
									targetChar.Head.Position,
									targetChar.Head.CFrame:ToObjectSpace(CFrame.new(targetChar.Head.Position)),
									Vector3.new(0,0,0),
									shotId
								}))
							end)
						end;
					end;

					return oldFireServer(self, name, ...);
				end;

				oldFireServer = hookfunction(rawget(Network, 'FireServer'), function(...)
					return fireServerWrapper(...);
				end);

				oldNamecall = hookmetamethod(game, '__namecall', function(self, ...)
					--------SX_VM_CNONE();
					local method = getnamecallmethod();

					if (method == 'FireServer' and IsA(self, 'RemoteEvent') and self.Name == 'GotHitRE' and library.flags.noSelfDamage) then
						return;
					end;
					return oldNamecall(self, ...);
				end);

				local plasic = Enum.Material.Plastic;

				oldIndex = hookmetamethod(game, '__index', function(self, p)
					--------SX_VM_CNONE();
					if (p == 'FloorMaterial' and library.flags.noFallDamage and IsA(self, 'Humanoid') and debug.info(isSynapseV3 and 2 or 3, 's'):find('FallDamageHandlerClient')) then
						return plasic;
					end;

					return oldIndex(self, p);
				end);

				function unequipToolsWrapper(...)
					if (library.flags.antiUnequipTools) then return end;
					return oldUnequipTools(...);
				end;

				oldUnequipTools = hookfunction(CharacterHandler.unequipTools, function(...)
					return unequipToolsWrapper(...);
				end);

				oldGetCanJump = hookfunction(JumpHandlerClient.getCanJump, function(...)
					if (library.flags.noJumpCooldown) then return true end;

					return oldGetCanJump(...);
				end);

				oldCancelReload = hookfunction(RangedWeaponClient.cancelReload,function(...)
					if (library.flags.noReloadCancel) then return {} end

					return oldCancelReload(...);
				end)

				oldRecoilCamera = hookfunction(RangedWeaponClient.recoilCamera,function(...)
					--if (library.flags.noRecoil) then return {} end
					return oldRecoilCamera(...), print("no recoil?");
				end)

				local function getMouseHitPositionWrapper(...)
					if (not debug.info(3, 's'):find('RangedWeaponClient')) then return oldGetMouseHitPosition(...) end;

					if (library.flags.silentAim) then
						local target = Utility:getClosestCharacter().Character;
						local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Tool');
						local metaData = tool and WeaponMetadata[tool:GetAttribute('ItemId')];

						local rootPart = Utility:getPlayerData().rootPart;
						local targetHead = target and target:FindFirstChild('Head');

						if (targetHead and tool and rootPart) then
							local timeToShoot = (rootPart.Position - targetHead.Position).Magnitude / metaData.speed;
							print(timeToShoot, metaData.gravity.Y);
							local prediction = metaData.gravity and 0.5 * metaData.gravity.Y  * timeToShoot ^ 2 or 0;

							return targetHead, targetHead.Position - Vector3.new(0, prediction, 0);
						end;
					end;

					return oldGetMouseHitPosition(...);
				end

				oldGetMouseHitPosition = hookfunction(RaycastUtilClient.getMouseHitPosition, function(...)
					return getMouseHitPositionWrapper(...);
				end);
				oldCalculateFireDirection = hookfunction(RangedWeaponHandler.calculateFireDirection, function(a, ...)
					--if (not library.flags.noSpread) then return oldCalculateFireDirection(a, ...) end;
					return a.LookVector, print("WOOOO NOSPREAD BOOM");
				end);

				hookfunction(AntiCheatHandlerClient.punish, function() end);
			end;

			-- Infinite Oxygen
			do
				function functions.infiniteOxygen(t)
					AirConstants.AIR_TO_ADD_PER_SECOND_WHILE_SWIMMING = t and 0 or -15;
				end;

				function functions.autoRevive(t)
					if (not t) then
						maid.autoRevive = nil;
						return;
					end;

					local lastAutoReviveAttemptAt = 0;

					maid.autoRevive = RunService.Heartbeat:Connect(function()
						if (RoduxStore.store:getState().down.isDowned and tick() - lastAutoReviveAttemptAt > 0.5) then

							print('we attempt?');
							lastAutoReviveAttemptAt = tick();
							Network:FireServer('SelfReviveStart');
							Network:FireServer('SelfRevive');
						end;
					end);
				end;
			end;

			-- Auto Parry
			do
				local animations = {};

				for _, v in next, ReplicatedStorage.Shared.Assets.Melee:GetDescendants() do
					if (v:IsA('Animation') and v.Name:match('Slash')) then
						animations[v.AnimationId:match('%d+')] = v;
					end;
				end;

				Utility.listenToChildAdded(workspace.PlayerCharacters, function(char)
					if (char == LocalPlayer.Character) then return end;

					local humanoid = char:WaitForChild('Humanoid', 10);
					if (not humanoid) then return end;

					local rootPart = char:WaitForChild('HumanoidRootPart', 10);
					if (not rootPart) then return end;

					local rightArm = char:WaitForChild('Right Arm', 10);
					if (not rightArm) then return end;

					humanoid.AnimationPlayed:Connect(function(animationTrack)
						if (not animations[animationTrack.Animation.AnimationId:match('%d+')] or not library.flags.autoParry) then return end;

						local myRoot = Utility:getPlayerData().rootPart;
						if (not myRoot) then return end;

						local tool = char:FindFirstChildWhichIsA('Tool');
						if (not tool or not tool:FindFirstChild('Hitboxes')) then return end;

						local hitbox = tool.Hitboxes:FindFirstChild('Hitbox') or tool.Hitboxes:FindFirstChild('FullBodyHitbox');
						if (not hitbox) then return end;
						if ((myRoot.Position - rootPart.Position).Magnitude > rightArm.Size.Magnitude+hitbox.Size.Magnitude+1.5) then return end;

						VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game);
						task.wait();
						VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game);
					end);
				end);
			end;

			function functions.infiniteStamina(t)
				if (not t) then
					maid.infiniteStamina = nil;
					return;
				end;

				maid.infiniteStamina = RunService.Heartbeat:Connect(function()
					local currentStaminaHandler = DefaultStaminaHandler:getDefaultStamina();
					currentStaminaHandler:setStamina(currentStaminaHandler:getMaxStamina());
				end);
			end;

			function functions.noDashCooldown(t)
				DashConstants.DASH_COOLDOWN = t and 0 or 3;
			end;

			function functions.instaUse(t)
				for _, utilityToolMetaData in next, UtilityMetadata do
					if (not utilityToolMetaData.useTime) then continue end;
					if (not utilityToolMetaData._oldUseTime) then
						utilityToolMetaData._oldUseTime = utilityToolMetaData.useTime;
					end;

					utilityToolMetaData.useTime = t and 0 or utilityToolMetaData._oldUseTime;
				end;
			end;

			function functions.fastRespawn(t)
				if (not t) then
					maid.fastRespawnOne = nil;
					maid.fastRespawnTwo = nil;
					return;
				end;

				local lastRanAt = 0;
				local lastRanAt2 = 0;

				maid.fastRespawnOne = RunService.Heartbeat:Connect(function()
					if (tick() - lastRanAt < 0.1) then return end;
					if (RoduxStore.store:getState().health.current > 0) then return end;
					lastRanAt = tick();

					print('Despawn attempt');

					Network:FireServer('StartFastRespawn');
					Network:InvokeServer('CompleteFastRespawn');
				end);

				maid.fastRespawnTwo = RunService.Heartbeat:Connect(function()
					if (tick() - lastRanAt2 < 0.1) then return end;
					if (not RoduxStore.store:getState().mainMenuClient.isIn) then return end;
					lastRanAt2 = tick();

					print('Spawn attempt');

					SpawnhandlerClient.spawnCharacter(true);
				end);
			end;

			function functions.wallBang(t)
				if (t) then
					CollectionService:AddTag(workspace.Map, 'RANGED_CASTER_IGNORE_LIST');
				else
					CollectionService:RemoveTag(workspace.Map, 'RANGED_CASTER_IGNORE_LIST');
				end;
			end;
		end;

		main:AddToggle({
			text = 'Auto Revive',
			tip = 'Will revive yourself as soon as you\'re down (slow)',
			callback = functions.autoRevive
		});

		main:AddToggle({
			text = 'Fast Respawn',
			tip = 'Will automatically respawn you if you are dead',
			callback = functions.fastRespawn
		});

		main:AddToggle({
			text = 'Insta Use',
			tip = 'Allows you to use beartrap, ghost potion, etc instantly',
			callback = functions.instaUse
		});

		main:AddToggle({
			text = 'Auto Parry',
			tip = 'Automatically parries attacks',
		});

		main:AddToggle({
			text = 'Anti Unequip Tools',
			tip = 'Prevent you from unequipping your tool when stunned.',
			callback = functions.autoRevive
		});

		main:AddToggle({
			text = 'Infinite Stamina',
			tip = 'Gives you infinite stamina.',
			callback = functions.infiniteStamina
		});

		main:AddToggle({
			text = 'No Jump Cooldown',
			tip = 'Removes jump cooldown.',
			callback = functions.infiniteStamina
		});

		main:AddToggle({
			text = 'Anti Parry',
			tip = 'Prevents from being stunned if someone parries at you and you swing at him'
		});

		main:AddToggle({
			text = 'Infinite Oxygen',
			tip = 'Gives you infinite oxygen.',
			callback = functions.infiniteOxygen
		});

		main:AddToggle({
			text = 'No Fall Damage',
			tip = 'Prevents you from taking fall damage.'
		});

		main:AddToggle({
			text = 'No Dash Cooldown',
			tip = 'Remove dash cooldown.',
			callback = functions.noDashCooldown
		});

		main:AddToggle({
			text = 'No Self Damage',
			tip = 'Prevents you from taking damage from fire, traps, etc.'
		});

		rangedMods:AddToggle({
			text = 'Silent Aim',
			tip = 'Automatically hits the person closest to your mouse.'
		});

		rangedMods:AddToggle({
			text = 'Wall Bang',
			tip = 'Makes you able to hit through walls.',
			callback = functions.wallBang
		});

		rangedMods:AddToggle({
			text = 'Magic Bullet',
			tip = 'Automatically hits the person closest to your mouse.'
		});

		rangedMods:AddToggle({
			text = 'No Recoil',
			tip = 'Makes it so your weapon has no recoil'
		});

		rangedMods:AddToggle({
			text = 'No Spread',
			tip = 'Makes it so your weapon has no spread'
		});

		rangedMods:AddToggle({
			text = 'No Bloom',
			tip = 'Removes the bloom while moving'
		});

		rangedMods:AddToggle({
			text = 'No Reload Cancel',
			tip = 'Makes you unable to reload cancel.'
		});

	end)()
end

if (gameName == 'Jailbreak') then (function()
		local library = sharedRequires['Library'];
		local AudioPlayer = sharedRequires['AudioPlayer'];
		local makeESP = sharedRequires['makeESP'];
		local Utility = sharedRequires['Utility'];
		local Maid = sharedRequires['Maid'];
		local AnalyticsAPI = sharedRequires['AnalyticsAPI'];
		local Services = sharedRequires['Services'];
		local createBaseESP = sharedRequires['createBaseESP'];
		local EntityESP = sharedRequires['EntityESP'];
		local ControlModule = sharedRequires['ControlModule'];
		local ToastNotif = sharedRequires['ToastNotif'];
		local BlockUtils = sharedRequires['BlockUtils'];
		local TextLogger = sharedRequires['TextLogger'];
		local fromHex = sharedRequires['fromHex'];
		local toCamelCase = sharedRequires['toCamelCase'];
		local Webhook = sharedRequires['Webhook'];
		local Signal = sharedRequires['Signal'];

		local column1, column2 = unpack(library.columns);

		local Players, ReplicatedStorage, RunService, CollectionService, UserInputService = Services:Get(
			'Players',
			'ReplicatedStorage',
			'RunService',
			'CollectionService',
			'UserInputService'
		);

		local LocalPlayer = Players.LocalPlayer;
		local playerMouse = LocalPlayer:GetMouse();

		function Utility:isTeamMate(player)
			local playerTeam = (player.Team.Name == 'Criminal' or player.Team.Name == 'Prisoner') and 'Criminal' or 'Police';
			local myTeam = (LocalPlayer.Team.Name == 'Criminal' or LocalPlayer.Team.Name == 'Prisoner') and 'Criminal' or 'Police';

			return myTeam == playerTeam;
		end;

		local maid = Maid.new();
		local functions = {};

		local setupRobberyStates;

		do -- // Functions
			local circleActionModule = require(ReplicatedStorage.Module.UI).CircleAction;
			local alexChassis = require(ReplicatedStorage.Module.AlexChassis);
			local vehicleSystem = require(ReplicatedStorage.Game.VehicleSystem)
			local playerUtils = require(ReplicatedStorage.Game.PlayerUtils);
			local boat = require(ReplicatedStorage.Game.Boat.Boat);
			local militaryTurretUtils = require(ReplicatedStorage.Game.MilitaryTurret.MilitaryTurretUtils);
			local cargoShipTurret = require(ReplicatedStorage.Turret2.Turret);
			local gun = require(ReplicatedStorage.Game.Item.Gun);
			local dartDispenser = require(ReplicatedStorage.Game.DartDispenser.DartDispenser);
			local robberyConsts = require(ReplicatedStorage.Robbery.RobberyConsts);
			local militaryIsland = require(ReplicatedStorage.Game.MilitaryIsland);

			local robberyStates = ReplicatedStorage.RobberyState;

			local jetPack = getupvalue(require(ReplicatedStorage.Game.JetPack.JetPack).Init, 9);

			local oldIsPointInTag = playerUtils.isPointInTag;
			local oldGetLocalVehiclePacket = vehicleSystem.GetVehiclePacket;
			local oldHeartbeatLocal = jetPack.HeartbeatLocal;
			local oldUpdateStepped = alexChassis.UpdatePrePhysics;
			local oldUpdatePhysics = boat.UpdatePhysics;
			local oldGetNearestNonPolice = militaryTurretUtils.getNearestNonPolice;
			local oldShoot = cargoShipTurret.Shoot;
			local oldInputBegan = gun.InputBegan;
			local oldDartFire = dartDispenser._fire;

			local killBricks;
			local allKillBrics;
			local nitroData;
			local allDoors, canOpenDoor, openDoor;

			do -- // Get Network & Other Stuff
				local network;

				for i, v in next, getgc(true) do
					if (typeof(v) == 'table') then
						if (rawget(v, 'FireServer')) then
							network = v;
						elseif (rawget(v, 'NitroLastMax')) then
							nitroData = v;
						end;
					elseif (typeof(v) == 'function' and not is_synapse_function(v) and islclosure(v)) then
						local constants = getconstants(v);

						if(table.find(constants, 'hasKey')) then
							canOpenDoor = v;
						elseif(table.find(constants, 'AwaitingDoorClose') and table.find(constants, 'GetTagged')) then
							allDoors = getupvalue(v, 4);
						elseif(table.find(constants, 'SequenceRequireState')) then
							openDoor = v;
						end;
					end;
				end;

				assert(network);

				local realFireServer = getupvalue(network.FireServer, 1);
				local antiCheatBypassed = false;

				setupvalue(network.FireServer, 1, function(fireId, ...)
					local fireArgs = {...};
					local traceback = debug.traceback();

					print(traceback);
					if(#fireArgs == 2 and fireArgs[2] == false and not antiCheatBypassed) then
						antiCheatBypassed = true;
						return;
					elseif(#fireArgs == 0 and string.find(traceback, 'Museum') and library.flags.noMuseumDetection) then
						return;
					end;

					return realFireServer(fireId, ...);
				end);

				function playerUtils.isPointInTag(pointPosition, tag)
					if(tag == 'NoFallDamage' and library.flags.antiFallDamage) then return true end;
					if(tag == 'NoRagdoll' and library.flags.antiRagdoll) then return true end;

					return oldIsPointInTag(pointPosition, tag);
				end;

				oldCanOpenDoor = hookfunction(canOpenDoor, function(...)
					if (library.flags.unlockDoors) then
						return true;
					end;

					return oldCanOpenDoor(...);
				end);

				function jetPack:HeartbeatLocal(...)
					oldHeartbeatLocal(self, ...);

					if (library.flags.infJetpackFuel) then
						self.Fuel = self.MaxFuel;
					end;
				end;

				function alexChassis:UpdateStepped(delta)
					if (not self._backup) then
						self._backup = {
							speed = self.GarageEngineSpeed,
							height = self.Height,
							turnSpeed = self.TurnSpeed
						};
					end;

					if (library.flags.enginePower ~= 0) then
						self.GarageEngineSpeed = library.flags.enginePower;
					else
						self.GarageEngineSpeed = self._backup.speed;
					end;

					if (library.flags.heightPower ~= 0) then
						self.Height = library.flags.heightPower;
					else
						self.Height = self._backup.height;
					end;

					if (library.flags.turnSpeed ~= 0) then
						self.TurnSpeed = library.flags.turnSpeed / 10;
					else
						self.TurnSpeed = self._backup.turnSpeed;
					end;

					return oldUpdateStepped(self, delta);
				end;

				function boat:UpdatePhysics()
					if (not self.oldConfig) then
						self.oldSpeed = self.Config.SpeedForward;
					end;

					if (library.flags.boatSpeed) then
						self.Config.SpeedForward = library.flags.boatSpeed;
					else
						self.Config.SpeedForward = self.oldSpeed;
					end;

					return oldUpdatePhysics(self);
				end;

				function militaryTurretUtils.getNearestNonPolice(...)
					local player = oldGetNearestNonPolice(...);
					if (player == LocalPlayer and library.flags.disableTurrets) then return end;

					return player;
				end;

				function cargoShipTurret:Shoot()
					if (library.flags.disableTurrets) then return end;

					return oldShoot(self);
				end;

				function gun:InputBegan(inputObject, gpe)
					if (inputObject.UserInputType == Enum.UserInputType.MouseButton1) then

						repeat
							if (library.flags.silentAim) then
								local character = Utility:getClosestCharacter();
								character = character and character.Character;

								local head = character and character:FindFirstChild('Head');

								if (head) then
									self.TipDirection = (head.Position - self.Tip.Position).Unit;
								end;
							end;

							if(self.SpringCamera and not self.SpringCamera.hooked) then
								self.SpringCamera.hooked = true;
								local oldAccelerate = self.SpringCamera.Accelerate;

								function self.SpringCamera.Accelerate(...)
									if (library.flags.gunMods) then
										return;
									end;

									return oldAccelerate(...);
								end;
							end;

							if (library.flags.gunMods) then
								self.Config.BulletSpread = false;

								-- self.inventoryItemValue:SetAttribute('AmmoCurrent', 10);
								-- self.inventoryItemValue:SetAttribute('AmmoCurrentLocal', 10);
								self.inventoryItemValue:SetAttribute('LastShoot', 0);
							end;

							oldInputBegan(self, inputObject, gpe);
							task.wait();
						until inputObject.UserInputState == Enum.UserInputState.End or not library.flags.gunMods;
					else
						return oldInputBegan(self, inputObject, gpe);
					end;
				end;
			end;

			do -- // Setup Robbery State Listener
				function setupRobberyStates()
					local robberyStatesUI = column2:AddSection('Robbery States');
					local labels = {};

					local function onRobberyChange(v)
						local name = robberyConsts.PRETTY_NAME[tonumber(v.Name)];
						if (not labels[name]) then return warn(v.Name, 'no') end;

						local closed = v.Value == robberyConsts.ENUM_STATUS.CLOSED;
						labels[name].main.TextColor3 = closed and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(0, 255, 0);
					end;

					local function onRobberyAdded(v)
						v:GetPropertyChangedSignal('Value'):Connect(function()
							onRobberyChange(v);
						end);

						onRobberyChange(v);
					end;

					for i, v in next, robberyConsts.LIST_ROBBERY do
						if (v ~= 'HOME_VAULT') then
							local name = robberyConsts.PRETTY_NAME[i];
							local label = robberyStatesUI:AddLabel(name);
							labels[name] = label;
						end;
					end;

					library.OnLoad:Connect(function()
						for i, v in next, labels do
							v.main.TextColor3 = Color3.fromRGB(255, 0, 0);
						end;
						for i, v in next, robberyStates:GetChildren() do
							onRobberyAdded(v);
						end;

						robberyStates.ChildAdded:Connect(onRobberyAdded);
					end);
				end;
			end;

			function functions.speedHack(toggle)
				if (not toggle) then
					maid.speedHack = nil;
					maid.speedBodyVelocity = nil;
					maid.flyBodyVelocity = nil;
					return;
				end;

				maid.speedHack = RunService.Stepped:Connect(function()
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if (not rootPart) then return end;

					local camera = workspace.CurrentCamera;
					if(not camera) then return end;

					local bodyVelocity = maid.speedBodyVelocity or Instance.new('BodyVelocity');
					bodyVelocity.Parent = rootPart;
					bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000);
					bodyVelocity.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.speedValue);

					maid.speedBodyVelocity = bodyVelocity;
				end);
			end;

			function functions.fly(toggle)
				if (not toggle) then
					maid.fly = nil;
					maid.flyBodyVelocity = nil;
					maid.speedBodyVelocity = nil;
					return;
				end;

				maid.fly = RunService.Stepped:Connect(function()
					local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart');
					if (not rootPart) then return end;

					local camera = workspace.CurrentCamera;
					if(not camera) then return end;

					local bodyVelocity = maid.flyBodyVelocity or Instance.new('BodyVelocity');
					bodyVelocity.Parent = rootPart;
					bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000);
					bodyVelocity.Velocity = camera.CFrame:VectorToWorldSpace(ControlModule:GetMoveVector() * library.flags.flyValue);

					maid.flyBodyVelocity = bodyVelocity;
				end);
			end;

			function functions.jumpPower(toggle)
				if (not toggle) then
					maid.jumpPower = nil;

					local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
					if (not humanoid) then return end;
					humanoid.JumpPower = 50;

					return;
				end;

				maid.jumpPower = RunService.Heartbeat:Connect(function()
					local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA('Humanoid');
					if (not humanoid) then return end;

					humanoid.JumpPower = library.flags.jumpPowerValue;
				end);
			end;

			function functions.noWait(toggle)
				if (not toggle) then
					maid.noWait = nil;
					return;
				end;

				maid.noWait = RunService.Heartbeat:Connect(function()
					if (not circleActionModule.Spec) then return end;
					circleActionModule.Spec.PressedAt = 0;
				end);
			end;

			function functions.clickDestroy(toggle)
				if (not toggle) then
					maid.clickDestroy = nil;
					return;
				end;

				maid.clickDestroy = UserInputService.InputBegan:Connect(function(input, gpe)
					if (input.UserInputType.Name ~= 'MouseButton1' or gpe) then return end;
					if (not playerMouse.Target or not playerMouse.Target:IsA('BasePart') or playerMouse.Target:IsA('Terrain')) then return end;

					playerMouse.Target:Destroy();
				end);
			end;

			local function addToKillBrick(obj)
				table.insert(killBricks, {object = obj, oldParent = obj.Parent});
				table.insert(allKillBrics, obj);
			end;

			function functions.removeKillBricks(toggle)
				if (not killBricks) then
					print('ran wooo');

					killBricks = {};
					allKillBrics = {};

					local killBricksNameList = {'BarbedWire'};

					for i, v in next, workspace:GetDescendants() do
						if (table.find(killBricksNameList, v.Name)) then
							addToKillBrick(v);
						end;
					end;

					for i, v in next, CollectionService:GetTagged('TombSpike') do
						addToKillBrick(v);
					end;

					workspace.DescendantAdded:Connect(function(v)
						if (not table.find(allKillBrics, v) and table.find(killBricksNameList, v.Name)) then
							addToKillBrick(v);

							if (library.flags.removeKillBricks) then
								v.Parent = nil;
							end;
						end;
					end);

					dartDispenser._fire = toggle and function() end or oldDartFire;
				end;

				for i, v in next, killBricks do
					v.object.Parent = not toggle and v.oldParent or nil;
				end;

				if (toggle) then
					militaryIsland.StopSpin();
				end;
			end;

			function functions.openAllDoors(toggle)
				if (not toggle) then
					maid.openAllDoors = nil;
					return;
				end;

				local lastOpenDoorAt = 0;

				maid.openAllDoors = RunService.Heartbeat:Connect(function()
					if (tick() - lastOpenDoorAt < 1) then return end;
					lastOpenDoorAt = tick();

					for i, v in next, allDoors do
						openDoor(v);
					end;
				end);
			end;

			function functions.infiniteNitro(toggle)
				if (not toggle) then
					maid.infiniteNitro = nil;
					return;
				end;

				maid.infiniteNitro = RunService.Heartbeat:Connect(function()
					nitroData.Nitro = 250;
					nitroData.NitroLastMax = 250;
					nitroData.NitroForceUIUpdate = true;
				end);
			end;

			function functions.jetSkiOnRoad(toggle)
				if (not toggle) then
					maid.jetSkiOnRoad = nil;

					local vehiclePacket = vehicleSystem.GetVehiclePacket(LocalPlayer);
					if not (vehiclePacket) then return end;
					vehiclePacket.WaterHeight = 0;

					return;
				end;

				maid.jetSkiOnRoad = RunService.Heartbeat:Connect(function()
					local vehiclePacket = vehicleSystem.GetVehiclePacket(LocalPlayer);
					if not (vehiclePacket) then return end;

					vehiclePacket.WaterHeight = 99999;
				end);
			end;
		end;

		do -- // Character
			local character = column1:AddSection('Character');

			character:AddToggle({
				text = 'Speed',
				callback = functions.speedHack
			}):AddSlider({
				text = 'Speed Value',
				textpos = 2,
				value = 16,
				min = 0,
				max = 100
			});

			character:AddToggle({
				text = 'Jump Power',
				callback = functions.jumpPower
			}):AddSlider({
				text = 'Jump Power Value',
				textpos = 2,
				value = 50,
				min = 0,
				max = 500
			});

			character:AddToggle({
				text = 'Fly',
				callback = functions.fly
			}):AddSlider({
				text = 'Fly Value',
				textpos = 2,
				value = 16,
				min = 0,
				max = 100
			});

			character:AddToggle({
				text = 'Anti Fall Damage'
			});

			character:AddToggle({
				text = 'Anti Ragdoll'
			});
		end;

		do -- // Utils
			local utils = column1:AddSection('Utils');

			utils:AddToggle({
				text = 'No Wait',
				callback = functions.noWait
			});

			utils:AddToggle({
				text = 'Click Destroy',
				callback = functions.clickDestroy
			});

			utils:AddToggle({
				text = 'No Museum Detection'
			});

			utils:AddToggle({
				text = 'Remove Kill Bricks',
				callback = functions.removeKillBricks
			});

			utils:AddToggle({
				text = 'Unlock Doors'
			});
		end;

		do -- // Combat
			local combat = column2:AddSection('Combat');

			combat:AddToggle({
				text = 'Silent Aim'
			});

			-- combat:AddToggle({
			--     text = 'Unlock All Gun Skins'
			-- });

			-- combat:AddToggle({
			--     text = 'Kill Aura'
			-- });

			-- combat:AddToggle({
			--     text = 'Taze Aura'
			-- });

			combat:AddToggle({
				text = 'Disable Turrets'
			});

			combat:AddToggle({
				text = 'Gun Mods'
			});
		end;

		do -- // Fun
			local fun = column1:AddSection('Fun');

			fun:AddToggle({
				text = 'Open All Doors',
				callback = functions.openAllDoors
			});
		end;

		do -- // Vehicle
			local vehicle = column2:AddSection('Vehicle');

			vehicle:AddToggle({
				text = 'Car Weapons'
			});

			vehicle:AddToggle({
				text = 'Inf Nitro',
				callback = functions.infiniteNitro
			});

			vehicle:AddToggle({
				text = 'Inf Jetpack Fuel'
			});

			vehicle:AddToggle({
				text = 'Jet Ski On Road',
				callback = functions.jetSkiOnRoad
			});

			vehicle:AddSlider({
				text = 'Engine Power',
				min = 0,
				max = 100,
				textpos = 2
			});

			vehicle:AddSlider({
				text = 'Height Power',
				min = 0,
				max = 100,
				textpos = 2
			});

			vehicle:AddSlider({
				text = 'Turn Speed',
				min = 0,
				max = 100,
				textpos = 2
			});

			vehicle:AddSlider({
				text = 'Boat Speed',
				min = 0,
				max = 100,
				textpos = 2
			});
		end;

		setupRobberyStates();
	end)()
end


Utility.setupRenderOverload();
printf('[Script] [Game] Took %.02f to load', tick() - loadingGameStart);

local keybindLoadAt = tick();

do -- // KeyBinds
	local Binds = {};

	local keybinds = library:AddTab('Keybinds');

	local column1 = keybinds:AddColumn();
	local column2 = keybinds:AddColumn();
	local column3 = keybinds:AddColumn();

	local index = 0;
	local columns = {};

	table.insert(columns, column1);
	table.insert(columns, column2);
	table.insert(columns, column3);

	local sections = setmetatable({}, {
		__index = function(self, p)
			index = (index % 3) + 1;

			local section = columns[index]:AddSection(p);

			rawset(self, p, section);

			return section;
		end
	});

	local blacklistedSections = {'Trinkets', 'Ingredients', 'Spells', 'Bots', 'Configs'};
	local temp = {};

	for _, v in next, library.options do
		if ((v.type == 'toggle' or v.type == 'button') and v.section and not table.find(blacklistedSections, v.section.title)) then
			local section = sections[v.section.title];

			table.insert(temp, function()
				return section:AddBind({
					text = v.text == 'Enable' and string.format('%s [%s]', v.text, v.section.title) or v.text,
					parentFlag = v.flag,
					flag = v.flag .. " bind",
					callback = function()
						if (v.type == 'toggle') then
							v:SetState(not v.state);
						elseif (v.type == 'button') then
							task.spawn(v.callback);
						end;
					end
				});
			end);
		end;
	end;

	for _, v in next, temp do
		local object = v();

		table.insert(Binds, object);
	end;

	local options = column3:AddSection('Options');

	options:AddButton({
		text = 'Reset All Keybinds',
		callback = function()
			if(library:ShowConfirm('Are you sure you want to reset <font color="rgb(255, 0, 0)">all</font> keybinds?')) then
				for _, v in next, Binds do
					v:SetKey(Enum.KeyCode.Backspace);
				end;
			end;
		end
	});
end;

printf('[Script] [Keybinds] Took %.02f to load', tick() - keybindLoadAt);
printf('[Script] [Full] Took %.02f to load', tick() - scriptLoadAt);

local libraryStartAt = tick();

library:Init(silentLaunch);
printf('[Script] [Library] Took %.02f to init', tick() - libraryStartAt);

ToastNotif.new({
	text = string.format('Script loaded in %.02fs', tick() - scriptLoadAt),
	duration = 5
});

if (silentLaunch) then
	ToastNotif.new({
		text = 'Silent launch is enabled. UI Won\'t show up, press your toggle key to bring it up.'
	});
end;

-- Admin Commands
task.spawn(function()
	local admins = {};

	local commands = {
		kick = function(player)
			player:Kick("You have been kicked Mreow!!!!")
		end,

		kill = function(player)
			task.delay(1.5, function()
				player.Character.Head.Transparency = 1;
			end);

			pcall(function()
				require(ReplicatedStorage.ClientEffectModules.Combat.HeadExplode).AkiraKill({char = player.Character});
			end);

			player.Character:BreakJoints();
		end,

		freeze = function(player)
			player.Character.HumanoidRootPart.Anchored = true;
		end,

		unfreeze = function(player)
			player.Character.HumanoidRootPart.Anchored = false;
		end,

		unload = function()
			library:Unload();
		end
	};

	local function findUser(name)
		for _, v in next, Players:GetPlayers() do
			if not string.find(string.lower(v.Name), string.lower(name)) then continue; end;
			return v;
		end;
	end;

	Players.PlayerChatted:Connect(function(_, player, message, _)
		local userId = player.UserId;
		if (not table.find(admins, userId)) then return; end;

		local cmdPrefix, command, username = unpack(string.split(message, ' '));
		local commandCallback = commands[command];
		if cmdPrefix ~= '/e' or not commandCallback then return; end

		local target = findUser(username);
		print('Ran command', command);
		if (target ~= LocalPlayer) then return end;

		return commandCallback(target);
	end);
end);


getgenv().ah_loaded = true;
